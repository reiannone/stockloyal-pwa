(function() {
    const n = document.createElement("link").relList;
    if (n && n.supports && n.supports("modulepreload"))
        return;
    for (const u of document.querySelectorAll('link[rel="modulepreload"]'))
        c(u);
    new MutationObserver(u => {
        for (const p of u)
            if (p.type === "childList")
                for (const f of p.addedNodes)
                    f.tagName === "LINK" && f.rel === "modulepreload" && c(f)
    }
    ).observe(document, {
        childList: !0,
        subtree: !0
    });
    function a(u) {
        const p = {};
        return u.integrity && (p.integrity = u.integrity),
        u.referrerPolicy && (p.referrerPolicy = u.referrerPolicy),
        u.crossOrigin === "use-credentials" ? p.credentials = "include" : u.crossOrigin === "anonymous" ? p.credentials = "omit" : p.credentials = "same-origin",
        p
    }
    function c(u) {
        if (u.ep)
            return;
        u.ep = !0;
        const p = a(u);
        fetch(u.href, p)
    }
}
)();
(function() {
    const o = document.createElement("link").relList;
    if (o && o.supports && o.supports("modulepreload"))
        return;
    for (const c of document.querySelectorAll('link[rel="modulepreload"]'))
        a(c);
    new MutationObserver(c => {
        for (const u of c)
            if (u.type === "childList")
                for (const p of u.addedNodes)
                    p.tagName === "LINK" && p.rel === "modulepreload" && a(p)
    }
    ).observe(document, {
        childList: !0,
        subtree: !0
    });
    function n(c) {
        const u = {};
        return c.integrity && (u.integrity = c.integrity),
        c.referrerPolicy && (u.referrerPolicy = c.referrerPolicy),
        c.crossOrigin === "use-credentials" ? u.credentials = "include" : c.crossOrigin === "anonymous" ? u.credentials = "omit" : u.credentials = "same-origin",
        u
    }
    function a(c) {
        if (c.ep)
            return;
        c.ep = !0;
        const u = n(c);
        fetch(c.href, u)
    }
}
)();
(function() {
    const o = document.createElement("link").relList;
    if (o && o.supports && o.supports("modulepreload"))
        return;
    for (const c of document.querySelectorAll('link[rel="modulepreload"]'))
        a(c);
    new MutationObserver(c => {
        for (const u of c)
            if (u.type === "childList")
                for (const p of u.addedNodes)
                    p.tagName === "LINK" && p.rel === "modulepreload" && a(p)
    }
    ).observe(document, {
        childList: !0,
        subtree: !0
    });
    function n(c) {
        const u = {};
        return c.integrity && (u.integrity = c.integrity),
        c.referrerPolicy && (u.referrerPolicy = c.referrerPolicy),
        c.crossOrigin === "use-credentials" ? u.credentials = "include" : c.crossOrigin === "anonymous" ? u.credentials = "omit" : u.credentials = "same-origin",
        u
    }
    function a(c) {
        if (c.ep)
            return;
        c.ep = !0;
        const u = n(c);
        fetch(c.href, u)
    }
}
)();
(function() {
    const o = document.createElement("link").relList;
    if (o && o.supports && o.supports("modulepreload"))
        return;
    for (const c of document.querySelectorAll('link[rel="modulepreload"]'))
        a(c);
    new MutationObserver(c => {
        for (const u of c)
            if (u.type === "childList")
                for (const p of u.addedNodes)
                    p.tagName === "LINK" && p.rel === "modulepreload" && a(p)
    }
    ).observe(document, {
        childList: !0,
        subtree: !0
    });
    function n(c) {
        const u = {};
        return c.integrity && (u.integrity = c.integrity),
        c.referrerPolicy && (u.referrerPolicy = c.referrerPolicy),
        c.crossOrigin === "use-credentials" ? u.credentials = "include" : c.crossOrigin === "anonymous" ? u.credentials = "omit" : u.credentials = "same-origin",
        u
    }
    function a(c) {
        if (c.ep)
            return;
        c.ep = !0;
        const u = n(c);
        fetch(c.href, u)
    }
}
)();
var d7 = Object.defineProperty
  , u7 = (o, n, a) => n in o ? d7(o, n, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: a
}) : o[n] = a
  , C = (o, n, a) => u7(o, typeof n != "symbol" ? n + "" : n, a);
(function() {
    const o = document.createElement("link").relList;
    if (o && o.supports && o.supports("modulepreload"))
        return;
    for (const c of document.querySelectorAll('link[rel="modulepreload"]'))
        a(c);
    new MutationObserver(c => {
        for (const u of c)
            if (u.type === "childList")
                for (const p of u.addedNodes)
                    p.tagName === "LINK" && p.rel === "modulepreload" && a(p)
    }
    ).observe(document, {
        childList: !0,
        subtree: !0
    });
    function n(c) {
        const u = {};
        return c.integrity && (u.integrity = c.integrity),
        c.referrerPolicy && (u.referrerPolicy = c.referrerPolicy),
        c.crossOrigin === "use-credentials" ? u.credentials = "include" : c.crossOrigin === "anonymous" ? u.credentials = "omit" : u.credentials = "same-origin",
        u
    }
    function a(c) {
        if (c.ep)
            return;
        c.ep = !0;
        const u = n(c);
        fetch(c.href, u)
    }
}
)();
var Tu = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function nb(o) {
    return o && o.__esModule && Object.prototype.hasOwnProperty.call(o, "default") ? o.default : o
}
var uD = {
    exports: {}
}
  , om = {};
/**
* @license React
* react-jsx-runtime.production.js
*
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
var h7 = Symbol.for("react.transitional.element")
  , m7 = Symbol.for("react.fragment");
function hD(o, n, a) {
    var c = null;
    if (a !== void 0 && (c = "" + a),
    n.key !== void 0 && (c = "" + n.key),
    "key"in n) {
        a = {};
        for (var u in n)
            u !== "key" && (a[u] = n[u])
    } else
        a = n;
    return n = a.ref,
    {
        $$typeof: h7,
        type: o,
        key: c,
        ref: n !== void 0 ? n : null,
        props: a
    }
}
om.Fragment = m7;
om.jsx = hD;
om.jsxs = hD;
uD.exports = om;
var _ = uD.exports
  , mD = {
    exports: {}
}
  , Ae = {};
/**
* @license React
* react.production.js
*
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
var ib = Symbol.for("react.transitional.element")
  , p7 = Symbol.for("react.portal")
  , g7 = Symbol.for("react.fragment")
  , f7 = Symbol.for("react.strict_mode")
  , k7 = Symbol.for("react.profiler")
  , b7 = Symbol.for("react.consumer")
  , w7 = Symbol.for("react.context")
  , A7 = Symbol.for("react.forward_ref")
  , v7 = Symbol.for("react.suspense")
  , _7 = Symbol.for("react.memo")
  , pD = Symbol.for("react.lazy")
  , C7 = Symbol.for("react.activity")
  , kE = Symbol.iterator;
function y7(o) {
    return o === null || typeof o != "object" ? null : (o = kE && o[kE] || o["@@iterator"],
    typeof o == "function" ? o : null)
}
var gD = {
    isMounted: function() {
        return !1
    },
    enqueueForceUpdate: function() {},
    enqueueReplaceState: function() {},
    enqueueSetState: function() {}
}
  , fD = Object.assign
  , kD = {};
function Oa(o, n, a) {
    this.props = o,
    this.context = n,
    this.refs = kD,
    this.updater = a || gD
}
Oa.prototype.isReactComponent = {};
Oa.prototype.setState = function(o, n) {
    if (typeof o != "object" && typeof o != "function" && o != null)
        throw Error("takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, o, n, "setState")
}
;
Oa.prototype.forceUpdate = function(o) {
    this.updater.enqueueForceUpdate(this, o, "forceUpdate")
}
;
function bD() {}
bD.prototype = Oa.prototype;
function sb(o, n, a) {
    this.props = o,
    this.context = n,
    this.refs = kD,
    this.updater = a || gD
}
var ab = sb.prototype = new bD;
ab.constructor = sb;
fD(ab, Oa.prototype);
ab.isPureReactComponent = !0;
var bE = Array.isArray;
function zf() {}
var it = {
    H: null,
    A: null,
    T: null,
    S: null
}
  , wD = Object.prototype.hasOwnProperty;
function lb(o, n, a) {
    var c = a.ref;
    return {
        $$typeof: ib,
        type: o,
        key: n,
        ref: c !== void 0 ? c : null,
        props: a
    }
}
function x7(o, n) {
    return lb(o.type, n, o.props)
}
function cb(o) {
    return typeof o == "object" && o !== null && o.$$typeof === ib
}
function E7(o) {
    var n = {
        "=": "=0",
        ":": "=2"
    };
    return "$" + o.replace(/[=:]/g, function(a) {
        return n[a]
    })
}
var wE = /\/+/g;
function Pg(o, n) {
    return typeof o == "object" && o !== null && o.key != null ? E7("" + o.key) : n.toString(36)
}
function S7(o) {
    switch (o.status) {
    case "fulfilled":
        return o.value;
    case "rejected":
        throw o.reason;
    default:
        switch (typeof o.status == "string" ? o.then(zf, zf) : (o.status = "pending",
        o.then(function(n) {
            o.status === "pending" && (o.status = "fulfilled",
            o.value = n)
        }, function(n) {
            o.status === "pending" && (o.status = "rejected",
            o.reason = n)
        })),
        o.status) {
        case "fulfilled":
            return o.value;
        case "rejected":
            throw o.reason
        }
    }
    throw o
}
function Qs(o, n, a, c, u) {
    var p = typeof o;
    (p === "undefined" || p === "boolean") && (o = null);
    var f = !1;
    if (o === null)
        f = !0;
    else
        switch (p) {
        case "bigint":
        case "string":
        case "number":
            f = !0;
            break;
        case "object":
            switch (o.$$typeof) {
            case ib:
            case p7:
                f = !0;
                break;
            case pD:
                return f = o._init,
                Qs(f(o._payload), n, a, c, u)
            }
        }
    if (f)
        return u = u(o),
        f = c === "" ? "." + Pg(o, 0) : c,
        bE(u) ? (a = "",
        f != null && (a = f.replace(wE, "$&/") + "/"),
        Qs(u, n, a, "", function(y) {
            return y
        })) : u != null && (cb(u) && (u = x7(u, a + (u.key == null || o && o.key === u.key ? "" : ("" + u.key).replace(wE, "$&/") + "/") + f)),
        n.push(u)),
        1;
    f = 0;
    var w = c === "" ? "." : c + ":";
    if (bE(o))
        for (var k = 0; k < o.length; k++)
            c = o[k],
            p = w + Pg(c, k),
            f += Qs(c, n, a, p, u);
    else if (k = y7(o),
    typeof k == "function")
        for (o = k.call(o),
        k = 0; !(c = o.next()).done; )
            c = c.value,
            p = w + Pg(c, k++),
            f += Qs(c, n, a, p, u);
    else if (p === "object") {
        if (typeof o.then == "function")
            return Qs(S7(o), n, a, c, u);
        throw n = String(o),
        Error("Objects are not valid as a React child (found: " + (n === "[object Object]" ? "object with keys {" + Object.keys(o).join(", ") + "}" : n) + "). If you meant to render a collection of children, use an array instead.")
    }
    return f
}
function Iu(o, n, a) {
    if (o == null)
        return o;
    var c = []
      , u = 0;
    return Qs(o, c, "", "", function(p) {
        return n.call(a, p, u++)
    }),
    c
}
function D7(o) {
    if (o._status === -1) {
        var n = o._result;
        n = n(),
        n.then(function(a) {
            (o._status === 0 || o._status === -1) && (o._status = 1,
            o._result = a)
        }, function(a) {
            (o._status === 0 || o._status === -1) && (o._status = 2,
            o._result = a)
        }),
        o._status === -1 && (o._status = 0,
        o._result = n)
    }
    if (o._status === 1)
        return o._result.default;
    throw o._result
}
var AE = typeof reportError == "function" ? reportError : function(o) {
    if (typeof window == "object" && typeof window.ErrorEvent == "function") {
        var n = new window.ErrorEvent("error",{
            bubbles: !0,
            cancelable: !0,
            message: typeof o == "object" && o !== null && typeof o.message == "string" ? String(o.message) : String(o),
            error: o
        });
        if (!window.dispatchEvent(n))
            return
    } else if (typeof process == "object" && typeof process.emit == "function") {
        process.emit("uncaughtException", o);
        return
    }
    console.error(o)
}
  , T7 = {
    map: Iu,
    forEach: function(o, n, a) {
        Iu(o, function() {
            n.apply(this, arguments)
        }, a)
    },
    count: function(o) {
        var n = 0;
        return Iu(o, function() {
            n++
        }),
        n
    },
    toArray: function(o) {
        return Iu(o, function(n) {
            return n
        }) || []
    },
    only: function(o) {
        if (!cb(o))
            throw Error("React.Children.only expected to receive a single React element child.");
        return o
    }
};
Ae.Activity = C7;
Ae.Children = T7;
Ae.Component = Oa;
Ae.Fragment = g7;
Ae.Profiler = k7;
Ae.PureComponent = sb;
Ae.StrictMode = f7;
Ae.Suspense = v7;
Ae.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = it;
Ae.__COMPILER_RUNTIME = {
    __proto__: null,
    c: function(o) {
        return it.H.useMemoCache(o)
    }
};
Ae.cache = function(o) {
    return function() {
        return o.apply(null, arguments)
    }
}
;
Ae.cacheSignal = function() {
    return null
}
;
Ae.cloneElement = function(o, n, a) {
    if (o == null)
        throw Error("The argument must be a React element, but you passed " + o + ".");
    var c = fD({}, o.props)
      , u = o.key;
    if (n != null)
        for (p in n.key !== void 0 && (u = "" + n.key),
        n)
            !wD.call(n, p) || p === "key" || p === "__self" || p === "__source" || p === "ref" && n.ref === void 0 || (c[p] = n[p]);
    var p = arguments.length - 2;
    if (p === 1)
        c.children = a;
    else if (1 < p) {
        for (var f = Array(p), w = 0; w < p; w++)
            f[w] = arguments[w + 2];
        c.children = f
    }
    return lb(o.type, u, c)
}
;
Ae.createContext = function(o) {
    return o = {
        $$typeof: w7,
        _currentValue: o,
        _currentValue2: o,
        _threadCount: 0,
        Provider: null,
        Consumer: null
    },
    o.Provider = o,
    o.Consumer = {
        $$typeof: b7,
        _context: o
    },
    o
}
;
Ae.createElement = function(o, n, a) {
    var c, u = {}, p = null;
    if (n != null)
        for (c in n.key !== void 0 && (p = "" + n.key),
        n)
            wD.call(n, c) && c !== "key" && c !== "__self" && c !== "__source" && (u[c] = n[c]);
    var f = arguments.length - 2;
    if (f === 1)
        u.children = a;
    else if (1 < f) {
        for (var w = Array(f), k = 0; k < f; k++)
            w[k] = arguments[k + 2];
        u.children = w
    }
    if (o && o.defaultProps)
        for (c in f = o.defaultProps,
        f)
            u[c] === void 0 && (u[c] = f[c]);
    return lb(o, p, u)
}
;
Ae.createRef = function() {
    return {
        current: null
    }
}
;
Ae.forwardRef = function(o) {
    return {
        $$typeof: A7,
        render: o
    }
}
;
Ae.isValidElement = cb;
Ae.lazy = function(o) {
    return {
        $$typeof: pD,
        _payload: {
            _status: -1,
            _result: o
        },
        _init: D7
    }
}
;
Ae.memo = function(o, n) {
    return {
        $$typeof: _7,
        type: o,
        compare: n === void 0 ? null : n
    }
}
;
Ae.startTransition = function(o) {
    var n = it.T
      , a = {};
    it.T = a;
    try {
        var c = o()
          , u = it.S;
        u !== null && u(a, c),
        typeof c == "object" && c !== null && typeof c.then == "function" && c.then(zf, AE)
    } catch (p) {
        AE(p)
    } finally {
        n !== null && a.types !== null && (n.types = a.types),
        it.T = n
    }
}
;
Ae.unstable_useCacheRefresh = function() {
    return it.H.useCacheRefresh()
}
;
Ae.use = function(o) {
    return it.H.use(o)
}
;
Ae.useActionState = function(o, n, a) {
    return it.H.useActionState(o, n, a)
}
;
Ae.useCallback = function(o, n) {
    return it.H.useCallback(o, n)
}
;
Ae.useContext = function(o) {
    return it.H.useContext(o)
}
;
Ae.useDebugValue = function() {}
;
Ae.useDeferredValue = function(o, n) {
    return it.H.useDeferredValue(o, n)
}
;
Ae.useEffect = function(o, n) {
    return it.H.useEffect(o, n)
}
;
Ae.useEffectEvent = function(o) {
    return it.H.useEffectEvent(o)
}
;
Ae.useId = function() {
    return it.H.useId()
}
;
Ae.useImperativeHandle = function(o, n, a) {
    return it.H.useImperativeHandle(o, n, a)
}
;
Ae.useInsertionEffect = function(o, n) {
    return it.H.useInsertionEffect(o, n)
}
;
Ae.useLayoutEffect = function(o, n) {
    return it.H.useLayoutEffect(o, n)
}
;
Ae.useMemo = function(o, n) {
    return it.H.useMemo(o, n)
}
;
Ae.useOptimistic = function(o, n) {
    return it.H.useOptimistic(o, n)
}
;
Ae.useReducer = function(o, n, a) {
    return it.H.useReducer(o, n, a)
}
;
Ae.useRef = function(o) {
    return it.H.useRef(o)
}
;
Ae.useState = function(o) {
    return it.H.useState(o)
}
;
Ae.useSyncExternalStore = function(o, n, a) {
    return it.H.useSyncExternalStore(o, n, a)
}
;
Ae.useTransition = function() {
    return it.H.useTransition()
}
;
Ae.version = "19.2.0";
mD.exports = Ae;
var R = mD.exports;
const Jn = nb(R);
var AD = {
    exports: {}
}
  , rm = {}
  , vD = {
    exports: {}
}
  , _D = {};
/**
* @license React
* scheduler.production.js
*
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
(function(o) {
    function n(te, ue) {
        var me = te.length;
        te.push(ue);
        e: for (; 0 < me; ) {
            var Ce = me - 1 >>> 1
              , Ye = te[Ce];
            if (0 < u(Ye, ue))
                te[Ce] = ue,
                te[me] = Ye,
                me = Ce;
            else
                break e
        }
    }
    function a(te) {
        return te.length === 0 ? null : te[0]
    }
    function c(te) {
        if (te.length === 0)
            return null;
        var ue = te[0]
          , me = te.pop();
        if (me !== ue) {
            te[0] = me;
            e: for (var Ce = 0, Ye = te.length, Co = Ye >>> 1; Ce < Co; ) {
                var Dr = 2 * (Ce + 1) - 1
                  , oo = te[Dr]
                  , Uo = Dr + 1
                  , Se = te[Uo];
                if (0 > u(oo, me))
                    Uo < Ye && 0 > u(Se, oo) ? (te[Ce] = Se,
                    te[Uo] = me,
                    Ce = Uo) : (te[Ce] = oo,
                    te[Dr] = me,
                    Ce = Dr);
                else if (Uo < Ye && 0 > u(Se, me))
                    te[Ce] = Se,
                    te[Uo] = me,
                    Ce = Uo;
                else
                    break e
            }
        }
        return ue
    }
    function u(te, ue) {
        var me = te.sortIndex - ue.sortIndex;
        return me !== 0 ? me : te.id - ue.id
    }
    if (o.unstable_now = void 0,
    typeof performance == "object" && typeof performance.now == "function") {
        var p = performance;
        o.unstable_now = function() {
            return p.now()
        }
    } else {
        var f = Date
          , w = f.now();
        o.unstable_now = function() {
            return f.now() - w
        }
    }
    var k = []
      , y = []
      , E = 1
      , S = null
      , A = 3
      , D = !1
      , N = !1
      , L = !1
      , z = !1
      , B = typeof setTimeout == "function" ? setTimeout : null
      , M = typeof clearTimeout == "function" ? clearTimeout : null
      , j = typeof setImmediate < "u" ? setImmediate : null;
    function V(te) {
        for (var ue = a(y); ue !== null; ) {
            if (ue.callback === null)
                c(y);
            else if (ue.startTime <= te)
                c(y),
                ue.sortIndex = ue.expirationTime,
                n(k, ue);
            else
                break;
            ue = a(y)
        }
    }
    function G(te) {
        if (L = !1,
        V(te),
        !N)
            if (a(k) !== null)
                N = !0,
                Y || (Y = !0,
                ee());
            else {
                var ue = a(y);
                ue !== null && de(G, ue.startTime - te)
            }
    }
    var Y = !1
      , $ = -1
      , K = 5
      , Z = -1;
    function H() {
        return z ? !0 : !(o.unstable_now() - Z < K)
    }
    function W() {
        if (z = !1,
        Y) {
            var te = o.unstable_now();
            Z = te;
            var ue = !0;
            try {
                e: {
                    N = !1,
                    L && (L = !1,
                    M($),
                    $ = -1),
                    D = !0;
                    var me = A;
                    try {
                        t: {
                            for (V(te),
                            S = a(k); S !== null && !(S.expirationTime > te && H()); ) {
                                var Ce = S.callback;
                                if (typeof Ce == "function") {
                                    S.callback = null,
                                    A = S.priorityLevel;
                                    var Ye = Ce(S.expirationTime <= te);
                                    if (te = o.unstable_now(),
                                    typeof Ye == "function") {
                                        S.callback = Ye,
                                        V(te),
                                        ue = !0;
                                        break t
                                    }
                                    S === a(k) && c(k),
                                    V(te)
                                } else
                                    c(k);
                                S = a(k)
                            }
                            if (S !== null)
                                ue = !0;
                            else {
                                var Co = a(y);
                                Co !== null && de(G, Co.startTime - te),
                                ue = !1
                            }
                        }
                        break e
                    } finally {
                        S = null,
                        A = me,
                        D = !1
                    }
                    ue = void 0
                }
            } finally {
                ue ? ee() : Y = !1
            }
        }
    }
    var ee;
    if (typeof j == "function")
        ee = function() {
            j(W)
        }
        ;
    else if (typeof MessageChannel < "u") {
        var re = new MessageChannel
          , U = re.port2;
        re.port1.onmessage = W,
        ee = function() {
            U.postMessage(null)
        }
    } else
        ee = function() {
            B(W, 0)
        }
        ;
    function de(te, ue) {
        $ = B(function() {
            te(o.unstable_now())
        }, ue)
    }
    o.unstable_IdlePriority = 5,
    o.unstable_ImmediatePriority = 1,
    o.unstable_LowPriority = 4,
    o.unstable_NormalPriority = 3,
    o.unstable_Profiling = null,
    o.unstable_UserBlockingPriority = 2,
    o.unstable_cancelCallback = function(te) {
        te.callback = null
    }
    ,
    o.unstable_forceFrameRate = function(te) {
        0 > te || 125 < te ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : K = 0 < te ? Math.floor(1e3 / te) : 5
    }
    ,
    o.unstable_getCurrentPriorityLevel = function() {
        return A
    }
    ,
    o.unstable_next = function(te) {
        switch (A) {
        case 1:
        case 2:
        case 3:
            var ue = 3;
            break;
        default:
            ue = A
        }
        var me = A;
        A = ue;
        try {
            return te()
        } finally {
            A = me
        }
    }
    ,
    o.unstable_requestPaint = function() {
        z = !0
    }
    ,
    o.unstable_runWithPriority = function(te, ue) {
        switch (te) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
            break;
        default:
            te = 3
        }
        var me = A;
        A = te;
        try {
            return ue()
        } finally {
            A = me
        }
    }
    ,
    o.unstable_scheduleCallback = function(te, ue, me) {
        var Ce = o.unstable_now();
        switch (typeof me == "object" && me !== null ? (me = me.delay,
        me = typeof me == "number" && 0 < me ? Ce + me : Ce) : me = Ce,
        te) {
        case 1:
            var Ye = -1;
            break;
        case 2:
            Ye = 250;
            break;
        case 5:
            Ye = 1073741823;
            break;
        case 4:
            Ye = 1e4;
            break;
        default:
            Ye = 5e3
        }
        return Ye = me + Ye,
        te = {
            id: E++,
            callback: ue,
            priorityLevel: te,
            startTime: me,
            expirationTime: Ye,
            sortIndex: -1
        },
        me > Ce ? (te.sortIndex = me,
        n(y, te),
        a(k) === null && te === a(y) && (L ? (M($),
        $ = -1) : L = !0,
        de(G, me - Ce))) : (te.sortIndex = Ye,
        n(k, te),
        N || D || (N = !0,
        Y || (Y = !0,
        ee()))),
        te
    }
    ,
    o.unstable_shouldYield = H,
    o.unstable_wrapCallback = function(te) {
        var ue = A;
        return function() {
            var me = A;
            A = ue;
            try {
                return te.apply(this, arguments)
            } finally {
                A = me
            }
        }
    }
}
)(_D);
vD.exports = _D;
var I7 = vD.exports
  , CD = {
    exports: {}
}
  , ao = {};
/**
* @license React
* react-dom.production.js
*
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
var M7 = R;
function yD(o) {
    var n = "https://react.dev/errors/" + o;
    if (1 < arguments.length) {
        n += "?args[]=" + encodeURIComponent(arguments[1]);
        for (var a = 2; a < arguments.length; a++)
            n += "&args[]=" + encodeURIComponent(arguments[a])
    }
    return "Minified React error #" + o + "; visit " + n + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
}
function On() {}
var io = {
    d: {
        f: On,
        r: function() {
            throw Error(yD(522))
        },
        D: On,
        C: On,
        L: On,
        m: On,
        X: On,
        S: On,
        M: On
    },
    p: 0,
    findDOMNode: null
}
  , B7 = Symbol.for("react.portal");
function N7(o, n, a) {
    var c = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
        $$typeof: B7,
        key: c == null ? null : "" + c,
        children: o,
        containerInfo: n,
        implementation: a
    }
}
var rc = M7.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
function nm(o, n) {
    if (o === "font")
        return "";
    if (typeof n == "string")
        return n === "use-credentials" ? n : ""
}
ao.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = io;
ao.createPortal = function(o, n) {
    var a = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!n || n.nodeType !== 1 && n.nodeType !== 9 && n.nodeType !== 11)
        throw Error(yD(299));
    return N7(o, n, null, a)
}
;
ao.flushSync = function(o) {
    var n = rc.T
      , a = io.p;
    try {
        if (rc.T = null,
        io.p = 2,
        o)
            return o()
    } finally {
        rc.T = n,
        io.p = a,
        io.d.f()
    }
}
;
ao.preconnect = function(o, n) {
    typeof o == "string" && (n ? (n = n.crossOrigin,
    n = typeof n == "string" ? n === "use-credentials" ? n : "" : void 0) : n = null,
    io.d.C(o, n))
}
;
ao.prefetchDNS = function(o) {
    typeof o == "string" && io.d.D(o)
}
;
ao.preinit = function(o, n) {
    if (typeof o == "string" && n && typeof n.as == "string") {
        var a = n.as
          , c = nm(a, n.crossOrigin)
          , u = typeof n.integrity == "string" ? n.integrity : void 0
          , p = typeof n.fetchPriority == "string" ? n.fetchPriority : void 0;
        a === "style" ? io.d.S(o, typeof n.precedence == "string" ? n.precedence : void 0, {
            crossOrigin: c,
            integrity: u,
            fetchPriority: p
        }) : a === "script" && io.d.X(o, {
            crossOrigin: c,
            integrity: u,
            fetchPriority: p,
            nonce: typeof n.nonce == "string" ? n.nonce : void 0
        })
    }
}
;
ao.preinitModule = function(o, n) {
    if (typeof o == "string")
        if (typeof n == "object" && n !== null) {
            if (n.as == null || n.as === "script") {
                var a = nm(n.as, n.crossOrigin);
                io.d.M(o, {
                    crossOrigin: a,
                    integrity: typeof n.integrity == "string" ? n.integrity : void 0,
                    nonce: typeof n.nonce == "string" ? n.nonce : void 0
                })
            }
        } else
            n == null && io.d.M(o)
}
;
ao.preload = function(o, n) {
    if (typeof o == "string" && typeof n == "object" && n !== null && typeof n.as == "string") {
        var a = n.as
          , c = nm(a, n.crossOrigin);
        io.d.L(o, a, {
            crossOrigin: c,
            integrity: typeof n.integrity == "string" ? n.integrity : void 0,
            nonce: typeof n.nonce == "string" ? n.nonce : void 0,
            type: typeof n.type == "string" ? n.type : void 0,
            fetchPriority: typeof n.fetchPriority == "string" ? n.fetchPriority : void 0,
            referrerPolicy: typeof n.referrerPolicy == "string" ? n.referrerPolicy : void 0,
            imageSrcSet: typeof n.imageSrcSet == "string" ? n.imageSrcSet : void 0,
            imageSizes: typeof n.imageSizes == "string" ? n.imageSizes : void 0,
            media: typeof n.media == "string" ? n.media : void 0
        })
    }
}
;
ao.preloadModule = function(o, n) {
    if (typeof o == "string")
        if (n) {
            var a = nm(n.as, n.crossOrigin);
            io.d.m(o, {
                as: typeof n.as == "string" && n.as !== "script" ? n.as : void 0,
                crossOrigin: a,
                integrity: typeof n.integrity == "string" ? n.integrity : void 0
            })
        } else
            io.d.m(o)
}
;
ao.requestFormReset = function(o) {
    io.d.r(o)
}
;
ao.unstable_batchedUpdates = function(o, n) {
    return o(n)
}
;
ao.useFormState = function(o, n, a) {
    return rc.H.useFormState(o, n, a)
}
;
ao.useFormStatus = function() {
    return rc.H.useHostTransitionStatus()
}
;
ao.version = "19.2.0";
function xD() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
        try {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(xD)
        } catch (o) {
            console.error(o)
        }
}
xD(),
CD.exports = ao;
var P7 = CD.exports;
/**
* @license React
* react-dom-client.production.js
*
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
var jt = I7
  , ED = R
  , j7 = P7;
function oe(o) {
    var n = "https://react.dev/errors/" + o;
    if (1 < arguments.length) {
        n += "?args[]=" + encodeURIComponent(arguments[1]);
        for (var a = 2; a < arguments.length; a++)
            n += "&args[]=" + encodeURIComponent(arguments[a])
    }
    return "Minified React error #" + o + "; visit " + n + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
}
function SD(o) {
    return !(!o || o.nodeType !== 1 && o.nodeType !== 9 && o.nodeType !== 11)
}
function Wc(o) {
    var n = o
      , a = o;
    if (o.alternate)
        for (; n.return; )
            n = n.return;
    else {
        o = n;
        do
            n = o,
            n.flags & 4098 && (a = n.return),
            o = n.return;
        while (o)
    }
    return n.tag === 3 ? a : null
}
function DD(o) {
    if (o.tag === 13) {
        var n = o.memoizedState;
        if (n === null && (o = o.alternate,
        o !== null && (n = o.memoizedState)),
        n !== null)
            return n.dehydrated
    }
    return null
}
function TD(o) {
    if (o.tag === 31) {
        var n = o.memoizedState;
        if (n === null && (o = o.alternate,
        o !== null && (n = o.memoizedState)),
        n !== null)
            return n.dehydrated
    }
    return null
}
function vE(o) {
    if (Wc(o) !== o)
        throw Error(oe(188))
}
function L7(o) {
    var n = o.alternate;
    if (!n) {
        if (n = Wc(o),
        n === null)
            throw Error(oe(188));
        return n !== o ? null : o
    }
    for (var a = o, c = n; ; ) {
        var u = a.return;
        if (u === null)
            break;
        var p = u.alternate;
        if (p === null) {
            if (c = u.return,
            c !== null) {
                a = c;
                continue
            }
            break
        }
        if (u.child === p.child) {
            for (p = u.child; p; ) {
                if (p === a)
                    return vE(u),
                    o;
                if (p === c)
                    return vE(u),
                    n;
                p = p.sibling
            }
            throw Error(oe(188))
        }
        if (a.return !== c.return)
            a = u,
            c = p;
        else {
            for (var f = !1, w = u.child; w; ) {
                if (w === a) {
                    f = !0,
                    a = u,
                    c = p;
                    break
                }
                if (w === c) {
                    f = !0,
                    c = u,
                    a = p;
                    break
                }
                w = w.sibling
            }
            if (!f) {
                for (w = p.child; w; ) {
                    if (w === a) {
                        f = !0,
                        a = p,
                        c = u;
                        break
                    }
                    if (w === c) {
                        f = !0,
                        c = p,
                        a = u;
                        break
                    }
                    w = w.sibling
                }
                if (!f)
                    throw Error(oe(189))
            }
        }
        if (a.alternate !== c)
            throw Error(oe(190))
    }
    if (a.tag !== 3)
        throw Error(oe(188));
    return a.stateNode.current === a ? o : n
}
function ID(o) {
    var n = o.tag;
    if (n === 5 || n === 26 || n === 27 || n === 6)
        return o;
    for (o = o.child; o !== null; ) {
        if (n = ID(o),
        n !== null)
            return n;
        o = o.sibling
    }
    return null
}
var st = Object.assign
  , z7 = Symbol.for("react.element")
  , Mu = Symbol.for("react.transitional.element")
  , Zl = Symbol.for("react.portal")
  , ea = Symbol.for("react.fragment")
  , MD = Symbol.for("react.strict_mode")
  , Of = Symbol.for("react.profiler")
  , BD = Symbol.for("react.consumer")
  , un = Symbol.for("react.context")
  , db = Symbol.for("react.forward_ref")
  , Rf = Symbol.for("react.suspense")
  , Ff = Symbol.for("react.suspense_list")
  , ub = Symbol.for("react.memo")
  , Vn = Symbol.for("react.lazy")
  , Vf = Symbol.for("react.activity")
  , O7 = Symbol.for("react.memo_cache_sentinel")
  , _E = Symbol.iterator;
function Ul(o) {
    return o === null || typeof o != "object" ? null : (o = _E && o[_E] || o["@@iterator"],
    typeof o == "function" ? o : null)
}
var R7 = Symbol.for("react.client.reference");
function Uf(o) {
    if (o == null)
        return null;
    if (typeof o == "function")
        return o.$$typeof === R7 ? null : o.displayName || o.name || null;
    if (typeof o == "string")
        return o;
    switch (o) {
    case ea:
        return "Fragment";
    case Of:
        return "Profiler";
    case MD:
        return "StrictMode";
    case Rf:
        return "Suspense";
    case Ff:
        return "SuspenseList";
    case Vf:
        return "Activity"
    }
    if (typeof o == "object")
        switch (o.$$typeof) {
        case Zl:
            return "Portal";
        case un:
            return o.displayName || "Context";
        case BD:
            return (o._context.displayName || "Context") + ".Consumer";
        case db:
            var n = o.render;
            return o = o.displayName,
            o || (o = n.displayName || n.name || "",
            o = o !== "" ? "ForwardRef(" + o + ")" : "ForwardRef"),
            o;
        case ub:
            return n = o.displayName || null,
            n !== null ? n : Uf(o.type) || "Memo";
        case Vn:
            n = o._payload,
            o = o._init;
            try {
                return Uf(o(n))
            } catch {}
        }
    return null
}
var Jl = Array.isArray
  , we = ED.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE
  , Oe = j7.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE
  , Qi = {
    pending: !1,
    data: null,
    method: null,
    action: null
}
  , Hf = []
  , ta = -1;
function Hr(o) {
    return {
        current: o
    }
}
function Vt(o) {
    0 > ta || (o.current = Hf[ta],
    Hf[ta] = null,
    ta--)
}
function tt(o, n) {
    ta++,
    Hf[ta] = o.current,
    o.current = n
}
var Fr = Hr(null)
  , _c = Hr(null)
  , Xn = Hr(null)
  , bh = Hr(null);
function wh(o, n) {
    switch (tt(Xn, n),
    tt(_c, o),
    tt(Fr, null),
    n.nodeType) {
    case 9:
    case 11:
        o = (o = n.documentElement) && (o = o.namespaceURI) ? DS(o) : 0;
        break;
    default:
        if (o = n.tagName,
        n = n.namespaceURI)
            n = DS(n),
            o = JI(n, o);
        else
            switch (o) {
            case "svg":
                o = 1;
                break;
            case "math":
                o = 2;
                break;
            default:
                o = 0
            }
    }
    Vt(Fr),
    tt(Fr, o)
}
function xa() {
    Vt(Fr),
    Vt(_c),
    Vt(Xn)
}
function Wf(o) {
    o.memoizedState !== null && tt(bh, o);
    var n = Fr.current
      , a = JI(n, o.type);
    n !== a && (tt(_c, o),
    tt(Fr, a))
}
function Ah(o) {
    _c.current === o && (Vt(Fr),
    Vt(_c)),
    bh.current === o && (Vt(bh),
    Nc._currentValue = Qi)
}
var jg, CE;
function Hi(o) {
    if (jg === void 0)
        try {
            throw Error()
        } catch (a) {
            var n = a.stack.trim().match(/\n( *(at )?)/);
            jg = n && n[1] || "",
            CE = -1 < a.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < a.stack.indexOf("@") ? "@unknown:0:0" : ""
        }
    return `
` + jg + o + CE
}
var Lg = !1;
function zg(o, n) {
    if (!o || Lg)
        return "";
    Lg = !0;
    var a = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
        var c = {
            DetermineComponentFrameRoot: function() {
                try {
                    if (n) {
                        var S = function() {
                            throw Error()
                        };
                        if (Object.defineProperty(S.prototype, "props", {
                            set: function() {
                                throw Error()
                            }
                        }),
                        typeof Reflect == "object" && Reflect.construct) {
                            try {
                                Reflect.construct(S, [])
                            } catch (D) {
                                var A = D
                            }
                            Reflect.construct(o, [], S)
                        } else {
                            try {
                                S.call()
                            } catch (D) {
                                A = D
                            }
                            o.call(S.prototype)
                        }
                    } else {
                        try {
                            throw Error()
                        } catch (D) {
                            A = D
                        }
                        (S = o()) && typeof S.catch == "function" && S.catch(function() {})
                    }
                } catch (D) {
                    if (D && A && typeof D.stack == "string")
                        return [D.stack, A.stack]
                }
                return [null, null]
            }
        };
        c.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
        var u = Object.getOwnPropertyDescriptor(c.DetermineComponentFrameRoot, "name");
        u && u.configurable && Object.defineProperty(c.DetermineComponentFrameRoot, "name", {
            value: "DetermineComponentFrameRoot"
        });
        var p = c.DetermineComponentFrameRoot()
          , f = p[0]
          , w = p[1];
        if (f && w) {
            var k = f.split(`
`)
              , y = w.split(`
`);
            for (u = c = 0; c < k.length && !k[c].includes("DetermineComponentFrameRoot"); )
                c++;
            for (; u < y.length && !y[u].includes("DetermineComponentFrameRoot"); )
                u++;
            if (c === k.length || u === y.length)
                for (c = k.length - 1,
                u = y.length - 1; 1 <= c && 0 <= u && k[c] !== y[u]; )
                    u--;
            for (; 1 <= c && 0 <= u; c--,
            u--)
                if (k[c] !== y[u]) {
                    if (c !== 1 || u !== 1)
                        do
                            if (c--,
                            u--,
                            0 > u || k[c] !== y[u]) {
                                var E = `
` + k[c].replace(" at new ", " at ");
                                return o.displayName && E.includes("<anonymous>") && (E = E.replace("<anonymous>", o.displayName)),
                                E
                            }
                        while (1 <= c && 0 <= u);
                    break
                }
        }
    } finally {
        Lg = !1,
        Error.prepareStackTrace = a
    }
    return (a = o ? o.displayName || o.name : "") ? Hi(a) : ""
}
function F7(o, n) {
    switch (o.tag) {
    case 26:
    case 27:
    case 5:
        return Hi(o.type);
    case 16:
        return Hi("Lazy");
    case 13:
        return o.child !== n && n !== null ? Hi("Suspense Fallback") : Hi("Suspense");
    case 19:
        return Hi("SuspenseList");
    case 0:
    case 15:
        return zg(o.type, !1);
    case 11:
        return zg(o.type.render, !1);
    case 1:
        return zg(o.type, !0);
    case 31:
        return Hi("Activity");
    default:
        return ""
    }
}
function yE(o) {
    try {
        var n = ""
          , a = null;
        do
            n += F7(o, a),
            a = o,
            o = o.return;
        while (o);
        return n
    } catch (c) {
        return `
Error generating stack: ` + c.message + `
` + c.stack
    }
}
var $f = Object.prototype.hasOwnProperty
  , hb = jt.unstable_scheduleCallback
  , Og = jt.unstable_cancelCallback
  , V7 = jt.unstable_shouldYield
  , U7 = jt.unstable_requestPaint
  , Lo = jt.unstable_now
  , H7 = jt.unstable_getCurrentPriorityLevel
  , ND = jt.unstable_ImmediatePriority
  , PD = jt.unstable_UserBlockingPriority
  , vh = jt.unstable_NormalPriority
  , W7 = jt.unstable_LowPriority
  , jD = jt.unstable_IdlePriority
  , $7 = jt.log
  , q7 = jt.unstable_setDisableYieldValue
  , $c = null
  , zo = null;
function Gn(o) {
    if (typeof $7 == "function" && q7(o),
    zo && typeof zo.setStrictMode == "function")
        try {
            zo.setStrictMode($c, o)
        } catch {}
}
var Oo = Math.clz32 ? Math.clz32 : Y7
  , G7 = Math.log
  , K7 = Math.LN2;
function Y7(o) {
    return o >>>= 0,
    o === 0 ? 32 : 31 - (G7(o) / K7 | 0) | 0
}
var Bu = 256
  , Nu = 262144
  , Pu = 4194304;
function Wi(o) {
    var n = o & 42;
    if (n !== 0)
        return n;
    switch (o & -o) {
    case 1:
        return 1;
    case 2:
        return 2;
    case 4:
        return 4;
    case 8:
        return 8;
    case 16:
        return 16;
    case 32:
        return 32;
    case 64:
        return 64;
    case 128:
        return 128;
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
        return o & 261888;
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
        return o & 3932160;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
        return o & 62914560;
    case 67108864:
        return 67108864;
    case 134217728:
        return 134217728;
    case 268435456:
        return 268435456;
    case 536870912:
        return 536870912;
    case 1073741824:
        return 0;
    default:
        return o
    }
}
function im(o, n, a) {
    var c = o.pendingLanes;
    if (c === 0)
        return 0;
    var u = 0
      , p = o.suspendedLanes
      , f = o.pingedLanes;
    o = o.warmLanes;
    var w = c & 134217727;
    return w !== 0 ? (c = w & ~p,
    c !== 0 ? u = Wi(c) : (f &= w,
    f !== 0 ? u = Wi(f) : a || (a = w & ~o,
    a !== 0 && (u = Wi(a))))) : (w = c & ~p,
    w !== 0 ? u = Wi(w) : f !== 0 ? u = Wi(f) : a || (a = c & ~o,
    a !== 0 && (u = Wi(a)))),
    u === 0 ? 0 : n !== 0 && n !== u && !(n & p) && (p = u & -u,
    a = n & -n,
    p >= a || p === 32 && (a & 4194048) !== 0) ? n : u
}
function qc(o, n) {
    return (o.pendingLanes & ~(o.suspendedLanes & ~o.pingedLanes) & n) === 0
}
function Q7(o, n) {
    switch (o) {
    case 1:
    case 2:
    case 4:
    case 8:
    case 64:
        return n + 250;
    case 16:
    case 32:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
        return n + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
        return -1;
    case 67108864:
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
        return -1;
    default:
        return -1
    }
}
function LD() {
    var o = Pu;
    return Pu <<= 1,
    !(Pu & 62914560) && (Pu = 4194304),
    o
}
function Rg(o) {
    for (var n = [], a = 0; 31 > a; a++)
        n.push(o);
    return n
}
function Gc(o, n) {
    o.pendingLanes |= n,
    n !== 268435456 && (o.suspendedLanes = 0,
    o.pingedLanes = 0,
    o.warmLanes = 0)
}
function Z7(o, n, a, c, u, p) {
    var f = o.pendingLanes;
    o.pendingLanes = a,
    o.suspendedLanes = 0,
    o.pingedLanes = 0,
    o.warmLanes = 0,
    o.expiredLanes &= a,
    o.entangledLanes &= a,
    o.errorRecoveryDisabledLanes &= a,
    o.shellSuspendCounter = 0;
    var w = o.entanglements
      , k = o.expirationTimes
      , y = o.hiddenUpdates;
    for (a = f & ~a; 0 < a; ) {
        var E = 31 - Oo(a)
          , S = 1 << E;
        w[E] = 0,
        k[E] = -1;
        var A = y[E];
        if (A !== null)
            for (y[E] = null,
            E = 0; E < A.length; E++) {
                var D = A[E];
                D !== null && (D.lane &= -536870913)
            }
        a &= ~S
    }
    c !== 0 && zD(o, c, 0),
    p !== 0 && u === 0 && o.tag !== 0 && (o.suspendedLanes |= p & ~(f & ~n))
}
function zD(o, n, a) {
    o.pendingLanes |= n,
    o.suspendedLanes &= ~n;
    var c = 31 - Oo(n);
    o.entangledLanes |= n,
    o.entanglements[c] = o.entanglements[c] | 1073741824 | a & 261930
}
function OD(o, n) {
    var a = o.entangledLanes |= n;
    for (o = o.entanglements; a; ) {
        var c = 31 - Oo(a)
          , u = 1 << c;
        u & n | o[c] & n && (o[c] |= n),
        a &= ~u
    }
}
function RD(o, n) {
    var a = n & -n;
    return a = a & 42 ? 1 : mb(a),
    a & (o.suspendedLanes | n) ? 0 : a
}
function mb(o) {
    switch (o) {
    case 2:
        o = 1;
        break;
    case 8:
        o = 4;
        break;
    case 32:
        o = 16;
        break;
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
        o = 128;
        break;
    case 268435456:
        o = 134217728;
        break;
    default:
        o = 0
    }
    return o
}
function pb(o) {
    return o &= -o,
    2 < o ? 8 < o ? o & 134217727 ? 32 : 268435456 : 8 : 2
}
function FD() {
    var o = Oe.p;
    return o !== 0 ? o : (o = window.event,
    o === void 0 ? 32 : cM(o.type))
}
function xE(o, n) {
    var a = Oe.p;
    try {
        return Oe.p = o,
        n()
    } finally {
        Oe.p = a
    }
}
var pi = Math.random().toString(36).slice(2)
  , Gt = "__reactFiber$" + pi
  , vo = "__reactProps$" + pi
  , Ra = "__reactContainer$" + pi
  , qf = "__reactEvents$" + pi
  , J7 = "__reactListeners$" + pi
  , X7 = "__reactHandles$" + pi
  , EE = "__reactResources$" + pi
  , Kc = "__reactMarker$" + pi;
function gb(o) {
    delete o[Gt],
    delete o[vo],
    delete o[qf],
    delete o[J7],
    delete o[X7]
}
function oa(o) {
    var n = o[Gt];
    if (n)
        return n;
    for (var a = o.parentNode; a; ) {
        if (n = a[Ra] || a[Gt]) {
            if (a = n.alternate,
            n.child !== null || a !== null && a.child !== null)
                for (o = NS(o); o !== null; ) {
                    if (a = o[Gt])
                        return a;
                    o = NS(o)
                }
            return n
        }
        o = a,
        a = o.parentNode
    }
    return null
}
function Fa(o) {
    if (o = o[Gt] || o[Ra]) {
        var n = o.tag;
        if (n === 5 || n === 6 || n === 13 || n === 31 || n === 26 || n === 27 || n === 3)
            return o
    }
    return null
}
function Xl(o) {
    var n = o.tag;
    if (n === 5 || n === 26 || n === 27 || n === 6)
        return o.stateNode;
    throw Error(oe(33))
}
function ka(o) {
    var n = o[EE];
    return n || (n = o[EE] = {
        hoistableStyles: new Map,
        hoistableScripts: new Map
    }),
    n
}
function Ft(o) {
    o[Kc] = !0
}
var VD = new Set
  , UD = {};
function ls(o, n) {
    Ea(o, n),
    Ea(o + "Capture", n)
}
function Ea(o, n) {
    for (UD[o] = n,
    o = 0; o < n.length; o++)
        VD.add(n[o])
}
var e9 = RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$")
  , SE = {}
  , DE = {};
function t9(o) {
    return $f.call(DE, o) ? !0 : $f.call(SE, o) ? !1 : e9.test(o) ? DE[o] = !0 : (SE[o] = !0,
    !1)
}
function Zu(o, n, a) {
    if (t9(n))
        if (a === null)
            o.removeAttribute(n);
        else {
            switch (typeof a) {
            case "undefined":
            case "function":
            case "symbol":
                o.removeAttribute(n);
                return;
            case "boolean":
                var c = n.toLowerCase().slice(0, 5);
                if (c !== "data-" && c !== "aria-") {
                    o.removeAttribute(n);
                    return
                }
            }
            o.setAttribute(n, "" + a)
        }
}
function ju(o, n, a) {
    if (a === null)
        o.removeAttribute(n);
    else {
        switch (typeof a) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
            o.removeAttribute(n);
            return
        }
        o.setAttribute(n, "" + a)
    }
}
function on(o, n, a, c) {
    if (c === null)
        o.removeAttribute(a);
    else {
        switch (typeof c) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
            o.removeAttribute(a);
            return
        }
        o.setAttributeNS(n, a, "" + c)
    }
}
function er(o) {
    switch (typeof o) {
    case "bigint":
    case "boolean":
    case "number":
    case "string":
    case "undefined":
        return o;
    case "object":
        return o;
    default:
        return ""
    }
}
function HD(o) {
    var n = o.type;
    return (o = o.nodeName) && o.toLowerCase() === "input" && (n === "checkbox" || n === "radio")
}
function o9(o, n, a) {
    var c = Object.getOwnPropertyDescriptor(o.constructor.prototype, n);
    if (!o.hasOwnProperty(n) && typeof c < "u" && typeof c.get == "function" && typeof c.set == "function") {
        var u = c.get
          , p = c.set;
        return Object.defineProperty(o, n, {
            configurable: !0,
            get: function() {
                return u.call(this)
            },
            set: function(f) {
                a = "" + f,
                p.call(this, f)
            }
        }),
        Object.defineProperty(o, n, {
            enumerable: c.enumerable
        }),
        {
            getValue: function() {
                return a
            },
            setValue: function(f) {
                a = "" + f
            },
            stopTracking: function() {
                o._valueTracker = null,
                delete o[n]
            }
        }
    }
}
function Gf(o) {
    if (!o._valueTracker) {
        var n = HD(o) ? "checked" : "value";
        o._valueTracker = o9(o, n, "" + o[n])
    }
}
function WD(o) {
    if (!o)
        return !1;
    var n = o._valueTracker;
    if (!n)
        return !0;
    var a = n.getValue()
      , c = "";
    return o && (c = HD(o) ? o.checked ? "true" : "false" : o.value),
    o = c,
    o !== a ? (n.setValue(o),
    !0) : !1
}
function _h(o) {
    if (o = o || (typeof document < "u" ? document : void 0),
    typeof o > "u")
        return null;
    try {
        return o.activeElement || o.body
    } catch {
        return o.body
    }
}
var r9 = /[\n"\\]/g;
function Cr(o) {
    return o.replace(r9, function(n) {
        return "\\" + n.charCodeAt(0).toString(16) + " "
    })
}
function Kf(o, n, a, c, u, p, f, w) {
    o.name = "",
    f != null && typeof f != "function" && typeof f != "symbol" && typeof f != "boolean" ? o.type = f : o.removeAttribute("type"),
    n != null ? f === "number" ? (n === 0 && o.value === "" || o.value != n) && (o.value = "" + er(n)) : o.value !== "" + er(n) && (o.value = "" + er(n)) : f !== "submit" && f !== "reset" || o.removeAttribute("value"),
    n != null ? Yf(o, f, er(n)) : a != null ? Yf(o, f, er(a)) : c != null && o.removeAttribute("value"),
    u == null && p != null && (o.defaultChecked = !!p),
    u != null && (o.checked = u && typeof u != "function" && typeof u != "symbol"),
    w != null && typeof w != "function" && typeof w != "symbol" && typeof w != "boolean" ? o.name = "" + er(w) : o.removeAttribute("name")
}
function $D(o, n, a, c, u, p, f, w) {
    if (p != null && typeof p != "function" && typeof p != "symbol" && typeof p != "boolean" && (o.type = p),
    n != null || a != null) {
        if (!(p !== "submit" && p !== "reset" || n != null)) {
            Gf(o);
            return
        }
        a = a != null ? "" + er(a) : "",
        n = n != null ? "" + er(n) : a,
        w || n === o.value || (o.value = n),
        o.defaultValue = n
    }
    c = c ?? u,
    c = typeof c != "function" && typeof c != "symbol" && !!c,
    o.checked = w ? o.checked : !!c,
    o.defaultChecked = !!c,
    f != null && typeof f != "function" && typeof f != "symbol" && typeof f != "boolean" && (o.name = f),
    Gf(o)
}
function Yf(o, n, a) {
    n === "number" && _h(o.ownerDocument) === o || o.defaultValue === "" + a || (o.defaultValue = "" + a)
}
function ba(o, n, a, c) {
    if (o = o.options,
    n) {
        n = {};
        for (var u = 0; u < a.length; u++)
            n["$" + a[u]] = !0;
        for (a = 0; a < o.length; a++)
            u = n.hasOwnProperty("$" + o[a].value),
            o[a].selected !== u && (o[a].selected = u),
            u && c && (o[a].defaultSelected = !0)
    } else {
        for (a = "" + er(a),
        n = null,
        u = 0; u < o.length; u++) {
            if (o[u].value === a) {
                o[u].selected = !0,
                c && (o[u].defaultSelected = !0);
                return
            }
            n !== null || o[u].disabled || (n = o[u])
        }
        n !== null && (n.selected = !0)
    }
}
function qD(o, n, a) {
    if (n != null && (n = "" + er(n),
    n !== o.value && (o.value = n),
    a == null)) {
        o.defaultValue !== n && (o.defaultValue = n);
        return
    }
    o.defaultValue = a != null ? "" + er(a) : ""
}
function GD(o, n, a, c) {
    if (n == null) {
        if (c != null) {
            if (a != null)
                throw Error(oe(92));
            if (Jl(c)) {
                if (1 < c.length)
                    throw Error(oe(93));
                c = c[0]
            }
            a = c
        }
        a == null && (a = ""),
        n = a
    }
    a = er(n),
    o.defaultValue = a,
    c = o.textContent,
    c === a && c !== "" && c !== null && (o.value = c),
    Gf(o)
}
function Sa(o, n) {
    if (n) {
        var a = o.firstChild;
        if (a && a === o.lastChild && a.nodeType === 3) {
            a.nodeValue = n;
            return
        }
    }
    o.textContent = n
}
var n9 = new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));
function TE(o, n, a) {
    var c = n.indexOf("--") === 0;
    a == null || typeof a == "boolean" || a === "" ? c ? o.setProperty(n, "") : n === "float" ? o.cssFloat = "" : o[n] = "" : c ? o.setProperty(n, a) : typeof a != "number" || a === 0 || n9.has(n) ? n === "float" ? o.cssFloat = a : o[n] = ("" + a).trim() : o[n] = a + "px"
}
function KD(o, n, a) {
    if (n != null && typeof n != "object")
        throw Error(oe(62));
    if (o = o.style,
    a != null) {
        for (var c in a)
            !a.hasOwnProperty(c) || n != null && n.hasOwnProperty(c) || (c.indexOf("--") === 0 ? o.setProperty(c, "") : c === "float" ? o.cssFloat = "" : o[c] = "");
        for (var u in n)
            c = n[u],
            n.hasOwnProperty(u) && a[u] !== c && TE(o, u, c)
    } else
        for (var p in n)
            n.hasOwnProperty(p) && TE(o, p, n[p])
}
function fb(o) {
    if (o.indexOf("-") === -1)
        return !1;
    switch (o) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
        return !1;
    default:
        return !0
    }
}
var i9 = new Map([["acceptCharset", "accept-charset"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"], ["crossOrigin", "crossorigin"], ["accentHeight", "accent-height"], ["alignmentBaseline", "alignment-baseline"], ["arabicForm", "arabic-form"], ["baselineShift", "baseline-shift"], ["capHeight", "cap-height"], ["clipPath", "clip-path"], ["clipRule", "clip-rule"], ["colorInterpolation", "color-interpolation"], ["colorInterpolationFilters", "color-interpolation-filters"], ["colorProfile", "color-profile"], ["colorRendering", "color-rendering"], ["dominantBaseline", "dominant-baseline"], ["enableBackground", "enable-background"], ["fillOpacity", "fill-opacity"], ["fillRule", "fill-rule"], ["floodColor", "flood-color"], ["floodOpacity", "flood-opacity"], ["fontFamily", "font-family"], ["fontSize", "font-size"], ["fontSizeAdjust", "font-size-adjust"], ["fontStretch", "font-stretch"], ["fontStyle", "font-style"], ["fontVariant", "font-variant"], ["fontWeight", "font-weight"], ["glyphName", "glyph-name"], ["glyphOrientationHorizontal", "glyph-orientation-horizontal"], ["glyphOrientationVertical", "glyph-orientation-vertical"], ["horizAdvX", "horiz-adv-x"], ["horizOriginX", "horiz-origin-x"], ["imageRendering", "image-rendering"], ["letterSpacing", "letter-spacing"], ["lightingColor", "lighting-color"], ["markerEnd", "marker-end"], ["markerMid", "marker-mid"], ["markerStart", "marker-start"], ["overlinePosition", "overline-position"], ["overlineThickness", "overline-thickness"], ["paintOrder", "paint-order"], ["panose-1", "panose-1"], ["pointerEvents", "pointer-events"], ["renderingIntent", "rendering-intent"], ["shapeRendering", "shape-rendering"], ["stopColor", "stop-color"], ["stopOpacity", "stop-opacity"], ["strikethroughPosition", "strikethrough-position"], ["strikethroughThickness", "strikethrough-thickness"], ["strokeDasharray", "stroke-dasharray"], ["strokeDashoffset", "stroke-dashoffset"], ["strokeLinecap", "stroke-linecap"], ["strokeLinejoin", "stroke-linejoin"], ["strokeMiterlimit", "stroke-miterlimit"], ["strokeOpacity", "stroke-opacity"], ["strokeWidth", "stroke-width"], ["textAnchor", "text-anchor"], ["textDecoration", "text-decoration"], ["textRendering", "text-rendering"], ["transformOrigin", "transform-origin"], ["underlinePosition", "underline-position"], ["underlineThickness", "underline-thickness"], ["unicodeBidi", "unicode-bidi"], ["unicodeRange", "unicode-range"], ["unitsPerEm", "units-per-em"], ["vAlphabetic", "v-alphabetic"], ["vHanging", "v-hanging"], ["vIdeographic", "v-ideographic"], ["vMathematical", "v-mathematical"], ["vectorEffect", "vector-effect"], ["vertAdvY", "vert-adv-y"], ["vertOriginX", "vert-origin-x"], ["vertOriginY", "vert-origin-y"], ["wordSpacing", "word-spacing"], ["writingMode", "writing-mode"], ["xmlnsXlink", "xmlns:xlink"], ["xHeight", "x-height"]])
  , s9 = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
function Ju(o) {
    return s9.test("" + o) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : o
}
function hn() {}
var Qf = null;
function kb(o) {
    return o = o.target || o.srcElement || window,
    o.correspondingUseElement && (o = o.correspondingUseElement),
    o.nodeType === 3 ? o.parentNode : o
}
var ra = null
  , wa = null;
function IE(o) {
    var n = Fa(o);
    if (n && (o = n.stateNode)) {
        var a = o[vo] || null;
        e: switch (o = n.stateNode,
        n.type) {
        case "input":
            if (Kf(o, a.value, a.defaultValue, a.defaultValue, a.checked, a.defaultChecked, a.type, a.name),
            n = a.name,
            a.type === "radio" && n != null) {
                for (a = o; a.parentNode; )
                    a = a.parentNode;
                for (a = a.querySelectorAll('input[name="' + Cr("" + n) + '"][type="radio"]'),
                n = 0; n < a.length; n++) {
                    var c = a[n];
                    if (c !== o && c.form === o.form) {
                        var u = c[vo] || null;
                        if (!u)
                            throw Error(oe(90));
                        Kf(c, u.value, u.defaultValue, u.defaultValue, u.checked, u.defaultChecked, u.type, u.name)
                    }
                }
                for (n = 0; n < a.length; n++)
                    c = a[n],
                    c.form === o.form && WD(c)
            }
            break e;
        case "textarea":
            qD(o, a.value, a.defaultValue);
            break e;
        case "select":
            n = a.value,
            n != null && ba(o, !!a.multiple, n, !1)
        }
    }
}
var Fg = !1;
function YD(o, n, a) {
    if (Fg)
        return o(n, a);
    Fg = !0;
    try {
        var c = o(n);
        return c
    } finally {
        if (Fg = !1,
        (ra !== null || wa !== null) && (km(),
        ra && (n = ra,
        o = wa,
        wa = ra = null,
        IE(n),
        o)))
            for (n = 0; n < o.length; n++)
                IE(o[n])
    }
}
function Cc(o, n) {
    var a = o.stateNode;
    if (a === null)
        return null;
    var c = a[vo] || null;
    if (c === null)
        return null;
    a = c[n];
    e: switch (n) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
        (c = !c.disabled) || (o = o.type,
        c = !(o === "button" || o === "input" || o === "select" || o === "textarea")),
        o = !c;
        break e;
    default:
        o = !1
    }
    if (o)
        return null;
    if (a && typeof a != "function")
        throw Error(oe(231, n, typeof a));
    return a
}
var bn = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u")
  , Zf = !1;
if (bn)
    try {
        var Hl = {};
        Object.defineProperty(Hl, "passive", {
            get: function() {
                Zf = !0
            }
        }),
        window.addEventListener("test", Hl, Hl),
        window.removeEventListener("test", Hl, Hl)
    } catch {
        Zf = !1
    }
var Kn = null
  , bb = null
  , Xu = null;
function QD() {
    if (Xu)
        return Xu;
    var o, n = bb, a = n.length, c, u = "value"in Kn ? Kn.value : Kn.textContent, p = u.length;
    for (o = 0; o < a && n[o] === u[o]; o++)
        ;
    var f = a - o;
    for (c = 1; c <= f && n[a - c] === u[p - c]; c++)
        ;
    return Xu = u.slice(o, 1 < c ? 1 - c : void 0)
}
function eh(o) {
    var n = o.keyCode;
    return "charCode"in o ? (o = o.charCode,
    o === 0 && n === 13 && (o = 13)) : o = n,
    o === 10 && (o = 13),
    32 <= o || o === 13 ? o : 0
}
function Lu() {
    return !0
}
function ME() {
    return !1
}
function _o(o) {
    function n(a, c, u, p, f) {
        this._reactName = a,
        this._targetInst = u,
        this.type = c,
        this.nativeEvent = p,
        this.target = f,
        this.currentTarget = null;
        for (var w in o)
            o.hasOwnProperty(w) && (a = o[w],
            this[w] = a ? a(p) : p[w]);
        return this.isDefaultPrevented = (p.defaultPrevented != null ? p.defaultPrevented : p.returnValue === !1) ? Lu : ME,
        this.isPropagationStopped = ME,
        this
    }
    return st(n.prototype, {
        preventDefault: function() {
            this.defaultPrevented = !0;
            var a = this.nativeEvent;
            a && (a.preventDefault ? a.preventDefault() : typeof a.returnValue != "unknown" && (a.returnValue = !1),
            this.isDefaultPrevented = Lu)
        },
        stopPropagation: function() {
            var a = this.nativeEvent;
            a && (a.stopPropagation ? a.stopPropagation() : typeof a.cancelBubble != "unknown" && (a.cancelBubble = !0),
            this.isPropagationStopped = Lu)
        },
        persist: function() {},
        isPersistent: Lu
    }),
    n
}
var cs = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(o) {
        return o.timeStamp || Date.now()
    },
    defaultPrevented: 0,
    isTrusted: 0
}, sm = _o(cs), Yc = st({}, cs, {
    view: 0,
    detail: 0
}), a9 = _o(Yc), Vg, Ug, Wl, am = st({}, Yc, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: wb,
    button: 0,
    buttons: 0,
    relatedTarget: function(o) {
        return o.relatedTarget === void 0 ? o.fromElement === o.srcElement ? o.toElement : o.fromElement : o.relatedTarget
    },
    movementX: function(o) {
        return "movementX"in o ? o.movementX : (o !== Wl && (Wl && o.type === "mousemove" ? (Vg = o.screenX - Wl.screenX,
        Ug = o.screenY - Wl.screenY) : Ug = Vg = 0,
        Wl = o),
        Vg)
    },
    movementY: function(o) {
        return "movementY"in o ? o.movementY : Ug
    }
}), BE = _o(am), l9 = st({}, am, {
    dataTransfer: 0
}), c9 = _o(l9), d9 = st({}, Yc, {
    relatedTarget: 0
}), Hg = _o(d9), u9 = st({}, cs, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
}), h9 = _o(u9), m9 = st({}, cs, {
    clipboardData: function(o) {
        return "clipboardData"in o ? o.clipboardData : window.clipboardData
    }
}), p9 = _o(m9), g9 = st({}, cs, {
    data: 0
}), NE = _o(g9), f9 = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
}, k9 = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
}, b9 = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
};
function w9(o) {
    var n = this.nativeEvent;
    return n.getModifierState ? n.getModifierState(o) : (o = b9[o]) ? !!n[o] : !1
}
function wb() {
    return w9
}
var A9 = st({}, Yc, {
    key: function(o) {
        if (o.key) {
            var n = f9[o.key] || o.key;
            if (n !== "Unidentified")
                return n
        }
        return o.type === "keypress" ? (o = eh(o),
        o === 13 ? "Enter" : String.fromCharCode(o)) : o.type === "keydown" || o.type === "keyup" ? k9[o.keyCode] || "Unidentified" : ""
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: wb,
    charCode: function(o) {
        return o.type === "keypress" ? eh(o) : 0
    },
    keyCode: function(o) {
        return o.type === "keydown" || o.type === "keyup" ? o.keyCode : 0
    },
    which: function(o) {
        return o.type === "keypress" ? eh(o) : o.type === "keydown" || o.type === "keyup" ? o.keyCode : 0
    }
})
  , v9 = _o(A9)
  , _9 = st({}, am, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
})
  , PE = _o(_9)
  , C9 = st({}, Yc, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: wb
})
  , y9 = _o(C9)
  , x9 = st({}, cs, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
})
  , E9 = _o(x9)
  , S9 = st({}, am, {
    deltaX: function(o) {
        return "deltaX"in o ? o.deltaX : "wheelDeltaX"in o ? -o.wheelDeltaX : 0
    },
    deltaY: function(o) {
        return "deltaY"in o ? o.deltaY : "wheelDeltaY"in o ? -o.wheelDeltaY : "wheelDelta"in o ? -o.wheelDelta : 0
    },
    deltaZ: 0,
    deltaMode: 0
})
  , D9 = _o(S9)
  , T9 = st({}, cs, {
    newState: 0,
    oldState: 0
})
  , I9 = _o(T9)
  , M9 = [9, 13, 27, 32]
  , Ab = bn && "CompositionEvent"in window
  , nc = null;
bn && "documentMode"in document && (nc = document.documentMode);
var B9 = bn && "TextEvent"in window && !nc
  , ZD = bn && (!Ab || nc && 8 < nc && 11 >= nc)
  , jE = " "
  , LE = !1;
function JD(o, n) {
    switch (o) {
    case "keyup":
        return M9.indexOf(n.keyCode) !== -1;
    case "keydown":
        return n.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
        return !0;
    default:
        return !1
    }
}
function XD(o) {
    return o = o.detail,
    typeof o == "object" && "data"in o ? o.data : null
}
var na = !1;
function N9(o, n) {
    switch (o) {
    case "compositionend":
        return XD(n);
    case "keypress":
        return n.which !== 32 ? null : (LE = !0,
        jE);
    case "textInput":
        return o = n.data,
        o === jE && LE ? null : o;
    default:
        return null
    }
}
function P9(o, n) {
    if (na)
        return o === "compositionend" || !Ab && JD(o, n) ? (o = QD(),
        Xu = bb = Kn = null,
        na = !1,
        o) : null;
    switch (o) {
    case "paste":
        return null;
    case "keypress":
        if (!(n.ctrlKey || n.altKey || n.metaKey) || n.ctrlKey && n.altKey) {
            if (n.char && 1 < n.char.length)
                return n.char;
            if (n.which)
                return String.fromCharCode(n.which)
        }
        return null;
    case "compositionend":
        return ZD && n.locale !== "ko" ? null : n.data;
    default:
        return null
    }
}
var j9 = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
};
function zE(o) {
    var n = o && o.nodeName && o.nodeName.toLowerCase();
    return n === "input" ? !!j9[o.type] : n === "textarea"
}
function eT(o, n, a, c) {
    ra ? wa ? wa.push(c) : wa = [c] : ra = c,
    n = Fh(n, "onChange"),
    0 < n.length && (a = new sm("onChange","change",null,a,c),
    o.push({
        event: a,
        listeners: n
    }))
}
var ic = null
  , yc = null;
function L9(o) {
    YI(o, 0)
}
function lm(o) {
    var n = Xl(o);
    if (WD(n))
        return o
}
function OE(o, n) {
    if (o === "change")
        return n
}
var tT = !1;
if (bn) {
    var Wg;
    if (bn) {
        var $g = "oninput"in document;
        if (!$g) {
            var RE = document.createElement("div");
            RE.setAttribute("oninput", "return;"),
            $g = typeof RE.oninput == "function"
        }
        Wg = $g
    } else
        Wg = !1;
    tT = Wg && (!document.documentMode || 9 < document.documentMode)
}
function FE() {
    ic && (ic.detachEvent("onpropertychange", oT),
    yc = ic = null)
}
function oT(o) {
    if (o.propertyName === "value" && lm(yc)) {
        var n = [];
        eT(n, yc, o, kb(o)),
        YD(L9, n)
    }
}
function z9(o, n, a) {
    o === "focusin" ? (FE(),
    ic = n,
    yc = a,
    ic.attachEvent("onpropertychange", oT)) : o === "focusout" && FE()
}
function O9(o) {
    if (o === "selectionchange" || o === "keyup" || o === "keydown")
        return lm(yc)
}
function R9(o, n) {
    if (o === "click")
        return lm(n)
}
function F9(o, n) {
    if (o === "input" || o === "change")
        return lm(n)
}
function V9(o, n) {
    return o === n && (o !== 0 || 1 / o === 1 / n) || o !== o && n !== n
}
var Fo = typeof Object.is == "function" ? Object.is : V9;
function xc(o, n) {
    if (Fo(o, n))
        return !0;
    if (typeof o != "object" || o === null || typeof n != "object" || n === null)
        return !1;
    var a = Object.keys(o)
      , c = Object.keys(n);
    if (a.length !== c.length)
        return !1;
    for (c = 0; c < a.length; c++) {
        var u = a[c];
        if (!$f.call(n, u) || !Fo(o[u], n[u]))
            return !1
    }
    return !0
}
function VE(o) {
    for (; o && o.firstChild; )
        o = o.firstChild;
    return o
}
function UE(o, n) {
    var a = VE(o);
    o = 0;
    for (var c; a; ) {
        if (a.nodeType === 3) {
            if (c = o + a.textContent.length,
            o <= n && c >= n)
                return {
                    node: a,
                    offset: n - o
                };
            o = c
        }
        e: {
            for (; a; ) {
                if (a.nextSibling) {
                    a = a.nextSibling;
                    break e
                }
                a = a.parentNode
            }
            a = void 0
        }
        a = VE(a)
    }
}
function rT(o, n) {
    return o && n ? o === n ? !0 : o && o.nodeType === 3 ? !1 : n && n.nodeType === 3 ? rT(o, n.parentNode) : "contains"in o ? o.contains(n) : o.compareDocumentPosition ? !!(o.compareDocumentPosition(n) & 16) : !1 : !1
}
function nT(o) {
    o = o != null && o.ownerDocument != null && o.ownerDocument.defaultView != null ? o.ownerDocument.defaultView : window;
    for (var n = _h(o.document); n instanceof o.HTMLIFrameElement; ) {
        try {
            var a = typeof n.contentWindow.location.href == "string"
        } catch {
            a = !1
        }
        if (a)
            o = n.contentWindow;
        else
            break;
        n = _h(o.document)
    }
    return n
}
function vb(o) {
    var n = o && o.nodeName && o.nodeName.toLowerCase();
    return n && (n === "input" && (o.type === "text" || o.type === "search" || o.type === "tel" || o.type === "url" || o.type === "password") || n === "textarea" || o.contentEditable === "true")
}
var U9 = bn && "documentMode"in document && 11 >= document.documentMode
  , ia = null
  , Jf = null
  , sc = null
  , Xf = !1;
function HE(o, n, a) {
    var c = a.window === a ? a.document : a.nodeType === 9 ? a : a.ownerDocument;
    Xf || ia == null || ia !== _h(c) || (c = ia,
    "selectionStart"in c && vb(c) ? c = {
        start: c.selectionStart,
        end: c.selectionEnd
    } : (c = (c.ownerDocument && c.ownerDocument.defaultView || window).getSelection(),
    c = {
        anchorNode: c.anchorNode,
        anchorOffset: c.anchorOffset,
        focusNode: c.focusNode,
        focusOffset: c.focusOffset
    }),
    sc && xc(sc, c) || (sc = c,
    c = Fh(Jf, "onSelect"),
    0 < c.length && (n = new sm("onSelect","select",null,n,a),
    o.push({
        event: n,
        listeners: c
    }),
    n.target = ia)))
}
function Vi(o, n) {
    var a = {};
    return a[o.toLowerCase()] = n.toLowerCase(),
    a["Webkit" + o] = "webkit" + n,
    a["Moz" + o] = "moz" + n,
    a
}
var sa = {
    animationend: Vi("Animation", "AnimationEnd"),
    animationiteration: Vi("Animation", "AnimationIteration"),
    animationstart: Vi("Animation", "AnimationStart"),
    transitionrun: Vi("Transition", "TransitionRun"),
    transitionstart: Vi("Transition", "TransitionStart"),
    transitioncancel: Vi("Transition", "TransitionCancel"),
    transitionend: Vi("Transition", "TransitionEnd")
}
  , qg = {}
  , iT = {};
bn && (iT = document.createElement("div").style,
"AnimationEvent"in window || (delete sa.animationend.animation,
delete sa.animationiteration.animation,
delete sa.animationstart.animation),
"TransitionEvent"in window || delete sa.transitionend.transition);
function ds(o) {
    if (qg[o])
        return qg[o];
    if (!sa[o])
        return o;
    var n = sa[o], a;
    for (a in n)
        if (n.hasOwnProperty(a) && a in iT)
            return qg[o] = n[a];
    return o
}
var sT = ds("animationend")
  , aT = ds("animationiteration")
  , lT = ds("animationstart")
  , H9 = ds("transitionrun")
  , W9 = ds("transitionstart")
  , $9 = ds("transitioncancel")
  , cT = ds("transitionend")
  , dT = new Map
  , ek = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
ek.push("scrollEnd");
function Er(o, n) {
    dT.set(o, n),
    ls(n, [o])
}
var Ch = typeof reportError == "function" ? reportError : function(o) {
    if (typeof window == "object" && typeof window.ErrorEvent == "function") {
        var n = new window.ErrorEvent("error",{
            bubbles: !0,
            cancelable: !0,
            message: typeof o == "object" && o !== null && typeof o.message == "string" ? String(o.message) : String(o),
            error: o
        });
        if (!window.dispatchEvent(n))
            return
    } else if (typeof process == "object" && typeof process.emit == "function") {
        process.emit("uncaughtException", o);
        return
    }
    console.error(o)
}
  , Xo = []
  , aa = 0
  , _b = 0;
function cm() {
    for (var o = aa, n = _b = aa = 0; n < o; ) {
        var a = Xo[n];
        Xo[n++] = null;
        var c = Xo[n];
        Xo[n++] = null;
        var u = Xo[n];
        Xo[n++] = null;
        var p = Xo[n];
        if (Xo[n++] = null,
        c !== null && u !== null) {
            var f = c.pending;
            f === null ? u.next = u : (u.next = f.next,
            f.next = u),
            c.pending = u
        }
        p !== 0 && uT(a, u, p)
    }
}
function dm(o, n, a, c) {
    Xo[aa++] = o,
    Xo[aa++] = n,
    Xo[aa++] = a,
    Xo[aa++] = c,
    _b |= c,
    o.lanes |= c,
    o = o.alternate,
    o !== null && (o.lanes |= c)
}
function Cb(o, n, a, c) {
    return dm(o, n, a, c),
    yh(o)
}
function us(o, n) {
    return dm(o, null, null, n),
    yh(o)
}
function uT(o, n, a) {
    o.lanes |= a;
    var c = o.alternate;
    c !== null && (c.lanes |= a);
    for (var u = !1, p = o.return; p !== null; )
        p.childLanes |= a,
        c = p.alternate,
        c !== null && (c.childLanes |= a),
        p.tag === 22 && (o = p.stateNode,
        o === null || o._visibility & 1 || (u = !0)),
        o = p,
        p = p.return;
    return o.tag === 3 ? (p = o.stateNode,
    u && n !== null && (u = 31 - Oo(a),
    o = p.hiddenUpdates,
    c = o[u],
    c === null ? o[u] = [n] : c.push(n),
    n.lane = a | 536870912),
    p) : null
}
function yh(o) {
    if (50 < gc)
        throw gc = 0,
        vk = null,
        Error(oe(185));
    for (var n = o.return; n !== null; )
        o = n,
        n = o.return;
    return o.tag === 3 ? o.stateNode : null
}
var la = {};
function q9(o, n, a, c) {
    this.tag = o,
    this.key = a,
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
    this.index = 0,
    this.refCleanup = this.ref = null,
    this.pendingProps = n,
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
    this.mode = c,
    this.subtreeFlags = this.flags = 0,
    this.deletions = null,
    this.childLanes = this.lanes = 0,
    this.alternate = null
}
function Po(o, n, a, c) {
    return new q9(o,n,a,c)
}
function yb(o) {
    return o = o.prototype,
    !(!o || !o.isReactComponent)
}
function pn(o, n) {
    var a = o.alternate;
    return a === null ? (a = Po(o.tag, n, o.key, o.mode),
    a.elementType = o.elementType,
    a.type = o.type,
    a.stateNode = o.stateNode,
    a.alternate = o,
    o.alternate = a) : (a.pendingProps = n,
    a.type = o.type,
    a.flags = 0,
    a.subtreeFlags = 0,
    a.deletions = null),
    a.flags = o.flags & 65011712,
    a.childLanes = o.childLanes,
    a.lanes = o.lanes,
    a.child = o.child,
    a.memoizedProps = o.memoizedProps,
    a.memoizedState = o.memoizedState,
    a.updateQueue = o.updateQueue,
    n = o.dependencies,
    a.dependencies = n === null ? null : {
        lanes: n.lanes,
        firstContext: n.firstContext
    },
    a.sibling = o.sibling,
    a.index = o.index,
    a.ref = o.ref,
    a.refCleanup = o.refCleanup,
    a
}
function hT(o, n) {
    o.flags &= 65011714;
    var a = o.alternate;
    return a === null ? (o.childLanes = 0,
    o.lanes = n,
    o.child = null,
    o.subtreeFlags = 0,
    o.memoizedProps = null,
    o.memoizedState = null,
    o.updateQueue = null,
    o.dependencies = null,
    o.stateNode = null) : (o.childLanes = a.childLanes,
    o.lanes = a.lanes,
    o.child = a.child,
    o.subtreeFlags = 0,
    o.deletions = null,
    o.memoizedProps = a.memoizedProps,
    o.memoizedState = a.memoizedState,
    o.updateQueue = a.updateQueue,
    o.type = a.type,
    n = a.dependencies,
    o.dependencies = n === null ? null : {
        lanes: n.lanes,
        firstContext: n.firstContext
    }),
    o
}
function th(o, n, a, c, u, p) {
    var f = 0;
    if (c = o,
    typeof o == "function")
        yb(o) && (f = 1);
    else if (typeof o == "string")
        f = ZV(o, a, Fr.current) ? 26 : o === "html" || o === "head" || o === "body" ? 27 : 5;
    else
        e: switch (o) {
        case Vf:
            return o = Po(31, a, n, u),
            o.elementType = Vf,
            o.lanes = p,
            o;
        case ea:
            return Zi(a.children, u, p, n);
        case MD:
            f = 8,
            u |= 24;
            break;
        case Of:
            return o = Po(12, a, n, u | 2),
            o.elementType = Of,
            o.lanes = p,
            o;
        case Rf:
            return o = Po(13, a, n, u),
            o.elementType = Rf,
            o.lanes = p,
            o;
        case Ff:
            return o = Po(19, a, n, u),
            o.elementType = Ff,
            o.lanes = p,
            o;
        default:
            if (typeof o == "object" && o !== null)
                switch (o.$$typeof) {
                case un:
                    f = 10;
                    break e;
                case BD:
                    f = 9;
                    break e;
                case db:
                    f = 11;
                    break e;
                case ub:
                    f = 14;
                    break e;
                case Vn:
                    f = 16,
                    c = null;
                    break e
                }
            f = 29,
            a = Error(oe(130, o === null ? "null" : typeof o, "")),
            c = null
        }
    return n = Po(f, a, n, u),
    n.elementType = o,
    n.type = c,
    n.lanes = p,
    n
}
function Zi(o, n, a, c) {
    return o = Po(7, o, c, n),
    o.lanes = a,
    o
}
function Gg(o, n, a) {
    return o = Po(6, o, null, n),
    o.lanes = a,
    o
}
function mT(o) {
    var n = Po(18, null, null, 0);
    return n.stateNode = o,
    n
}
function Kg(o, n, a) {
    return n = Po(4, o.children !== null ? o.children : [], o.key, n),
    n.lanes = a,
    n.stateNode = {
        containerInfo: o.containerInfo,
        pendingChildren: null,
        implementation: o.implementation
    },
    n
}
var WE = new WeakMap;
function rr(o, n) {
    if (typeof o == "object" && o !== null) {
        var a = WE.get(o);
        return a !== void 0 ? a : (n = {
            value: o,
            source: n,
            stack: yE(n)
        },
        WE.set(o, n),
        n)
    }
    return {
        value: o,
        source: n,
        stack: yE(n)
    }
}
var ca = []
  , da = 0
  , xh = null
  , Ec = 0
  , tr = []
  , or = 0
  , li = null
  , zr = 1
  , Or = "";
function cn(o, n) {
    ca[da++] = Ec,
    ca[da++] = xh,
    xh = o,
    Ec = n
}
function pT(o, n, a) {
    tr[or++] = zr,
    tr[or++] = Or,
    tr[or++] = li,
    li = o;
    var c = zr;
    o = Or;
    var u = 32 - Oo(c) - 1;
    c &= ~(1 << u),
    a += 1;
    var p = 32 - Oo(n) + u;
    if (30 < p) {
        var f = u - u % 5;
        p = (c & (1 << f) - 1).toString(32),
        c >>= f,
        u -= f,
        zr = 1 << 32 - Oo(n) + u | a << u | c,
        Or = p + o
    } else
        zr = 1 << p | a << u | c,
        Or = o
}
function xb(o) {
    o.return !== null && (cn(o, 1),
    pT(o, 1, 0))
}
function Eb(o) {
    for (; o === xh; )
        xh = ca[--da],
        ca[da] = null,
        Ec = ca[--da],
        ca[da] = null;
    for (; o === li; )
        li = tr[--or],
        tr[or] = null,
        Or = tr[--or],
        tr[or] = null,
        zr = tr[--or],
        tr[or] = null
}
function gT(o, n) {
    tr[or++] = zr,
    tr[or++] = Or,
    tr[or++] = li,
    zr = n.id,
    Or = n.overflow,
    li = o
}
var Kt = null
  , nt = null
  , Be = !1
  , ei = null
  , nr = !1
  , tk = Error(oe(519));
function ci(o) {
    var n = Error(oe(418, 1 < arguments.length && arguments[1] !== void 0 && arguments[1] ? "text" : "HTML", ""));
    throw Sc(rr(n, o)),
    tk
}
function $E(o) {
    var n = o.stateNode
      , a = o.type
      , c = o.memoizedProps;
    switch (n[Gt] = o,
    n[vo] = c,
    a) {
    case "dialog":
        xe("cancel", n),
        xe("close", n);
        break;
    case "iframe":
    case "object":
    case "embed":
        xe("load", n);
        break;
    case "video":
    case "audio":
        for (a = 0; a < Mc.length; a++)
            xe(Mc[a], n);
        break;
    case "source":
        xe("error", n);
        break;
    case "img":
    case "image":
    case "link":
        xe("error", n),
        xe("load", n);
        break;
    case "details":
        xe("toggle", n);
        break;
    case "input":
        xe("invalid", n),
        $D(n, c.value, c.defaultValue, c.checked, c.defaultChecked, c.type, c.name, !0);
        break;
    case "select":
        xe("invalid", n);
        break;
    case "textarea":
        xe("invalid", n),
        GD(n, c.value, c.defaultValue, c.children)
    }
    a = c.children,
    typeof a != "string" && typeof a != "number" && typeof a != "bigint" || n.textContent === "" + a || c.suppressHydrationWarning === !0 || ZI(n.textContent, a) ? (c.popover != null && (xe("beforetoggle", n),
    xe("toggle", n)),
    c.onScroll != null && xe("scroll", n),
    c.onScrollEnd != null && xe("scrollend", n),
    c.onClick != null && (n.onclick = hn),
    n = !0) : n = !1,
    n || ci(o, !0)
}
function qE(o) {
    for (Kt = o.return; Kt; )
        switch (Kt.tag) {
        case 5:
        case 31:
        case 13:
            nr = !1;
            return;
        case 27:
        case 3:
            nr = !0;
            return;
        default:
            Kt = Kt.return
        }
}
function Gs(o) {
    if (o !== Kt)
        return !1;
    if (!Be)
        return qE(o),
        Be = !0,
        !1;
    var n = o.tag, a;
    if ((a = n !== 3 && n !== 27) && ((a = n === 5) && (a = o.type,
    a = !(a !== "form" && a !== "button") || Ek(o.type, o.memoizedProps)),
    a = !a),
    a && nt && ci(o),
    qE(o),
    n === 13) {
        if (o = o.memoizedState,
        o = o !== null ? o.dehydrated : null,
        !o)
            throw Error(oe(317));
        nt = BS(o)
    } else if (n === 31) {
        if (o = o.memoizedState,
        o = o !== null ? o.dehydrated : null,
        !o)
            throw Error(oe(317));
        nt = BS(o)
    } else
        n === 27 ? (n = nt,
        gi(o.type) ? (o = Ik,
        Ik = null,
        nt = o) : nt = n) : nt = Kt ? sr(o.stateNode.nextSibling) : null;
    return !0
}
function rs() {
    nt = Kt = null,
    Be = !1
}
function Yg() {
    var o = ei;
    return o !== null && (ko === null ? ko = o : ko.push.apply(ko, o),
    ei = null),
    o
}
function Sc(o) {
    ei === null ? ei = [o] : ei.push(o)
}
var ok = Hr(null)
  , hs = null
  , mn = null;
function Hn(o, n, a) {
    tt(ok, n._currentValue),
    n._currentValue = a
}
function gn(o) {
    o._currentValue = ok.current,
    Vt(ok)
}
function rk(o, n, a) {
    for (; o !== null; ) {
        var c = o.alternate;
        if ((o.childLanes & n) !== n ? (o.childLanes |= n,
        c !== null && (c.childLanes |= n)) : c !== null && (c.childLanes & n) !== n && (c.childLanes |= n),
        o === a)
            break;
        o = o.return
    }
}
function nk(o, n, a, c) {
    var u = o.child;
    for (u !== null && (u.return = o); u !== null; ) {
        var p = u.dependencies;
        if (p !== null) {
            var f = u.child;
            p = p.firstContext;
            e: for (; p !== null; ) {
                var w = p;
                p = u;
                for (var k = 0; k < n.length; k++)
                    if (w.context === n[k]) {
                        p.lanes |= a,
                        w = p.alternate,
                        w !== null && (w.lanes |= a),
                        rk(p.return, a, o),
                        c || (f = null);
                        break e
                    }
                p = w.next
            }
        } else if (u.tag === 18) {
            if (f = u.return,
            f === null)
                throw Error(oe(341));
            f.lanes |= a,
            p = f.alternate,
            p !== null && (p.lanes |= a),
            rk(f, a, o),
            f = null
        } else
            f = u.child;
        if (f !== null)
            f.return = u;
        else
            for (f = u; f !== null; ) {
                if (f === o) {
                    f = null;
                    break
                }
                if (u = f.sibling,
                u !== null) {
                    u.return = f.return,
                    f = u;
                    break
                }
                f = f.return
            }
        u = f
    }
}
function Va(o, n, a, c) {
    o = null;
    for (var u = n, p = !1; u !== null; ) {
        if (!p) {
            if (u.flags & 524288)
                p = !0;
            else if (u.flags & 262144)
                break
        }
        if (u.tag === 10) {
            var f = u.alternate;
            if (f === null)
                throw Error(oe(387));
            if (f = f.memoizedProps,
            f !== null) {
                var w = u.type;
                Fo(u.pendingProps.value, f.value) || (o !== null ? o.push(w) : o = [w])
            }
        } else if (u === bh.current) {
            if (f = u.alternate,
            f === null)
                throw Error(oe(387));
            f.memoizedState.memoizedState !== u.memoizedState.memoizedState && (o !== null ? o.push(Nc) : o = [Nc])
        }
        u = u.return
    }
    o !== null && nk(n, o, a, c),
    n.flags |= 262144
}
function Eh(o) {
    for (o = o.firstContext; o !== null; ) {
        if (!Fo(o.context._currentValue, o.memoizedValue))
            return !0;
        o = o.next
    }
    return !1
}
function ns(o) {
    hs = o,
    mn = null,
    o = o.dependencies,
    o !== null && (o.firstContext = null)
}
function Yt(o) {
    return fT(hs, o)
}
function zu(o, n) {
    return hs === null && ns(o),
    fT(o, n)
}
function fT(o, n) {
    var a = n._currentValue;
    if (n = {
        context: n,
        memoizedValue: a,
        next: null
    },
    mn === null) {
        if (o === null)
            throw Error(oe(308));
        mn = n,
        o.dependencies = {
            lanes: 0,
            firstContext: n
        },
        o.flags |= 524288
    } else
        mn = mn.next = n;
    return a
}
var G9 = typeof AbortController < "u" ? AbortController : function() {
    var o = []
      , n = this.signal = {
        aborted: !1,
        addEventListener: function(a, c) {
            o.push(c)
        }
    };
    this.abort = function() {
        n.aborted = !0,
        o.forEach(function(a) {
            return a()
        })
    }
}
  , K9 = jt.unstable_scheduleCallback
  , Y9 = jt.unstable_NormalPriority
  , Tt = {
    $$typeof: un,
    Consumer: null,
    Provider: null,
    _currentValue: null,
    _currentValue2: null,
    _threadCount: 0
};
function Sb() {
    return {
        controller: new G9,
        data: new Map,
        refCount: 0
    }
}
function Qc(o) {
    o.refCount--,
    o.refCount === 0 && K9(Y9, function() {
        o.controller.abort()
    })
}
var ac = null
  , ik = 0
  , Da = 0
  , Aa = null;
function Q9(o, n) {
    if (ac === null) {
        var a = ac = [];
        ik = 0,
        Da = Jb(),
        Aa = {
            status: "pending",
            value: void 0,
            then: function(c) {
                a.push(c)
            }
        }
    }
    return ik++,
    n.then(GE, GE),
    n
}
function GE() {
    if (--ik === 0 && ac !== null) {
        Aa !== null && (Aa.status = "fulfilled");
        var o = ac;
        ac = null,
        Da = 0,
        Aa = null;
        for (var n = 0; n < o.length; n++)
            (0,
            o[n])()
    }
}
function Z9(o, n) {
    var a = []
      , c = {
        status: "pending",
        value: null,
        reason: null,
        then: function(u) {
            a.push(u)
        }
    };
    return o.then(function() {
        c.status = "fulfilled",
        c.value = n;
        for (var u = 0; u < a.length; u++)
            (0,
            a[u])(n)
    }, function(u) {
        for (c.status = "rejected",
        c.reason = u,
        u = 0; u < a.length; u++)
            (0,
            a[u])(void 0)
    }),
    c
}
var KE = we.S;
we.S = function(o, n) {
    II = Lo(),
    typeof n == "object" && n !== null && typeof n.then == "function" && Q9(o, n),
    KE !== null && KE(o, n)
}
;
var Ji = Hr(null);
function Db() {
    var o = Ji.current;
    return o !== null ? o : Xe.pooledCache
}
function oh(o, n) {
    n === null ? tt(Ji, Ji.current) : tt(Ji, n.pool)
}
function kT() {
    var o = Db();
    return o === null ? null : {
        parent: Tt._currentValue,
        pool: o
    }
}
var Ua = Error(oe(460))
  , Tb = Error(oe(474))
  , um = Error(oe(542))
  , Sh = {
    then: function() {}
};
function YE(o) {
    return o = o.status,
    o === "fulfilled" || o === "rejected"
}
function bT(o, n, a) {
    switch (a = o[a],
    a === void 0 ? o.push(n) : a !== n && (n.then(hn, hn),
    n = a),
    n.status) {
    case "fulfilled":
        return n.value;
    case "rejected":
        throw o = n.reason,
        ZE(o),
        o;
    default:
        if (typeof n.status == "string")
            n.then(hn, hn);
        else {
            if (o = Xe,
            o !== null && 100 < o.shellSuspendCounter)
                throw Error(oe(482));
            o = n,
            o.status = "pending",
            o.then(function(c) {
                if (n.status === "pending") {
                    var u = n;
                    u.status = "fulfilled",
                    u.value = c
                }
            }, function(c) {
                if (n.status === "pending") {
                    var u = n;
                    u.status = "rejected",
                    u.reason = c
                }
            })
        }
        switch (n.status) {
        case "fulfilled":
            return n.value;
        case "rejected":
            throw o = n.reason,
            ZE(o),
            o
        }
        throw Xi = n,
        Ua
    }
}
function $i(o) {
    try {
        var n = o._init;
        return n(o._payload)
    } catch (a) {
        throw a !== null && typeof a == "object" && typeof a.then == "function" ? (Xi = a,
        Ua) : a
    }
}
var Xi = null;
function QE() {
    if (Xi === null)
        throw Error(oe(459));
    var o = Xi;
    return Xi = null,
    o
}
function ZE(o) {
    if (o === Ua || o === um)
        throw Error(oe(483))
}
var va = null
  , Dc = 0;
function Ou(o) {
    var n = Dc;
    return Dc += 1,
    va === null && (va = []),
    bT(va, o, n)
}
function $l(o, n) {
    n = n.props.ref,
    o.ref = n !== void 0 ? n : null
}
function Ru(o, n) {
    throw n.$$typeof === z7 ? Error(oe(525)) : (o = Object.prototype.toString.call(n),
    Error(oe(31, o === "[object Object]" ? "object with keys {" + Object.keys(n).join(", ") + "}" : o)))
}
function wT(o) {
    function n(B, M) {
        if (o) {
            var j = B.deletions;
            j === null ? (B.deletions = [M],
            B.flags |= 16) : j.push(M)
        }
    }
    function a(B, M) {
        if (!o)
            return null;
        for (; M !== null; )
            n(B, M),
            M = M.sibling;
        return null
    }
    function c(B) {
        for (var M = new Map; B !== null; )
            B.key !== null ? M.set(B.key, B) : M.set(B.index, B),
            B = B.sibling;
        return M
    }
    function u(B, M) {
        return B = pn(B, M),
        B.index = 0,
        B.sibling = null,
        B
    }
    function p(B, M, j) {
        return B.index = j,
        o ? (j = B.alternate,
        j !== null ? (j = j.index,
        j < M ? (B.flags |= 67108866,
        M) : j) : (B.flags |= 67108866,
        M)) : (B.flags |= 1048576,
        M)
    }
    function f(B) {
        return o && B.alternate === null && (B.flags |= 67108866),
        B
    }
    function w(B, M, j, V) {
        return M === null || M.tag !== 6 ? (M = Gg(j, B.mode, V),
        M.return = B,
        M) : (M = u(M, j),
        M.return = B,
        M)
    }
    function k(B, M, j, V) {
        var G = j.type;
        return G === ea ? E(B, M, j.props.children, V, j.key) : M !== null && (M.elementType === G || typeof G == "object" && G !== null && G.$$typeof === Vn && $i(G) === M.type) ? (M = u(M, j.props),
        $l(M, j),
        M.return = B,
        M) : (M = th(j.type, j.key, j.props, null, B.mode, V),
        $l(M, j),
        M.return = B,
        M)
    }
    function y(B, M, j, V) {
        return M === null || M.tag !== 4 || M.stateNode.containerInfo !== j.containerInfo || M.stateNode.implementation !== j.implementation ? (M = Kg(j, B.mode, V),
        M.return = B,
        M) : (M = u(M, j.children || []),
        M.return = B,
        M)
    }
    function E(B, M, j, V, G) {
        return M === null || M.tag !== 7 ? (M = Zi(j, B.mode, V, G),
        M.return = B,
        M) : (M = u(M, j),
        M.return = B,
        M)
    }
    function S(B, M, j) {
        if (typeof M == "string" && M !== "" || typeof M == "number" || typeof M == "bigint")
            return M = Gg("" + M, B.mode, j),
            M.return = B,
            M;
        if (typeof M == "object" && M !== null) {
            switch (M.$$typeof) {
            case Mu:
                return j = th(M.type, M.key, M.props, null, B.mode, j),
                $l(j, M),
                j.return = B,
                j;
            case Zl:
                return M = Kg(M, B.mode, j),
                M.return = B,
                M;
            case Vn:
                return M = $i(M),
                S(B, M, j)
            }
            if (Jl(M) || Ul(M))
                return M = Zi(M, B.mode, j, null),
                M.return = B,
                M;
            if (typeof M.then == "function")
                return S(B, Ou(M), j);
            if (M.$$typeof === un)
                return S(B, zu(B, M), j);
            Ru(B, M)
        }
        return null
    }
    function A(B, M, j, V) {
        var G = M !== null ? M.key : null;
        if (typeof j == "string" && j !== "" || typeof j == "number" || typeof j == "bigint")
            return G !== null ? null : w(B, M, "" + j, V);
        if (typeof j == "object" && j !== null) {
            switch (j.$$typeof) {
            case Mu:
                return j.key === G ? k(B, M, j, V) : null;
            case Zl:
                return j.key === G ? y(B, M, j, V) : null;
            case Vn:
                return j = $i(j),
                A(B, M, j, V)
            }
            if (Jl(j) || Ul(j))
                return G !== null ? null : E(B, M, j, V, null);
            if (typeof j.then == "function")
                return A(B, M, Ou(j), V);
            if (j.$$typeof === un)
                return A(B, M, zu(B, j), V);
            Ru(B, j)
        }
        return null
    }
    function D(B, M, j, V, G) {
        if (typeof V == "string" && V !== "" || typeof V == "number" || typeof V == "bigint")
            return B = B.get(j) || null,
            w(M, B, "" + V, G);
        if (typeof V == "object" && V !== null) {
            switch (V.$$typeof) {
            case Mu:
                return B = B.get(V.key === null ? j : V.key) || null,
                k(M, B, V, G);
            case Zl:
                return B = B.get(V.key === null ? j : V.key) || null,
                y(M, B, V, G);
            case Vn:
                return V = $i(V),
                D(B, M, j, V, G)
            }
            if (Jl(V) || Ul(V))
                return B = B.get(j) || null,
                E(M, B, V, G, null);
            if (typeof V.then == "function")
                return D(B, M, j, Ou(V), G);
            if (V.$$typeof === un)
                return D(B, M, j, zu(M, V), G);
            Ru(M, V)
        }
        return null
    }
    function N(B, M, j, V) {
        for (var G = null, Y = null, $ = M, K = M = 0, Z = null; $ !== null && K < j.length; K++) {
            $.index > K ? (Z = $,
            $ = null) : Z = $.sibling;
            var H = A(B, $, j[K], V);
            if (H === null) {
                $ === null && ($ = Z);
                break
            }
            o && $ && H.alternate === null && n(B, $),
            M = p(H, M, K),
            Y === null ? G = H : Y.sibling = H,
            Y = H,
            $ = Z
        }
        if (K === j.length)
            return a(B, $),
            Be && cn(B, K),
            G;
        if ($ === null) {
            for (; K < j.length; K++)
                $ = S(B, j[K], V),
                $ !== null && (M = p($, M, K),
                Y === null ? G = $ : Y.sibling = $,
                Y = $);
            return Be && cn(B, K),
            G
        }
        for ($ = c($); K < j.length; K++)
            Z = D($, B, K, j[K], V),
            Z !== null && (o && Z.alternate !== null && $.delete(Z.key === null ? K : Z.key),
            M = p(Z, M, K),
            Y === null ? G = Z : Y.sibling = Z,
            Y = Z);
        return o && $.forEach(function(W) {
            return n(B, W)
        }),
        Be && cn(B, K),
        G
    }
    function L(B, M, j, V) {
        if (j == null)
            throw Error(oe(151));
        for (var G = null, Y = null, $ = M, K = M = 0, Z = null, H = j.next(); $ !== null && !H.done; K++,
        H = j.next()) {
            $.index > K ? (Z = $,
            $ = null) : Z = $.sibling;
            var W = A(B, $, H.value, V);
            if (W === null) {
                $ === null && ($ = Z);
                break
            }
            o && $ && W.alternate === null && n(B, $),
            M = p(W, M, K),
            Y === null ? G = W : Y.sibling = W,
            Y = W,
            $ = Z
        }
        if (H.done)
            return a(B, $),
            Be && cn(B, K),
            G;
        if ($ === null) {
            for (; !H.done; K++,
            H = j.next())
                H = S(B, H.value, V),
                H !== null && (M = p(H, M, K),
                Y === null ? G = H : Y.sibling = H,
                Y = H);
            return Be && cn(B, K),
            G
        }
        for ($ = c($); !H.done; K++,
        H = j.next())
            H = D($, B, K, H.value, V),
            H !== null && (o && H.alternate !== null && $.delete(H.key === null ? K : H.key),
            M = p(H, M, K),
            Y === null ? G = H : Y.sibling = H,
            Y = H);
        return o && $.forEach(function(ee) {
            return n(B, ee)
        }),
        Be && cn(B, K),
        G
    }
    function z(B, M, j, V) {
        if (typeof j == "object" && j !== null && j.type === ea && j.key === null && (j = j.props.children),
        typeof j == "object" && j !== null) {
            switch (j.$$typeof) {
            case Mu:
                e: {
                    for (var G = j.key; M !== null; ) {
                        if (M.key === G) {
                            if (G = j.type,
                            G === ea) {
                                if (M.tag === 7) {
                                    a(B, M.sibling),
                                    V = u(M, j.props.children),
                                    V.return = B,
                                    B = V;
                                    break e
                                }
                            } else if (M.elementType === G || typeof G == "object" && G !== null && G.$$typeof === Vn && $i(G) === M.type) {
                                a(B, M.sibling),
                                V = u(M, j.props),
                                $l(V, j),
                                V.return = B,
                                B = V;
                                break e
                            }
                            a(B, M);
                            break
                        } else
                            n(B, M);
                        M = M.sibling
                    }
                    j.type === ea ? (V = Zi(j.props.children, B.mode, V, j.key),
                    V.return = B,
                    B = V) : (V = th(j.type, j.key, j.props, null, B.mode, V),
                    $l(V, j),
                    V.return = B,
                    B = V)
                }
                return f(B);
            case Zl:
                e: {
                    for (G = j.key; M !== null; ) {
                        if (M.key === G)
                            if (M.tag === 4 && M.stateNode.containerInfo === j.containerInfo && M.stateNode.implementation === j.implementation) {
                                a(B, M.sibling),
                                V = u(M, j.children || []),
                                V.return = B,
                                B = V;
                                break e
                            } else {
                                a(B, M);
                                break
                            }
                        else
                            n(B, M);
                        M = M.sibling
                    }
                    V = Kg(j, B.mode, V),
                    V.return = B,
                    B = V
                }
                return f(B);
            case Vn:
                return j = $i(j),
                z(B, M, j, V)
            }
            if (Jl(j))
                return N(B, M, j, V);
            if (Ul(j)) {
                if (G = Ul(j),
                typeof G != "function")
                    throw Error(oe(150));
                return j = G.call(j),
                L(B, M, j, V)
            }
            if (typeof j.then == "function")
                return z(B, M, Ou(j), V);
            if (j.$$typeof === un)
                return z(B, M, zu(B, j), V);
            Ru(B, j)
        }
        return typeof j == "string" && j !== "" || typeof j == "number" || typeof j == "bigint" ? (j = "" + j,
        M !== null && M.tag === 6 ? (a(B, M.sibling),
        V = u(M, j),
        V.return = B,
        B = V) : (a(B, M),
        V = Gg(j, B.mode, V),
        V.return = B,
        B = V),
        f(B)) : a(B, M)
    }
    return function(B, M, j, V) {
        try {
            Dc = 0;
            var G = z(B, M, j, V);
            return va = null,
            G
        } catch ($) {
            if ($ === Ua || $ === um)
                throw $;
            var Y = Po(29, $, null, B.mode);
            return Y.lanes = V,
            Y.return = B,
            Y
        } finally {}
    }
}
var is = wT(!0)
  , AT = wT(!1)
  , Un = !1;
function Ib(o) {
    o.updateQueue = {
        baseState: o.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
            pending: null,
            lanes: 0,
            hiddenCallbacks: null
        },
        callbacks: null
    }
}
function sk(o, n) {
    o = o.updateQueue,
    n.updateQueue === o && (n.updateQueue = {
        baseState: o.baseState,
        firstBaseUpdate: o.firstBaseUpdate,
        lastBaseUpdate: o.lastBaseUpdate,
        shared: o.shared,
        callbacks: null
    })
}
function ti(o) {
    return {
        lane: o,
        tag: 0,
        payload: null,
        callback: null,
        next: null
    }
}
function oi(o, n, a) {
    var c = o.updateQueue;
    if (c === null)
        return null;
    if (c = c.shared,
    ze & 2) {
        var u = c.pending;
        return u === null ? n.next = n : (n.next = u.next,
        u.next = n),
        c.pending = n,
        n = yh(o),
        uT(o, null, a),
        n
    }
    return dm(o, c, n, a),
    yh(o)
}
function lc(o, n, a) {
    if (n = n.updateQueue,
    n !== null && (n = n.shared,
    (a & 4194048) !== 0)) {
        var c = n.lanes;
        c &= o.pendingLanes,
        a |= c,
        n.lanes = a,
        OD(o, a)
    }
}
function Qg(o, n) {
    var a = o.updateQueue
      , c = o.alternate;
    if (c !== null && (c = c.updateQueue,
    a === c)) {
        var u = null
          , p = null;
        if (a = a.firstBaseUpdate,
        a !== null) {
            do {
                var f = {
                    lane: a.lane,
                    tag: a.tag,
                    payload: a.payload,
                    callback: null,
                    next: null
                };
                p === null ? u = p = f : p = p.next = f,
                a = a.next
            } while (a !== null);
            p === null ? u = p = n : p = p.next = n
        } else
            u = p = n;
        a = {
            baseState: c.baseState,
            firstBaseUpdate: u,
            lastBaseUpdate: p,
            shared: c.shared,
            callbacks: c.callbacks
        },
        o.updateQueue = a;
        return
    }
    o = a.lastBaseUpdate,
    o === null ? a.firstBaseUpdate = n : o.next = n,
    a.lastBaseUpdate = n
}
var ak = !1;
function cc() {
    if (ak) {
        var o = Aa;
        if (o !== null)
            throw o
    }
}
function dc(o, n, a, c) {
    ak = !1;
    var u = o.updateQueue;
    Un = !1;
    var p = u.firstBaseUpdate
      , f = u.lastBaseUpdate
      , w = u.shared.pending;
    if (w !== null) {
        u.shared.pending = null;
        var k = w
          , y = k.next;
        k.next = null,
        f === null ? p = y : f.next = y,
        f = k;
        var E = o.alternate;
        E !== null && (E = E.updateQueue,
        w = E.lastBaseUpdate,
        w !== f && (w === null ? E.firstBaseUpdate = y : w.next = y,
        E.lastBaseUpdate = k))
    }
    if (p !== null) {
        var S = u.baseState;
        f = 0,
        E = y = k = null,
        w = p;
        do {
            var A = w.lane & -536870913
              , D = A !== w.lane;
            if (D ? (Ie & A) === A : (c & A) === A) {
                A !== 0 && A === Da && (ak = !0),
                E !== null && (E = E.next = {
                    lane: 0,
                    tag: w.tag,
                    payload: w.payload,
                    callback: null,
                    next: null
                });
                e: {
                    var N = o
                      , L = w;
                    A = n;
                    var z = a;
                    switch (L.tag) {
                    case 1:
                        if (N = L.payload,
                        typeof N == "function") {
                            S = N.call(z, S, A);
                            break e
                        }
                        S = N;
                        break e;
                    case 3:
                        N.flags = N.flags & -65537 | 128;
                    case 0:
                        if (N = L.payload,
                        A = typeof N == "function" ? N.call(z, S, A) : N,
                        A == null)
                            break e;
                        S = st({}, S, A);
                        break e;
                    case 2:
                        Un = !0
                    }
                }
                A = w.callback,
                A !== null && (o.flags |= 64,
                D && (o.flags |= 8192),
                D = u.callbacks,
                D === null ? u.callbacks = [A] : D.push(A))
            } else
                D = {
                    lane: A,
                    tag: w.tag,
                    payload: w.payload,
                    callback: w.callback,
                    next: null
                },
                E === null ? (y = E = D,
                k = S) : E = E.next = D,
                f |= A;
            if (w = w.next,
            w === null) {
                if (w = u.shared.pending,
                w === null)
                    break;
                D = w,
                w = D.next,
                D.next = null,
                u.lastBaseUpdate = D,
                u.shared.pending = null
            }
        } while (!0);
        E === null && (k = S),
        u.baseState = k,
        u.firstBaseUpdate = y,
        u.lastBaseUpdate = E,
        p === null && (u.shared.lanes = 0),
        ui |= f,
        o.lanes = f,
        o.memoizedState = S
    }
}
function vT(o, n) {
    if (typeof o != "function")
        throw Error(oe(191, o));
    o.call(n)
}
function _T(o, n) {
    var a = o.callbacks;
    if (a !== null)
        for (o.callbacks = null,
        o = 0; o < a.length; o++)
            vT(a[o], n)
}
var Ta = Hr(null)
  , Dh = Hr(0);
function JE(o, n) {
    o = _n,
    tt(Dh, o),
    tt(Ta, n),
    _n = o | n.baseLanes
}
function lk() {
    tt(Dh, _n),
    tt(Ta, Ta.current)
}
function Mb() {
    _n = Dh.current,
    Vt(Ta),
    Vt(Dh)
}
var Vo = Hr(null)
  , yr = null;
function Wn(o) {
    var n = o.alternate;
    tt(yt, yt.current & 1),
    tt(Vo, o),
    yr === null && (n === null || Ta.current !== null || n.memoizedState !== null) && (yr = o)
}
function ck(o) {
    tt(yt, yt.current),
    tt(Vo, o),
    yr === null && (yr = o)
}
function CT(o) {
    o.tag === 22 ? (tt(yt, yt.current),
    tt(Vo, o),
    yr === null && (yr = o)) : $n()
}
function $n() {
    tt(yt, yt.current),
    tt(Vo, Vo.current)
}
function No(o) {
    Vt(Vo),
    yr === o && (yr = null),
    Vt(yt)
}
var yt = Hr(0);
function Th(o) {
    for (var n = o; n !== null; ) {
        if (n.tag === 13) {
            var a = n.memoizedState;
            if (a !== null && (a = a.dehydrated,
            a === null || Dk(a) || Tk(a)))
                return n
        } else if (n.tag === 19 && (n.memoizedProps.revealOrder === "forwards" || n.memoizedProps.revealOrder === "backwards" || n.memoizedProps.revealOrder === "unstable_legacy-backwards" || n.memoizedProps.revealOrder === "together")) {
            if (n.flags & 128)
                return n
        } else if (n.child !== null) {
            n.child.return = n,
            n = n.child;
            continue
        }
        if (n === o)
            break;
        for (; n.sibling === null; ) {
            if (n.return === null || n.return === o)
                return null;
            n = n.return
        }
        n.sibling.return = n.return,
        n = n.sibling
    }
    return null
}
var wn = 0
  , ve = null
  , Ke = null
  , St = null
  , Ih = !1
  , _a = !1
  , ss = !1
  , Mh = 0
  , Tc = 0
  , Ca = null
  , J9 = 0;
function gt() {
    throw Error(oe(321))
}
function Bb(o, n) {
    if (n === null)
        return !1;
    for (var a = 0; a < n.length && a < o.length; a++)
        if (!Fo(o[a], n[a]))
            return !1;
    return !0
}
function Nb(o, n, a, c, u, p) {
    return wn = p,
    ve = n,
    n.memoizedState = null,
    n.updateQueue = null,
    n.lanes = 0,
    we.H = o === null || o.memoizedState === null ? eI : Wb,
    ss = !1,
    p = a(c, u),
    ss = !1,
    _a && (p = xT(n, a, c, u)),
    yT(o),
    p
}
function yT(o) {
    we.H = Ic;
    var n = Ke !== null && Ke.next !== null;
    if (wn = 0,
    St = Ke = ve = null,
    Ih = !1,
    Tc = 0,
    Ca = null,
    n)
        throw Error(oe(300));
    o === null || It || (o = o.dependencies,
    o !== null && Eh(o) && (It = !0))
}
function xT(o, n, a, c) {
    ve = o;
    var u = 0;
    do {
        if (_a && (Ca = null),
        Tc = 0,
        _a = !1,
        25 <= u)
            throw Error(oe(301));
        if (u += 1,
        St = Ke = null,
        o.updateQueue != null) {
            var p = o.updateQueue;
            p.lastEffect = null,
            p.events = null,
            p.stores = null,
            p.memoCache != null && (p.memoCache.index = 0)
        }
        we.H = tI,
        p = n(a, c)
    } while (_a);
    return p
}
function X9() {
    var o = we.H
      , n = o.useState()[0];
    return n = typeof n.then == "function" ? Zc(n) : n,
    o = o.useState()[0],
    (Ke !== null ? Ke.memoizedState : null) !== o && (ve.flags |= 1024),
    n
}
function Pb() {
    var o = Mh !== 0;
    return Mh = 0,
    o
}
function jb(o, n, a) {
    n.updateQueue = o.updateQueue,
    n.flags &= -2053,
    o.lanes &= ~a
}
function Lb(o) {
    if (Ih) {
        for (o = o.memoizedState; o !== null; ) {
            var n = o.queue;
            n !== null && (n.pending = null),
            o = o.next
        }
        Ih = !1
    }
    wn = 0,
    St = Ke = ve = null,
    _a = !1,
    Tc = Mh = 0,
    Ca = null
}
function no() {
    var o = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
    };
    return St === null ? ve.memoizedState = St = o : St = St.next = o,
    St
}
function xt() {
    if (Ke === null) {
        var o = ve.alternate;
        o = o !== null ? o.memoizedState : null
    } else
        o = Ke.next;
    var n = St === null ? ve.memoizedState : St.next;
    if (n !== null)
        St = n,
        Ke = o;
    else {
        if (o === null)
            throw ve.alternate === null ? Error(oe(467)) : Error(oe(310));
        Ke = o,
        o = {
            memoizedState: Ke.memoizedState,
            baseState: Ke.baseState,
            baseQueue: Ke.baseQueue,
            queue: Ke.queue,
            next: null
        },
        St === null ? ve.memoizedState = St = o : St = St.next = o
    }
    return St
}
function hm() {
    return {
        lastEffect: null,
        events: null,
        stores: null,
        memoCache: null
    }
}
function Zc(o) {
    var n = Tc;
    return Tc += 1,
    Ca === null && (Ca = []),
    o = bT(Ca, o, n),
    n = ve,
    (St === null ? n.memoizedState : St.next) === null && (n = n.alternate,
    we.H = n === null || n.memoizedState === null ? eI : Wb),
    o
}
function mm(o) {
    if (o !== null && typeof o == "object") {
        if (typeof o.then == "function")
            return Zc(o);
        if (o.$$typeof === un)
            return Yt(o)
    }
    throw Error(oe(438, String(o)))
}
function zb(o) {
    var n = null
      , a = ve.updateQueue;
    if (a !== null && (n = a.memoCache),
    n == null) {
        var c = ve.alternate;
        c !== null && (c = c.updateQueue,
        c !== null && (c = c.memoCache,
        c != null && (n = {
            data: c.data.map(function(u) {
                return u.slice()
            }),
            index: 0
        })))
    }
    if (n == null && (n = {
        data: [],
        index: 0
    }),
    a === null && (a = hm(),
    ve.updateQueue = a),
    a.memoCache = n,
    a = n.data[n.index],
    a === void 0)
        for (a = n.data[n.index] = Array(o),
        c = 0; c < o; c++)
            a[c] = O7;
    return n.index++,
    a
}
function An(o, n) {
    return typeof n == "function" ? n(o) : n
}
function rh(o) {
    var n = xt();
    return Ob(n, Ke, o)
}
function Ob(o, n, a) {
    var c = o.queue;
    if (c === null)
        throw Error(oe(311));
    c.lastRenderedReducer = a;
    var u = o.baseQueue
      , p = c.pending;
    if (p !== null) {
        if (u !== null) {
            var f = u.next;
            u.next = p.next,
            p.next = f
        }
        n.baseQueue = u = p,
        c.pending = null
    }
    if (p = o.baseState,
    u === null)
        o.memoizedState = p;
    else {
        n = u.next;
        var w = f = null
          , k = null
          , y = n
          , E = !1;
        do {
            var S = y.lane & -536870913;
            if (S !== y.lane ? (Ie & S) === S : (wn & S) === S) {
                var A = y.revertLane;
                if (A === 0)
                    k !== null && (k = k.next = {
                        lane: 0,
                        revertLane: 0,
                        gesture: null,
                        action: y.action,
                        hasEagerState: y.hasEagerState,
                        eagerState: y.eagerState,
                        next: null
                    }),
                    S === Da && (E = !0);
                else if ((wn & A) === A) {
                    y = y.next,
                    A === Da && (E = !0);
                    continue
                } else
                    S = {
                        lane: 0,
                        revertLane: y.revertLane,
                        gesture: null,
                        action: y.action,
                        hasEagerState: y.hasEagerState,
                        eagerState: y.eagerState,
                        next: null
                    },
                    k === null ? (w = k = S,
                    f = p) : k = k.next = S,
                    ve.lanes |= A,
                    ui |= A;
                S = y.action,
                ss && a(p, S),
                p = y.hasEagerState ? y.eagerState : a(p, S)
            } else
                A = {
                    lane: S,
                    revertLane: y.revertLane,
                    gesture: y.gesture,
                    action: y.action,
                    hasEagerState: y.hasEagerState,
                    eagerState: y.eagerState,
                    next: null
                },
                k === null ? (w = k = A,
                f = p) : k = k.next = A,
                ve.lanes |= S,
                ui |= S;
            y = y.next
        } while (y !== null && y !== n);
        if (k === null ? f = p : k.next = w,
        !Fo(p, o.memoizedState) && (It = !0,
        E && (a = Aa,
        a !== null)))
            throw a;
        o.memoizedState = p,
        o.baseState = f,
        o.baseQueue = k,
        c.lastRenderedState = p
    }
    return u === null && (c.lanes = 0),
    [o.memoizedState, c.dispatch]
}
function Zg(o) {
    var n = xt()
      , a = n.queue;
    if (a === null)
        throw Error(oe(311));
    a.lastRenderedReducer = o;
    var c = a.dispatch
      , u = a.pending
      , p = n.memoizedState;
    if (u !== null) {
        a.pending = null;
        var f = u = u.next;
        do
            p = o(p, f.action),
            f = f.next;
        while (f !== u);
        Fo(p, n.memoizedState) || (It = !0),
        n.memoizedState = p,
        n.baseQueue === null && (n.baseState = p),
        a.lastRenderedState = p
    }
    return [p, c]
}
function ET(o, n, a) {
    var c = ve
      , u = xt()
      , p = Be;
    if (p) {
        if (a === void 0)
            throw Error(oe(407));
        a = a()
    } else
        a = n();
    var f = !Fo((Ke || u).memoizedState, a);
    if (f && (u.memoizedState = a,
    It = !0),
    u = u.queue,
    Rb(TT.bind(null, c, u, o), [o]),
    u.getSnapshot !== n || f || St !== null && St.memoizedState.tag & 1) {
        if (c.flags |= 2048,
        Ia(9, {
            destroy: void 0
        }, DT.bind(null, c, u, a, n), null),
        Xe === null)
            throw Error(oe(349));
        p || wn & 127 || ST(c, n, a)
    }
    return a
}
function ST(o, n, a) {
    o.flags |= 16384,
    o = {
        getSnapshot: n,
        value: a
    },
    n = ve.updateQueue,
    n === null ? (n = hm(),
    ve.updateQueue = n,
    n.stores = [o]) : (a = n.stores,
    a === null ? n.stores = [o] : a.push(o))
}
function DT(o, n, a, c) {
    n.value = a,
    n.getSnapshot = c,
    IT(n) && MT(o)
}
function TT(o, n, a) {
    return a(function() {
        IT(n) && MT(o)
    })
}
function IT(o) {
    var n = o.getSnapshot;
    o = o.value;
    try {
        var a = n();
        return !Fo(o, a)
    } catch {
        return !0
    }
}
function MT(o) {
    var n = us(o, 2);
    n !== null && Ao(n, o, 2)
}
function dk(o) {
    var n = no();
    if (typeof o == "function") {
        var a = o;
        if (o = a(),
        ss) {
            Gn(!0);
            try {
                a()
            } finally {
                Gn(!1)
            }
        }
    }
    return n.memoizedState = n.baseState = o,
    n.queue = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: An,
        lastRenderedState: o
    },
    n
}
function BT(o, n, a, c) {
    return o.baseState = a,
    Ob(o, Ke, typeof c == "function" ? c : An)
}
function eV(o, n, a, c, u) {
    if (gm(o))
        throw Error(oe(485));
    if (o = n.action,
    o !== null) {
        var p = {
            payload: u,
            action: o,
            next: null,
            isTransition: !0,
            status: "pending",
            value: null,
            reason: null,
            listeners: [],
            then: function(f) {
                p.listeners.push(f)
            }
        };
        we.T !== null ? a(!0) : p.isTransition = !1,
        c(p),
        a = n.pending,
        a === null ? (p.next = n.pending = p,
        NT(n, p)) : (p.next = a.next,
        n.pending = a.next = p)
    }
}
function NT(o, n) {
    var a = n.action
      , c = n.payload
      , u = o.state;
    if (n.isTransition) {
        var p = we.T
          , f = {};
        we.T = f;
        try {
            var w = a(u, c)
              , k = we.S;
            k !== null && k(f, w),
            XE(o, n, w)
        } catch (y) {
            uk(o, n, y)
        } finally {
            p !== null && f.types !== null && (p.types = f.types),
            we.T = p
        }
    } else
        try {
            p = a(u, c),
            XE(o, n, p)
        } catch (y) {
            uk(o, n, y)
        }
}
function XE(o, n, a) {
    a !== null && typeof a == "object" && typeof a.then == "function" ? a.then(function(c) {
        eS(o, n, c)
    }, function(c) {
        return uk(o, n, c)
    }) : eS(o, n, a)
}
function eS(o, n, a) {
    n.status = "fulfilled",
    n.value = a,
    PT(n),
    o.state = a,
    n = o.pending,
    n !== null && (a = n.next,
    a === n ? o.pending = null : (a = a.next,
    n.next = a,
    NT(o, a)))
}
function uk(o, n, a) {
    var c = o.pending;
    if (o.pending = null,
    c !== null) {
        c = c.next;
        do
            n.status = "rejected",
            n.reason = a,
            PT(n),
            n = n.next;
        while (n !== c)
    }
    o.action = null
}
function PT(o) {
    o = o.listeners;
    for (var n = 0; n < o.length; n++)
        (0,
        o[n])()
}
function jT(o, n) {
    return n
}
function tS(o, n) {
    if (Be) {
        var a = Xe.formState;
        if (a !== null) {
            e: {
                var c = ve;
                if (Be) {
                    if (nt) {
                        t: {
                            for (var u = nt, p = nr; u.nodeType !== 8; ) {
                                if (!p) {
                                    u = null;
                                    break t
                                }
                                if (u = sr(u.nextSibling),
                                u === null) {
                                    u = null;
                                    break t
                                }
                            }
                            p = u.data,
                            u = p === "F!" || p === "F" ? u : null
                        }
                        if (u) {
                            nt = sr(u.nextSibling),
                            c = u.data === "F!";
                            break e
                        }
                    }
                    ci(c)
                }
                c = !1
            }
            c && (n = a[0])
        }
    }
    return a = no(),
    a.memoizedState = a.baseState = n,
    c = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: jT,
        lastRenderedState: n
    },
    a.queue = c,
    a = ZT.bind(null, ve, c),
    c.dispatch = a,
    c = dk(!1),
    p = Hb.bind(null, ve, !1, c.queue),
    c = no(),
    u = {
        state: n,
        dispatch: null,
        action: o,
        pending: null
    },
    c.queue = u,
    a = eV.bind(null, ve, u, p, a),
    u.dispatch = a,
    c.memoizedState = o,
    [n, a, !1]
}
function oS(o) {
    var n = xt();
    return LT(n, Ke, o)
}
function LT(o, n, a) {
    if (n = Ob(o, n, jT)[0],
    o = rh(An)[0],
    typeof n == "object" && n !== null && typeof n.then == "function")
        try {
            var c = Zc(n)
        } catch (f) {
            throw f === Ua ? um : f
        }
    else
        c = n;
    n = xt();
    var u = n.queue
      , p = u.dispatch;
    return a !== n.memoizedState && (ve.flags |= 2048,
    Ia(9, {
        destroy: void 0
    }, tV.bind(null, u, a), null)),
    [c, p, o]
}
function tV(o, n) {
    o.action = n
}
function rS(o) {
    var n = xt()
      , a = Ke;
    if (a !== null)
        return LT(n, a, o);
    xt(),
    n = n.memoizedState,
    a = xt();
    var c = a.queue.dispatch;
    return a.memoizedState = o,
    [n, c, !1]
}
function Ia(o, n, a, c) {
    return o = {
        tag: o,
        create: a,
        deps: c,
        inst: n,
        next: null
    },
    n = ve.updateQueue,
    n === null && (n = hm(),
    ve.updateQueue = n),
    a = n.lastEffect,
    a === null ? n.lastEffect = o.next = o : (c = a.next,
    a.next = o,
    o.next = c,
    n.lastEffect = o),
    o
}
function zT() {
    return xt().memoizedState
}
function nh(o, n, a, c) {
    var u = no();
    ve.flags |= o,
    u.memoizedState = Ia(1 | n, {
        destroy: void 0
    }, a, c === void 0 ? null : c)
}
function pm(o, n, a, c) {
    var u = xt();
    c = c === void 0 ? null : c;
    var p = u.memoizedState.inst;
    Ke !== null && c !== null && Bb(c, Ke.memoizedState.deps) ? u.memoizedState = Ia(n, p, a, c) : (ve.flags |= o,
    u.memoizedState = Ia(1 | n, p, a, c))
}
function nS(o, n) {
    nh(8390656, 8, o, n)
}
function Rb(o, n) {
    pm(2048, 8, o, n)
}
function oV(o) {
    ve.flags |= 4;
    var n = ve.updateQueue;
    if (n === null)
        n = hm(),
        ve.updateQueue = n,
        n.events = [o];
    else {
        var a = n.events;
        a === null ? n.events = [o] : a.push(o)
    }
}
function OT(o) {
    var n = xt().memoizedState;
    return oV({
        ref: n,
        nextImpl: o
    }),
    function() {
        if (ze & 2)
            throw Error(oe(440));
        return n.impl.apply(void 0, arguments)
    }
}
function RT(o, n) {
    return pm(4, 2, o, n)
}
function FT(o, n) {
    return pm(4, 4, o, n)
}
function VT(o, n) {
    if (typeof n == "function") {
        o = o();
        var a = n(o);
        return function() {
            typeof a == "function" ? a() : n(null)
        }
    }
    if (n != null)
        return o = o(),
        n.current = o,
        function() {
            n.current = null
        }
}
function UT(o, n, a) {
    a = a != null ? a.concat([o]) : null,
    pm(4, 4, VT.bind(null, n, o), a)
}
function Fb() {}
function HT(o, n) {
    var a = xt();
    n = n === void 0 ? null : n;
    var c = a.memoizedState;
    return n !== null && Bb(n, c[1]) ? c[0] : (a.memoizedState = [o, n],
    o)
}
function WT(o, n) {
    var a = xt();
    n = n === void 0 ? null : n;
    var c = a.memoizedState;
    if (n !== null && Bb(n, c[1]))
        return c[0];
    if (c = o(),
    ss) {
        Gn(!0);
        try {
            o()
        } finally {
            Gn(!1)
        }
    }
    return a.memoizedState = [c, n],
    c
}
function Vb(o, n, a) {
    return a === void 0 || wn & 1073741824 && !(Ie & 261930) ? o.memoizedState = n : (o.memoizedState = a,
    o = BI(),
    ve.lanes |= o,
    ui |= o,
    a)
}
function $T(o, n, a, c) {
    return Fo(a, n) ? a : Ta.current !== null ? (o = Vb(o, a, c),
    Fo(o, n) || (It = !0),
    o) : !(wn & 42) || wn & 1073741824 && !(Ie & 261930) ? (It = !0,
    o.memoizedState = a) : (o = BI(),
    ve.lanes |= o,
    ui |= o,
    n)
}
function qT(o, n, a, c, u) {
    var p = Oe.p;
    Oe.p = p !== 0 && 8 > p ? p : 8;
    var f = we.T
      , w = {};
    we.T = w,
    Hb(o, !1, n, a);
    try {
        var k = u()
          , y = we.S;
        if (y !== null && y(w, k),
        k !== null && typeof k == "object" && typeof k.then == "function") {
            var E = Z9(k, c);
            uc(o, n, E, Ro(o))
        } else
            uc(o, n, c, Ro(o))
    } catch (S) {
        uc(o, n, {
            then: function() {},
            status: "rejected",
            reason: S
        }, Ro())
    } finally {
        Oe.p = p,
        f !== null && w.types !== null && (f.types = w.types),
        we.T = f
    }
}
function rV() {}
function hk(o, n, a, c) {
    if (o.tag !== 5)
        throw Error(oe(476));
    var u = GT(o).queue;
    qT(o, u, n, Qi, a === null ? rV : function() {
        return KT(o),
        a(c)
    }
    )
}
function GT(o) {
    var n = o.memoizedState;
    if (n !== null)
        return n;
    n = {
        memoizedState: Qi,
        baseState: Qi,
        baseQueue: null,
        queue: {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: An,
            lastRenderedState: Qi
        },
        next: null
    };
    var a = {};
    return n.next = {
        memoizedState: a,
        baseState: a,
        baseQueue: null,
        queue: {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: An,
            lastRenderedState: a
        },
        next: null
    },
    o.memoizedState = n,
    o = o.alternate,
    o !== null && (o.memoizedState = n),
    n
}
function KT(o) {
    var n = GT(o);
    n.next === null && (n = o.alternate.memoizedState),
    uc(o, n.next.queue, {}, Ro())
}
function Ub() {
    return Yt(Nc)
}
function YT() {
    return xt().memoizedState
}
function QT() {
    return xt().memoizedState
}
function nV(o) {
    for (var n = o.return; n !== null; ) {
        switch (n.tag) {
        case 24:
        case 3:
            var a = Ro();
            o = ti(a);
            var c = oi(n, o, a);
            c !== null && (Ao(c, n, a),
            lc(c, n, a)),
            n = {
                cache: Sb()
            },
            o.payload = n;
            return
        }
        n = n.return
    }
}
function iV(o, n, a) {
    var c = Ro();
    a = {
        lane: c,
        revertLane: 0,
        gesture: null,
        action: a,
        hasEagerState: !1,
        eagerState: null,
        next: null
    },
    gm(o) ? JT(n, a) : (a = Cb(o, n, a, c),
    a !== null && (Ao(a, o, c),
    XT(a, n, c)))
}
function ZT(o, n, a) {
    var c = Ro();
    uc(o, n, a, c)
}
function uc(o, n, a, c) {
    var u = {
        lane: c,
        revertLane: 0,
        gesture: null,
        action: a,
        hasEagerState: !1,
        eagerState: null,
        next: null
    };
    if (gm(o))
        JT(n, u);
    else {
        var p = o.alternate;
        if (o.lanes === 0 && (p === null || p.lanes === 0) && (p = n.lastRenderedReducer,
        p !== null))
            try {
                var f = n.lastRenderedState
                  , w = p(f, a);
                if (u.hasEagerState = !0,
                u.eagerState = w,
                Fo(w, f))
                    return dm(o, n, u, 0),
                    Xe === null && cm(),
                    !1
            } catch {} finally {}
        if (a = Cb(o, n, u, c),
        a !== null)
            return Ao(a, o, c),
            XT(a, n, c),
            !0
    }
    return !1
}
function Hb(o, n, a, c) {
    if (c = {
        lane: 2,
        revertLane: Jb(),
        gesture: null,
        action: c,
        hasEagerState: !1,
        eagerState: null,
        next: null
    },
    gm(o)) {
        if (n)
            throw Error(oe(479))
    } else
        n = Cb(o, a, c, 2),
        n !== null && Ao(n, o, 2)
}
function gm(o) {
    var n = o.alternate;
    return o === ve || n !== null && n === ve
}
function JT(o, n) {
    _a = Ih = !0;
    var a = o.pending;
    a === null ? n.next = n : (n.next = a.next,
    a.next = n),
    o.pending = n
}
function XT(o, n, a) {
    if (a & 4194048) {
        var c = n.lanes;
        c &= o.pendingLanes,
        a |= c,
        n.lanes = a,
        OD(o, a)
    }
}
var Ic = {
    readContext: Yt,
    use: mm,
    useCallback: gt,
    useContext: gt,
    useEffect: gt,
    useImperativeHandle: gt,
    useLayoutEffect: gt,
    useInsertionEffect: gt,
    useMemo: gt,
    useReducer: gt,
    useRef: gt,
    useState: gt,
    useDebugValue: gt,
    useDeferredValue: gt,
    useTransition: gt,
    useSyncExternalStore: gt,
    useId: gt,
    useHostTransitionStatus: gt,
    useFormState: gt,
    useActionState: gt,
    useOptimistic: gt,
    useMemoCache: gt,
    useCacheRefresh: gt
};
Ic.useEffectEvent = gt;
var eI = {
    readContext: Yt,
    use: mm,
    useCallback: function(o, n) {
        return no().memoizedState = [o, n === void 0 ? null : n],
        o
    },
    useContext: Yt,
    useEffect: nS,
    useImperativeHandle: function(o, n, a) {
        a = a != null ? a.concat([o]) : null,
        nh(4194308, 4, VT.bind(null, n, o), a)
    },
    useLayoutEffect: function(o, n) {
        return nh(4194308, 4, o, n)
    },
    useInsertionEffect: function(o, n) {
        nh(4, 2, o, n)
    },
    useMemo: function(o, n) {
        var a = no();
        n = n === void 0 ? null : n;
        var c = o();
        if (ss) {
            Gn(!0);
            try {
                o()
            } finally {
                Gn(!1)
            }
        }
        return a.memoizedState = [c, n],
        c
    },
    useReducer: function(o, n, a) {
        var c = no();
        if (a !== void 0) {
            var u = a(n);
            if (ss) {
                Gn(!0);
                try {
                    a(n)
                } finally {
                    Gn(!1)
                }
            }
        } else
            u = n;
        return c.memoizedState = c.baseState = u,
        o = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: o,
            lastRenderedState: u
        },
        c.queue = o,
        o = o.dispatch = iV.bind(null, ve, o),
        [c.memoizedState, o]
    },
    useRef: function(o) {
        var n = no();
        return o = {
            current: o
        },
        n.memoizedState = o
    },
    useState: function(o) {
        o = dk(o);
        var n = o.queue
          , a = ZT.bind(null, ve, n);
        return n.dispatch = a,
        [o.memoizedState, a]
    },
    useDebugValue: Fb,
    useDeferredValue: function(o, n) {
        var a = no();
        return Vb(a, o, n)
    },
    useTransition: function() {
        var o = dk(!1);
        return o = qT.bind(null, ve, o.queue, !0, !1),
        no().memoizedState = o,
        [!1, o]
    },
    useSyncExternalStore: function(o, n, a) {
        var c = ve
          , u = no();
        if (Be) {
            if (a === void 0)
                throw Error(oe(407));
            a = a()
        } else {
            if (a = n(),
            Xe === null)
                throw Error(oe(349));
            Ie & 127 || ST(c, n, a)
        }
        u.memoizedState = a;
        var p = {
            value: a,
            getSnapshot: n
        };
        return u.queue = p,
        nS(TT.bind(null, c, p, o), [o]),
        c.flags |= 2048,
        Ia(9, {
            destroy: void 0
        }, DT.bind(null, c, p, a, n), null),
        a
    },
    useId: function() {
        var o = no()
          , n = Xe.identifierPrefix;
        if (Be) {
            var a = Or
              , c = zr;
            a = (c & ~(1 << 32 - Oo(c) - 1)).toString(32) + a,
            n = "_" + n + "R_" + a,
            a = Mh++,
            0 < a && (n += "H" + a.toString(32)),
            n += "_"
        } else
            a = J9++,
            n = "_" + n + "r_" + a.toString(32) + "_";
        return o.memoizedState = n
    },
    useHostTransitionStatus: Ub,
    useFormState: tS,
    useActionState: tS,
    useOptimistic: function(o) {
        var n = no();
        n.memoizedState = n.baseState = o;
        var a = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: null,
            lastRenderedState: null
        };
        return n.queue = a,
        n = Hb.bind(null, ve, !0, a),
        a.dispatch = n,
        [o, n]
    },
    useMemoCache: zb,
    useCacheRefresh: function() {
        return no().memoizedState = nV.bind(null, ve)
    },
    useEffectEvent: function(o) {
        var n = no()
          , a = {
            impl: o
        };
        return n.memoizedState = a,
        function() {
            if (ze & 2)
                throw Error(oe(440));
            return a.impl.apply(void 0, arguments)
        }
    }
}
  , Wb = {
    readContext: Yt,
    use: mm,
    useCallback: HT,
    useContext: Yt,
    useEffect: Rb,
    useImperativeHandle: UT,
    useInsertionEffect: RT,
    useLayoutEffect: FT,
    useMemo: WT,
    useReducer: rh,
    useRef: zT,
    useState: function() {
        return rh(An)
    },
    useDebugValue: Fb,
    useDeferredValue: function(o, n) {
        var a = xt();
        return $T(a, Ke.memoizedState, o, n)
    },
    useTransition: function() {
        var o = rh(An)[0]
          , n = xt().memoizedState;
        return [typeof o == "boolean" ? o : Zc(o), n]
    },
    useSyncExternalStore: ET,
    useId: YT,
    useHostTransitionStatus: Ub,
    useFormState: oS,
    useActionState: oS,
    useOptimistic: function(o, n) {
        var a = xt();
        return BT(a, Ke, o, n)
    },
    useMemoCache: zb,
    useCacheRefresh: QT
};
Wb.useEffectEvent = OT;
var tI = {
    readContext: Yt,
    use: mm,
    useCallback: HT,
    useContext: Yt,
    useEffect: Rb,
    useImperativeHandle: UT,
    useInsertionEffect: RT,
    useLayoutEffect: FT,
    useMemo: WT,
    useReducer: Zg,
    useRef: zT,
    useState: function() {
        return Zg(An)
    },
    useDebugValue: Fb,
    useDeferredValue: function(o, n) {
        var a = xt();
        return Ke === null ? Vb(a, o, n) : $T(a, Ke.memoizedState, o, n)
    },
    useTransition: function() {
        var o = Zg(An)[0]
          , n = xt().memoizedState;
        return [typeof o == "boolean" ? o : Zc(o), n]
    },
    useSyncExternalStore: ET,
    useId: YT,
    useHostTransitionStatus: Ub,
    useFormState: rS,
    useActionState: rS,
    useOptimistic: function(o, n) {
        var a = xt();
        return Ke !== null ? BT(a, Ke, o, n) : (a.baseState = o,
        [o, a.queue.dispatch])
    },
    useMemoCache: zb,
    useCacheRefresh: QT
};
tI.useEffectEvent = OT;
function Jg(o, n, a, c) {
    n = o.memoizedState,
    a = a(c, n),
    a = a == null ? n : st({}, n, a),
    o.memoizedState = a,
    o.lanes === 0 && (o.updateQueue.baseState = a)
}
var mk = {
    enqueueSetState: function(o, n, a) {
        o = o._reactInternals;
        var c = Ro()
          , u = ti(c);
        u.payload = n,
        a != null && (u.callback = a),
        n = oi(o, u, c),
        n !== null && (Ao(n, o, c),
        lc(n, o, c))
    },
    enqueueReplaceState: function(o, n, a) {
        o = o._reactInternals;
        var c = Ro()
          , u = ti(c);
        u.tag = 1,
        u.payload = n,
        a != null && (u.callback = a),
        n = oi(o, u, c),
        n !== null && (Ao(n, o, c),
        lc(n, o, c))
    },
    enqueueForceUpdate: function(o, n) {
        o = o._reactInternals;
        var a = Ro()
          , c = ti(a);
        c.tag = 2,
        n != null && (c.callback = n),
        n = oi(o, c, a),
        n !== null && (Ao(n, o, a),
        lc(n, o, a))
    }
};
function iS(o, n, a, c, u, p, f) {
    return o = o.stateNode,
    typeof o.shouldComponentUpdate == "function" ? o.shouldComponentUpdate(c, p, f) : n.prototype && n.prototype.isPureReactComponent ? !xc(a, c) || !xc(u, p) : !0
}
function sS(o, n, a, c) {
    o = n.state,
    typeof n.componentWillReceiveProps == "function" && n.componentWillReceiveProps(a, c),
    typeof n.UNSAFE_componentWillReceiveProps == "function" && n.UNSAFE_componentWillReceiveProps(a, c),
    n.state !== o && mk.enqueueReplaceState(n, n.state, null)
}
function as(o, n) {
    var a = n;
    if ("ref"in n) {
        a = {};
        for (var c in n)
            c !== "ref" && (a[c] = n[c])
    }
    if (o = o.defaultProps) {
        a === n && (a = st({}, a));
        for (var u in o)
            a[u] === void 0 && (a[u] = o[u])
    }
    return a
}
function oI(o) {
    Ch(o)
}
function rI(o) {
    console.error(o)
}
function nI(o) {
    Ch(o)
}
function Bh(o, n) {
    try {
        var a = o.onUncaughtError;
        a(n.value, {
            componentStack: n.stack
        })
    } catch (c) {
        setTimeout(function() {
            throw c
        })
    }
}
function aS(o, n, a) {
    try {
        var c = o.onCaughtError;
        c(a.value, {
            componentStack: a.stack,
            errorBoundary: n.tag === 1 ? n.stateNode : null
        })
    } catch (u) {
        setTimeout(function() {
            throw u
        })
    }
}
function pk(o, n, a) {
    return a = ti(a),
    a.tag = 3,
    a.payload = {
        element: null
    },
    a.callback = function() {
        Bh(o, n)
    }
    ,
    a
}
function iI(o) {
    return o = ti(o),
    o.tag = 3,
    o
}
function sI(o, n, a, c) {
    var u = a.type.getDerivedStateFromError;
    if (typeof u == "function") {
        var p = c.value;
        o.payload = function() {
            return u(p)
        }
        ,
        o.callback = function() {
            aS(n, a, c)
        }
    }
    var f = a.stateNode;
    f !== null && typeof f.componentDidCatch == "function" && (o.callback = function() {
        aS(n, a, c),
        typeof u != "function" && (ri === null ? ri = new Set([this]) : ri.add(this));
        var w = c.stack;
        this.componentDidCatch(c.value, {
            componentStack: w !== null ? w : ""
        })
    }
    )
}
function sV(o, n, a, c, u) {
    if (a.flags |= 32768,
    c !== null && typeof c == "object" && typeof c.then == "function") {
        if (n = a.alternate,
        n !== null && Va(n, a, u, !0),
        a = Vo.current,
        a !== null) {
            switch (a.tag) {
            case 31:
            case 13:
                return yr === null ? zh() : a.alternate === null && kt === 0 && (kt = 3),
                a.flags &= -257,
                a.flags |= 65536,
                a.lanes = u,
                c === Sh ? a.flags |= 16384 : (n = a.updateQueue,
                n === null ? a.updateQueue = new Set([c]) : n.add(c),
                df(o, c, u)),
                !1;
            case 22:
                return a.flags |= 65536,
                c === Sh ? a.flags |= 16384 : (n = a.updateQueue,
                n === null ? (n = {
                    transitions: null,
                    markerInstances: null,
                    retryQueue: new Set([c])
                },
                a.updateQueue = n) : (a = n.retryQueue,
                a === null ? n.retryQueue = new Set([c]) : a.add(c)),
                df(o, c, u)),
                !1
            }
            throw Error(oe(435, a.tag))
        }
        return df(o, c, u),
        zh(),
        !1
    }
    if (Be)
        return n = Vo.current,
        n !== null ? (!(n.flags & 65536) && (n.flags |= 256),
        n.flags |= 65536,
        n.lanes = u,
        c !== tk && (o = Error(oe(422), {
            cause: c
        }),
        Sc(rr(o, a)))) : (c !== tk && (n = Error(oe(423), {
            cause: c
        }),
        Sc(rr(n, a))),
        o = o.current.alternate,
        o.flags |= 65536,
        u &= -u,
        o.lanes |= u,
        c = rr(c, a),
        u = pk(o.stateNode, c, u),
        Qg(o, u),
        kt !== 4 && (kt = 2)),
        !1;
    var p = Error(oe(520), {
        cause: c
    });
    if (p = rr(p, a),
    pc === null ? pc = [p] : pc.push(p),
    kt !== 4 && (kt = 2),
    n === null)
        return !0;
    c = rr(c, a),
    a = n;
    do {
        switch (a.tag) {
        case 3:
            return a.flags |= 65536,
            o = u & -u,
            a.lanes |= o,
            o = pk(a.stateNode, c, o),
            Qg(a, o),
            !1;
        case 1:
            if (n = a.type,
            p = a.stateNode,
            (a.flags & 128) === 0 && (typeof n.getDerivedStateFromError == "function" || p !== null && typeof p.componentDidCatch == "function" && (ri === null || !ri.has(p))))
                return a.flags |= 65536,
                u &= -u,
                a.lanes |= u,
                u = iI(u),
                sI(u, o, a, c),
                Qg(a, u),
                !1
        }
        a = a.return
    } while (a !== null);
    return !1
}
var $b = Error(oe(461))
  , It = !1;
function qt(o, n, a, c) {
    n.child = o === null ? AT(n, null, a, c) : is(n, o.child, a, c)
}
function lS(o, n, a, c, u) {
    a = a.render;
    var p = n.ref;
    if ("ref"in c) {
        var f = {};
        for (var w in c)
            w !== "ref" && (f[w] = c[w])
    } else
        f = c;
    return ns(n),
    c = Nb(o, n, a, f, p, u),
    w = Pb(),
    o !== null && !It ? (jb(o, n, u),
    vn(o, n, u)) : (Be && w && xb(n),
    n.flags |= 1,
    qt(o, n, c, u),
    n.child)
}
function cS(o, n, a, c, u) {
    if (o === null) {
        var p = a.type;
        return typeof p == "function" && !yb(p) && p.defaultProps === void 0 && a.compare === null ? (n.tag = 15,
        n.type = p,
        aI(o, n, p, c, u)) : (o = th(a.type, null, c, n, n.mode, u),
        o.ref = n.ref,
        o.return = n,
        n.child = o)
    }
    if (p = o.child,
    !qb(o, u)) {
        var f = p.memoizedProps;
        if (a = a.compare,
        a = a !== null ? a : xc,
        a(f, c) && o.ref === n.ref)
            return vn(o, n, u)
    }
    return n.flags |= 1,
    o = pn(p, c),
    o.ref = n.ref,
    o.return = n,
    n.child = o
}
function aI(o, n, a, c, u) {
    if (o !== null) {
        var p = o.memoizedProps;
        if (xc(p, c) && o.ref === n.ref)
            if (It = !1,
            n.pendingProps = c = p,
            qb(o, u))
                o.flags & 131072 && (It = !0);
            else
                return n.lanes = o.lanes,
                vn(o, n, u)
    }
    return gk(o, n, a, c, u)
}
function lI(o, n, a, c) {
    var u = c.children
      , p = o !== null ? o.memoizedState : null;
    if (o === null && n.stateNode === null && (n.stateNode = {
        _visibility: 1,
        _pendingMarkers: null,
        _retryCache: null,
        _transitions: null
    }),
    c.mode === "hidden") {
        if (n.flags & 128) {
            if (p = p !== null ? p.baseLanes | a : a,
            o !== null) {
                for (c = n.child = o.child,
                u = 0; c !== null; )
                    u = u | c.lanes | c.childLanes,
                    c = c.sibling;
                c = u & ~p
            } else
                c = 0,
                n.child = null;
            return dS(o, n, p, a, c)
        }
        if (a & 536870912)
            n.memoizedState = {
                baseLanes: 0,
                cachePool: null
            },
            o !== null && oh(n, p !== null ? p.cachePool : null),
            p !== null ? JE(n, p) : lk(),
            CT(n);
        else
            return c = n.lanes = 536870912,
            dS(o, n, p !== null ? p.baseLanes | a : a, a, c)
    } else
        p !== null ? (oh(n, p.cachePool),
        JE(n, p),
        $n(),
        n.memoizedState = null) : (o !== null && oh(n, null),
        lk(),
        $n());
    return qt(o, n, u, a),
    n.child
}
function ec(o, n) {
    return o !== null && o.tag === 22 || n.stateNode !== null || (n.stateNode = {
        _visibility: 1,
        _pendingMarkers: null,
        _retryCache: null,
        _transitions: null
    }),
    n.sibling
}
function dS(o, n, a, c, u) {
    var p = Db();
    return p = p === null ? null : {
        parent: Tt._currentValue,
        pool: p
    },
    n.memoizedState = {
        baseLanes: a,
        cachePool: p
    },
    o !== null && oh(n, null),
    lk(),
    CT(n),
    o !== null && Va(o, n, c, !0),
    n.childLanes = u,
    null
}
function ih(o, n) {
    return n = Nh({
        mode: n.mode,
        children: n.children
    }, o.mode),
    n.ref = o.ref,
    o.child = n,
    n.return = o,
    n
}
function uS(o, n, a) {
    return is(n, o.child, null, a),
    o = ih(n, n.pendingProps),
    o.flags |= 2,
    No(n),
    n.memoizedState = null,
    o
}
function aV(o, n, a) {
    var c = n.pendingProps
      , u = (n.flags & 128) !== 0;
    if (n.flags &= -129,
    o === null) {
        if (Be) {
            if (c.mode === "hidden")
                return o = ih(n, c),
                n.lanes = 536870912,
                ec(null, o);
            if (ck(n),
            (o = nt) ? (o = eM(o, nr),
            o = o !== null && o.data === "&" ? o : null,
            o !== null && (n.memoizedState = {
                dehydrated: o,
                treeContext: li !== null ? {
                    id: zr,
                    overflow: Or
                } : null,
                retryLane: 536870912,
                hydrationErrors: null
            },
            a = mT(o),
            a.return = n,
            n.child = a,
            Kt = n,
            nt = null)) : o = null,
            o === null)
                throw ci(n);
            return n.lanes = 536870912,
            null
        }
        return ih(n, c)
    }
    var p = o.memoizedState;
    if (p !== null) {
        var f = p.dehydrated;
        if (ck(n),
        u)
            if (n.flags & 256)
                n.flags &= -257,
                n = uS(o, n, a);
            else if (n.memoizedState !== null)
                n.child = o.child,
                n.flags |= 128,
                n = null;
            else
                throw Error(oe(558));
        else if (It || Va(o, n, a, !1),
        u = (a & o.childLanes) !== 0,
        It || u) {
            if (c = Xe,
            c !== null && (f = RD(c, a),
            f !== 0 && f !== p.retryLane))
                throw p.retryLane = f,
                us(o, f),
                Ao(c, o, f),
                $b;
            zh(),
            n = uS(o, n, a)
        } else
            o = p.treeContext,
            nt = sr(f.nextSibling),
            Kt = n,
            Be = !0,
            ei = null,
            nr = !1,
            o !== null && gT(n, o),
            n = ih(n, c),
            n.flags |= 4096;
        return n
    }
    return o = pn(o.child, {
        mode: c.mode,
        children: c.children
    }),
    o.ref = n.ref,
    n.child = o,
    o.return = n,
    o
}
function sh(o, n) {
    var a = n.ref;
    if (a === null)
        o !== null && o.ref !== null && (n.flags |= 4194816);
    else {
        if (typeof a != "function" && typeof a != "object")
            throw Error(oe(284));
        (o === null || o.ref !== a) && (n.flags |= 4194816)
    }
}
function gk(o, n, a, c, u) {
    return ns(n),
    a = Nb(o, n, a, c, void 0, u),
    c = Pb(),
    o !== null && !It ? (jb(o, n, u),
    vn(o, n, u)) : (Be && c && xb(n),
    n.flags |= 1,
    qt(o, n, a, u),
    n.child)
}
function hS(o, n, a, c, u, p) {
    return ns(n),
    n.updateQueue = null,
    a = xT(n, c, a, u),
    yT(o),
    c = Pb(),
    o !== null && !It ? (jb(o, n, p),
    vn(o, n, p)) : (Be && c && xb(n),
    n.flags |= 1,
    qt(o, n, a, p),
    n.child)
}
function mS(o, n, a, c, u) {
    if (ns(n),
    n.stateNode === null) {
        var p = la
          , f = a.contextType;
        typeof f == "object" && f !== null && (p = Yt(f)),
        p = new a(c,p),
        n.memoizedState = p.state !== null && p.state !== void 0 ? p.state : null,
        p.updater = mk,
        n.stateNode = p,
        p._reactInternals = n,
        p = n.stateNode,
        p.props = c,
        p.state = n.memoizedState,
        p.refs = {},
        Ib(n),
        f = a.contextType,
        p.context = typeof f == "object" && f !== null ? Yt(f) : la,
        p.state = n.memoizedState,
        f = a.getDerivedStateFromProps,
        typeof f == "function" && (Jg(n, a, f, c),
        p.state = n.memoizedState),
        typeof a.getDerivedStateFromProps == "function" || typeof p.getSnapshotBeforeUpdate == "function" || typeof p.UNSAFE_componentWillMount != "function" && typeof p.componentWillMount != "function" || (f = p.state,
        typeof p.componentWillMount == "function" && p.componentWillMount(),
        typeof p.UNSAFE_componentWillMount == "function" && p.UNSAFE_componentWillMount(),
        f !== p.state && mk.enqueueReplaceState(p, p.state, null),
        dc(n, c, p, u),
        cc(),
        p.state = n.memoizedState),
        typeof p.componentDidMount == "function" && (n.flags |= 4194308),
        c = !0
    } else if (o === null) {
        p = n.stateNode;
        var w = n.memoizedProps
          , k = as(a, w);
        p.props = k;
        var y = p.context
          , E = a.contextType;
        f = la,
        typeof E == "object" && E !== null && (f = Yt(E));
        var S = a.getDerivedStateFromProps;
        E = typeof S == "function" || typeof p.getSnapshotBeforeUpdate == "function",
        w = n.pendingProps !== w,
        E || typeof p.UNSAFE_componentWillReceiveProps != "function" && typeof p.componentWillReceiveProps != "function" || (w || y !== f) && sS(n, p, c, f),
        Un = !1;
        var A = n.memoizedState;
        p.state = A,
        dc(n, c, p, u),
        cc(),
        y = n.memoizedState,
        w || A !== y || Un ? (typeof S == "function" && (Jg(n, a, S, c),
        y = n.memoizedState),
        (k = Un || iS(n, a, k, c, A, y, f)) ? (E || typeof p.UNSAFE_componentWillMount != "function" && typeof p.componentWillMount != "function" || (typeof p.componentWillMount == "function" && p.componentWillMount(),
        typeof p.UNSAFE_componentWillMount == "function" && p.UNSAFE_componentWillMount()),
        typeof p.componentDidMount == "function" && (n.flags |= 4194308)) : (typeof p.componentDidMount == "function" && (n.flags |= 4194308),
        n.memoizedProps = c,
        n.memoizedState = y),
        p.props = c,
        p.state = y,
        p.context = f,
        c = k) : (typeof p.componentDidMount == "function" && (n.flags |= 4194308),
        c = !1)
    } else {
        p = n.stateNode,
        sk(o, n),
        f = n.memoizedProps,
        E = as(a, f),
        p.props = E,
        S = n.pendingProps,
        A = p.context,
        y = a.contextType,
        k = la,
        typeof y == "object" && y !== null && (k = Yt(y)),
        w = a.getDerivedStateFromProps,
        (y = typeof w == "function" || typeof p.getSnapshotBeforeUpdate == "function") || typeof p.UNSAFE_componentWillReceiveProps != "function" && typeof p.componentWillReceiveProps != "function" || (f !== S || A !== k) && sS(n, p, c, k),
        Un = !1,
        A = n.memoizedState,
        p.state = A,
        dc(n, c, p, u),
        cc();
        var D = n.memoizedState;
        f !== S || A !== D || Un || o !== null && o.dependencies !== null && Eh(o.dependencies) ? (typeof w == "function" && (Jg(n, a, w, c),
        D = n.memoizedState),
        (E = Un || iS(n, a, E, c, A, D, k) || o !== null && o.dependencies !== null && Eh(o.dependencies)) ? (y || typeof p.UNSAFE_componentWillUpdate != "function" && typeof p.componentWillUpdate != "function" || (typeof p.componentWillUpdate == "function" && p.componentWillUpdate(c, D, k),
        typeof p.UNSAFE_componentWillUpdate == "function" && p.UNSAFE_componentWillUpdate(c, D, k)),
        typeof p.componentDidUpdate == "function" && (n.flags |= 4),
        typeof p.getSnapshotBeforeUpdate == "function" && (n.flags |= 1024)) : (typeof p.componentDidUpdate != "function" || f === o.memoizedProps && A === o.memoizedState || (n.flags |= 4),
        typeof p.getSnapshotBeforeUpdate != "function" || f === o.memoizedProps && A === o.memoizedState || (n.flags |= 1024),
        n.memoizedProps = c,
        n.memoizedState = D),
        p.props = c,
        p.state = D,
        p.context = k,
        c = E) : (typeof p.componentDidUpdate != "function" || f === o.memoizedProps && A === o.memoizedState || (n.flags |= 4),
        typeof p.getSnapshotBeforeUpdate != "function" || f === o.memoizedProps && A === o.memoizedState || (n.flags |= 1024),
        c = !1)
    }
    return p = c,
    sh(o, n),
    c = (n.flags & 128) !== 0,
    p || c ? (p = n.stateNode,
    a = c && typeof a.getDerivedStateFromError != "function" ? null : p.render(),
    n.flags |= 1,
    o !== null && c ? (n.child = is(n, o.child, null, u),
    n.child = is(n, null, a, u)) : qt(o, n, a, u),
    n.memoizedState = p.state,
    o = n.child) : o = vn(o, n, u),
    o
}
function pS(o, n, a, c) {
    return rs(),
    n.flags |= 256,
    qt(o, n, a, c),
    n.child
}
var Xg = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0,
    hydrationErrors: null
};
function ef(o) {
    return {
        baseLanes: o,
        cachePool: kT()
    }
}
function tf(o, n, a) {
    return o = o !== null ? o.childLanes & ~a : 0,
    n && (o |= jo),
    o
}
function cI(o, n, a) {
    var c = n.pendingProps, u = !1, p = (n.flags & 128) !== 0, f;
    if ((f = p) || (f = o !== null && o.memoizedState === null ? !1 : (yt.current & 2) !== 0),
    f && (u = !0,
    n.flags &= -129),
    f = (n.flags & 32) !== 0,
    n.flags &= -33,
    o === null) {
        if (Be) {
            if (u ? Wn(n) : $n(),
            (o = nt) ? (o = eM(o, nr),
            o = o !== null && o.data !== "&" ? o : null,
            o !== null && (n.memoizedState = {
                dehydrated: o,
                treeContext: li !== null ? {
                    id: zr,
                    overflow: Or
                } : null,
                retryLane: 536870912,
                hydrationErrors: null
            },
            a = mT(o),
            a.return = n,
            n.child = a,
            Kt = n,
            nt = null)) : o = null,
            o === null)
                throw ci(n);
            return Tk(o) ? n.lanes = 32 : n.lanes = 536870912,
            null
        }
        var w = c.children;
        return c = c.fallback,
        u ? ($n(),
        u = n.mode,
        w = Nh({
            mode: "hidden",
            children: w
        }, u),
        c = Zi(c, u, a, null),
        w.return = n,
        c.return = n,
        w.sibling = c,
        n.child = w,
        c = n.child,
        c.memoizedState = ef(a),
        c.childLanes = tf(o, f, a),
        n.memoizedState = Xg,
        ec(null, c)) : (Wn(n),
        fk(n, w))
    }
    var k = o.memoizedState;
    if (k !== null && (w = k.dehydrated,
    w !== null)) {
        if (p)
            n.flags & 256 ? (Wn(n),
            n.flags &= -257,
            n = of(o, n, a)) : n.memoizedState !== null ? ($n(),
            n.child = o.child,
            n.flags |= 128,
            n = null) : ($n(),
            w = c.fallback,
            u = n.mode,
            c = Nh({
                mode: "visible",
                children: c.children
            }, u),
            w = Zi(w, u, a, null),
            w.flags |= 2,
            c.return = n,
            w.return = n,
            c.sibling = w,
            n.child = c,
            is(n, o.child, null, a),
            c = n.child,
            c.memoizedState = ef(a),
            c.childLanes = tf(o, f, a),
            n.memoizedState = Xg,
            n = ec(null, c));
        else if (Wn(n),
        Tk(w)) {
            if (f = w.nextSibling && w.nextSibling.dataset,
            f)
                var y = f.dgst;
            f = y,
            c = Error(oe(419)),
            c.stack = "",
            c.digest = f,
            Sc({
                value: c,
                source: null,
                stack: null
            }),
            n = of(o, n, a)
        } else if (It || Va(o, n, a, !1),
        f = (a & o.childLanes) !== 0,
        It || f) {
            if (f = Xe,
            f !== null && (c = RD(f, a),
            c !== 0 && c !== k.retryLane))
                throw k.retryLane = c,
                us(o, c),
                Ao(f, o, c),
                $b;
            Dk(w) || zh(),
            n = of(o, n, a)
        } else
            Dk(w) ? (n.flags |= 192,
            n.child = o.child,
            n = null) : (o = k.treeContext,
            nt = sr(w.nextSibling),
            Kt = n,
            Be = !0,
            ei = null,
            nr = !1,
            o !== null && gT(n, o),
            n = fk(n, c.children),
            n.flags |= 4096);
        return n
    }
    return u ? ($n(),
    w = c.fallback,
    u = n.mode,
    k = o.child,
    y = k.sibling,
    c = pn(k, {
        mode: "hidden",
        children: c.children
    }),
    c.subtreeFlags = k.subtreeFlags & 65011712,
    y !== null ? w = pn(y, w) : (w = Zi(w, u, a, null),
    w.flags |= 2),
    w.return = n,
    c.return = n,
    c.sibling = w,
    n.child = c,
    ec(null, c),
    c = n.child,
    w = o.child.memoizedState,
    w === null ? w = ef(a) : (u = w.cachePool,
    u !== null ? (k = Tt._currentValue,
    u = u.parent !== k ? {
        parent: k,
        pool: k
    } : u) : u = kT(),
    w = {
        baseLanes: w.baseLanes | a,
        cachePool: u
    }),
    c.memoizedState = w,
    c.childLanes = tf(o, f, a),
    n.memoizedState = Xg,
    ec(o.child, c)) : (Wn(n),
    a = o.child,
    o = a.sibling,
    a = pn(a, {
        mode: "visible",
        children: c.children
    }),
    a.return = n,
    a.sibling = null,
    o !== null && (f = n.deletions,
    f === null ? (n.deletions = [o],
    n.flags |= 16) : f.push(o)),
    n.child = a,
    n.memoizedState = null,
    a)
}
function fk(o, n) {
    return n = Nh({
        mode: "visible",
        children: n
    }, o.mode),
    n.return = o,
    o.child = n
}
function Nh(o, n) {
    return o = Po(22, o, null, n),
    o.lanes = 0,
    o
}
function of(o, n, a) {
    return is(n, o.child, null, a),
    o = fk(n, n.pendingProps.children),
    o.flags |= 2,
    n.memoizedState = null,
    o
}
function gS(o, n, a) {
    o.lanes |= n;
    var c = o.alternate;
    c !== null && (c.lanes |= n),
    rk(o.return, n, a)
}
function rf(o, n, a, c, u, p) {
    var f = o.memoizedState;
    f === null ? o.memoizedState = {
        isBackwards: n,
        rendering: null,
        renderingStartTime: 0,
        last: c,
        tail: a,
        tailMode: u,
        treeForkCount: p
    } : (f.isBackwards = n,
    f.rendering = null,
    f.renderingStartTime = 0,
    f.last = c,
    f.tail = a,
    f.tailMode = u,
    f.treeForkCount = p)
}
function dI(o, n, a) {
    var c = n.pendingProps
      , u = c.revealOrder
      , p = c.tail;
    c = c.children;
    var f = yt.current
      , w = (f & 2) !== 0;
    if (w ? (f = f & 1 | 2,
    n.flags |= 128) : f &= 1,
    tt(yt, f),
    qt(o, n, c, a),
    c = Be ? Ec : 0,
    !w && o !== null && o.flags & 128)
        e: for (o = n.child; o !== null; ) {
            if (o.tag === 13)
                o.memoizedState !== null && gS(o, a, n);
            else if (o.tag === 19)
                gS(o, a, n);
            else if (o.child !== null) {
                o.child.return = o,
                o = o.child;
                continue
            }
            if (o === n)
                break e;
            for (; o.sibling === null; ) {
                if (o.return === null || o.return === n)
                    break e;
                o = o.return
            }
            o.sibling.return = o.return,
            o = o.sibling
        }
    switch (u) {
    case "forwards":
        for (a = n.child,
        u = null; a !== null; )
            o = a.alternate,
            o !== null && Th(o) === null && (u = a),
            a = a.sibling;
        a = u,
        a === null ? (u = n.child,
        n.child = null) : (u = a.sibling,
        a.sibling = null),
        rf(n, !1, u, a, p, c);
        break;
    case "backwards":
    case "unstable_legacy-backwards":
        for (a = null,
        u = n.child,
        n.child = null; u !== null; ) {
            if (o = u.alternate,
            o !== null && Th(o) === null) {
                n.child = u;
                break
            }
            o = u.sibling,
            u.sibling = a,
            a = u,
            u = o
        }
        rf(n, !0, a, null, p, c);
        break;
    case "together":
        rf(n, !1, null, null, void 0, c);
        break;
    default:
        n.memoizedState = null
    }
    return n.child
}
function vn(o, n, a) {
    if (o !== null && (n.dependencies = o.dependencies),
    ui |= n.lanes,
    !(a & n.childLanes))
        if (o !== null) {
            if (Va(o, n, a, !1),
            (a & n.childLanes) === 0)
                return null
        } else
            return null;
    if (o !== null && n.child !== o.child)
        throw Error(oe(153));
    if (n.child !== null) {
        for (o = n.child,
        a = pn(o, o.pendingProps),
        n.child = a,
        a.return = n; o.sibling !== null; )
            o = o.sibling,
            a = a.sibling = pn(o, o.pendingProps),
            a.return = n;
        a.sibling = null
    }
    return n.child
}
function qb(o, n) {
    return o.lanes & n ? !0 : (o = o.dependencies,
    !!(o !== null && Eh(o)))
}
function lV(o, n, a) {
    switch (n.tag) {
    case 3:
        wh(n, n.stateNode.containerInfo),
        Hn(n, Tt, o.memoizedState.cache),
        rs();
        break;
    case 27:
    case 5:
        Wf(n);
        break;
    case 4:
        wh(n, n.stateNode.containerInfo);
        break;
    case 10:
        Hn(n, n.type, n.memoizedProps.value);
        break;
    case 31:
        if (n.memoizedState !== null)
            return n.flags |= 128,
            ck(n),
            null;
        break;
    case 13:
        var c = n.memoizedState;
        if (c !== null)
            return c.dehydrated !== null ? (Wn(n),
            n.flags |= 128,
            null) : a & n.child.childLanes ? cI(o, n, a) : (Wn(n),
            o = vn(o, n, a),
            o !== null ? o.sibling : null);
        Wn(n);
        break;
    case 19:
        var u = (o.flags & 128) !== 0;
        if (c = (a & n.childLanes) !== 0,
        c || (Va(o, n, a, !1),
        c = (a & n.childLanes) !== 0),
        u) {
            if (c)
                return dI(o, n, a);
            n.flags |= 128
        }
        if (u = n.memoizedState,
        u !== null && (u.rendering = null,
        u.tail = null,
        u.lastEffect = null),
        tt(yt, yt.current),
        c)
            break;
        return null;
    case 22:
        return n.lanes = 0,
        lI(o, n, a, n.pendingProps);
    case 24:
        Hn(n, Tt, o.memoizedState.cache)
    }
    return vn(o, n, a)
}
function uI(o, n, a) {
    if (o !== null)
        if (o.memoizedProps !== n.pendingProps)
            It = !0;
        else {
            if (!qb(o, a) && !(n.flags & 128))
                return It = !1,
                lV(o, n, a);
            It = !!(o.flags & 131072)
        }
    else
        It = !1,
        Be && n.flags & 1048576 && pT(n, Ec, n.index);
    switch (n.lanes = 0,
    n.tag) {
    case 16:
        e: {
            var c = n.pendingProps;
            if (o = $i(n.elementType),
            n.type = o,
            typeof o == "function")
                yb(o) ? (c = as(o, c),
                n.tag = 1,
                n = mS(null, n, o, c, a)) : (n.tag = 0,
                n = gk(null, n, o, c, a));
            else {
                if (o != null) {
                    var u = o.$$typeof;
                    if (u === db) {
                        n.tag = 11,
                        n = lS(null, n, o, c, a);
                        break e
                    } else if (u === ub) {
                        n.tag = 14,
                        n = cS(null, n, o, c, a);
                        break e
                    }
                }
                throw n = Uf(o) || o,
                Error(oe(306, n, ""))
            }
        }
        return n;
    case 0:
        return gk(o, n, n.type, n.pendingProps, a);
    case 1:
        return c = n.type,
        u = as(c, n.pendingProps),
        mS(o, n, c, u, a);
    case 3:
        e: {
            if (wh(n, n.stateNode.containerInfo),
            o === null)
                throw Error(oe(387));
            c = n.pendingProps;
            var p = n.memoizedState;
            u = p.element,
            sk(o, n),
            dc(n, c, null, a);
            var f = n.memoizedState;
            if (c = f.cache,
            Hn(n, Tt, c),
            c !== p.cache && nk(n, [Tt], a, !0),
            cc(),
            c = f.element,
            p.isDehydrated)
                if (p = {
                    element: c,
                    isDehydrated: !1,
                    cache: f.cache
                },
                n.updateQueue.baseState = p,
                n.memoizedState = p,
                n.flags & 256) {
                    n = pS(o, n, c, a);
                    break e
                } else if (c !== u) {
                    u = rr(Error(oe(424)), n),
                    Sc(u),
                    n = pS(o, n, c, a);
                    break e
                } else {
                    switch (o = n.stateNode.containerInfo,
                    o.nodeType) {
                    case 9:
                        o = o.body;
                        break;
                    default:
                        o = o.nodeName === "HTML" ? o.ownerDocument.body : o
                    }
                    for (nt = sr(o.firstChild),
                    Kt = n,
                    Be = !0,
                    ei = null,
                    nr = !0,
                    a = AT(n, null, c, a),
                    n.child = a; a; )
                        a.flags = a.flags & -3 | 4096,
                        a = a.sibling
                }
            else {
                if (rs(),
                c === u) {
                    n = vn(o, n, a);
                    break e
                }
                qt(o, n, c, a)
            }
            n = n.child
        }
        return n;
    case 26:
        return sh(o, n),
        o === null ? (a = jS(n.type, null, n.pendingProps, null)) ? n.memoizedState = a : Be || (a = n.type,
        o = n.pendingProps,
        c = Vh(Xn.current).createElement(a),
        c[Gt] = n,
        c[vo] = o,
        Qt(c, a, o),
        Ft(c),
        n.stateNode = c) : n.memoizedState = jS(n.type, o.memoizedProps, n.pendingProps, o.memoizedState),
        null;
    case 27:
        return Wf(n),
        o === null && Be && (c = n.stateNode = tM(n.type, n.pendingProps, Xn.current),
        Kt = n,
        nr = !0,
        u = nt,
        gi(n.type) ? (Ik = u,
        nt = sr(c.firstChild)) : nt = u),
        qt(o, n, n.pendingProps.children, a),
        sh(o, n),
        o === null && (n.flags |= 4194304),
        n.child;
    case 5:
        return o === null && Be && ((u = c = nt) && (c = OV(c, n.type, n.pendingProps, nr),
        c !== null ? (n.stateNode = c,
        Kt = n,
        nt = sr(c.firstChild),
        nr = !1,
        u = !0) : u = !1),
        u || ci(n)),
        Wf(n),
        u = n.type,
        p = n.pendingProps,
        f = o !== null ? o.memoizedProps : null,
        c = p.children,
        Ek(u, p) ? c = null : f !== null && Ek(u, f) && (n.flags |= 32),
        n.memoizedState !== null && (u = Nb(o, n, X9, null, null, a),
        Nc._currentValue = u),
        sh(o, n),
        qt(o, n, c, a),
        n.child;
    case 6:
        return o === null && Be && ((o = a = nt) && (a = RV(a, n.pendingProps, nr),
        a !== null ? (n.stateNode = a,
        Kt = n,
        nt = null,
        o = !0) : o = !1),
        o || ci(n)),
        null;
    case 13:
        return cI(o, n, a);
    case 4:
        return wh(n, n.stateNode.containerInfo),
        c = n.pendingProps,
        o === null ? n.child = is(n, null, c, a) : qt(o, n, c, a),
        n.child;
    case 11:
        return lS(o, n, n.type, n.pendingProps, a);
    case 7:
        return qt(o, n, n.pendingProps, a),
        n.child;
    case 8:
        return qt(o, n, n.pendingProps.children, a),
        n.child;
    case 12:
        return qt(o, n, n.pendingProps.children, a),
        n.child;
    case 10:
        return c = n.pendingProps,
        Hn(n, n.type, c.value),
        qt(o, n, c.children, a),
        n.child;
    case 9:
        return u = n.type._context,
        c = n.pendingProps.children,
        ns(n),
        u = Yt(u),
        c = c(u),
        n.flags |= 1,
        qt(o, n, c, a),
        n.child;
    case 14:
        return cS(o, n, n.type, n.pendingProps, a);
    case 15:
        return aI(o, n, n.type, n.pendingProps, a);
    case 19:
        return dI(o, n, a);
    case 31:
        return aV(o, n, a);
    case 22:
        return lI(o, n, a, n.pendingProps);
    case 24:
        return ns(n),
        c = Yt(Tt),
        o === null ? (u = Db(),
        u === null && (u = Xe,
        p = Sb(),
        u.pooledCache = p,
        p.refCount++,
        p !== null && (u.pooledCacheLanes |= a),
        u = p),
        n.memoizedState = {
            parent: c,
            cache: u
        },
        Ib(n),
        Hn(n, Tt, u)) : (o.lanes & a && (sk(o, n),
        dc(n, null, null, a),
        cc()),
        u = o.memoizedState,
        p = n.memoizedState,
        u.parent !== c ? (u = {
            parent: c,
            cache: c
        },
        n.memoizedState = u,
        n.lanes === 0 && (n.memoizedState = n.updateQueue.baseState = u),
        Hn(n, Tt, c)) : (c = p.cache,
        Hn(n, Tt, c),
        c !== u.cache && nk(n, [Tt], a, !0))),
        qt(o, n, n.pendingProps.children, a),
        n.child;
    case 29:
        throw n.pendingProps
    }
    throw Error(oe(156, n.tag))
}
function rn(o) {
    o.flags |= 4
}
function nf(o, n, a, c, u) {
    if ((n = (o.mode & 32) !== 0) && (n = !1),
    n) {
        if (o.flags |= 16777216,
        (u & 335544128) === u)
            if (o.stateNode.complete)
                o.flags |= 8192;
            else if (jI())
                o.flags |= 8192;
            else
                throw Xi = Sh,
                Tb
    } else
        o.flags &= -16777217
}
function fS(o, n) {
    if (n.type !== "stylesheet" || n.state.loading & 4)
        o.flags &= -16777217;
    else if (o.flags |= 16777216,
    !nM(n))
        if (jI())
            o.flags |= 8192;
        else
            throw Xi = Sh,
            Tb
}
function Fu(o, n) {
    n !== null && (o.flags |= 4),
    o.flags & 16384 && (n = o.tag !== 22 ? LD() : 536870912,
    o.lanes |= n,
    Ma |= n)
}
function ql(o, n) {
    if (!Be)
        switch (o.tailMode) {
        case "hidden":
            n = o.tail;
            for (var a = null; n !== null; )
                n.alternate !== null && (a = n),
                n = n.sibling;
            a === null ? o.tail = null : a.sibling = null;
            break;
        case "collapsed":
            a = o.tail;
            for (var c = null; a !== null; )
                a.alternate !== null && (c = a),
                a = a.sibling;
            c === null ? n || o.tail === null ? o.tail = null : o.tail.sibling = null : c.sibling = null
        }
}
function rt(o) {
    var n = o.alternate !== null && o.alternate.child === o.child
      , a = 0
      , c = 0;
    if (n)
        for (var u = o.child; u !== null; )
            a |= u.lanes | u.childLanes,
            c |= u.subtreeFlags & 65011712,
            c |= u.flags & 65011712,
            u.return = o,
            u = u.sibling;
    else
        for (u = o.child; u !== null; )
            a |= u.lanes | u.childLanes,
            c |= u.subtreeFlags,
            c |= u.flags,
            u.return = o,
            u = u.sibling;
    return o.subtreeFlags |= c,
    o.childLanes = a,
    n
}
function cV(o, n, a) {
    var c = n.pendingProps;
    switch (Eb(n),
    n.tag) {
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
        return rt(n),
        null;
    case 1:
        return rt(n),
        null;
    case 3:
        return a = n.stateNode,
        c = null,
        o !== null && (c = o.memoizedState.cache),
        n.memoizedState.cache !== c && (n.flags |= 2048),
        gn(Tt),
        xa(),
        a.pendingContext && (a.context = a.pendingContext,
        a.pendingContext = null),
        (o === null || o.child === null) && (Gs(n) ? rn(n) : o === null || o.memoizedState.isDehydrated && !(n.flags & 256) || (n.flags |= 1024,
        Yg())),
        rt(n),
        null;
    case 26:
        var u = n.type
          , p = n.memoizedState;
        return o === null ? (rn(n),
        p !== null ? (rt(n),
        fS(n, p)) : (rt(n),
        nf(n, u, null, c, a))) : p ? p !== o.memoizedState ? (rn(n),
        rt(n),
        fS(n, p)) : (rt(n),
        n.flags &= -16777217) : (o = o.memoizedProps,
        o !== c && rn(n),
        rt(n),
        nf(n, u, o, c, a)),
        null;
    case 27:
        if (Ah(n),
        a = Xn.current,
        u = n.type,
        o !== null && n.stateNode != null)
            o.memoizedProps !== c && rn(n);
        else {
            if (!c) {
                if (n.stateNode === null)
                    throw Error(oe(166));
                return rt(n),
                null
            }
            o = Fr.current,
            Gs(n) ? $E(n) : (o = tM(u, c, a),
            n.stateNode = o,
            rn(n))
        }
        return rt(n),
        null;
    case 5:
        if (Ah(n),
        u = n.type,
        o !== null && n.stateNode != null)
            o.memoizedProps !== c && rn(n);
        else {
            if (!c) {
                if (n.stateNode === null)
                    throw Error(oe(166));
                return rt(n),
                null
            }
            if (p = Fr.current,
            Gs(n))
                $E(n);
            else {
                var f = Vh(Xn.current);
                switch (p) {
                case 1:
                    p = f.createElementNS("http://www.w3.org/2000/svg", u);
                    break;
                case 2:
                    p = f.createElementNS("http://www.w3.org/1998/Math/MathML", u);
                    break;
                default:
                    switch (u) {
                    case "svg":
                        p = f.createElementNS("http://www.w3.org/2000/svg", u);
                        break;
                    case "math":
                        p = f.createElementNS("http://www.w3.org/1998/Math/MathML", u);
                        break;
                    case "script":
                        p = f.createElement("div"),
                        p.innerHTML = "<script><\/script>",
                        p = p.removeChild(p.firstChild);
                        break;
                    case "select":
                        p = typeof c.is == "string" ? f.createElement("select", {
                            is: c.is
                        }) : f.createElement("select"),
                        c.multiple ? p.multiple = !0 : c.size && (p.size = c.size);
                        break;
                    default:
                        p = typeof c.is == "string" ? f.createElement(u, {
                            is: c.is
                        }) : f.createElement(u)
                    }
                }
                p[Gt] = n,
                p[vo] = c;
                e: for (f = n.child; f !== null; ) {
                    if (f.tag === 5 || f.tag === 6)
                        p.appendChild(f.stateNode);
                    else if (f.tag !== 4 && f.tag !== 27 && f.child !== null) {
                        f.child.return = f,
                        f = f.child;
                        continue
                    }
                    if (f === n)
                        break e;
                    for (; f.sibling === null; ) {
                        if (f.return === null || f.return === n)
                            break e;
                        f = f.return
                    }
                    f.sibling.return = f.return,
                    f = f.sibling
                }
                n.stateNode = p;
                e: switch (Qt(p, u, c),
                u) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                    c = !!c.autoFocus;
                    break e;
                case "img":
                    c = !0;
                    break e;
                default:
                    c = !1
                }
                c && rn(n)
            }
        }
        return rt(n),
        nf(n, n.type, o === null ? null : o.memoizedProps, n.pendingProps, a),
        null;
    case 6:
        if (o && n.stateNode != null)
            o.memoizedProps !== c && rn(n);
        else {
            if (typeof c != "string" && n.stateNode === null)
                throw Error(oe(166));
            if (o = Xn.current,
            Gs(n)) {
                if (o = n.stateNode,
                a = n.memoizedProps,
                c = null,
                u = Kt,
                u !== null)
                    switch (u.tag) {
                    case 27:
                    case 5:
                        c = u.memoizedProps
                    }
                o[Gt] = n,
                o = !!(o.nodeValue === a || c !== null && c.suppressHydrationWarning === !0 || ZI(o.nodeValue, a)),
                o || ci(n, !0)
            } else
                o = Vh(o).createTextNode(c),
                o[Gt] = n,
                n.stateNode = o
        }
        return rt(n),
        null;
    case 31:
        if (a = n.memoizedState,
        o === null || o.memoizedState !== null) {
            if (c = Gs(n),
            a !== null) {
                if (o === null) {
                    if (!c)
                        throw Error(oe(318));
                    if (o = n.memoizedState,
                    o = o !== null ? o.dehydrated : null,
                    !o)
                        throw Error(oe(557));
                    o[Gt] = n
                } else
                    rs(),
                    !(n.flags & 128) && (n.memoizedState = null),
                    n.flags |= 4;
                rt(n),
                o = !1
            } else
                a = Yg(),
                o !== null && o.memoizedState !== null && (o.memoizedState.hydrationErrors = a),
                o = !0;
            if (!o)
                return n.flags & 256 ? (No(n),
                n) : (No(n),
                null);
            if (n.flags & 128)
                throw Error(oe(558))
        }
        return rt(n),
        null;
    case 13:
        if (c = n.memoizedState,
        o === null || o.memoizedState !== null && o.memoizedState.dehydrated !== null) {
            if (u = Gs(n),
            c !== null && c.dehydrated !== null) {
                if (o === null) {
                    if (!u)
                        throw Error(oe(318));
                    if (u = n.memoizedState,
                    u = u !== null ? u.dehydrated : null,
                    !u)
                        throw Error(oe(317));
                    u[Gt] = n
                } else
                    rs(),
                    !(n.flags & 128) && (n.memoizedState = null),
                    n.flags |= 4;
                rt(n),
                u = !1
            } else
                u = Yg(),
                o !== null && o.memoizedState !== null && (o.memoizedState.hydrationErrors = u),
                u = !0;
            if (!u)
                return n.flags & 256 ? (No(n),
                n) : (No(n),
                null)
        }
        return No(n),
        n.flags & 128 ? (n.lanes = a,
        n) : (a = c !== null,
        o = o !== null && o.memoizedState !== null,
        a && (c = n.child,
        u = null,
        c.alternate !== null && c.alternate.memoizedState !== null && c.alternate.memoizedState.cachePool !== null && (u = c.alternate.memoizedState.cachePool.pool),
        p = null,
        c.memoizedState !== null && c.memoizedState.cachePool !== null && (p = c.memoizedState.cachePool.pool),
        p !== u && (c.flags |= 2048)),
        a !== o && a && (n.child.flags |= 8192),
        Fu(n, n.updateQueue),
        rt(n),
        null);
    case 4:
        return xa(),
        o === null && Xb(n.stateNode.containerInfo),
        rt(n),
        null;
    case 10:
        return gn(n.type),
        rt(n),
        null;
    case 19:
        if (Vt(yt),
        c = n.memoizedState,
        c === null)
            return rt(n),
            null;
        if (u = (n.flags & 128) !== 0,
        p = c.rendering,
        p === null)
            if (u)
                ql(c, !1);
            else {
                if (kt !== 0 || o !== null && o.flags & 128)
                    for (o = n.child; o !== null; ) {
                        if (p = Th(o),
                        p !== null) {
                            for (n.flags |= 128,
                            ql(c, !1),
                            o = p.updateQueue,
                            n.updateQueue = o,
                            Fu(n, o),
                            n.subtreeFlags = 0,
                            o = a,
                            a = n.child; a !== null; )
                                hT(a, o),
                                a = a.sibling;
                            return tt(yt, yt.current & 1 | 2),
                            Be && cn(n, c.treeForkCount),
                            n.child
                        }
                        o = o.sibling
                    }
                c.tail !== null && Lo() > jh && (n.flags |= 128,
                u = !0,
                ql(c, !1),
                n.lanes = 4194304)
            }
        else {
            if (!u)
                if (o = Th(p),
                o !== null) {
                    if (n.flags |= 128,
                    u = !0,
                    o = o.updateQueue,
                    n.updateQueue = o,
                    Fu(n, o),
                    ql(c, !0),
                    c.tail === null && c.tailMode === "hidden" && !p.alternate && !Be)
                        return rt(n),
                        null
                } else
                    2 * Lo() - c.renderingStartTime > jh && a !== 536870912 && (n.flags |= 128,
                    u = !0,
                    ql(c, !1),
                    n.lanes = 4194304);
            c.isBackwards ? (p.sibling = n.child,
            n.child = p) : (o = c.last,
            o !== null ? o.sibling = p : n.child = p,
            c.last = p)
        }
        return c.tail !== null ? (o = c.tail,
        c.rendering = o,
        c.tail = o.sibling,
        c.renderingStartTime = Lo(),
        o.sibling = null,
        a = yt.current,
        tt(yt, u ? a & 1 | 2 : a & 1),
        Be && cn(n, c.treeForkCount),
        o) : (rt(n),
        null);
    case 22:
    case 23:
        return No(n),
        Mb(),
        c = n.memoizedState !== null,
        o !== null ? o.memoizedState !== null !== c && (n.flags |= 8192) : c && (n.flags |= 8192),
        c ? a & 536870912 && !(n.flags & 128) && (rt(n),
        n.subtreeFlags & 6 && (n.flags |= 8192)) : rt(n),
        a = n.updateQueue,
        a !== null && Fu(n, a.retryQueue),
        a = null,
        o !== null && o.memoizedState !== null && o.memoizedState.cachePool !== null && (a = o.memoizedState.cachePool.pool),
        c = null,
        n.memoizedState !== null && n.memoizedState.cachePool !== null && (c = n.memoizedState.cachePool.pool),
        c !== a && (n.flags |= 2048),
        o !== null && Vt(Ji),
        null;
    case 24:
        return a = null,
        o !== null && (a = o.memoizedState.cache),
        n.memoizedState.cache !== a && (n.flags |= 2048),
        gn(Tt),
        rt(n),
        null;
    case 25:
        return null;
    case 30:
        return null
    }
    throw Error(oe(156, n.tag))
}
function dV(o, n) {
    switch (Eb(n),
    n.tag) {
    case 1:
        return o = n.flags,
        o & 65536 ? (n.flags = o & -65537 | 128,
        n) : null;
    case 3:
        return gn(Tt),
        xa(),
        o = n.flags,
        o & 65536 && !(o & 128) ? (n.flags = o & -65537 | 128,
        n) : null;
    case 26:
    case 27:
    case 5:
        return Ah(n),
        null;
    case 31:
        if (n.memoizedState !== null) {
            if (No(n),
            n.alternate === null)
                throw Error(oe(340));
            rs()
        }
        return o = n.flags,
        o & 65536 ? (n.flags = o & -65537 | 128,
        n) : null;
    case 13:
        if (No(n),
        o = n.memoizedState,
        o !== null && o.dehydrated !== null) {
            if (n.alternate === null)
                throw Error(oe(340));
            rs()
        }
        return o = n.flags,
        o & 65536 ? (n.flags = o & -65537 | 128,
        n) : null;
    case 19:
        return Vt(yt),
        null;
    case 4:
        return xa(),
        null;
    case 10:
        return gn(n.type),
        null;
    case 22:
    case 23:
        return No(n),
        Mb(),
        o !== null && Vt(Ji),
        o = n.flags,
        o & 65536 ? (n.flags = o & -65537 | 128,
        n) : null;
    case 24:
        return gn(Tt),
        null;
    case 25:
        return null;
    default:
        return null
    }
}
function hI(o, n) {
    switch (Eb(n),
    n.tag) {
    case 3:
        gn(Tt),
        xa();
        break;
    case 26:
    case 27:
    case 5:
        Ah(n);
        break;
    case 4:
        xa();
        break;
    case 31:
        n.memoizedState !== null && No(n);
        break;
    case 13:
        No(n);
        break;
    case 19:
        Vt(yt);
        break;
    case 10:
        gn(n.type);
        break;
    case 22:
    case 23:
        No(n),
        Mb(),
        o !== null && Vt(Ji);
        break;
    case 24:
        gn(Tt)
    }
}
function Jc(o, n) {
    try {
        var a = n.updateQueue
          , c = a !== null ? a.lastEffect : null;
        if (c !== null) {
            var u = c.next;
            a = u;
            do {
                if ((a.tag & o) === o) {
                    c = void 0;
                    var p = a.create
                      , f = a.inst;
                    c = p(),
                    f.destroy = c
                }
                a = a.next
            } while (a !== u)
        }
    } catch (w) {
        He(n, n.return, w)
    }
}
function di(o, n, a) {
    try {
        var c = n.updateQueue
          , u = c !== null ? c.lastEffect : null;
        if (u !== null) {
            var p = u.next;
            c = p;
            do {
                if ((c.tag & o) === o) {
                    var f = c.inst
                      , w = f.destroy;
                    if (w !== void 0) {
                        f.destroy = void 0,
                        u = n;
                        var k = a
                          , y = w;
                        try {
                            y()
                        } catch (E) {
                            He(u, k, E)
                        }
                    }
                }
                c = c.next
            } while (c !== p)
        }
    } catch (E) {
        He(n, n.return, E)
    }
}
function mI(o) {
    var n = o.updateQueue;
    if (n !== null) {
        var a = o.stateNode;
        try {
            _T(n, a)
        } catch (c) {
            He(o, o.return, c)
        }
    }
}
function pI(o, n, a) {
    a.props = as(o.type, o.memoizedProps),
    a.state = o.memoizedState;
    try {
        a.componentWillUnmount()
    } catch (c) {
        He(o, n, c)
    }
}
function hc(o, n) {
    try {
        var a = o.ref;
        if (a !== null) {
            switch (o.tag) {
            case 26:
            case 27:
            case 5:
                var c = o.stateNode;
                break;
            case 30:
                c = o.stateNode;
                break;
            default:
                c = o.stateNode
            }
            typeof a == "function" ? o.refCleanup = a(c) : a.current = c
        }
    } catch (u) {
        He(o, n, u)
    }
}
function Rr(o, n) {
    var a = o.ref
      , c = o.refCleanup;
    if (a !== null)
        if (typeof c == "function")
            try {
                c()
            } catch (u) {
                He(o, n, u)
            } finally {
                o.refCleanup = null,
                o = o.alternate,
                o != null && (o.refCleanup = null)
            }
        else if (typeof a == "function")
            try {
                a(null)
            } catch (u) {
                He(o, n, u)
            }
        else
            a.current = null
}
function gI(o) {
    var n = o.type
      , a = o.memoizedProps
      , c = o.stateNode;
    try {
        e: switch (n) {
        case "button":
        case "input":
        case "select":
        case "textarea":
            a.autoFocus && c.focus();
            break e;
        case "img":
            a.src ? c.src = a.src : a.srcSet && (c.srcset = a.srcSet)
        }
    } catch (u) {
        He(o, o.return, u)
    }
}
function sf(o, n, a) {
    try {
        var c = o.stateNode;
        BV(c, o.type, a, n),
        c[vo] = n
    } catch (u) {
        He(o, o.return, u)
    }
}
function fI(o) {
    return o.tag === 5 || o.tag === 3 || o.tag === 26 || o.tag === 27 && gi(o.type) || o.tag === 4
}
function af(o) {
    e: for (; ; ) {
        for (; o.sibling === null; ) {
            if (o.return === null || fI(o.return))
                return null;
            o = o.return
        }
        for (o.sibling.return = o.return,
        o = o.sibling; o.tag !== 5 && o.tag !== 6 && o.tag !== 18; ) {
            if (o.tag === 27 && gi(o.type) || o.flags & 2 || o.child === null || o.tag === 4)
                continue e;
            o.child.return = o,
            o = o.child
        }
        if (!(o.flags & 2))
            return o.stateNode
    }
}
function kk(o, n, a) {
    var c = o.tag;
    if (c === 5 || c === 6)
        o = o.stateNode,
        n ? (a.nodeType === 9 ? a.body : a.nodeName === "HTML" ? a.ownerDocument.body : a).insertBefore(o, n) : (n = a.nodeType === 9 ? a.body : a.nodeName === "HTML" ? a.ownerDocument.body : a,
        n.appendChild(o),
        a = a._reactRootContainer,
        a != null || n.onclick !== null || (n.onclick = hn));
    else if (c !== 4 && (c === 27 && gi(o.type) && (a = o.stateNode,
    n = null),
    o = o.child,
    o !== null))
        for (kk(o, n, a),
        o = o.sibling; o !== null; )
            kk(o, n, a),
            o = o.sibling
}
function Ph(o, n, a) {
    var c = o.tag;
    if (c === 5 || c === 6)
        o = o.stateNode,
        n ? a.insertBefore(o, n) : a.appendChild(o);
    else if (c !== 4 && (c === 27 && gi(o.type) && (a = o.stateNode),
    o = o.child,
    o !== null))
        for (Ph(o, n, a),
        o = o.sibling; o !== null; )
            Ph(o, n, a),
            o = o.sibling
}
function kI(o) {
    var n = o.stateNode
      , a = o.memoizedProps;
    try {
        for (var c = o.type, u = n.attributes; u.length; )
            n.removeAttributeNode(u[0]);
        Qt(n, c, a),
        n[Gt] = o,
        n[vo] = a
    } catch (p) {
        He(o, o.return, p)
    }
}
var dn = !1
  , Dt = !1
  , lf = !1
  , kS = typeof WeakSet == "function" ? WeakSet : Set
  , Rt = null;
function uV(o, n) {
    if (o = o.containerInfo,
    yk = $h,
    o = nT(o),
    vb(o)) {
        if ("selectionStart"in o)
            var a = {
                start: o.selectionStart,
                end: o.selectionEnd
            };
        else
            e: {
                a = (a = o.ownerDocument) && a.defaultView || window;
                var c = a.getSelection && a.getSelection();
                if (c && c.rangeCount !== 0) {
                    a = c.anchorNode;
                    var u = c.anchorOffset
                      , p = c.focusNode;
                    c = c.focusOffset;
                    try {
                        a.nodeType,
                        p.nodeType
                    } catch {
                        a = null;
                        break e
                    }
                    var f = 0
                      , w = -1
                      , k = -1
                      , y = 0
                      , E = 0
                      , S = o
                      , A = null;
                    t: for (; ; ) {
                        for (var D; S !== a || u !== 0 && S.nodeType !== 3 || (w = f + u),
                        S !== p || c !== 0 && S.nodeType !== 3 || (k = f + c),
                        S.nodeType === 3 && (f += S.nodeValue.length),
                        (D = S.firstChild) !== null; )
                            A = S,
                            S = D;
                        for (; ; ) {
                            if (S === o)
                                break t;
                            if (A === a && ++y === u && (w = f),
                            A === p && ++E === c && (k = f),
                            (D = S.nextSibling) !== null)
                                break;
                            S = A,
                            A = S.parentNode
                        }
                        S = D
                    }
                    a = w === -1 || k === -1 ? null : {
                        start: w,
                        end: k
                    }
                } else
                    a = null
            }
        a = a || {
            start: 0,
            end: 0
        }
    } else
        a = null;
    for (xk = {
        focusedElem: o,
        selectionRange: a
    },
    $h = !1,
    Rt = n; Rt !== null; )
        if (n = Rt,
        o = n.child,
        (n.subtreeFlags & 1028) !== 0 && o !== null)
            o.return = n,
            Rt = o;
        else
            for (; Rt !== null; ) {
                switch (n = Rt,
                p = n.alternate,
                o = n.flags,
                n.tag) {
                case 0:
                    if (o & 4 && (o = n.updateQueue,
                    o = o !== null ? o.events : null,
                    o !== null))
                        for (a = 0; a < o.length; a++)
                            u = o[a],
                            u.ref.impl = u.nextImpl;
                    break;
                case 11:
                case 15:
                    break;
                case 1:
                    if (o & 1024 && p !== null) {
                        o = void 0,
                        a = n,
                        u = p.memoizedProps,
                        p = p.memoizedState,
                        c = a.stateNode;
                        try {
                            var N = as(a.type, u);
                            o = c.getSnapshotBeforeUpdate(N, p),
                            c.__reactInternalSnapshotBeforeUpdate = o
                        } catch (L) {
                            He(a, a.return, L)
                        }
                    }
                    break;
                case 3:
                    if (o & 1024) {
                        if (o = n.stateNode.containerInfo,
                        a = o.nodeType,
                        a === 9)
                            Sk(o);
                        else if (a === 1)
                            switch (o.nodeName) {
                            case "HEAD":
                            case "HTML":
                            case "BODY":
                                Sk(o);
                                break;
                            default:
                                o.textContent = ""
                            }
                    }
                    break;
                case 5:
                case 26:
                case 27:
                case 6:
                case 4:
                case 17:
                    break;
                default:
                    if (o & 1024)
                        throw Error(oe(163))
                }
                if (o = n.sibling,
                o !== null) {
                    o.return = n.return,
                    Rt = o;
                    break
                }
                Rt = n.return
            }
}
function bI(o, n, a) {
    var c = a.flags;
    switch (a.tag) {
    case 0:
    case 11:
    case 15:
        sn(o, a),
        c & 4 && Jc(5, a);
        break;
    case 1:
        if (sn(o, a),
        c & 4)
            if (o = a.stateNode,
            n === null)
                try {
                    o.componentDidMount()
                } catch (f) {
                    He(a, a.return, f)
                }
            else {
                var u = as(a.type, n.memoizedProps);
                n = n.memoizedState;
                try {
                    o.componentDidUpdate(u, n, o.__reactInternalSnapshotBeforeUpdate)
                } catch (f) {
                    He(a, a.return, f)
                }
            }
        c & 64 && mI(a),
        c & 512 && hc(a, a.return);
        break;
    case 3:
        if (sn(o, a),
        c & 64 && (o = a.updateQueue,
        o !== null)) {
            if (n = null,
            a.child !== null)
                switch (a.child.tag) {
                case 27:
                case 5:
                    n = a.child.stateNode;
                    break;
                case 1:
                    n = a.child.stateNode
                }
            try {
                _T(o, n)
            } catch (f) {
                He(a, a.return, f)
            }
        }
        break;
    case 27:
        n === null && c & 4 && kI(a);
    case 26:
    case 5:
        sn(o, a),
        n === null && c & 4 && gI(a),
        c & 512 && hc(a, a.return);
        break;
    case 12:
        sn(o, a);
        break;
    case 31:
        sn(o, a),
        c & 4 && vI(o, a);
        break;
    case 13:
        sn(o, a),
        c & 4 && _I(o, a),
        c & 64 && (o = a.memoizedState,
        o !== null && (o = o.dehydrated,
        o !== null && (a = AV.bind(null, a),
        FV(o, a))));
        break;
    case 22:
        if (c = a.memoizedState !== null || dn,
        !c) {
            n = n !== null && n.memoizedState !== null || Dt,
            u = dn;
            var p = Dt;
            dn = c,
            (Dt = n) && !p ? ln(o, a, (a.subtreeFlags & 8772) !== 0) : sn(o, a),
            dn = u,
            Dt = p
        }
        break;
    case 30:
        break;
    default:
        sn(o, a)
    }
}
function wI(o) {
    var n = o.alternate;
    n !== null && (o.alternate = null,
    wI(n)),
    o.child = null,
    o.deletions = null,
    o.sibling = null,
    o.tag === 5 && (n = o.stateNode,
    n !== null && gb(n)),
    o.stateNode = null,
    o.return = null,
    o.dependencies = null,
    o.memoizedProps = null,
    o.memoizedState = null,
    o.pendingProps = null,
    o.stateNode = null,
    o.updateQueue = null
}
var at = null
  , fo = !1;
function nn(o, n, a) {
    for (a = a.child; a !== null; )
        AI(o, n, a),
        a = a.sibling
}
function AI(o, n, a) {
    if (zo && typeof zo.onCommitFiberUnmount == "function")
        try {
            zo.onCommitFiberUnmount($c, a)
        } catch {}
    switch (a.tag) {
    case 26:
        Dt || Rr(a, n),
        nn(o, n, a),
        a.memoizedState ? a.memoizedState.count-- : a.stateNode && (a = a.stateNode,
        a.parentNode.removeChild(a));
        break;
    case 27:
        Dt || Rr(a, n);
        var c = at
          , u = fo;
        gi(a.type) && (at = a.stateNode,
        fo = !1),
        nn(o, n, a),
        fc(a.stateNode),
        at = c,
        fo = u;
        break;
    case 5:
        Dt || Rr(a, n);
    case 6:
        if (c = at,
        u = fo,
        at = null,
        nn(o, n, a),
        at = c,
        fo = u,
        at !== null)
            if (fo)
                try {
                    (at.nodeType === 9 ? at.body : at.nodeName === "HTML" ? at.ownerDocument.body : at).removeChild(a.stateNode)
                } catch (p) {
                    He(a, n, p)
                }
            else
                try {
                    at.removeChild(a.stateNode)
                } catch (p) {
                    He(a, n, p)
                }
        break;
    case 18:
        at !== null && (fo ? (o = at,
        IS(o.nodeType === 9 ? o.body : o.nodeName === "HTML" ? o.ownerDocument.body : o, a.stateNode),
        ja(o)) : IS(at, a.stateNode));
        break;
    case 4:
        c = at,
        u = fo,
        at = a.stateNode.containerInfo,
        fo = !0,
        nn(o, n, a),
        at = c,
        fo = u;
        break;
    case 0:
    case 11:
    case 14:
    case 15:
        di(2, a, n),
        Dt || di(4, a, n),
        nn(o, n, a);
        break;
    case 1:
        Dt || (Rr(a, n),
        c = a.stateNode,
        typeof c.componentWillUnmount == "function" && pI(a, n, c)),
        nn(o, n, a);
        break;
    case 21:
        nn(o, n, a);
        break;
    case 22:
        Dt = (c = Dt) || a.memoizedState !== null,
        nn(o, n, a),
        Dt = c;
        break;
    default:
        nn(o, n, a)
    }
}
function vI(o, n) {
    if (n.memoizedState === null && (o = n.alternate,
    o !== null && (o = o.memoizedState,
    o !== null))) {
        o = o.dehydrated;
        try {
            ja(o)
        } catch (a) {
            He(n, n.return, a)
        }
    }
}
function _I(o, n) {
    if (n.memoizedState === null && (o = n.alternate,
    o !== null && (o = o.memoizedState,
    o !== null && (o = o.dehydrated,
    o !== null))))
        try {
            ja(o)
        } catch (a) {
            He(n, n.return, a)
        }
}
function hV(o) {
    switch (o.tag) {
    case 31:
    case 13:
    case 19:
        var n = o.stateNode;
        return n === null && (n = o.stateNode = new kS),
        n;
    case 22:
        return o = o.stateNode,
        n = o._retryCache,
        n === null && (n = o._retryCache = new kS),
        n;
    default:
        throw Error(oe(435, o.tag))
    }
}
function Vu(o, n) {
    var a = hV(o);
    n.forEach(function(c) {
        if (!a.has(c)) {
            a.add(c);
            var u = vV.bind(null, o, c);
            c.then(u, u)
        }
    })
}
function mo(o, n) {
    var a = n.deletions;
    if (a !== null)
        for (var c = 0; c < a.length; c++) {
            var u = a[c]
              , p = o
              , f = n
              , w = f;
            e: for (; w !== null; ) {
                switch (w.tag) {
                case 27:
                    if (gi(w.type)) {
                        at = w.stateNode,
                        fo = !1;
                        break e
                    }
                    break;
                case 5:
                    at = w.stateNode,
                    fo = !1;
                    break e;
                case 3:
                case 4:
                    at = w.stateNode.containerInfo,
                    fo = !0;
                    break e
                }
                w = w.return
            }
            if (at === null)
                throw Error(oe(160));
            AI(p, f, u),
            at = null,
            fo = !1,
            p = u.alternate,
            p !== null && (p.return = null),
            u.return = null
        }
    if (n.subtreeFlags & 13886)
        for (n = n.child; n !== null; )
            CI(n, o),
            n = n.sibling
}
var _r = null;
function CI(o, n) {
    var a = o.alternate
      , c = o.flags;
    switch (o.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
        mo(n, o),
        po(o),
        c & 4 && (di(3, o, o.return),
        Jc(3, o),
        di(5, o, o.return));
        break;
    case 1:
        mo(n, o),
        po(o),
        c & 512 && (Dt || a === null || Rr(a, a.return)),
        c & 64 && dn && (o = o.updateQueue,
        o !== null && (c = o.callbacks,
        c !== null && (a = o.shared.hiddenCallbacks,
        o.shared.hiddenCallbacks = a === null ? c : a.concat(c))));
        break;
    case 26:
        var u = _r;
        if (mo(n, o),
        po(o),
        c & 512 && (Dt || a === null || Rr(a, a.return)),
        c & 4) {
            var p = a !== null ? a.memoizedState : null;
            if (c = o.memoizedState,
            a === null)
                if (c === null)
                    if (o.stateNode === null) {
                        e: {
                            c = o.type,
                            a = o.memoizedProps,
                            u = u.ownerDocument || u;
                            t: switch (c) {
                            case "title":
                                p = u.getElementsByTagName("title")[0],
                                (!p || p[Kc] || p[Gt] || p.namespaceURI === "http://www.w3.org/2000/svg" || p.hasAttribute("itemprop")) && (p = u.createElement(c),
                                u.head.insertBefore(p, u.querySelector("head > title"))),
                                Qt(p, c, a),
                                p[Gt] = o,
                                Ft(p),
                                c = p;
                                break e;
                            case "link":
                                var f = zS("link", "href", u).get(c + (a.href || ""));
                                if (f) {
                                    for (var w = 0; w < f.length; w++)
                                        if (p = f[w],
                                        p.getAttribute("href") === (a.href == null || a.href === "" ? null : a.href) && p.getAttribute("rel") === (a.rel == null ? null : a.rel) && p.getAttribute("title") === (a.title == null ? null : a.title) && p.getAttribute("crossorigin") === (a.crossOrigin == null ? null : a.crossOrigin)) {
                                            f.splice(w, 1);
                                            break t
                                        }
                                }
                                p = u.createElement(c),
                                Qt(p, c, a),
                                u.head.appendChild(p);
                                break;
                            case "meta":
                                if (f = zS("meta", "content", u).get(c + (a.content || ""))) {
                                    for (w = 0; w < f.length; w++)
                                        if (p = f[w],
                                        p.getAttribute("content") === (a.content == null ? null : "" + a.content) && p.getAttribute("name") === (a.name == null ? null : a.name) && p.getAttribute("property") === (a.property == null ? null : a.property) && p.getAttribute("http-equiv") === (a.httpEquiv == null ? null : a.httpEquiv) && p.getAttribute("charset") === (a.charSet == null ? null : a.charSet)) {
                                            f.splice(w, 1);
                                            break t
                                        }
                                }
                                p = u.createElement(c),
                                Qt(p, c, a),
                                u.head.appendChild(p);
                                break;
                            default:
                                throw Error(oe(468, c))
                            }
                            p[Gt] = o,
                            Ft(p),
                            c = p
                        }
                        o.stateNode = c
                    } else
                        OS(u, o.type, o.stateNode);
                else
                    o.stateNode = LS(u, c, o.memoizedProps);
            else
                p !== c ? (p === null ? a.stateNode !== null && (a = a.stateNode,
                a.parentNode.removeChild(a)) : p.count--,
                c === null ? OS(u, o.type, o.stateNode) : LS(u, c, o.memoizedProps)) : c === null && o.stateNode !== null && sf(o, o.memoizedProps, a.memoizedProps)
        }
        break;
    case 27:
        mo(n, o),
        po(o),
        c & 512 && (Dt || a === null || Rr(a, a.return)),
        a !== null && c & 4 && sf(o, o.memoizedProps, a.memoizedProps);
        break;
    case 5:
        if (mo(n, o),
        po(o),
        c & 512 && (Dt || a === null || Rr(a, a.return)),
        o.flags & 32) {
            u = o.stateNode;
            try {
                Sa(u, "")
            } catch (N) {
                He(o, o.return, N)
            }
        }
        c & 4 && o.stateNode != null && (u = o.memoizedProps,
        sf(o, u, a !== null ? a.memoizedProps : u)),
        c & 1024 && (lf = !0);
        break;
    case 6:
        if (mo(n, o),
        po(o),
        c & 4) {
            if (o.stateNode === null)
                throw Error(oe(162));
            c = o.memoizedProps,
            a = o.stateNode;
            try {
                a.nodeValue = c
            } catch (N) {
                He(o, o.return, N)
            }
        }
        break;
    case 3:
        if (ch = null,
        u = _r,
        _r = Uh(n.containerInfo),
        mo(n, o),
        _r = u,
        po(o),
        c & 4 && a !== null && a.memoizedState.isDehydrated)
            try {
                ja(n.containerInfo)
            } catch (N) {
                He(o, o.return, N)
            }
        lf && (lf = !1,
        yI(o));
        break;
    case 4:
        c = _r,
        _r = Uh(o.stateNode.containerInfo),
        mo(n, o),
        po(o),
        _r = c;
        break;
    case 12:
        mo(n, o),
        po(o);
        break;
    case 31:
        mo(n, o),
        po(o),
        c & 4 && (c = o.updateQueue,
        c !== null && (o.updateQueue = null,
        Vu(o, c)));
        break;
    case 13:
        mo(n, o),
        po(o),
        o.child.flags & 8192 && o.memoizedState !== null != (a !== null && a.memoizedState !== null) && (fm = Lo()),
        c & 4 && (c = o.updateQueue,
        c !== null && (o.updateQueue = null,
        Vu(o, c)));
        break;
    case 22:
        u = o.memoizedState !== null;
        var k = a !== null && a.memoizedState !== null
          , y = dn
          , E = Dt;
        if (dn = y || u,
        Dt = E || k,
        mo(n, o),
        Dt = E,
        dn = y,
        po(o),
        c & 8192)
            e: for (n = o.stateNode,
            n._visibility = u ? n._visibility & -2 : n._visibility | 1,
            u && (a === null || k || dn || Dt || qi(o)),
            a = null,
            n = o; ; ) {
                if (n.tag === 5 || n.tag === 26) {
                    if (a === null) {
                        k = a = n;
                        try {
                            if (p = k.stateNode,
                            u)
                                f = p.style,
                                typeof f.setProperty == "function" ? f.setProperty("display", "none", "important") : f.display = "none";
                            else {
                                w = k.stateNode;
                                var S = k.memoizedProps.style
                                  , A = S != null && S.hasOwnProperty("display") ? S.display : null;
                                w.style.display = A == null || typeof A == "boolean" ? "" : ("" + A).trim()
                            }
                        } catch (N) {
                            He(k, k.return, N)
                        }
                    }
                } else if (n.tag === 6) {
                    if (a === null) {
                        k = n;
                        try {
                            k.stateNode.nodeValue = u ? "" : k.memoizedProps
                        } catch (N) {
                            He(k, k.return, N)
                        }
                    }
                } else if (n.tag === 18) {
                    if (a === null) {
                        k = n;
                        try {
                            var D = k.stateNode;
                            u ? MS(D, !0) : MS(k.stateNode, !1)
                        } catch (N) {
                            He(k, k.return, N)
                        }
                    }
                } else if ((n.tag !== 22 && n.tag !== 23 || n.memoizedState === null || n === o) && n.child !== null) {
                    n.child.return = n,
                    n = n.child;
                    continue
                }
                if (n === o)
                    break e;
                for (; n.sibling === null; ) {
                    if (n.return === null || n.return === o)
                        break e;
                    a === n && (a = null),
                    n = n.return
                }
                a === n && (a = null),
                n.sibling.return = n.return,
                n = n.sibling
            }
        c & 4 && (c = o.updateQueue,
        c !== null && (a = c.retryQueue,
        a !== null && (c.retryQueue = null,
        Vu(o, a))));
        break;
    case 19:
        mo(n, o),
        po(o),
        c & 4 && (c = o.updateQueue,
        c !== null && (o.updateQueue = null,
        Vu(o, c)));
        break;
    case 30:
        break;
    case 21:
        break;
    default:
        mo(n, o),
        po(o)
    }
}
function po(o) {
    var n = o.flags;
    if (n & 2) {
        try {
            for (var a, c = o.return; c !== null; ) {
                if (fI(c)) {
                    a = c;
                    break
                }
                c = c.return
            }
            if (a == null)
                throw Error(oe(160));
            switch (a.tag) {
            case 27:
                var u = a.stateNode
                  , p = af(o);
                Ph(o, p, u);
                break;
            case 5:
                var f = a.stateNode;
                a.flags & 32 && (Sa(f, ""),
                a.flags &= -33);
                var w = af(o);
                Ph(o, w, f);
                break;
            case 3:
            case 4:
                var k = a.stateNode.containerInfo
                  , y = af(o);
                kk(o, y, k);
                break;
            default:
                throw Error(oe(161))
            }
        } catch (E) {
            He(o, o.return, E)
        }
        o.flags &= -3
    }
    n & 4096 && (o.flags &= -4097)
}
function yI(o) {
    if (o.subtreeFlags & 1024)
        for (o = o.child; o !== null; ) {
            var n = o;
            yI(n),
            n.tag === 5 && n.flags & 1024 && n.stateNode.reset(),
            o = o.sibling
        }
}
function sn(o, n) {
    if (n.subtreeFlags & 8772)
        for (n = n.child; n !== null; )
            bI(o, n.alternate, n),
            n = n.sibling
}
function qi(o) {
    for (o = o.child; o !== null; ) {
        var n = o;
        switch (n.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
            di(4, n, n.return),
            qi(n);
            break;
        case 1:
            Rr(n, n.return);
            var a = n.stateNode;
            typeof a.componentWillUnmount == "function" && pI(n, n.return, a),
            qi(n);
            break;
        case 27:
            fc(n.stateNode);
        case 26:
        case 5:
            Rr(n, n.return),
            qi(n);
            break;
        case 22:
            n.memoizedState === null && qi(n);
            break;
        case 30:
            qi(n);
            break;
        default:
            qi(n)
        }
        o = o.sibling
    }
}
function ln(o, n, a) {
    for (a = a && (n.subtreeFlags & 8772) !== 0,
    n = n.child; n !== null; ) {
        var c = n.alternate
          , u = o
          , p = n
          , f = p.flags;
        switch (p.tag) {
        case 0:
        case 11:
        case 15:
            ln(u, p, a),
            Jc(4, p);
            break;
        case 1:
            if (ln(u, p, a),
            c = p,
            u = c.stateNode,
            typeof u.componentDidMount == "function")
                try {
                    u.componentDidMount()
                } catch (y) {
                    He(c, c.return, y)
                }
            if (c = p,
            u = c.updateQueue,
            u !== null) {
                var w = c.stateNode;
                try {
                    var k = u.shared.hiddenCallbacks;
                    if (k !== null)
                        for (u.shared.hiddenCallbacks = null,
                        u = 0; u < k.length; u++)
                            vT(k[u], w)
                } catch (y) {
                    He(c, c.return, y)
                }
            }
            a && f & 64 && mI(p),
            hc(p, p.return);
            break;
        case 27:
            kI(p);
        case 26:
        case 5:
            ln(u, p, a),
            a && c === null && f & 4 && gI(p),
            hc(p, p.return);
            break;
        case 12:
            ln(u, p, a);
            break;
        case 31:
            ln(u, p, a),
            a && f & 4 && vI(u, p);
            break;
        case 13:
            ln(u, p, a),
            a && f & 4 && _I(u, p);
            break;
        case 22:
            p.memoizedState === null && ln(u, p, a),
            hc(p, p.return);
            break;
        case 30:
            break;
        default:
            ln(u, p, a)
        }
        n = n.sibling
    }
}
function Gb(o, n) {
    var a = null;
    o !== null && o.memoizedState !== null && o.memoizedState.cachePool !== null && (a = o.memoizedState.cachePool.pool),
    o = null,
    n.memoizedState !== null && n.memoizedState.cachePool !== null && (o = n.memoizedState.cachePool.pool),
    o !== a && (o != null && o.refCount++,
    a != null && Qc(a))
}
function Kb(o, n) {
    o = null,
    n.alternate !== null && (o = n.alternate.memoizedState.cache),
    n = n.memoizedState.cache,
    n !== o && (n.refCount++,
    o != null && Qc(o))
}
function Ar(o, n, a, c) {
    if (n.subtreeFlags & 10256)
        for (n = n.child; n !== null; )
            xI(o, n, a, c),
            n = n.sibling
}
function xI(o, n, a, c) {
    var u = n.flags;
    switch (n.tag) {
    case 0:
    case 11:
    case 15:
        Ar(o, n, a, c),
        u & 2048 && Jc(9, n);
        break;
    case 1:
        Ar(o, n, a, c);
        break;
    case 3:
        Ar(o, n, a, c),
        u & 2048 && (o = null,
        n.alternate !== null && (o = n.alternate.memoizedState.cache),
        n = n.memoizedState.cache,
        n !== o && (n.refCount++,
        o != null && Qc(o)));
        break;
    case 12:
        if (u & 2048) {
            Ar(o, n, a, c),
            o = n.stateNode;
            try {
                var p = n.memoizedProps
                  , f = p.id
                  , w = p.onPostCommit;
                typeof w == "function" && w(f, n.alternate === null ? "mount" : "update", o.passiveEffectDuration, -0)
            } catch (k) {
                He(n, n.return, k)
            }
        } else
            Ar(o, n, a, c);
        break;
    case 31:
        Ar(o, n, a, c);
        break;
    case 13:
        Ar(o, n, a, c);
        break;
    case 23:
        break;
    case 22:
        p = n.stateNode,
        f = n.alternate,
        n.memoizedState !== null ? p._visibility & 2 ? Ar(o, n, a, c) : mc(o, n) : p._visibility & 2 ? Ar(o, n, a, c) : (p._visibility |= 2,
        Zs(o, n, a, c, (n.subtreeFlags & 10256) !== 0 || !1)),
        u & 2048 && Gb(f, n);
        break;
    case 24:
        Ar(o, n, a, c),
        u & 2048 && Kb(n.alternate, n);
        break;
    default:
        Ar(o, n, a, c)
    }
}
function Zs(o, n, a, c, u) {
    for (u = u && ((n.subtreeFlags & 10256) !== 0 || !1),
    n = n.child; n !== null; ) {
        var p = o
          , f = n
          , w = a
          , k = c
          , y = f.flags;
        switch (f.tag) {
        case 0:
        case 11:
        case 15:
            Zs(p, f, w, k, u),
            Jc(8, f);
            break;
        case 23:
            break;
        case 22:
            var E = f.stateNode;
            f.memoizedState !== null ? E._visibility & 2 ? Zs(p, f, w, k, u) : mc(p, f) : (E._visibility |= 2,
            Zs(p, f, w, k, u)),
            u && y & 2048 && Gb(f.alternate, f);
            break;
        case 24:
            Zs(p, f, w, k, u),
            u && y & 2048 && Kb(f.alternate, f);
            break;
        default:
            Zs(p, f, w, k, u)
        }
        n = n.sibling
    }
}
function mc(o, n) {
    if (n.subtreeFlags & 10256)
        for (n = n.child; n !== null; ) {
            var a = o
              , c = n
              , u = c.flags;
            switch (c.tag) {
            case 22:
                mc(a, c),
                u & 2048 && Gb(c.alternate, c);
                break;
            case 24:
                mc(a, c),
                u & 2048 && Kb(c.alternate, c);
                break;
            default:
                mc(a, c)
            }
            n = n.sibling
        }
}
var tc = 8192;
function Ks(o, n, a) {
    if (o.subtreeFlags & tc)
        for (o = o.child; o !== null; )
            EI(o, n, a),
            o = o.sibling
}
function EI(o, n, a) {
    switch (o.tag) {
    case 26:
        Ks(o, n, a),
        o.flags & tc && o.memoizedState !== null && JV(a, _r, o.memoizedState, o.memoizedProps);
        break;
    case 5:
        Ks(o, n, a);
        break;
    case 3:
    case 4:
        var c = _r;
        _r = Uh(o.stateNode.containerInfo),
        Ks(o, n, a),
        _r = c;
        break;
    case 22:
        o.memoizedState === null && (c = o.alternate,
        c !== null && c.memoizedState !== null ? (c = tc,
        tc = 16777216,
        Ks(o, n, a),
        tc = c) : Ks(o, n, a));
        break;
    default:
        Ks(o, n, a)
    }
}
function SI(o) {
    var n = o.alternate;
    if (n !== null && (o = n.child,
    o !== null)) {
        n.child = null;
        do
            n = o.sibling,
            o.sibling = null,
            o = n;
        while (o !== null)
    }
}
function Gl(o) {
    var n = o.deletions;
    if (o.flags & 16) {
        if (n !== null)
            for (var a = 0; a < n.length; a++) {
                var c = n[a];
                Rt = c,
                TI(c, o)
            }
        SI(o)
    }
    if (o.subtreeFlags & 10256)
        for (o = o.child; o !== null; )
            DI(o),
            o = o.sibling
}
function DI(o) {
    switch (o.tag) {
    case 0:
    case 11:
    case 15:
        Gl(o),
        o.flags & 2048 && di(9, o, o.return);
        break;
    case 3:
        Gl(o);
        break;
    case 12:
        Gl(o);
        break;
    case 22:
        var n = o.stateNode;
        o.memoizedState !== null && n._visibility & 2 && (o.return === null || o.return.tag !== 13) ? (n._visibility &= -3,
        ah(o)) : Gl(o);
        break;
    default:
        Gl(o)
    }
}
function ah(o) {
    var n = o.deletions;
    if (o.flags & 16) {
        if (n !== null)
            for (var a = 0; a < n.length; a++) {
                var c = n[a];
                Rt = c,
                TI(c, o)
            }
        SI(o)
    }
    for (o = o.child; o !== null; ) {
        switch (n = o,
        n.tag) {
        case 0:
        case 11:
        case 15:
            di(8, n, n.return),
            ah(n);
            break;
        case 22:
            a = n.stateNode,
            a._visibility & 2 && (a._visibility &= -3,
            ah(n));
            break;
        default:
            ah(n)
        }
        o = o.sibling
    }
}
function TI(o, n) {
    for (; Rt !== null; ) {
        var a = Rt;
        switch (a.tag) {
        case 0:
        case 11:
        case 15:
            di(8, a, n);
            break;
        case 23:
        case 22:
            if (a.memoizedState !== null && a.memoizedState.cachePool !== null) {
                var c = a.memoizedState.cachePool.pool;
                c != null && c.refCount++
            }
            break;
        case 24:
            Qc(a.memoizedState.cache)
        }
        if (c = a.child,
        c !== null)
            c.return = a,
            Rt = c;
        else
            e: for (a = o; Rt !== null; ) {
                c = Rt;
                var u = c.sibling
                  , p = c.return;
                if (wI(c),
                c === a) {
                    Rt = null;
                    break e
                }
                if (u !== null) {
                    u.return = p,
                    Rt = u;
                    break e
                }
                Rt = p
            }
    }
}
var mV = {
    getCacheForType: function(o) {
        var n = Yt(Tt)
          , a = n.data.get(o);
        return a === void 0 && (a = o(),
        n.data.set(o, a)),
        a
    },
    cacheSignal: function() {
        return Yt(Tt).controller.signal
    }
}
  , pV = typeof WeakMap == "function" ? WeakMap : Map
  , ze = 0
  , Xe = null
  , Ee = null
  , Ie = 0
  , Ue = 0
  , Bo = null
  , Yn = !1
  , Ha = !1
  , Yb = !1
  , _n = 0
  , kt = 0
  , ui = 0
  , es = 0
  , Qb = 0
  , jo = 0
  , Ma = 0
  , pc = null
  , ko = null
  , bk = !1
  , fm = 0
  , II = 0
  , jh = 1 / 0
  , Lh = null
  , ri = null
  , Pt = 0
  , ni = null
  , Ba = null
  , fn = 0
  , wk = 0
  , Ak = null
  , MI = null
  , gc = 0
  , vk = null;
function Ro() {
    return ze & 2 && Ie !== 0 ? Ie & -Ie : we.T !== null ? Jb() : FD()
}
function BI() {
    if (jo === 0)
        if (!(Ie & 536870912) || Be) {
            var o = Nu;
            Nu <<= 1,
            !(Nu & 3932160) && (Nu = 262144),
            jo = o
        } else
            jo = 536870912;
    return o = Vo.current,
    o !== null && (o.flags |= 32),
    jo
}
function Ao(o, n, a) {
    (o === Xe && (Ue === 2 || Ue === 9) || o.cancelPendingCommit !== null) && (Na(o, 0),
    Qn(o, Ie, jo, !1)),
    Gc(o, a),
    (!(ze & 2) || o !== Xe) && (o === Xe && (!(ze & 2) && (es |= a),
    kt === 4 && Qn(o, Ie, jo, !1)),
    Wr(o))
}
function NI(o, n, a) {
    if (ze & 6)
        throw Error(oe(327));
    var c = !a && (n & 127) === 0 && (n & o.expiredLanes) === 0 || qc(o, n)
      , u = c ? kV(o, n) : cf(o, n, !0)
      , p = c;
    do {
        if (u === 0) {
            Ha && !c && Qn(o, n, 0, !1);
            break
        } else {
            if (a = o.current.alternate,
            p && !gV(a)) {
                u = cf(o, n, !1),
                p = !1;
                continue
            }
            if (u === 2) {
                if (p = n,
                o.errorRecoveryDisabledLanes & p)
                    var f = 0;
                else
                    f = o.pendingLanes & -536870913,
                    f = f !== 0 ? f : f & 536870912 ? 536870912 : 0;
                if (f !== 0) {
                    n = f;
                    e: {
                        var w = o;
                        u = pc;
                        var k = w.current.memoizedState.isDehydrated;
                        if (k && (Na(w, f).flags |= 256),
                        f = cf(w, f, !1),
                        f !== 2) {
                            if (Yb && !k) {
                                w.errorRecoveryDisabledLanes |= p,
                                es |= p,
                                u = 4;
                                break e
                            }
                            p = ko,
                            ko = u,
                            p !== null && (ko === null ? ko = p : ko.push.apply(ko, p))
                        }
                        u = f
                    }
                    if (p = !1,
                    u !== 2)
                        continue
                }
            }
            if (u === 1) {
                Na(o, 0),
                Qn(o, n, 0, !0);
                break
            }
            e: {
                switch (c = o,
                p = u,
                p) {
                case 0:
                case 1:
                    throw Error(oe(345));
                case 4:
                    if ((n & 4194048) !== n)
                        break;
                case 6:
                    Qn(c, n, jo, !Yn);
                    break e;
                case 2:
                    ko = null;
                    break;
                case 3:
                case 5:
                    break;
                default:
                    throw Error(oe(329))
                }
                if ((n & 62914560) === n && (u = fm + 300 - Lo(),
                10 < u)) {
                    if (Qn(c, n, jo, !Yn),
                    im(c, 0, !0) !== 0)
                        break e;
                    fn = n,
                    c.timeoutHandle = XI(bS.bind(null, c, a, ko, Lh, bk, n, jo, es, Ma, Yn, p, "Throttled", -0, 0), u);
                    break e
                }
                bS(c, a, ko, Lh, bk, n, jo, es, Ma, Yn, p, null, -0, 0)
            }
        }
        break
    } while (!0);
    Wr(o)
}
function bS(o, n, a, c, u, p, f, w, k, y, E, S, A, D) {
    if (o.timeoutHandle = -1,
    S = n.subtreeFlags,
    S & 8192 || (S & 16785408) === 16785408) {
        S = {
            stylesheets: null,
            count: 0,
            imgCount: 0,
            imgBytes: 0,
            suspenseyImages: [],
            waitingForImages: !0,
            waitingForViewTransition: !1,
            unsuspend: hn
        },
        EI(n, p, S);
        var N = (p & 62914560) === p ? fm - Lo() : (p & 4194048) === p ? II - Lo() : 0;
        if (N = XV(S, N),
        N !== null) {
            fn = p,
            o.cancelPendingCommit = N(AS.bind(null, o, n, p, a, c, u, f, w, k, E, S, null, A, D)),
            Qn(o, p, f, !y);
            return
        }
    }
    AS(o, n, p, a, c, u, f, w, k)
}
function gV(o) {
    for (var n = o; ; ) {
        var a = n.tag;
        if ((a === 0 || a === 11 || a === 15) && n.flags & 16384 && (a = n.updateQueue,
        a !== null && (a = a.stores,
        a !== null)))
            for (var c = 0; c < a.length; c++) {
                var u = a[c]
                  , p = u.getSnapshot;
                u = u.value;
                try {
                    if (!Fo(p(), u))
                        return !1
                } catch {
                    return !1
                }
            }
        if (a = n.child,
        n.subtreeFlags & 16384 && a !== null)
            a.return = n,
            n = a;
        else {
            if (n === o)
                break;
            for (; n.sibling === null; ) {
                if (n.return === null || n.return === o)
                    return !0;
                n = n.return
            }
            n.sibling.return = n.return,
            n = n.sibling
        }
    }
    return !0
}
function Qn(o, n, a, c) {
    n &= ~Qb,
    n &= ~es,
    o.suspendedLanes |= n,
    o.pingedLanes &= ~n,
    c && (o.warmLanes |= n),
    c = o.expirationTimes;
    for (var u = n; 0 < u; ) {
        var p = 31 - Oo(u)
          , f = 1 << p;
        c[p] = -1,
        u &= ~f
    }
    a !== 0 && zD(o, a, n)
}
function km() {
    return ze & 6 ? !0 : (Xc(0),
    !1)
}
function Zb() {
    if (Ee !== null) {
        if (Ue === 0)
            var o = Ee.return;
        else
            o = Ee,
            mn = hs = null,
            Lb(o),
            va = null,
            Dc = 0,
            o = Ee;
        for (; o !== null; )
            hI(o.alternate, o),
            o = o.return;
        Ee = null
    }
}
function Na(o, n) {
    var a = o.timeoutHandle;
    a !== -1 && (o.timeoutHandle = -1,
    jV(a)),
    a = o.cancelPendingCommit,
    a !== null && (o.cancelPendingCommit = null,
    a()),
    fn = 0,
    Zb(),
    Xe = o,
    Ee = a = pn(o.current, null),
    Ie = n,
    Ue = 0,
    Bo = null,
    Yn = !1,
    Ha = qc(o, n),
    Yb = !1,
    Ma = jo = Qb = es = ui = kt = 0,
    ko = pc = null,
    bk = !1,
    n & 8 && (n |= n & 32);
    var c = o.entangledLanes;
    if (c !== 0)
        for (o = o.entanglements,
        c &= n; 0 < c; ) {
            var u = 31 - Oo(c)
              , p = 1 << u;
            n |= o[u],
            c &= ~p
        }
    return _n = n,
    cm(),
    a
}
function PI(o, n) {
    ve = null,
    we.H = Ic,
    n === Ua || n === um ? (n = QE(),
    Ue = 3) : n === Tb ? (n = QE(),
    Ue = 4) : Ue = n === $b ? 8 : n !== null && typeof n == "object" && typeof n.then == "function" ? 6 : 1,
    Bo = n,
    Ee === null && (kt = 1,
    Bh(o, rr(n, o.current)))
}
function jI() {
    var o = Vo.current;
    return o === null ? !0 : (Ie & 4194048) === Ie ? yr === null : (Ie & 62914560) === Ie || Ie & 536870912 ? o === yr : !1
}
function LI() {
    var o = we.H;
    return we.H = Ic,
    o === null ? Ic : o
}
function zI() {
    var o = we.A;
    return we.A = mV,
    o
}
function zh() {
    kt = 4,
    Yn || (Ie & 4194048) !== Ie && Vo.current !== null || (Ha = !0),
    !(ui & 134217727) && !(es & 134217727) || Xe === null || Qn(Xe, Ie, jo, !1)
}
function cf(o, n, a) {
    var c = ze;
    ze |= 2;
    var u = LI()
      , p = zI();
    (Xe !== o || Ie !== n) && (Lh = null,
    Na(o, n)),
    n = !1;
    var f = kt;
    e: do
        try {
            if (Ue !== 0 && Ee !== null) {
                var w = Ee
                  , k = Bo;
                switch (Ue) {
                case 8:
                    Zb(),
                    f = 6;
                    break e;
                case 3:
                case 2:
                case 9:
                case 6:
                    Vo.current === null && (n = !0);
                    var y = Ue;
                    if (Ue = 0,
                    Bo = null,
                    ua(o, w, k, y),
                    a && Ha) {
                        f = 0;
                        break e
                    }
                    break;
                default:
                    y = Ue,
                    Ue = 0,
                    Bo = null,
                    ua(o, w, k, y)
                }
            }
            fV(),
            f = kt;
            break
        } catch (E) {
            PI(o, E)
        }
    while (!0);
    return n && o.shellSuspendCounter++,
    mn = hs = null,
    ze = c,
    we.H = u,
    we.A = p,
    Ee === null && (Xe = null,
    Ie = 0,
    cm()),
    f
}
function fV() {
    for (; Ee !== null; )
        OI(Ee)
}
function kV(o, n) {
    var a = ze;
    ze |= 2;
    var c = LI()
      , u = zI();
    Xe !== o || Ie !== n ? (Lh = null,
    jh = Lo() + 500,
    Na(o, n)) : Ha = qc(o, n);
    e: do
        try {
            if (Ue !== 0 && Ee !== null) {
                n = Ee;
                var p = Bo;
                t: switch (Ue) {
                case 1:
                    Ue = 0,
                    Bo = null,
                    ua(o, n, p, 1);
                    break;
                case 2:
                case 9:
                    if (YE(p)) {
                        Ue = 0,
                        Bo = null,
                        wS(n);
                        break
                    }
                    n = function() {
                        Ue !== 2 && Ue !== 9 || Xe !== o || (Ue = 7),
                        Wr(o)
                    }
                    ,
                    p.then(n, n);
                    break e;
                case 3:
                    Ue = 7;
                    break e;
                case 4:
                    Ue = 5;
                    break e;
                case 7:
                    YE(p) ? (Ue = 0,
                    Bo = null,
                    wS(n)) : (Ue = 0,
                    Bo = null,
                    ua(o, n, p, 7));
                    break;
                case 5:
                    var f = null;
                    switch (Ee.tag) {
                    case 26:
                        f = Ee.memoizedState;
                    case 5:
                    case 27:
                        var w = Ee;
                        if (f ? nM(f) : w.stateNode.complete) {
                            Ue = 0,
                            Bo = null;
                            var k = w.sibling;
                            if (k !== null)
                                Ee = k;
                            else {
                                var y = w.return;
                                y !== null ? (Ee = y,
                                bm(y)) : Ee = null
                            }
                            break t
                        }
                    }
                    Ue = 0,
                    Bo = null,
                    ua(o, n, p, 5);
                    break;
                case 6:
                    Ue = 0,
                    Bo = null,
                    ua(o, n, p, 6);
                    break;
                case 8:
                    Zb(),
                    kt = 6;
                    break e;
                default:
                    throw Error(oe(462))
                }
            }
            bV();
            break
        } catch (E) {
            PI(o, E)
        }
    while (!0);
    return mn = hs = null,
    we.H = c,
    we.A = u,
    ze = a,
    Ee !== null ? 0 : (Xe = null,
    Ie = 0,
    cm(),
    kt)
}
function bV() {
    for (; Ee !== null && !V7(); )
        OI(Ee)
}
function OI(o) {
    var n = uI(o.alternate, o, _n);
    o.memoizedProps = o.pendingProps,
    n === null ? bm(o) : Ee = n
}
function wS(o) {
    var n = o
      , a = n.alternate;
    switch (n.tag) {
    case 15:
    case 0:
        n = hS(a, n, n.pendingProps, n.type, void 0, Ie);
        break;
    case 11:
        n = hS(a, n, n.pendingProps, n.type.render, n.ref, Ie);
        break;
    case 5:
        Lb(n);
    default:
        hI(a, n),
        n = Ee = hT(n, _n),
        n = uI(a, n, _n)
    }
    o.memoizedProps = o.pendingProps,
    n === null ? bm(o) : Ee = n
}
function ua(o, n, a, c) {
    mn = hs = null,
    Lb(n),
    va = null,
    Dc = 0;
    var u = n.return;
    try {
        if (sV(o, u, n, a, Ie)) {
            kt = 1,
            Bh(o, rr(a, o.current)),
            Ee = null;
            return
        }
    } catch (p) {
        if (u !== null)
            throw Ee = u,
            p;
        kt = 1,
        Bh(o, rr(a, o.current)),
        Ee = null;
        return
    }
    n.flags & 32768 ? (Be || c === 1 ? o = !0 : Ha || Ie & 536870912 ? o = !1 : (Yn = o = !0,
    (c === 2 || c === 9 || c === 3 || c === 6) && (c = Vo.current,
    c !== null && c.tag === 13 && (c.flags |= 16384))),
    RI(n, o)) : bm(n)
}
function bm(o) {
    var n = o;
    do {
        if (n.flags & 32768) {
            RI(n, Yn);
            return
        }
        o = n.return;
        var a = cV(n.alternate, n, _n);
        if (a !== null) {
            Ee = a;
            return
        }
        if (n = n.sibling,
        n !== null) {
            Ee = n;
            return
        }
        Ee = n = o
    } while (n !== null);
    kt === 0 && (kt = 5)
}
function RI(o, n) {
    do {
        var a = dV(o.alternate, o);
        if (a !== null) {
            a.flags &= 32767,
            Ee = a;
            return
        }
        if (a = o.return,
        a !== null && (a.flags |= 32768,
        a.subtreeFlags = 0,
        a.deletions = null),
        !n && (o = o.sibling,
        o !== null)) {
            Ee = o;
            return
        }
        Ee = o = a
    } while (o !== null);
    kt = 6,
    Ee = null
}
function AS(o, n, a, c, u, p, f, w, k) {
    o.cancelPendingCommit = null;
    do
        wm();
    while (Pt !== 0);
    if (ze & 6)
        throw Error(oe(327));
    if (n !== null) {
        if (n === o.current)
            throw Error(oe(177));
        if (p = n.lanes | n.childLanes,
        p |= _b,
        Z7(o, a, p, f, w, k),
        o === Xe && (Ee = Xe = null,
        Ie = 0),
        Ba = n,
        ni = o,
        fn = a,
        wk = p,
        Ak = u,
        MI = c,
        n.subtreeFlags & 10256 || n.flags & 10256 ? (o.callbackNode = null,
        o.callbackPriority = 0,
        _V(vh, function() {
            return WI(),
            null
        })) : (o.callbackNode = null,
        o.callbackPriority = 0),
        c = (n.flags & 13878) !== 0,
        n.subtreeFlags & 13878 || c) {
            c = we.T,
            we.T = null,
            u = Oe.p,
            Oe.p = 2,
            f = ze,
            ze |= 4;
            try {
                uV(o, n, a)
            } finally {
                ze = f,
                Oe.p = u,
                we.T = c
            }
        }
        Pt = 1,
        FI(),
        VI(),
        UI()
    }
}
function FI() {
    if (Pt === 1) {
        Pt = 0;
        var o = ni
          , n = Ba
          , a = (n.flags & 13878) !== 0;
        if (n.subtreeFlags & 13878 || a) {
            a = we.T,
            we.T = null;
            var c = Oe.p;
            Oe.p = 2;
            var u = ze;
            ze |= 4;
            try {
                CI(n, o);
                var p = xk
                  , f = nT(o.containerInfo)
                  , w = p.focusedElem
                  , k = p.selectionRange;
                if (f !== w && w && w.ownerDocument && rT(w.ownerDocument.documentElement, w)) {
                    if (k !== null && vb(w)) {
                        var y = k.start
                          , E = k.end;
                        if (E === void 0 && (E = y),
                        "selectionStart"in w)
                            w.selectionStart = y,
                            w.selectionEnd = Math.min(E, w.value.length);
                        else {
                            var S = w.ownerDocument || document
                              , A = S && S.defaultView || window;
                            if (A.getSelection) {
                                var D = A.getSelection()
                                  , N = w.textContent.length
                                  , L = Math.min(k.start, N)
                                  , z = k.end === void 0 ? L : Math.min(k.end, N);
                                !D.extend && L > z && (f = z,
                                z = L,
                                L = f);
                                var B = UE(w, L)
                                  , M = UE(w, z);
                                if (B && M && (D.rangeCount !== 1 || D.anchorNode !== B.node || D.anchorOffset !== B.offset || D.focusNode !== M.node || D.focusOffset !== M.offset)) {
                                    var j = S.createRange();
                                    j.setStart(B.node, B.offset),
                                    D.removeAllRanges(),
                                    L > z ? (D.addRange(j),
                                    D.extend(M.node, M.offset)) : (j.setEnd(M.node, M.offset),
                                    D.addRange(j))
                                }
                            }
                        }
                    }
                    for (S = [],
                    D = w; D = D.parentNode; )
                        D.nodeType === 1 && S.push({
                            element: D,
                            left: D.scrollLeft,
                            top: D.scrollTop
                        });
                    for (typeof w.focus == "function" && w.focus(),
                    w = 0; w < S.length; w++) {
                        var V = S[w];
                        V.element.scrollLeft = V.left,
                        V.element.scrollTop = V.top
                    }
                }
                $h = !!yk,
                xk = yk = null
            } finally {
                ze = u,
                Oe.p = c,
                we.T = a
            }
        }
        o.current = n,
        Pt = 2
    }
}
function VI() {
    if (Pt === 2) {
        Pt = 0;
        var o = ni
          , n = Ba
          , a = (n.flags & 8772) !== 0;
        if (n.subtreeFlags & 8772 || a) {
            a = we.T,
            we.T = null;
            var c = Oe.p;
            Oe.p = 2;
            var u = ze;
            ze |= 4;
            try {
                bI(o, n.alternate, n)
            } finally {
                ze = u,
                Oe.p = c,
                we.T = a
            }
        }
        Pt = 3
    }
}
function UI() {
    if (Pt === 4 || Pt === 3) {
        Pt = 0,
        U7();
        var o = ni
          , n = Ba
          , a = fn
          , c = MI;
        n.subtreeFlags & 10256 || n.flags & 10256 ? Pt = 5 : (Pt = 0,
        Ba = ni = null,
        HI(o, o.pendingLanes));
        var u = o.pendingLanes;
        if (u === 0 && (ri = null),
        pb(a),
        n = n.stateNode,
        zo && typeof zo.onCommitFiberRoot == "function")
            try {
                zo.onCommitFiberRoot($c, n, void 0, (n.current.flags & 128) === 128)
            } catch {}
        if (c !== null) {
            n = we.T,
            u = Oe.p,
            Oe.p = 2,
            we.T = null;
            try {
                for (var p = o.onRecoverableError, f = 0; f < c.length; f++) {
                    var w = c[f];
                    p(w.value, {
                        componentStack: w.stack
                    })
                }
            } finally {
                we.T = n,
                Oe.p = u
            }
        }
        fn & 3 && wm(),
        Wr(o),
        u = o.pendingLanes,
        a & 261930 && u & 42 ? o === vk ? gc++ : (gc = 0,
        vk = o) : gc = 0,
        Xc(0)
    }
}
function HI(o, n) {
    (o.pooledCacheLanes &= n) === 0 && (n = o.pooledCache,
    n != null && (o.pooledCache = null,
    Qc(n)))
}
function wm() {
    return FI(),
    VI(),
    UI(),
    WI()
}
function WI() {
    if (Pt !== 5)
        return !1;
    var o = ni
      , n = wk;
    wk = 0;
    var a = pb(fn)
      , c = we.T
      , u = Oe.p;
    try {
        Oe.p = 32 > a ? 32 : a,
        we.T = null,
        a = Ak,
        Ak = null;
        var p = ni
          , f = fn;
        if (Pt = 0,
        Ba = ni = null,
        fn = 0,
        ze & 6)
            throw Error(oe(331));
        var w = ze;
        if (ze |= 4,
        DI(p.current),
        xI(p, p.current, f, a),
        ze = w,
        Xc(0, !1),
        zo && typeof zo.onPostCommitFiberRoot == "function")
            try {
                zo.onPostCommitFiberRoot($c, p)
            } catch {}
        return !0
    } finally {
        Oe.p = u,
        we.T = c,
        HI(o, n)
    }
}
function vS(o, n, a) {
    n = rr(a, n),
    n = pk(o.stateNode, n, 2),
    o = oi(o, n, 2),
    o !== null && (Gc(o, 2),
    Wr(o))
}
function He(o, n, a) {
    if (o.tag === 3)
        vS(o, o, a);
    else
        for (; n !== null; ) {
            if (n.tag === 3) {
                vS(n, o, a);
                break
            } else if (n.tag === 1) {
                var c = n.stateNode;
                if (typeof n.type.getDerivedStateFromError == "function" || typeof c.componentDidCatch == "function" && (ri === null || !ri.has(c))) {
                    o = rr(a, o),
                    a = iI(2),
                    c = oi(n, a, 2),
                    c !== null && (sI(a, c, n, o),
                    Gc(c, 2),
                    Wr(c));
                    break
                }
            }
            n = n.return
        }
}
function df(o, n, a) {
    var c = o.pingCache;
    if (c === null) {
        c = o.pingCache = new pV;
        var u = new Set;
        c.set(n, u)
    } else
        u = c.get(n),
        u === void 0 && (u = new Set,
        c.set(n, u));
    u.has(a) || (Yb = !0,
    u.add(a),
    o = wV.bind(null, o, n, a),
    n.then(o, o))
}
function wV(o, n, a) {
    var c = o.pingCache;
    c !== null && c.delete(n),
    o.pingedLanes |= o.suspendedLanes & a,
    o.warmLanes &= ~a,
    Xe === o && (Ie & a) === a && (kt === 4 || kt === 3 && (Ie & 62914560) === Ie && 300 > Lo() - fm ? !(ze & 2) && Na(o, 0) : Qb |= a,
    Ma === Ie && (Ma = 0)),
    Wr(o)
}
function $I(o, n) {
    n === 0 && (n = LD()),
    o = us(o, n),
    o !== null && (Gc(o, n),
    Wr(o))
}
function AV(o) {
    var n = o.memoizedState
      , a = 0;
    n !== null && (a = n.retryLane),
    $I(o, a)
}
function vV(o, n) {
    var a = 0;
    switch (o.tag) {
    case 31:
    case 13:
        var c = o.stateNode
          , u = o.memoizedState;
        u !== null && (a = u.retryLane);
        break;
    case 19:
        c = o.stateNode;
        break;
    case 22:
        c = o.stateNode._retryCache;
        break;
    default:
        throw Error(oe(314))
    }
    c !== null && c.delete(n),
    $I(o, a)
}
function _V(o, n) {
    return hb(o, n)
}
var Oh = null
  , Js = null
  , _k = !1
  , Rh = !1
  , uf = !1
  , Zn = 0;
function Wr(o) {
    o !== Js && o.next === null && (Js === null ? Oh = Js = o : Js = Js.next = o),
    Rh = !0,
    _k || (_k = !0,
    yV())
}
function Xc(o, n) {
    if (!uf && Rh) {
        uf = !0;
        do
            for (var a = !1, c = Oh; c !== null; ) {
                if (o !== 0) {
                    var u = c.pendingLanes;
                    if (u === 0)
                        var p = 0;
                    else {
                        var f = c.suspendedLanes
                          , w = c.pingedLanes;
                        p = (1 << 31 - Oo(42 | o) + 1) - 1,
                        p &= u & ~(f & ~w),
                        p = p & 201326741 ? p & 201326741 | 1 : p ? p | 2 : 0
                    }
                    p !== 0 && (a = !0,
                    _S(c, p))
                } else
                    p = Ie,
                    p = im(c, c === Xe ? p : 0, c.cancelPendingCommit !== null || c.timeoutHandle !== -1),
                    !(p & 3) || qc(c, p) || (a = !0,
                    _S(c, p));
                c = c.next
            }
        while (a);
        uf = !1
    }
}
function CV() {
    qI()
}
function qI() {
    Rh = _k = !1;
    var o = 0;
    Zn !== 0 && PV() && (o = Zn);
    for (var n = Lo(), a = null, c = Oh; c !== null; ) {
        var u = c.next
          , p = GI(c, n);
        p === 0 ? (c.next = null,
        a === null ? Oh = u : a.next = u,
        u === null && (Js = a)) : (a = c,
        (o !== 0 || p & 3) && (Rh = !0)),
        c = u
    }
    Pt !== 0 && Pt !== 5 || Xc(o),
    Zn !== 0 && (Zn = 0)
}
function GI(o, n) {
    for (var a = o.suspendedLanes, c = o.pingedLanes, u = o.expirationTimes, p = o.pendingLanes & -62914561; 0 < p; ) {
        var f = 31 - Oo(p)
          , w = 1 << f
          , k = u[f];
        k === -1 ? (!(w & a) || w & c) && (u[f] = Q7(w, n)) : k <= n && (o.expiredLanes |= w),
        p &= ~w
    }
    if (n = Xe,
    a = Ie,
    a = im(o, o === n ? a : 0, o.cancelPendingCommit !== null || o.timeoutHandle !== -1),
    c = o.callbackNode,
    a === 0 || o === n && (Ue === 2 || Ue === 9) || o.cancelPendingCommit !== null)
        return c !== null && c !== null && Og(c),
        o.callbackNode = null,
        o.callbackPriority = 0;
    if (!(a & 3) || qc(o, a)) {
        if (n = a & -a,
        n === o.callbackPriority)
            return n;
        switch (c !== null && Og(c),
        pb(a)) {
        case 2:
        case 8:
            a = PD;
            break;
        case 32:
            a = vh;
            break;
        case 268435456:
            a = jD;
            break;
        default:
            a = vh
        }
        return c = KI.bind(null, o),
        a = hb(a, c),
        o.callbackPriority = n,
        o.callbackNode = a,
        n
    }
    return c !== null && c !== null && Og(c),
    o.callbackPriority = 2,
    o.callbackNode = null,
    2
}
function KI(o, n) {
    if (Pt !== 0 && Pt !== 5)
        return o.callbackNode = null,
        o.callbackPriority = 0,
        null;
    var a = o.callbackNode;
    if (wm() && o.callbackNode !== a)
        return null;
    var c = Ie;
    return c = im(o, o === Xe ? c : 0, o.cancelPendingCommit !== null || o.timeoutHandle !== -1),
    c === 0 ? null : (NI(o, c, n),
    GI(o, Lo()),
    o.callbackNode != null && o.callbackNode === a ? KI.bind(null, o) : null)
}
function _S(o, n) {
    if (wm())
        return null;
    NI(o, n, !0)
}
function yV() {
    LV(function() {
        ze & 6 ? hb(ND, CV) : qI()
    })
}
function Jb() {
    if (Zn === 0) {
        var o = Da;
        o === 0 && (o = Bu,
        Bu <<= 1,
        !(Bu & 261888) && (Bu = 256)),
        Zn = o
    }
    return Zn
}
function CS(o) {
    return o == null || typeof o == "symbol" || typeof o == "boolean" ? null : typeof o == "function" ? o : Ju("" + o)
}
function yS(o, n) {
    var a = n.ownerDocument.createElement("input");
    return a.name = n.name,
    a.value = n.value,
    o.id && a.setAttribute("form", o.id),
    n.parentNode.insertBefore(a, n),
    o = new FormData(o),
    a.parentNode.removeChild(a),
    o
}
function xV(o, n, a, c, u) {
    if (n === "submit" && a && a.stateNode === u) {
        var p = CS((u[vo] || null).action)
          , f = c.submitter;
        f && (n = (n = f[vo] || null) ? CS(n.formAction) : f.getAttribute("formAction"),
        n !== null && (p = n,
        f = null));
        var w = new sm("action","action",null,c,u);
        o.push({
            event: w,
            listeners: [{
                instance: null,
                listener: function() {
                    if (c.defaultPrevented) {
                        if (Zn !== 0) {
                            var k = f ? yS(u, f) : new FormData(u);
                            hk(a, {
                                pending: !0,
                                data: k,
                                method: u.method,
                                action: p
                            }, null, k)
                        }
                    } else
                        typeof p == "function" && (w.preventDefault(),
                        k = f ? yS(u, f) : new FormData(u),
                        hk(a, {
                            pending: !0,
                            data: k,
                            method: u.method,
                            action: p
                        }, p, k))
                },
                currentTarget: u
            }]
        })
    }
}
for (var hf = 0; hf < ek.length; hf++) {
    var mf = ek[hf]
      , EV = mf.toLowerCase()
      , SV = mf[0].toUpperCase() + mf.slice(1);
    Er(EV, "on" + SV)
}
Er(sT, "onAnimationEnd");
Er(aT, "onAnimationIteration");
Er(lT, "onAnimationStart");
Er("dblclick", "onDoubleClick");
Er("focusin", "onFocus");
Er("focusout", "onBlur");
Er(H9, "onTransitionRun");
Er(W9, "onTransitionStart");
Er($9, "onTransitionCancel");
Er(cT, "onTransitionEnd");
Ea("onMouseEnter", ["mouseout", "mouseover"]);
Ea("onMouseLeave", ["mouseout", "mouseover"]);
Ea("onPointerEnter", ["pointerout", "pointerover"]);
Ea("onPointerLeave", ["pointerout", "pointerover"]);
ls("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
ls("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
ls("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
ls("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
ls("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
ls("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var Mc = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ")
  , DV = new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(Mc));
function YI(o, n) {
    n = (n & 4) !== 0;
    for (var a = 0; a < o.length; a++) {
        var c = o[a]
          , u = c.event;
        c = c.listeners;
        e: {
            var p = void 0;
            if (n)
                for (var f = c.length - 1; 0 <= f; f--) {
                    var w = c[f]
                      , k = w.instance
                      , y = w.currentTarget;
                    if (w = w.listener,
                    k !== p && u.isPropagationStopped())
                        break e;
                    p = w,
                    u.currentTarget = y;
                    try {
                        p(u)
                    } catch (E) {
                        Ch(E)
                    }
                    u.currentTarget = null,
                    p = k
                }
            else
                for (f = 0; f < c.length; f++) {
                    if (w = c[f],
                    k = w.instance,
                    y = w.currentTarget,
                    w = w.listener,
                    k !== p && u.isPropagationStopped())
                        break e;
                    p = w,
                    u.currentTarget = y;
                    try {
                        p(u)
                    } catch (E) {
                        Ch(E)
                    }
                    u.currentTarget = null,
                    p = k
                }
        }
    }
}
function xe(o, n) {
    var a = n[qf];
    a === void 0 && (a = n[qf] = new Set);
    var c = o + "__bubble";
    a.has(c) || (QI(n, o, 2, !1),
    a.add(c))
}
function pf(o, n, a) {
    var c = 0;
    n && (c |= 4),
    QI(a, o, c, n)
}
var Uu = "_reactListening" + Math.random().toString(36).slice(2);
function Xb(o) {
    if (!o[Uu]) {
        o[Uu] = !0,
        VD.forEach(function(a) {
            a !== "selectionchange" && (DV.has(a) || pf(a, !1, o),
            pf(a, !0, o))
        });
        var n = o.nodeType === 9 ? o : o.ownerDocument;
        n === null || n[Uu] || (n[Uu] = !0,
        pf("selectionchange", !1, n))
    }
}
function QI(o, n, a, c) {
    switch (cM(n)) {
    case 2:
        var u = o8;
        break;
    case 8:
        u = r8;
        break;
    default:
        u = rw
    }
    a = u.bind(null, n, a, o),
    u = void 0,
    !Zf || n !== "touchstart" && n !== "touchmove" && n !== "wheel" || (u = !0),
    c ? u !== void 0 ? o.addEventListener(n, a, {
        capture: !0,
        passive: u
    }) : o.addEventListener(n, a, !0) : u !== void 0 ? o.addEventListener(n, a, {
        passive: u
    }) : o.addEventListener(n, a, !1)
}
function gf(o, n, a, c, u) {
    var p = c;
    if (!(n & 1) && !(n & 2) && c !== null)
        e: for (; ; ) {
            if (c === null)
                return;
            var f = c.tag;
            if (f === 3 || f === 4) {
                var w = c.stateNode.containerInfo;
                if (w === u)
                    break;
                if (f === 4)
                    for (f = c.return; f !== null; ) {
                        var k = f.tag;
                        if ((k === 3 || k === 4) && f.stateNode.containerInfo === u)
                            return;
                        f = f.return
                    }
                for (; w !== null; ) {
                    if (f = oa(w),
                    f === null)
                        return;
                    if (k = f.tag,
                    k === 5 || k === 6 || k === 26 || k === 27) {
                        c = p = f;
                        continue e
                    }
                    w = w.parentNode
                }
            }
            c = c.return
        }
    YD(function() {
        var y = p
          , E = kb(a)
          , S = [];
        e: {
            var A = dT.get(o);
            if (A !== void 0) {
                var D = sm
                  , N = o;
                switch (o) {
                case "keypress":
                    if (eh(a) === 0)
                        break e;
                case "keydown":
                case "keyup":
                    D = v9;
                    break;
                case "focusin":
                    N = "focus",
                    D = Hg;
                    break;
                case "focusout":
                    N = "blur",
                    D = Hg;
                    break;
                case "beforeblur":
                case "afterblur":
                    D = Hg;
                    break;
                case "click":
                    if (a.button === 2)
                        break e;
                case "auxclick":
                case "dblclick":
                case "mousedown":
                case "mousemove":
                case "mouseup":
                case "mouseout":
                case "mouseover":
                case "contextmenu":
                    D = BE;
                    break;
                case "drag":
                case "dragend":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "dragstart":
                case "drop":
                    D = c9;
                    break;
                case "touchcancel":
                case "touchend":
                case "touchmove":
                case "touchstart":
                    D = y9;
                    break;
                case sT:
                case aT:
                case lT:
                    D = h9;
                    break;
                case cT:
                    D = E9;
                    break;
                case "scroll":
                case "scrollend":
                    D = a9;
                    break;
                case "wheel":
                    D = D9;
                    break;
                case "copy":
                case "cut":
                case "paste":
                    D = p9;
                    break;
                case "gotpointercapture":
                case "lostpointercapture":
                case "pointercancel":
                case "pointerdown":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "pointerup":
                    D = PE;
                    break;
                case "toggle":
                case "beforetoggle":
                    D = I9
                }
                var L = (n & 4) !== 0
                  , z = !L && (o === "scroll" || o === "scrollend")
                  , B = L ? A !== null ? A + "Capture" : null : A;
                L = [];
                for (var M = y, j; M !== null; ) {
                    var V = M;
                    if (j = V.stateNode,
                    V = V.tag,
                    V !== 5 && V !== 26 && V !== 27 || j === null || B === null || (V = Cc(M, B),
                    V != null && L.push(Bc(M, V, j))),
                    z)
                        break;
                    M = M.return
                }
                0 < L.length && (A = new D(A,N,null,a,E),
                S.push({
                    event: A,
                    listeners: L
                }))
            }
        }
        if (!(n & 7)) {
            e: {
                if (A = o === "mouseover" || o === "pointerover",
                D = o === "mouseout" || o === "pointerout",
                A && a !== Qf && (N = a.relatedTarget || a.fromElement) && (oa(N) || N[Ra]))
                    break e;
                if ((D || A) && (A = E.window === E ? E : (A = E.ownerDocument) ? A.defaultView || A.parentWindow : window,
                D ? (N = a.relatedTarget || a.toElement,
                D = y,
                N = N ? oa(N) : null,
                N !== null && (z = Wc(N),
                L = N.tag,
                N !== z || L !== 5 && L !== 27 && L !== 6) && (N = null)) : (D = null,
                N = y),
                D !== N)) {
                    if (L = BE,
                    V = "onMouseLeave",
                    B = "onMouseEnter",
                    M = "mouse",
                    (o === "pointerout" || o === "pointerover") && (L = PE,
                    V = "onPointerLeave",
                    B = "onPointerEnter",
                    M = "pointer"),
                    z = D == null ? A : Xl(D),
                    j = N == null ? A : Xl(N),
                    A = new L(V,M + "leave",D,a,E),
                    A.target = z,
                    A.relatedTarget = j,
                    V = null,
                    oa(E) === y && (L = new L(B,M + "enter",N,a,E),
                    L.target = j,
                    L.relatedTarget = z,
                    V = L),
                    z = V,
                    D && N)
                        t: {
                            for (L = TV,
                            B = D,
                            M = N,
                            j = 0,
                            V = B; V; V = L(V))
                                j++;
                            V = 0;
                            for (var G = M; G; G = L(G))
                                V++;
                            for (; 0 < j - V; )
                                B = L(B),
                                j--;
                            for (; 0 < V - j; )
                                M = L(M),
                                V--;
                            for (; j--; ) {
                                if (B === M || M !== null && B === M.alternate) {
                                    L = B;
                                    break t
                                }
                                B = L(B),
                                M = L(M)
                            }
                            L = null
                        }
                    else
                        L = null;
                    D !== null && xS(S, A, D, L, !1),
                    N !== null && z !== null && xS(S, z, N, L, !0)
                }
            }
            e: {
                if (A = y ? Xl(y) : window,
                D = A.nodeName && A.nodeName.toLowerCase(),
                D === "select" || D === "input" && A.type === "file")
                    var Y = OE;
                else if (zE(A))
                    if (tT)
                        Y = F9;
                    else {
                        Y = O9;
                        var $ = z9
                    }
                else
                    D = A.nodeName,
                    !D || D.toLowerCase() !== "input" || A.type !== "checkbox" && A.type !== "radio" ? y && fb(y.elementType) && (Y = OE) : Y = R9;
                if (Y && (Y = Y(o, y))) {
                    eT(S, Y, a, E);
                    break e
                }
                $ && $(o, A, y),
                o === "focusout" && y && A.type === "number" && y.memoizedProps.value != null && Yf(A, "number", A.value)
            }
            switch ($ = y ? Xl(y) : window,
            o) {
            case "focusin":
                (zE($) || $.contentEditable === "true") && (ia = $,
                Jf = y,
                sc = null);
                break;
            case "focusout":
                sc = Jf = ia = null;
                break;
            case "mousedown":
                Xf = !0;
                break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
                Xf = !1,
                HE(S, a, E);
                break;
            case "selectionchange":
                if (U9)
                    break;
            case "keydown":
            case "keyup":
                HE(S, a, E)
            }
            var K;
            if (Ab)
                e: {
                    switch (o) {
                    case "compositionstart":
                        var Z = "onCompositionStart";
                        break e;
                    case "compositionend":
                        Z = "onCompositionEnd";
                        break e;
                    case "compositionupdate":
                        Z = "onCompositionUpdate";
                        break e
                    }
                    Z = void 0
                }
            else
                na ? JD(o, a) && (Z = "onCompositionEnd") : o === "keydown" && a.keyCode === 229 && (Z = "onCompositionStart");
            Z && (ZD && a.locale !== "ko" && (na || Z !== "onCompositionStart" ? Z === "onCompositionEnd" && na && (K = QD()) : (Kn = E,
            bb = "value"in Kn ? Kn.value : Kn.textContent,
            na = !0)),
            $ = Fh(y, Z),
            0 < $.length && (Z = new NE(Z,o,null,a,E),
            S.push({
                event: Z,
                listeners: $
            }),
            K ? Z.data = K : (K = XD(a),
            K !== null && (Z.data = K)))),
            (K = B9 ? N9(o, a) : P9(o, a)) && (Z = Fh(y, "onBeforeInput"),
            0 < Z.length && ($ = new NE("onBeforeInput","beforeinput",null,a,E),
            S.push({
                event: $,
                listeners: Z
            }),
            $.data = K)),
            xV(S, o, y, a, E)
        }
        YI(S, n)
    })
}
function Bc(o, n, a) {
    return {
        instance: o,
        listener: n,
        currentTarget: a
    }
}
function Fh(o, n) {
    for (var a = n + "Capture", c = []; o !== null; ) {
        var u = o
          , p = u.stateNode;
        if (u = u.tag,
        u !== 5 && u !== 26 && u !== 27 || p === null || (u = Cc(o, a),
        u != null && c.unshift(Bc(o, u, p)),
        u = Cc(o, n),
        u != null && c.push(Bc(o, u, p))),
        o.tag === 3)
            return c;
        o = o.return
    }
    return []
}
function TV(o) {
    if (o === null)
        return null;
    do
        o = o.return;
    while (o && o.tag !== 5 && o.tag !== 27);
    return o || null
}
function xS(o, n, a, c, u) {
    for (var p = n._reactName, f = []; a !== null && a !== c; ) {
        var w = a
          , k = w.alternate
          , y = w.stateNode;
        if (w = w.tag,
        k !== null && k === c)
            break;
        w !== 5 && w !== 26 && w !== 27 || y === null || (k = y,
        u ? (y = Cc(a, p),
        y != null && f.unshift(Bc(a, y, k))) : u || (y = Cc(a, p),
        y != null && f.push(Bc(a, y, k)))),
        a = a.return
    }
    f.length !== 0 && o.push({
        event: n,
        listeners: f
    })
}
var IV = /\r\n?/g
  , MV = /\u0000|\uFFFD/g;
function ES(o) {
    return (typeof o == "string" ? o : "" + o).replace(IV, `
`).replace(MV, "")
}
function ZI(o, n) {
    return n = ES(n),
    ES(o) === n
}
function Ge(o, n, a, c, u, p) {
    switch (a) {
    case "children":
        typeof c == "string" ? n === "body" || n === "textarea" && c === "" || Sa(o, c) : (typeof c == "number" || typeof c == "bigint") && n !== "body" && Sa(o, "" + c);
        break;
    case "className":
        ju(o, "class", c);
        break;
    case "tabIndex":
        ju(o, "tabindex", c);
        break;
    case "dir":
    case "role":
    case "viewBox":
    case "width":
    case "height":
        ju(o, a, c);
        break;
    case "style":
        KD(o, c, p);
        break;
    case "data":
        if (n !== "object") {
            ju(o, "data", c);
            break
        }
    case "src":
    case "href":
        if (c === "" && (n !== "a" || a !== "href")) {
            o.removeAttribute(a);
            break
        }
        if (c == null || typeof c == "function" || typeof c == "symbol" || typeof c == "boolean") {
            o.removeAttribute(a);
            break
        }
        c = Ju("" + c),
        o.setAttribute(a, c);
        break;
    case "action":
    case "formAction":
        if (typeof c == "function") {
            o.setAttribute(a, "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");
            break
        } else
            typeof p == "function" && (a === "formAction" ? (n !== "input" && Ge(o, n, "name", u.name, u, null),
            Ge(o, n, "formEncType", u.formEncType, u, null),
            Ge(o, n, "formMethod", u.formMethod, u, null),
            Ge(o, n, "formTarget", u.formTarget, u, null)) : (Ge(o, n, "encType", u.encType, u, null),
            Ge(o, n, "method", u.method, u, null),
            Ge(o, n, "target", u.target, u, null)));
        if (c == null || typeof c == "symbol" || typeof c == "boolean") {
            o.removeAttribute(a);
            break
        }
        c = Ju("" + c),
        o.setAttribute(a, c);
        break;
    case "onClick":
        c != null && (o.onclick = hn);
        break;
    case "onScroll":
        c != null && xe("scroll", o);
        break;
    case "onScrollEnd":
        c != null && xe("scrollend", o);
        break;
    case "dangerouslySetInnerHTML":
        if (c != null) {
            if (typeof c != "object" || !("__html"in c))
                throw Error(oe(61));
            if (a = c.__html,
            a != null) {
                if (u.children != null)
                    throw Error(oe(60));
                o.innerHTML = a
            }
        }
        break;
    case "multiple":
        o.multiple = c && typeof c != "function" && typeof c != "symbol";
        break;
    case "muted":
        o.muted = c && typeof c != "function" && typeof c != "symbol";
        break;
    case "suppressContentEditableWarning":
    case "suppressHydrationWarning":
    case "defaultValue":
    case "defaultChecked":
    case "innerHTML":
    case "ref":
        break;
    case "autoFocus":
        break;
    case "xlinkHref":
        if (c == null || typeof c == "function" || typeof c == "boolean" || typeof c == "symbol") {
            o.removeAttribute("xlink:href");
            break
        }
        a = Ju("" + c),
        o.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", a);
        break;
    case "contentEditable":
    case "spellCheck":
    case "draggable":
    case "value":
    case "autoReverse":
    case "externalResourcesRequired":
    case "focusable":
    case "preserveAlpha":
        c != null && typeof c != "function" && typeof c != "symbol" ? o.setAttribute(a, "" + c) : o.removeAttribute(a);
        break;
    case "inert":
    case "allowFullScreen":
    case "async":
    case "autoPlay":
    case "controls":
    case "default":
    case "defer":
    case "disabled":
    case "disablePictureInPicture":
    case "disableRemotePlayback":
    case "formNoValidate":
    case "hidden":
    case "loop":
    case "noModule":
    case "noValidate":
    case "open":
    case "playsInline":
    case "readOnly":
    case "required":
    case "reversed":
    case "scoped":
    case "seamless":
    case "itemScope":
        c && typeof c != "function" && typeof c != "symbol" ? o.setAttribute(a, "") : o.removeAttribute(a);
        break;
    case "capture":
    case "download":
        c === !0 ? o.setAttribute(a, "") : c !== !1 && c != null && typeof c != "function" && typeof c != "symbol" ? o.setAttribute(a, c) : o.removeAttribute(a);
        break;
    case "cols":
    case "rows":
    case "size":
    case "span":
        c != null && typeof c != "function" && typeof c != "symbol" && !isNaN(c) && 1 <= c ? o.setAttribute(a, c) : o.removeAttribute(a);
        break;
    case "rowSpan":
    case "start":
        c == null || typeof c == "function" || typeof c == "symbol" || isNaN(c) ? o.removeAttribute(a) : o.setAttribute(a, c);
        break;
    case "popover":
        xe("beforetoggle", o),
        xe("toggle", o),
        Zu(o, "popover", c);
        break;
    case "xlinkActuate":
        on(o, "http://www.w3.org/1999/xlink", "xlink:actuate", c);
        break;
    case "xlinkArcrole":
        on(o, "http://www.w3.org/1999/xlink", "xlink:arcrole", c);
        break;
    case "xlinkRole":
        on(o, "http://www.w3.org/1999/xlink", "xlink:role", c);
        break;
    case "xlinkShow":
        on(o, "http://www.w3.org/1999/xlink", "xlink:show", c);
        break;
    case "xlinkTitle":
        on(o, "http://www.w3.org/1999/xlink", "xlink:title", c);
        break;
    case "xlinkType":
        on(o, "http://www.w3.org/1999/xlink", "xlink:type", c);
        break;
    case "xmlBase":
        on(o, "http://www.w3.org/XML/1998/namespace", "xml:base", c);
        break;
    case "xmlLang":
        on(o, "http://www.w3.org/XML/1998/namespace", "xml:lang", c);
        break;
    case "xmlSpace":
        on(o, "http://www.w3.org/XML/1998/namespace", "xml:space", c);
        break;
    case "is":
        Zu(o, "is", c);
        break;
    case "innerText":
    case "textContent":
        break;
    default:
        (!(2 < a.length) || a[0] !== "o" && a[0] !== "O" || a[1] !== "n" && a[1] !== "N") && (a = i9.get(a) || a,
        Zu(o, a, c))
    }
}
function Ck(o, n, a, c, u, p) {
    switch (a) {
    case "style":
        KD(o, c, p);
        break;
    case "dangerouslySetInnerHTML":
        if (c != null) {
            if (typeof c != "object" || !("__html"in c))
                throw Error(oe(61));
            if (a = c.__html,
            a != null) {
                if (u.children != null)
                    throw Error(oe(60));
                o.innerHTML = a
            }
        }
        break;
    case "children":
        typeof c == "string" ? Sa(o, c) : (typeof c == "number" || typeof c == "bigint") && Sa(o, "" + c);
        break;
    case "onScroll":
        c != null && xe("scroll", o);
        break;
    case "onScrollEnd":
        c != null && xe("scrollend", o);
        break;
    case "onClick":
        c != null && (o.onclick = hn);
        break;
    case "suppressContentEditableWarning":
    case "suppressHydrationWarning":
    case "innerHTML":
    case "ref":
        break;
    case "innerText":
    case "textContent":
        break;
    default:
        if (!UD.hasOwnProperty(a))
            e: {
                if (a[0] === "o" && a[1] === "n" && (u = a.endsWith("Capture"),
                n = a.slice(2, u ? a.length - 7 : void 0),
                p = o[vo] || null,
                p = p != null ? p[a] : null,
                typeof p == "function" && o.removeEventListener(n, p, u),
                typeof c == "function")) {
                    typeof p != "function" && p !== null && (a in o ? o[a] = null : o.hasAttribute(a) && o.removeAttribute(a)),
                    o.addEventListener(n, c, u);
                    break e
                }
                a in o ? o[a] = c : c === !0 ? o.setAttribute(a, "") : Zu(o, a, c)
            }
    }
}
function Qt(o, n, a) {
    switch (n) {
    case "div":
    case "span":
    case "svg":
    case "path":
    case "a":
    case "g":
    case "p":
    case "li":
        break;
    case "img":
        xe("error", o),
        xe("load", o);
        var c = !1, u = !1, p;
        for (p in a)
            if (a.hasOwnProperty(p)) {
                var f = a[p];
                if (f != null)
                    switch (p) {
                    case "src":
                        c = !0;
                        break;
                    case "srcSet":
                        u = !0;
                        break;
                    case "children":
                    case "dangerouslySetInnerHTML":
                        throw Error(oe(137, n));
                    default:
                        Ge(o, n, p, f, a, null)
                    }
            }
        u && Ge(o, n, "srcSet", a.srcSet, a, null),
        c && Ge(o, n, "src", a.src, a, null);
        return;
    case "input":
        xe("invalid", o);
        var w = p = f = u = null
          , k = null
          , y = null;
        for (c in a)
            if (a.hasOwnProperty(c)) {
                var E = a[c];
                if (E != null)
                    switch (c) {
                    case "name":
                        u = E;
                        break;
                    case "type":
                        f = E;
                        break;
                    case "checked":
                        k = E;
                        break;
                    case "defaultChecked":
                        y = E;
                        break;
                    case "value":
                        p = E;
                        break;
                    case "defaultValue":
                        w = E;
                        break;
                    case "children":
                    case "dangerouslySetInnerHTML":
                        if (E != null)
                            throw Error(oe(137, n));
                        break;
                    default:
                        Ge(o, n, c, E, a, null)
                    }
            }
        $D(o, p, w, k, y, f, u, !1);
        return;
    case "select":
        xe("invalid", o),
        c = f = p = null;
        for (u in a)
            if (a.hasOwnProperty(u) && (w = a[u],
            w != null))
                switch (u) {
                case "value":
                    p = w;
                    break;
                case "defaultValue":
                    f = w;
                    break;
                case "multiple":
                    c = w;
                default:
                    Ge(o, n, u, w, a, null)
                }
        n = p,
        a = f,
        o.multiple = !!c,
        n != null ? ba(o, !!c, n, !1) : a != null && ba(o, !!c, a, !0);
        return;
    case "textarea":
        xe("invalid", o),
        p = u = c = null;
        for (f in a)
            if (a.hasOwnProperty(f) && (w = a[f],
            w != null))
                switch (f) {
                case "value":
                    c = w;
                    break;
                case "defaultValue":
                    u = w;
                    break;
                case "children":
                    p = w;
                    break;
                case "dangerouslySetInnerHTML":
                    if (w != null)
                        throw Error(oe(91));
                    break;
                default:
                    Ge(o, n, f, w, a, null)
                }
        GD(o, c, u, p);
        return;
    case "option":
        for (k in a)
            if (a.hasOwnProperty(k) && (c = a[k],
            c != null))
                switch (k) {
                case "selected":
                    o.selected = c && typeof c != "function" && typeof c != "symbol";
                    break;
                default:
                    Ge(o, n, k, c, a, null)
                }
        return;
    case "dialog":
        xe("beforetoggle", o),
        xe("toggle", o),
        xe("cancel", o),
        xe("close", o);
        break;
    case "iframe":
    case "object":
        xe("load", o);
        break;
    case "video":
    case "audio":
        for (c = 0; c < Mc.length; c++)
            xe(Mc[c], o);
        break;
    case "image":
        xe("error", o),
        xe("load", o);
        break;
    case "details":
        xe("toggle", o);
        break;
    case "embed":
    case "source":
    case "link":
        xe("error", o),
        xe("load", o);
    case "area":
    case "base":
    case "br":
    case "col":
    case "hr":
    case "keygen":
    case "meta":
    case "param":
    case "track":
    case "wbr":
    case "menuitem":
        for (y in a)
            if (a.hasOwnProperty(y) && (c = a[y],
            c != null))
                switch (y) {
                case "children":
                case "dangerouslySetInnerHTML":
                    throw Error(oe(137, n));
                default:
                    Ge(o, n, y, c, a, null)
                }
        return;
    default:
        if (fb(n)) {
            for (E in a)
                a.hasOwnProperty(E) && (c = a[E],
                c !== void 0 && Ck(o, n, E, c, a, void 0));
            return
        }
    }
    for (w in a)
        a.hasOwnProperty(w) && (c = a[w],
        c != null && Ge(o, n, w, c, a, null))
}
function BV(o, n, a, c) {
    switch (n) {
    case "div":
    case "span":
    case "svg":
    case "path":
    case "a":
    case "g":
    case "p":
    case "li":
        break;
    case "input":
        var u = null
          , p = null
          , f = null
          , w = null
          , k = null
          , y = null
          , E = null;
        for (D in a) {
            var S = a[D];
            if (a.hasOwnProperty(D) && S != null)
                switch (D) {
                case "checked":
                    break;
                case "value":
                    break;
                case "defaultValue":
                    k = S;
                default:
                    c.hasOwnProperty(D) || Ge(o, n, D, null, c, S)
                }
        }
        for (var A in c) {
            var D = c[A];
            if (S = a[A],
            c.hasOwnProperty(A) && (D != null || S != null))
                switch (A) {
                case "type":
                    p = D;
                    break;
                case "name":
                    u = D;
                    break;
                case "checked":
                    y = D;
                    break;
                case "defaultChecked":
                    E = D;
                    break;
                case "value":
                    f = D;
                    break;
                case "defaultValue":
                    w = D;
                    break;
                case "children":
                case "dangerouslySetInnerHTML":
                    if (D != null)
                        throw Error(oe(137, n));
                    break;
                default:
                    D !== S && Ge(o, n, A, D, c, S)
                }
        }
        Kf(o, f, w, k, y, E, p, u);
        return;
    case "select":
        D = f = w = A = null;
        for (p in a)
            if (k = a[p],
            a.hasOwnProperty(p) && k != null)
                switch (p) {
                case "value":
                    break;
                case "multiple":
                    D = k;
                default:
                    c.hasOwnProperty(p) || Ge(o, n, p, null, c, k)
                }
        for (u in c)
            if (p = c[u],
            k = a[u],
            c.hasOwnProperty(u) && (p != null || k != null))
                switch (u) {
                case "value":
                    A = p;
                    break;
                case "defaultValue":
                    w = p;
                    break;
                case "multiple":
                    f = p;
                default:
                    p !== k && Ge(o, n, u, p, c, k)
                }
        n = w,
        a = f,
        c = D,
        A != null ? ba(o, !!a, A, !1) : !!c != !!a && (n != null ? ba(o, !!a, n, !0) : ba(o, !!a, a ? [] : "", !1));
        return;
    case "textarea":
        D = A = null;
        for (w in a)
            if (u = a[w],
            a.hasOwnProperty(w) && u != null && !c.hasOwnProperty(w))
                switch (w) {
                case "value":
                    break;
                case "children":
                    break;
                default:
                    Ge(o, n, w, null, c, u)
                }
        for (f in c)
            if (u = c[f],
            p = a[f],
            c.hasOwnProperty(f) && (u != null || p != null))
                switch (f) {
                case "value":
                    A = u;
                    break;
                case "defaultValue":
                    D = u;
                    break;
                case "children":
                    break;
                case "dangerouslySetInnerHTML":
                    if (u != null)
                        throw Error(oe(91));
                    break;
                default:
                    u !== p && Ge(o, n, f, u, c, p)
                }
        qD(o, A, D);
        return;
    case "option":
        for (var N in a)
            if (A = a[N],
            a.hasOwnProperty(N) && A != null && !c.hasOwnProperty(N))
                switch (N) {
                case "selected":
                    o.selected = !1;
                    break;
                default:
                    Ge(o, n, N, null, c, A)
                }
        for (k in c)
            if (A = c[k],
            D = a[k],
            c.hasOwnProperty(k) && A !== D && (A != null || D != null))
                switch (k) {
                case "selected":
                    o.selected = A && typeof A != "function" && typeof A != "symbol";
                    break;
                default:
                    Ge(o, n, k, A, c, D)
                }
        return;
    case "img":
    case "link":
    case "area":
    case "base":
    case "br":
    case "col":
    case "embed":
    case "hr":
    case "keygen":
    case "meta":
    case "param":
    case "source":
    case "track":
    case "wbr":
    case "menuitem":
        for (var L in a)
            A = a[L],
            a.hasOwnProperty(L) && A != null && !c.hasOwnProperty(L) && Ge(o, n, L, null, c, A);
        for (y in c)
            if (A = c[y],
            D = a[y],
            c.hasOwnProperty(y) && A !== D && (A != null || D != null))
                switch (y) {
                case "children":
                case "dangerouslySetInnerHTML":
                    if (A != null)
                        throw Error(oe(137, n));
                    break;
                default:
                    Ge(o, n, y, A, c, D)
                }
        return;
    default:
        if (fb(n)) {
            for (var z in a)
                A = a[z],
                a.hasOwnProperty(z) && A !== void 0 && !c.hasOwnProperty(z) && Ck(o, n, z, void 0, c, A);
            for (E in c)
                A = c[E],
                D = a[E],
                !c.hasOwnProperty(E) || A === D || A === void 0 && D === void 0 || Ck(o, n, E, A, c, D);
            return
        }
    }
    for (var B in a)
        A = a[B],
        a.hasOwnProperty(B) && A != null && !c.hasOwnProperty(B) && Ge(o, n, B, null, c, A);
    for (S in c)
        A = c[S],
        D = a[S],
        !c.hasOwnProperty(S) || A === D || A == null && D == null || Ge(o, n, S, A, c, D)
}
function SS(o) {
    switch (o) {
    case "css":
    case "script":
    case "font":
    case "img":
    case "image":
    case "input":
    case "link":
        return !0;
    default:
        return !1
    }
}
function NV() {
    if (typeof performance.getEntriesByType == "function") {
        for (var o = 0, n = 0, a = performance.getEntriesByType("resource"), c = 0; c < a.length; c++) {
            var u = a[c]
              , p = u.transferSize
              , f = u.initiatorType
              , w = u.duration;
            if (p && w && SS(f)) {
                for (f = 0,
                w = u.responseEnd,
                c += 1; c < a.length; c++) {
                    var k = a[c]
                      , y = k.startTime;
                    if (y > w)
                        break;
                    var E = k.transferSize
                      , S = k.initiatorType;
                    E && SS(S) && (k = k.responseEnd,
                    f += E * (k < w ? 1 : (w - y) / (k - y)))
                }
                if (--c,
                n += 8 * (p + f) / (u.duration / 1e3),
                o++,
                10 < o)
                    break
            }
        }
        if (0 < o)
            return n / o / 1e6
    }
    return navigator.connection && (o = navigator.connection.downlink,
    typeof o == "number") ? o : 5
}
var yk = null
  , xk = null;
function Vh(o) {
    return o.nodeType === 9 ? o : o.ownerDocument
}
function DS(o) {
    switch (o) {
    case "http://www.w3.org/2000/svg":
        return 1;
    case "http://www.w3.org/1998/Math/MathML":
        return 2;
    default:
        return 0
    }
}
function JI(o, n) {
    if (o === 0)
        switch (n) {
        case "svg":
            return 1;
        case "math":
            return 2;
        default:
            return 0
        }
    return o === 1 && n === "foreignObject" ? 0 : o
}
function Ek(o, n) {
    return o === "textarea" || o === "noscript" || typeof n.children == "string" || typeof n.children == "number" || typeof n.children == "bigint" || typeof n.dangerouslySetInnerHTML == "object" && n.dangerouslySetInnerHTML !== null && n.dangerouslySetInnerHTML.__html != null
}
var ff = null;
function PV() {
    var o = window.event;
    return o && o.type === "popstate" ? o === ff ? !1 : (ff = o,
    !0) : (ff = null,
    !1)
}
var XI = typeof setTimeout == "function" ? setTimeout : void 0
  , jV = typeof clearTimeout == "function" ? clearTimeout : void 0
  , TS = typeof Promise == "function" ? Promise : void 0
  , LV = typeof queueMicrotask == "function" ? queueMicrotask : typeof TS < "u" ? function(o) {
    return TS.resolve(null).then(o).catch(zV)
}
: XI;
function zV(o) {
    setTimeout(function() {
        throw o
    })
}
function gi(o) {
    return o === "head"
}
function IS(o, n) {
    var a = n
      , c = 0;
    do {
        var u = a.nextSibling;
        if (o.removeChild(a),
        u && u.nodeType === 8)
            if (a = u.data,
            a === "/$" || a === "/&") {
                if (c === 0) {
                    o.removeChild(u),
                    ja(n);
                    return
                }
                c--
            } else if (a === "$" || a === "$?" || a === "$~" || a === "$!" || a === "&")
                c++;
            else if (a === "html")
                fc(o.ownerDocument.documentElement);
            else if (a === "head") {
                a = o.ownerDocument.head,
                fc(a);
                for (var p = a.firstChild; p; ) {
                    var f = p.nextSibling
                      , w = p.nodeName;
                    p[Kc] || w === "SCRIPT" || w === "STYLE" || w === "LINK" && p.rel.toLowerCase() === "stylesheet" || a.removeChild(p),
                    p = f
                }
            } else
                a === "body" && fc(o.ownerDocument.body);
        a = u
    } while (a);
    ja(n)
}
function MS(o, n) {
    var a = o;
    o = 0;
    do {
        var c = a.nextSibling;
        if (a.nodeType === 1 ? n ? (a._stashedDisplay = a.style.display,
        a.style.display = "none") : (a.style.display = a._stashedDisplay || "",
        a.getAttribute("style") === "" && a.removeAttribute("style")) : a.nodeType === 3 && (n ? (a._stashedText = a.nodeValue,
        a.nodeValue = "") : a.nodeValue = a._stashedText || ""),
        c && c.nodeType === 8)
            if (a = c.data,
            a === "/$") {
                if (o === 0)
                    break;
                o--
            } else
                a !== "$" && a !== "$?" && a !== "$~" && a !== "$!" || o++;
        a = c
    } while (a)
}
function Sk(o) {
    var n = o.firstChild;
    for (n && n.nodeType === 10 && (n = n.nextSibling); n; ) {
        var a = n;
        switch (n = n.nextSibling,
        a.nodeName) {
        case "HTML":
        case "HEAD":
        case "BODY":
            Sk(a),
            gb(a);
            continue;
        case "SCRIPT":
        case "STYLE":
            continue;
        case "LINK":
            if (a.rel.toLowerCase() === "stylesheet")
                continue
        }
        o.removeChild(a)
    }
}
function OV(o, n, a, c) {
    for (; o.nodeType === 1; ) {
        var u = a;
        if (o.nodeName.toLowerCase() !== n.toLowerCase()) {
            if (!c && (o.nodeName !== "INPUT" || o.type !== "hidden"))
                break
        } else if (c) {
            if (!o[Kc])
                switch (n) {
                case "meta":
                    if (!o.hasAttribute("itemprop"))
                        break;
                    return o;
                case "link":
                    if (p = o.getAttribute("rel"),
                    p === "stylesheet" && o.hasAttribute("data-precedence") || p !== u.rel || o.getAttribute("href") !== (u.href == null || u.href === "" ? null : u.href) || o.getAttribute("crossorigin") !== (u.crossOrigin == null ? null : u.crossOrigin) || o.getAttribute("title") !== (u.title == null ? null : u.title))
                        break;
                    return o;
                case "style":
                    if (o.hasAttribute("data-precedence"))
                        break;
                    return o;
                case "script":
                    if (p = o.getAttribute("src"),
                    (p !== (u.src == null ? null : u.src) || o.getAttribute("type") !== (u.type == null ? null : u.type) || o.getAttribute("crossorigin") !== (u.crossOrigin == null ? null : u.crossOrigin)) && p && o.hasAttribute("async") && !o.hasAttribute("itemprop"))
                        break;
                    return o;
                default:
                    return o
                }
        } else if (n === "input" && o.type === "hidden") {
            var p = u.name == null ? null : "" + u.name;
            if (u.type === "hidden" && o.getAttribute("name") === p)
                return o
        } else
            return o;
        if (o = sr(o.nextSibling),
        o === null)
            break
    }
    return null
}
function RV(o, n, a) {
    if (n === "")
        return null;
    for (; o.nodeType !== 3; )
        if ((o.nodeType !== 1 || o.nodeName !== "INPUT" || o.type !== "hidden") && !a || (o = sr(o.nextSibling),
        o === null))
            return null;
    return o
}
function eM(o, n) {
    for (; o.nodeType !== 8; )
        if ((o.nodeType !== 1 || o.nodeName !== "INPUT" || o.type !== "hidden") && !n || (o = sr(o.nextSibling),
        o === null))
            return null;
    return o
}
function Dk(o) {
    return o.data === "$?" || o.data === "$~"
}
function Tk(o) {
    return o.data === "$!" || o.data === "$?" && o.ownerDocument.readyState !== "loading"
}
function FV(o, n) {
    var a = o.ownerDocument;
    if (o.data === "$~")
        o._reactRetry = n;
    else if (o.data !== "$?" || a.readyState !== "loading")
        n();
    else {
        var c = function() {
            n(),
            a.removeEventListener("DOMContentLoaded", c)
        };
        a.addEventListener("DOMContentLoaded", c),
        o._reactRetry = c
    }
}
function sr(o) {
    for (; o != null; o = o.nextSibling) {
        var n = o.nodeType;
        if (n === 1 || n === 3)
            break;
        if (n === 8) {
            if (n = o.data,
            n === "$" || n === "$!" || n === "$?" || n === "$~" || n === "&" || n === "F!" || n === "F")
                break;
            if (n === "/$" || n === "/&")
                return null
        }
    }
    return o
}
var Ik = null;
function BS(o) {
    o = o.nextSibling;
    for (var n = 0; o; ) {
        if (o.nodeType === 8) {
            var a = o.data;
            if (a === "/$" || a === "/&") {
                if (n === 0)
                    return sr(o.nextSibling);
                n--
            } else
                a !== "$" && a !== "$!" && a !== "$?" && a !== "$~" && a !== "&" || n++
        }
        o = o.nextSibling
    }
    return null
}
function NS(o) {
    o = o.previousSibling;
    for (var n = 0; o; ) {
        if (o.nodeType === 8) {
            var a = o.data;
            if (a === "$" || a === "$!" || a === "$?" || a === "$~" || a === "&") {
                if (n === 0)
                    return o;
                n--
            } else
                a !== "/$" && a !== "/&" || n++
        }
        o = o.previousSibling
    }
    return null
}
function tM(o, n, a) {
    switch (n = Vh(a),
    o) {
    case "html":
        if (o = n.documentElement,
        !o)
            throw Error(oe(452));
        return o;
    case "head":
        if (o = n.head,
        !o)
            throw Error(oe(453));
        return o;
    case "body":
        if (o = n.body,
        !o)
            throw Error(oe(454));
        return o;
    default:
        throw Error(oe(451))
    }
}
function fc(o) {
    for (var n = o.attributes; n.length; )
        o.removeAttributeNode(n[0]);
    gb(o)
}
var lr = new Map
  , PS = new Set;
function Uh(o) {
    return typeof o.getRootNode == "function" ? o.getRootNode() : o.nodeType === 9 ? o : o.ownerDocument
}
var En = Oe.d;
Oe.d = {
    f: VV,
    r: UV,
    D: HV,
    C: WV,
    L: $V,
    m: qV,
    X: KV,
    S: GV,
    M: YV
};
function VV() {
    var o = En.f()
      , n = km();
    return o || n
}
function UV(o) {
    var n = Fa(o);
    n !== null && n.tag === 5 && n.type === "form" ? KT(n) : En.r(o)
}
var Wa = typeof document > "u" ? null : document;
function oM(o, n, a) {
    var c = Wa;
    if (c && typeof n == "string" && n) {
        var u = Cr(n);
        u = 'link[rel="' + o + '"][href="' + u + '"]',
        typeof a == "string" && (u += '[crossorigin="' + a + '"]'),
        PS.has(u) || (PS.add(u),
        o = {
            rel: o,
            crossOrigin: a,
            href: n
        },
        c.querySelector(u) === null && (n = c.createElement("link"),
        Qt(n, "link", o),
        Ft(n),
        c.head.appendChild(n)))
    }
}
function HV(o) {
    En.D(o),
    oM("dns-prefetch", o, null)
}
function WV(o, n) {
    En.C(o, n),
    oM("preconnect", o, n)
}
function $V(o, n, a) {
    En.L(o, n, a);
    var c = Wa;
    if (c && o && n) {
        var u = 'link[rel="preload"][as="' + Cr(n) + '"]';
        n === "image" && a && a.imageSrcSet ? (u += '[imagesrcset="' + Cr(a.imageSrcSet) + '"]',
        typeof a.imageSizes == "string" && (u += '[imagesizes="' + Cr(a.imageSizes) + '"]')) : u += '[href="' + Cr(o) + '"]';
        var p = u;
        switch (n) {
        case "style":
            p = Pa(o);
            break;
        case "script":
            p = $a(o)
        }
        lr.has(p) || (o = st({
            rel: "preload",
            href: n === "image" && a && a.imageSrcSet ? void 0 : o,
            as: n
        }, a),
        lr.set(p, o),
        c.querySelector(u) !== null || n === "style" && c.querySelector(ed(p)) || n === "script" && c.querySelector(td(p)) || (n = c.createElement("link"),
        Qt(n, "link", o),
        Ft(n),
        c.head.appendChild(n)))
    }
}
function qV(o, n) {
    En.m(o, n);
    var a = Wa;
    if (a && o) {
        var c = n && typeof n.as == "string" ? n.as : "script"
          , u = 'link[rel="modulepreload"][as="' + Cr(c) + '"][href="' + Cr(o) + '"]'
          , p = u;
        switch (c) {
        case "audioworklet":
        case "paintworklet":
        case "serviceworker":
        case "sharedworker":
        case "worker":
        case "script":
            p = $a(o)
        }
        if (!lr.has(p) && (o = st({
            rel: "modulepreload",
            href: o
        }, n),
        lr.set(p, o),
        a.querySelector(u) === null)) {
            switch (c) {
            case "audioworklet":
            case "paintworklet":
            case "serviceworker":
            case "sharedworker":
            case "worker":
            case "script":
                if (a.querySelector(td(p)))
                    return
            }
            c = a.createElement("link"),
            Qt(c, "link", o),
            Ft(c),
            a.head.appendChild(c)
        }
    }
}
function GV(o, n, a) {
    En.S(o, n, a);
    var c = Wa;
    if (c && o) {
        var u = ka(c).hoistableStyles
          , p = Pa(o);
        n = n || "default";
        var f = u.get(p);
        if (!f) {
            var w = {
                loading: 0,
                preload: null
            };
            if (f = c.querySelector(ed(p)))
                w.loading = 5;
            else {
                o = st({
                    rel: "stylesheet",
                    href: o,
                    "data-precedence": n
                }, a),
                (a = lr.get(p)) && ew(o, a);
                var k = f = c.createElement("link");
                Ft(k),
                Qt(k, "link", o),
                k._p = new Promise(function(y, E) {
                    k.onload = y,
                    k.onerror = E
                }
                ),
                k.addEventListener("load", function() {
                    w.loading |= 1
                }),
                k.addEventListener("error", function() {
                    w.loading |= 2
                }),
                w.loading |= 4,
                lh(f, n, c)
            }
            f = {
                type: "stylesheet",
                instance: f,
                count: 1,
                state: w
            },
            u.set(p, f)
        }
    }
}
function KV(o, n) {
    En.X(o, n);
    var a = Wa;
    if (a && o) {
        var c = ka(a).hoistableScripts
          , u = $a(o)
          , p = c.get(u);
        p || (p = a.querySelector(td(u)),
        p || (o = st({
            src: o,
            async: !0
        }, n),
        (n = lr.get(u)) && tw(o, n),
        p = a.createElement("script"),
        Ft(p),
        Qt(p, "link", o),
        a.head.appendChild(p)),
        p = {
            type: "script",
            instance: p,
            count: 1,
            state: null
        },
        c.set(u, p))
    }
}
function YV(o, n) {
    En.M(o, n);
    var a = Wa;
    if (a && o) {
        var c = ka(a).hoistableScripts
          , u = $a(o)
          , p = c.get(u);
        p || (p = a.querySelector(td(u)),
        p || (o = st({
            src: o,
            async: !0,
            type: "module"
        }, n),
        (n = lr.get(u)) && tw(o, n),
        p = a.createElement("script"),
        Ft(p),
        Qt(p, "link", o),
        a.head.appendChild(p)),
        p = {
            type: "script",
            instance: p,
            count: 1,
            state: null
        },
        c.set(u, p))
    }
}
function jS(o, n, a, c) {
    var u = (u = Xn.current) ? Uh(u) : null;
    if (!u)
        throw Error(oe(446));
    switch (o) {
    case "meta":
    case "title":
        return null;
    case "style":
        return typeof a.precedence == "string" && typeof a.href == "string" ? (n = Pa(a.href),
        a = ka(u).hoistableStyles,
        c = a.get(n),
        c || (c = {
            type: "style",
            instance: null,
            count: 0,
            state: null
        },
        a.set(n, c)),
        c) : {
            type: "void",
            instance: null,
            count: 0,
            state: null
        };
    case "link":
        if (a.rel === "stylesheet" && typeof a.href == "string" && typeof a.precedence == "string") {
            o = Pa(a.href);
            var p = ka(u).hoistableStyles
              , f = p.get(o);
            if (f || (u = u.ownerDocument || u,
            f = {
                type: "stylesheet",
                instance: null,
                count: 0,
                state: {
                    loading: 0,
                    preload: null
                }
            },
            p.set(o, f),
            (p = u.querySelector(ed(o))) && !p._p && (f.instance = p,
            f.state.loading = 5),
            lr.has(o) || (a = {
                rel: "preload",
                as: "style",
                href: a.href,
                crossOrigin: a.crossOrigin,
                integrity: a.integrity,
                media: a.media,
                hrefLang: a.hrefLang,
                referrerPolicy: a.referrerPolicy
            },
            lr.set(o, a),
            p || QV(u, o, a, f.state))),
            n && c === null)
                throw Error(oe(528, ""));
            return f
        }
        if (n && c !== null)
            throw Error(oe(529, ""));
        return null;
    case "script":
        return n = a.async,
        a = a.src,
        typeof a == "string" && n && typeof n != "function" && typeof n != "symbol" ? (n = $a(a),
        a = ka(u).hoistableScripts,
        c = a.get(n),
        c || (c = {
            type: "script",
            instance: null,
            count: 0,
            state: null
        },
        a.set(n, c)),
        c) : {
            type: "void",
            instance: null,
            count: 0,
            state: null
        };
    default:
        throw Error(oe(444, o))
    }
}
function Pa(o) {
    return 'href="' + Cr(o) + '"'
}
function ed(o) {
    return 'link[rel="stylesheet"][' + o + "]"
}
function rM(o) {
    return st({}, o, {
        "data-precedence": o.precedence,
        precedence: null
    })
}
function QV(o, n, a, c) {
    o.querySelector('link[rel="preload"][as="style"][' + n + "]") ? c.loading = 1 : (n = o.createElement("link"),
    c.preload = n,
    n.addEventListener("load", function() {
        return c.loading |= 1
    }),
    n.addEventListener("error", function() {
        return c.loading |= 2
    }),
    Qt(n, "link", a),
    Ft(n),
    o.head.appendChild(n))
}
function $a(o) {
    return '[src="' + Cr(o) + '"]'
}
function td(o) {
    return "script[async]" + o
}
function LS(o, n, a) {
    if (n.count++,
    n.instance === null)
        switch (n.type) {
        case "style":
            var c = o.querySelector('style[data-href~="' + Cr(a.href) + '"]');
            if (c)
                return n.instance = c,
                Ft(c),
                c;
            var u = st({}, a, {
                "data-href": a.href,
                "data-precedence": a.precedence,
                href: null,
                precedence: null
            });
            return c = (o.ownerDocument || o).createElement("style"),
            Ft(c),
            Qt(c, "style", u),
            lh(c, a.precedence, o),
            n.instance = c;
        case "stylesheet":
            u = Pa(a.href);
            var p = o.querySelector(ed(u));
            if (p)
                return n.state.loading |= 4,
                n.instance = p,
                Ft(p),
                p;
            c = rM(a),
            (u = lr.get(u)) && ew(c, u),
            p = (o.ownerDocument || o).createElement("link"),
            Ft(p);
            var f = p;
            return f._p = new Promise(function(w, k) {
                f.onload = w,
                f.onerror = k
            }
            ),
            Qt(p, "link", c),
            n.state.loading |= 4,
            lh(p, a.precedence, o),
            n.instance = p;
        case "script":
            return p = $a(a.src),
            (u = o.querySelector(td(p))) ? (n.instance = u,
            Ft(u),
            u) : (c = a,
            (u = lr.get(p)) && (c = st({}, a),
            tw(c, u)),
            o = o.ownerDocument || o,
            u = o.createElement("script"),
            Ft(u),
            Qt(u, "link", c),
            o.head.appendChild(u),
            n.instance = u);
        case "void":
            return null;
        default:
            throw Error(oe(443, n.type))
        }
    else
        n.type === "stylesheet" && !(n.state.loading & 4) && (c = n.instance,
        n.state.loading |= 4,
        lh(c, a.precedence, o));
    return n.instance
}
function lh(o, n, a) {
    for (var c = a.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'), u = c.length ? c[c.length - 1] : null, p = u, f = 0; f < c.length; f++) {
        var w = c[f];
        if (w.dataset.precedence === n)
            p = w;
        else if (p !== u)
            break
    }
    p ? p.parentNode.insertBefore(o, p.nextSibling) : (n = a.nodeType === 9 ? a.head : a,
    n.insertBefore(o, n.firstChild))
}
function ew(o, n) {
    o.crossOrigin == null && (o.crossOrigin = n.crossOrigin),
    o.referrerPolicy == null && (o.referrerPolicy = n.referrerPolicy),
    o.title == null && (o.title = n.title)
}
function tw(o, n) {
    o.crossOrigin == null && (o.crossOrigin = n.crossOrigin),
    o.referrerPolicy == null && (o.referrerPolicy = n.referrerPolicy),
    o.integrity == null && (o.integrity = n.integrity)
}
var ch = null;
function zS(o, n, a) {
    if (ch === null) {
        var c = new Map
          , u = ch = new Map;
        u.set(a, c)
    } else
        u = ch,
        c = u.get(a),
        c || (c = new Map,
        u.set(a, c));
    if (c.has(o))
        return c;
    for (c.set(o, null),
    a = a.getElementsByTagName(o),
    u = 0; u < a.length; u++) {
        var p = a[u];
        if (!(p[Kc] || p[Gt] || o === "link" && p.getAttribute("rel") === "stylesheet") && p.namespaceURI !== "http://www.w3.org/2000/svg") {
            var f = p.getAttribute(n) || "";
            f = o + f;
            var w = c.get(f);
            w ? w.push(p) : c.set(f, [p])
        }
    }
    return c
}
function OS(o, n, a) {
    o = o.ownerDocument || o,
    o.head.insertBefore(a, n === "title" ? o.querySelector("head > title") : null)
}
function ZV(o, n, a) {
    if (a === 1 || n.itemProp != null)
        return !1;
    switch (o) {
    case "meta":
    case "title":
        return !0;
    case "style":
        if (typeof n.precedence != "string" || typeof n.href != "string" || n.href === "")
            break;
        return !0;
    case "link":
        if (typeof n.rel != "string" || typeof n.href != "string" || n.href === "" || n.onLoad || n.onError)
            break;
        switch (n.rel) {
        case "stylesheet":
            return o = n.disabled,
            typeof n.precedence == "string" && o == null;
        default:
            return !0
        }
    case "script":
        if (n.async && typeof n.async != "function" && typeof n.async != "symbol" && !n.onLoad && !n.onError && n.src && typeof n.src == "string")
            return !0
    }
    return !1
}
function nM(o) {
    return !(o.type === "stylesheet" && !(o.state.loading & 3))
}
function JV(o, n, a, c) {
    if (a.type === "stylesheet" && (typeof c.media != "string" || matchMedia(c.media).matches !== !1) && !(a.state.loading & 4)) {
        if (a.instance === null) {
            var u = Pa(c.href)
              , p = n.querySelector(ed(u));
            if (p) {
                n = p._p,
                n !== null && typeof n == "object" && typeof n.then == "function" && (o.count++,
                o = Hh.bind(o),
                n.then(o, o)),
                a.state.loading |= 4,
                a.instance = p,
                Ft(p);
                return
            }
            p = n.ownerDocument || n,
            c = rM(c),
            (u = lr.get(u)) && ew(c, u),
            p = p.createElement("link"),
            Ft(p);
            var f = p;
            f._p = new Promise(function(w, k) {
                f.onload = w,
                f.onerror = k
            }
            ),
            Qt(p, "link", c),
            a.instance = p
        }
        o.stylesheets === null && (o.stylesheets = new Map),
        o.stylesheets.set(a, n),
        (n = a.state.preload) && !(a.state.loading & 3) && (o.count++,
        a = Hh.bind(o),
        n.addEventListener("load", a),
        n.addEventListener("error", a))
    }
}
var kf = 0;
function XV(o, n) {
    return o.stylesheets && o.count === 0 && dh(o, o.stylesheets),
    0 < o.count || 0 < o.imgCount ? function(a) {
        var c = setTimeout(function() {
            if (o.stylesheets && dh(o, o.stylesheets),
            o.unsuspend) {
                var p = o.unsuspend;
                o.unsuspend = null,
                p()
            }
        }, 6e4 + n);
        0 < o.imgBytes && kf === 0 && (kf = 62500 * NV());
        var u = setTimeout(function() {
            if (o.waitingForImages = !1,
            o.count === 0 && (o.stylesheets && dh(o, o.stylesheets),
            o.unsuspend)) {
                var p = o.unsuspend;
                o.unsuspend = null,
                p()
            }
        }, (o.imgBytes > kf ? 50 : 800) + n);
        return o.unsuspend = a,
        function() {
            o.unsuspend = null,
            clearTimeout(c),
            clearTimeout(u)
        }
    }
    : null
}
function Hh() {
    if (this.count--,
    this.count === 0 && (this.imgCount === 0 || !this.waitingForImages)) {
        if (this.stylesheets)
            dh(this, this.stylesheets);
        else if (this.unsuspend) {
            var o = this.unsuspend;
            this.unsuspend = null,
            o()
        }
    }
}
var Wh = null;
function dh(o, n) {
    o.stylesheets = null,
    o.unsuspend !== null && (o.count++,
    Wh = new Map,
    n.forEach(e8, o),
    Wh = null,
    Hh.call(o))
}
function e8(o, n) {
    if (!(n.state.loading & 4)) {
        var a = Wh.get(o);
        if (a)
            var c = a.get(null);
        else {
            a = new Map,
            Wh.set(o, a);
            for (var u = o.querySelectorAll("link[data-precedence],style[data-precedence]"), p = 0; p < u.length; p++) {
                var f = u[p];
                (f.nodeName === "LINK" || f.getAttribute("media") !== "not all") && (a.set(f.dataset.precedence, f),
                c = f)
            }
            c && a.set(null, c)
        }
        u = n.instance,
        f = u.getAttribute("data-precedence"),
        p = a.get(f) || c,
        p === c && a.set(null, u),
        a.set(f, u),
        this.count++,
        c = Hh.bind(this),
        u.addEventListener("load", c),
        u.addEventListener("error", c),
        p ? p.parentNode.insertBefore(u, p.nextSibling) : (o = o.nodeType === 9 ? o.head : o,
        o.insertBefore(u, o.firstChild)),
        n.state.loading |= 4
    }
}
var Nc = {
    $$typeof: un,
    Provider: null,
    Consumer: null,
    _currentValue: Qi,
    _currentValue2: Qi,
    _threadCount: 0
};
function t8(o, n, a, c, u, p, f, w, k) {
    this.tag = 1,
    this.containerInfo = o,
    this.pingCache = this.current = this.pendingChildren = null,
    this.timeoutHandle = -1,
    this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null,
    this.callbackPriority = 0,
    this.expirationTimes = Rg(-1),
    this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
    this.entanglements = Rg(0),
    this.hiddenUpdates = Rg(null),
    this.identifierPrefix = c,
    this.onUncaughtError = u,
    this.onCaughtError = p,
    this.onRecoverableError = f,
    this.pooledCache = null,
    this.pooledCacheLanes = 0,
    this.formState = k,
    this.incompleteTransitions = new Map
}
function iM(o, n, a, c, u, p, f, w, k, y, E, S) {
    return o = new t8(o,n,a,f,k,y,E,S,w),
    n = 1,
    p === !0 && (n |= 24),
    p = Po(3, null, null, n),
    o.current = p,
    p.stateNode = o,
    n = Sb(),
    n.refCount++,
    o.pooledCache = n,
    n.refCount++,
    p.memoizedState = {
        element: c,
        isDehydrated: a,
        cache: n
    },
    Ib(p),
    o
}
function sM(o) {
    return o ? (o = la,
    o) : la
}
function aM(o, n, a, c, u, p) {
    u = sM(u),
    c.context === null ? c.context = u : c.pendingContext = u,
    c = ti(n),
    c.payload = {
        element: a
    },
    p = p === void 0 ? null : p,
    p !== null && (c.callback = p),
    a = oi(o, c, n),
    a !== null && (Ao(a, o, n),
    lc(a, o, n))
}
function RS(o, n) {
    if (o = o.memoizedState,
    o !== null && o.dehydrated !== null) {
        var a = o.retryLane;
        o.retryLane = a !== 0 && a < n ? a : n
    }
}
function ow(o, n) {
    RS(o, n),
    (o = o.alternate) && RS(o, n)
}
function lM(o) {
    if (o.tag === 13 || o.tag === 31) {
        var n = us(o, 67108864);
        n !== null && Ao(n, o, 67108864),
        ow(o, 67108864)
    }
}
function FS(o) {
    if (o.tag === 13 || o.tag === 31) {
        var n = Ro();
        n = mb(n);
        var a = us(o, n);
        a !== null && Ao(a, o, n),
        ow(o, n)
    }
}
var $h = !0;
function o8(o, n, a, c) {
    var u = we.T;
    we.T = null;
    var p = Oe.p;
    try {
        Oe.p = 2,
        rw(o, n, a, c)
    } finally {
        Oe.p = p,
        we.T = u
    }
}
function r8(o, n, a, c) {
    var u = we.T;
    we.T = null;
    var p = Oe.p;
    try {
        Oe.p = 8,
        rw(o, n, a, c)
    } finally {
        Oe.p = p,
        we.T = u
    }
}
function rw(o, n, a, c) {
    if ($h) {
        var u = Mk(c);
        if (u === null)
            gf(o, n, c, qh, a),
            VS(o, c);
        else if (i8(u, o, n, a, c))
            c.stopPropagation();
        else if (VS(o, c),
        n & 4 && -1 < n8.indexOf(o)) {
            for (; u !== null; ) {
                var p = Fa(u);
                if (p !== null)
                    switch (p.tag) {
                    case 3:
                        if (p = p.stateNode,
                        p.current.memoizedState.isDehydrated) {
                            var f = Wi(p.pendingLanes);
                            if (f !== 0) {
                                var w = p;
                                for (w.pendingLanes |= 2,
                                w.entangledLanes |= 2; f; ) {
                                    var k = 1 << 31 - Oo(f);
                                    w.entanglements[1] |= k,
                                    f &= ~k
                                }
                                Wr(p),
                                !(ze & 6) && (jh = Lo() + 500,
                                Xc(0))
                            }
                        }
                        break;
                    case 31:
                    case 13:
                        w = us(p, 2),
                        w !== null && Ao(w, p, 2),
                        km(),
                        ow(p, 2)
                    }
                if (p = Mk(c),
                p === null && gf(o, n, c, qh, a),
                p === u)
                    break;
                u = p
            }
            u !== null && c.stopPropagation()
        } else
            gf(o, n, c, null, a)
    }
}
function Mk(o) {
    return o = kb(o),
    nw(o)
}
var qh = null;
function nw(o) {
    if (qh = null,
    o = oa(o),
    o !== null) {
        var n = Wc(o);
        if (n === null)
            o = null;
        else {
            var a = n.tag;
            if (a === 13) {
                if (o = DD(n),
                o !== null)
                    return o;
                o = null
            } else if (a === 31) {
                if (o = TD(n),
                o !== null)
                    return o;
                o = null
            } else if (a === 3) {
                if (n.stateNode.current.memoizedState.isDehydrated)
                    return n.tag === 3 ? n.stateNode.containerInfo : null;
                o = null
            } else
                n !== o && (o = null)
        }
    }
    return qh = o,
    null
}
function cM(o) {
    switch (o) {
    case "beforetoggle":
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "toggle":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
        return 2;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
        return 8;
    case "message":
        switch (H7()) {
        case ND:
            return 2;
        case PD:
            return 8;
        case vh:
        case W7:
            return 32;
        case jD:
            return 268435456;
        default:
            return 32
        }
    default:
        return 32
    }
}
var Bk = !1
  , ii = null
  , si = null
  , ai = null
  , Pc = new Map
  , jc = new Map
  , qn = []
  , n8 = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");
function VS(o, n) {
    switch (o) {
    case "focusin":
    case "focusout":
        ii = null;
        break;
    case "dragenter":
    case "dragleave":
        si = null;
        break;
    case "mouseover":
    case "mouseout":
        ai = null;
        break;
    case "pointerover":
    case "pointerout":
        Pc.delete(n.pointerId);
        break;
    case "gotpointercapture":
    case "lostpointercapture":
        jc.delete(n.pointerId)
    }
}
function Kl(o, n, a, c, u, p) {
    return o === null || o.nativeEvent !== p ? (o = {
        blockedOn: n,
        domEventName: a,
        eventSystemFlags: c,
        nativeEvent: p,
        targetContainers: [u]
    },
    n !== null && (n = Fa(n),
    n !== null && lM(n)),
    o) : (o.eventSystemFlags |= c,
    n = o.targetContainers,
    u !== null && n.indexOf(u) === -1 && n.push(u),
    o)
}
function i8(o, n, a, c, u) {
    switch (n) {
    case "focusin":
        return ii = Kl(ii, o, n, a, c, u),
        !0;
    case "dragenter":
        return si = Kl(si, o, n, a, c, u),
        !0;
    case "mouseover":
        return ai = Kl(ai, o, n, a, c, u),
        !0;
    case "pointerover":
        var p = u.pointerId;
        return Pc.set(p, Kl(Pc.get(p) || null, o, n, a, c, u)),
        !0;
    case "gotpointercapture":
        return p = u.pointerId,
        jc.set(p, Kl(jc.get(p) || null, o, n, a, c, u)),
        !0
    }
    return !1
}
function dM(o) {
    var n = oa(o.target);
    if (n !== null) {
        var a = Wc(n);
        if (a !== null) {
            if (n = a.tag,
            n === 13) {
                if (n = DD(a),
                n !== null) {
                    o.blockedOn = n,
                    xE(o.priority, function() {
                        FS(a)
                    });
                    return
                }
            } else if (n === 31) {
                if (n = TD(a),
                n !== null) {
                    o.blockedOn = n,
                    xE(o.priority, function() {
                        FS(a)
                    });
                    return
                }
            } else if (n === 3 && a.stateNode.current.memoizedState.isDehydrated) {
                o.blockedOn = a.tag === 3 ? a.stateNode.containerInfo : null;
                return
            }
        }
    }
    o.blockedOn = null
}
function uh(o) {
    if (o.blockedOn !== null)
        return !1;
    for (var n = o.targetContainers; 0 < n.length; ) {
        var a = Mk(o.nativeEvent);
        if (a === null) {
            a = o.nativeEvent;
            var c = new a.constructor(a.type,a);
            Qf = c,
            a.target.dispatchEvent(c),
            Qf = null
        } else
            return n = Fa(a),
            n !== null && lM(n),
            o.blockedOn = a,
            !1;
        n.shift()
    }
    return !0
}
function US(o, n, a) {
    uh(o) && a.delete(n)
}
function s8() {
    Bk = !1,
    ii !== null && uh(ii) && (ii = null),
    si !== null && uh(si) && (si = null),
    ai !== null && uh(ai) && (ai = null),
    Pc.forEach(US),
    jc.forEach(US)
}
function Hu(o, n) {
    o.blockedOn === n && (o.blockedOn = null,
    Bk || (Bk = !0,
    jt.unstable_scheduleCallback(jt.unstable_NormalPriority, s8)))
}
var Wu = null;
function HS(o) {
    Wu !== o && (Wu = o,
    jt.unstable_scheduleCallback(jt.unstable_NormalPriority, function() {
        Wu === o && (Wu = null);
        for (var n = 0; n < o.length; n += 3) {
            var a = o[n]
              , c = o[n + 1]
              , u = o[n + 2];
            if (typeof c != "function") {
                if (nw(c || a) === null)
                    continue;
                break
            }
            var p = Fa(a);
            p !== null && (o.splice(n, 3),
            n -= 3,
            hk(p, {
                pending: !0,
                data: u,
                method: a.method,
                action: c
            }, c, u))
        }
    }))
}
function ja(o) {
    function n(k) {
        return Hu(k, o)
    }
    ii !== null && Hu(ii, o),
    si !== null && Hu(si, o),
    ai !== null && Hu(ai, o),
    Pc.forEach(n),
    jc.forEach(n);
    for (var a = 0; a < qn.length; a++) {
        var c = qn[a];
        c.blockedOn === o && (c.blockedOn = null)
    }
    for (; 0 < qn.length && (a = qn[0],
    a.blockedOn === null); )
        dM(a),
        a.blockedOn === null && qn.shift();
    if (a = (o.ownerDocument || o).$$reactFormReplay,
    a != null)
        for (c = 0; c < a.length; c += 3) {
            var u = a[c]
              , p = a[c + 1]
              , f = u[vo] || null;
            if (typeof p == "function")
                f || HS(a);
            else if (f) {
                var w = null;
                if (p && p.hasAttribute("formAction")) {
                    if (u = p,
                    f = p[vo] || null)
                        w = f.formAction;
                    else if (nw(u) !== null)
                        continue
                } else
                    w = f.action;
                typeof w == "function" ? a[c + 1] = w : (a.splice(c, 3),
                c -= 3),
                HS(a)
            }
        }
}
function uM() {
    function o(p) {
        p.canIntercept && p.info === "react-transition" && p.intercept({
            handler: function() {
                return new Promise(function(f) {
                    return u = f
                }
                )
            },
            focusReset: "manual",
            scroll: "manual"
        })
    }
    function n() {
        u !== null && (u(),
        u = null),
        c || setTimeout(a, 20)
    }
    function a() {
        if (!c && !navigation.transition) {
            var p = navigation.currentEntry;
            p && p.url != null && navigation.navigate(p.url, {
                state: p.getState(),
                info: "react-transition",
                history: "replace"
            })
        }
    }
    if (typeof navigation == "object") {
        var c = !1
          , u = null;
        return navigation.addEventListener("navigate", o),
        navigation.addEventListener("navigatesuccess", n),
        navigation.addEventListener("navigateerror", n),
        setTimeout(a, 100),
        function() {
            c = !0,
            navigation.removeEventListener("navigate", o),
            navigation.removeEventListener("navigatesuccess", n),
            navigation.removeEventListener("navigateerror", n),
            u !== null && (u(),
            u = null)
        }
    }
}
function iw(o) {
    this._internalRoot = o
}
Am.prototype.render = iw.prototype.render = function(o) {
    var n = this._internalRoot;
    if (n === null)
        throw Error(oe(409));
    var a = n.current
      , c = Ro();
    aM(a, c, o, n, null, null)
}
;
Am.prototype.unmount = iw.prototype.unmount = function() {
    var o = this._internalRoot;
    if (o !== null) {
        this._internalRoot = null;
        var n = o.containerInfo;
        aM(o.current, 2, null, o, null, null),
        km(),
        n[Ra] = null
    }
}
;
function Am(o) {
    this._internalRoot = o
}
Am.prototype.unstable_scheduleHydration = function(o) {
    if (o) {
        var n = FD();
        o = {
            blockedOn: null,
            target: o,
            priority: n
        };
        for (var a = 0; a < qn.length && n !== 0 && n < qn[a].priority; a++)
            ;
        qn.splice(a, 0, o),
        a === 0 && dM(o)
    }
}
;
var WS = ED.version;
if (WS !== "19.2.0")
    throw Error(oe(527, WS, "19.2.0"));
Oe.findDOMNode = function(o) {
    var n = o._reactInternals;
    if (n === void 0)
        throw typeof o.render == "function" ? Error(oe(188)) : (o = Object.keys(o).join(","),
        Error(oe(268, o)));
    return o = L7(n),
    o = o !== null ? ID(o) : null,
    o = o === null ? null : o.stateNode,
    o
}
;
var a8 = {
    bundleType: 0,
    version: "19.2.0",
    rendererPackageName: "react-dom",
    currentDispatcherRef: we,
    reconcilerVersion: "19.2.0"
};
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var $u = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!$u.isDisabled && $u.supportsFiber)
        try {
            $c = $u.inject(a8),
            zo = $u
        } catch {}
}
rm.createRoot = function(o, n) {
    if (!SD(o))
        throw Error(oe(299));
    var a = !1
      , c = ""
      , u = oI
      , p = rI
      , f = nI;
    return n != null && (n.unstable_strictMode === !0 && (a = !0),
    n.identifierPrefix !== void 0 && (c = n.identifierPrefix),
    n.onUncaughtError !== void 0 && (u = n.onUncaughtError),
    n.onCaughtError !== void 0 && (p = n.onCaughtError),
    n.onRecoverableError !== void 0 && (f = n.onRecoverableError)),
    n = iM(o, 1, !1, null, null, a, c, null, u, p, f, uM),
    o[Ra] = n.current,
    Xb(o),
    new iw(n)
}
;
rm.hydrateRoot = function(o, n, a) {
    if (!SD(o))
        throw Error(oe(299));
    var c = !1
      , u = ""
      , p = oI
      , f = rI
      , w = nI
      , k = null;
    return a != null && (a.unstable_strictMode === !0 && (c = !0),
    a.identifierPrefix !== void 0 && (u = a.identifierPrefix),
    a.onUncaughtError !== void 0 && (p = a.onUncaughtError),
    a.onCaughtError !== void 0 && (f = a.onCaughtError),
    a.onRecoverableError !== void 0 && (w = a.onRecoverableError),
    a.formState !== void 0 && (k = a.formState)),
    n = iM(o, 1, !0, n, a ?? null, c, u, k, p, f, w, uM),
    n.context = sM(null),
    a = n.current,
    c = Ro(),
    c = mb(c),
    u = ti(c),
    u.callback = null,
    oi(a, u, c),
    a = c,
    n.current.lanes = a,
    Gc(n, a),
    Wr(n),
    o[Ra] = n.current,
    Xb(o),
    new Am(n)
}
;
rm.version = "19.2.0";
function hM() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
        try {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(hM)
        } catch (o) {
            console.error(o)
        }
}
hM(),
AD.exports = rm;
var l8 = AD.exports;
const c8 = nb(l8);
/**
* react-router v7.9.3
*
* Copyright (c) Remix Software Inc.
*
* This source code is licensed under the MIT license found in the
* LICENSE.md file in the root directory of this source tree.
*
* @license MIT
*/
var $S = "popstate";
function d8(o={}) {
    function n(u, p) {
        let {pathname: f="/", search: w="", hash: k=""} = ms(u.location.hash.substring(1));
        return !f.startsWith("/") && !f.startsWith(".") && (f = "/" + f),
        Nk("", {
            pathname: f,
            search: w,
            hash: k
        }, p.state && p.state.usr || null, p.state && p.state.key || "default")
    }
    function a(u, p) {
        let f = u.document.querySelector("base")
          , w = "";
        if (f && f.getAttribute("href")) {
            let k = u.location.href
              , y = k.indexOf("#");
            w = y === -1 ? k : k.slice(0, y)
        }
        return w + "#" + (typeof p == "string" ? p : Lc(p))
    }
    function c(u, p) {
        xr(u.pathname.charAt(0) === "/", `relative pathnames are not supported in hash history.push(${JSON.stringify(p)})`)
    }
    return h8(n, a, c, o)
}
function ht(o, n) {
    if (o === !1 || o === null || typeof o > "u")
        throw new Error(n)
}
function xr(o, n) {
    if (!o) {
        typeof console < "u" && console.warn(n);
        try {
            throw new Error(n)
        } catch {}
    }
}
function u8() {
    return Math.random().toString(36).substring(2, 10)
}
function qS(o, n) {
    return {
        usr: o.state,
        key: o.key,
        idx: n
    }
}
function Nk(o, n, a=null, c) {
    return {
        pathname: typeof o == "string" ? o : o.pathname,
        search: "",
        hash: "",
        ...typeof n == "string" ? ms(n) : n,
        state: a,
        key: n && n.key || c || u8()
    }
}
function Lc({pathname: o="/", search: n="", hash: a=""}) {
    return n && n !== "?" && (o += n.charAt(0) === "?" ? n : "?" + n),
    a && a !== "#" && (o += a.charAt(0) === "#" ? a : "#" + a),
    o
}
function ms(o) {
    let n = {};
    if (o) {
        let a = o.indexOf("#");
        a >= 0 && (n.hash = o.substring(a),
        o = o.substring(0, a));
        let c = o.indexOf("?");
        c >= 0 && (n.search = o.substring(c),
        o = o.substring(0, c)),
        o && (n.pathname = o)
    }
    return n
}
function h8(o, n, a, c={}) {
    let {window: u=document.defaultView, v5Compat: p=!1} = c
      , f = u.history
      , w = "POP"
      , k = null
      , y = E();
    y == null && (y = 0,
    f.replaceState({
        ...f.state,
        idx: y
    }, ""));
    function E() {
        return (f.state || {
            idx: null
        }).idx
    }
    function S() {
        w = "POP";
        let z = E()
          , B = z == null ? null : z - y;
        y = z,
        k && k({
            action: w,
            location: L.location,
            delta: B
        })
    }
    function A(z, B) {
        w = "PUSH";
        let M = Nk(L.location, z, B);
        a && a(M, z),
        y = E() + 1;
        let j = qS(M, y)
          , V = L.createHref(M);
        try {
            f.pushState(j, "", V)
        } catch (G) {
            if (G instanceof DOMException && G.name === "DataCloneError")
                throw G;
            u.location.assign(V)
        }
        p && k && k({
            action: w,
            location: L.location,
            delta: 1
        })
    }
    function D(z, B) {
        w = "REPLACE";
        let M = Nk(L.location, z, B);
        a && a(M, z),
        y = E();
        let j = qS(M, y)
          , V = L.createHref(M);
        f.replaceState(j, "", V),
        p && k && k({
            action: w,
            location: L.location,
            delta: 0
        })
    }
    function N(z) {
        return m8(z)
    }
    let L = {
        get action() {
            return w
        },
        get location() {
            return o(u, f)
        },
        listen(z) {
            if (k)
                throw new Error("A history only accepts one active listener");
            return u.addEventListener($S, S),
            k = z,
            () => {
                u.removeEventListener($S, S),
                k = null
            }
        },
        createHref(z) {
            return n(u, z)
        },
        createURL: N,
        encodeLocation(z) {
            let B = N(z);
            return {
                pathname: B.pathname,
                search: B.search,
                hash: B.hash
            }
        },
        push: A,
        replace: D,
        go(z) {
            return f.go(z)
        }
    };
    return L
}
function m8(o, n=!1) {
    let a = "http://localhost";
    typeof window < "u" && (a = window.location.origin !== "null" ? window.location.origin : window.location.href),
    ht(a, "No window.location.(origin|href) available to create URL");
    let c = typeof o == "string" ? o : Lc(o);
    return c = c.replace(/ $/, "%20"),
    !n && c.startsWith("//") && (c = a + c),
    new URL(c,a)
}
function mM(o, n, a="/") {
    return p8(o, n, a, !1)
}
function p8(o, n, a, c) {
    let u = typeof n == "string" ? ms(n) : n
      , p = Cn(u.pathname || "/", a);
    if (p == null)
        return null;
    let f = pM(o);
    g8(f);
    let w = null;
    for (let k = 0; w == null && k < f.length; ++k) {
        let y = E8(p);
        w = y8(f[k], y, c)
    }
    return w
}
function pM(o, n=[], a=[], c="", u=!1) {
    let p = (f, w, k=u, y) => {
        let E = {
            relativePath: y === void 0 ? f.path || "" : y,
            caseSensitive: f.caseSensitive === !0,
            childrenIndex: w,
            route: f
        };
        if (E.relativePath.startsWith("/")) {
            if (!E.relativePath.startsWith(c) && k)
                return;
            ht(E.relativePath.startsWith(c), `Absolute route path "${E.relativePath}" nested under path "${c}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`),
            E.relativePath = E.relativePath.slice(c.length)
        }
        let S = kn([c, E.relativePath])
          , A = a.concat(E);
        f.children && f.children.length > 0 && (ht(f.index !== !0, `Index routes must not have child routes. Please remove all child routes from route path "${S}".`),
        pM(f.children, n, A, S, k)),
        !(f.path == null && !f.index) && n.push({
            path: S,
            score: _8(S, f.index),
            routesMeta: A
        })
    }
    ;
    return o.forEach( (f, w) => {
        var k;
        if (f.path === "" || !((k = f.path) != null && k.includes("?")))
            p(f, w);
        else
            for (let y of gM(f.path))
                p(f, w, !0, y)
    }
    ),
    n
}
function gM(o) {
    let n = o.split("/");
    if (n.length === 0)
        return [];
    let[a,...c] = n
      , u = a.endsWith("?")
      , p = a.replace(/\?$/, "");
    if (c.length === 0)
        return u ? [p, ""] : [p];
    let f = gM(c.join("/"))
      , w = [];
    return w.push(...f.map(k => k === "" ? p : [p, k].join("/"))),
    u && w.push(...f),
    w.map(k => o.startsWith("/") && k === "" ? "/" : k)
}
function g8(o) {
    o.sort( (n, a) => n.score !== a.score ? a.score - n.score : C8(n.routesMeta.map(c => c.childrenIndex), a.routesMeta.map(c => c.childrenIndex)))
}
var f8 = /^:[\w-]+$/
  , k8 = 3
  , b8 = 2
  , w8 = 1
  , A8 = 10
  , v8 = -2
  , GS = o => o === "*";
function _8(o, n) {
    let a = o.split("/")
      , c = a.length;
    return a.some(GS) && (c += v8),
    n && (c += b8),
    a.filter(u => !GS(u)).reduce( (u, p) => u + (f8.test(p) ? k8 : p === "" ? w8 : A8), c)
}
function C8(o, n) {
    return o.length === n.length && o.slice(0, -1).every( (a, c) => a === n[c]) ? o[o.length - 1] - n[n.length - 1] : 0
}
function y8(o, n, a=!1) {
    let {routesMeta: c} = o
      , u = {}
      , p = "/"
      , f = [];
    for (let w = 0; w < c.length; ++w) {
        let k = c[w]
          , y = w === c.length - 1
          , E = p === "/" ? n : n.slice(p.length) || "/"
          , S = Gh({
            path: k.relativePath,
            caseSensitive: k.caseSensitive,
            end: y
        }, E)
          , A = k.route;
        if (!S && y && a && !c[c.length - 1].route.index && (S = Gh({
            path: k.relativePath,
            caseSensitive: k.caseSensitive,
            end: !1
        }, E)),
        !S)
            return null;
        Object.assign(u, S.params),
        f.push({
            params: u,
            pathname: kn([p, S.pathname]),
            pathnameBase: I8(kn([p, S.pathnameBase])),
            route: A
        }),
        S.pathnameBase !== "/" && (p = kn([p, S.pathnameBase]))
    }
    return f
}
function Gh(o, n) {
    typeof o == "string" && (o = {
        path: o,
        caseSensitive: !1,
        end: !0
    });
    let[a,c] = x8(o.path, o.caseSensitive, o.end)
      , u = n.match(a);
    if (!u)
        return null;
    let p = u[0]
      , f = p.replace(/(.)\/+$/, "$1")
      , w = u.slice(1);
    return {
        params: c.reduce( (k, {paramName: y, isOptional: E}, S) => {
            if (y === "*") {
                let D = w[S] || "";
                f = p.slice(0, p.length - D.length).replace(/(.)\/+$/, "$1")
            }
            const A = w[S];
            return E && !A ? k[y] = void 0 : k[y] = (A || "").replace(/%2F/g, "/"),
            k
        }
        , {}),
        pathname: p,
        pathnameBase: f,
        pattern: o
    }
}
function x8(o, n=!1, a=!0) {
    xr(o === "*" || !o.endsWith("*") || o.endsWith("/*"), `Route path "${o}" will be treated as if it were "${o.replace(/\*$/, "/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${o.replace(/\*$/, "/*")}".`);
    let c = []
      , u = "^" + o.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (p, f, w) => (c.push({
        paramName: f,
        isOptional: w != null
    }),
    w ? "/?([^\\/]+)?" : "/([^\\/]+)")).replace(/\/([\w-]+)\?(\/|$)/g, "(/$1)?$2");
    return o.endsWith("*") ? (c.push({
        paramName: "*"
    }),
    u += o === "*" || o === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : a ? u += "\\/*$" : o !== "" && o !== "/" && (u += "(?:(?=\\/|$))"),
    [new RegExp(u,n ? void 0 : "i"), c]
}
function E8(o) {
    try {
        return o.split("/").map(n => decodeURIComponent(n).replace(/\//g, "%2F")).join("/")
    } catch (n) {
        return xr(!1, `The URL path "${o}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${n}).`),
        o
    }
}
function Cn(o, n) {
    if (n === "/")
        return o;
    if (!o.toLowerCase().startsWith(n.toLowerCase()))
        return null;
    let a = n.endsWith("/") ? n.length - 1 : n.length
      , c = o.charAt(a);
    return c && c !== "/" ? null : o.slice(a) || "/"
}
function S8(o, n="/") {
    let {pathname: a, search: c="", hash: u=""} = typeof o == "string" ? ms(o) : o;
    return {
        pathname: a ? a.startsWith("/") ? a : D8(a, n) : n,
        search: M8(c),
        hash: B8(u)
    }
}
function D8(o, n) {
    let a = n.replace(/\/+$/, "").split("/");
    return o.split("/").forEach(c => {
        c === ".." ? a.length > 1 && a.pop() : c !== "." && a.push(c)
    }
    ),
    a.length > 1 ? a.join("/") : "/"
}
function bf(o, n, a, c) {
    return `Cannot include a '${o}' character in a manually specified \`to.${n}\` field [${JSON.stringify(c)}].  Please separate it out to the \`to.${a}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`
}
function T8(o) {
    return o.filter( (n, a) => a === 0 || n.route.path && n.route.path.length > 0)
}
function fM(o) {
    let n = T8(o);
    return n.map( (a, c) => c === n.length - 1 ? a.pathname : a.pathnameBase)
}
function kM(o, n, a, c=!1) {
    let u;
    typeof o == "string" ? u = ms(o) : (u = {
        ...o
    },
    ht(!u.pathname || !u.pathname.includes("?"), bf("?", "pathname", "search", u)),
    ht(!u.pathname || !u.pathname.includes("#"), bf("#", "pathname", "hash", u)),
    ht(!u.search || !u.search.includes("#"), bf("#", "search", "hash", u)));
    let p = o === "" || u.pathname === "", f = p ? "/" : u.pathname, w;
    if (f == null)
        w = a;
    else {
        let S = n.length - 1;
        if (!c && f.startsWith("..")) {
            let A = f.split("/");
            for (; A[0] === ".."; )
                A.shift(),
                S -= 1;
            u.pathname = A.join("/")
        }
        w = S >= 0 ? n[S] : "/"
    }
    let k = S8(u, w)
      , y = f && f !== "/" && f.endsWith("/")
      , E = (p || f === ".") && a.endsWith("/");
    return !k.pathname.endsWith("/") && (y || E) && (k.pathname += "/"),
    k
}
var kn = o => o.join("/").replace(/\/\/+/g, "/")
  , I8 = o => o.replace(/\/+$/, "").replace(/^\/*/, "/")
  , M8 = o => !o || o === "?" ? "" : o.startsWith("?") ? o : "?" + o
  , B8 = o => !o || o === "#" ? "" : o.startsWith("#") ? o : "#" + o;
function N8(o) {
    return o != null && typeof o.status == "number" && typeof o.statusText == "string" && typeof o.internal == "boolean" && "data"in o
}
var bM = ["POST", "PUT", "PATCH", "DELETE"];
new Set(bM);
var P8 = ["GET", ...bM];
new Set(P8);
var qa = R.createContext(null);
qa.displayName = "DataRouter";
var vm = R.createContext(null);
vm.displayName = "DataRouterState";
R.createContext(!1);
var wM = R.createContext({
    isTransitioning: !1
});
wM.displayName = "ViewTransition";
var j8 = R.createContext(new Map);
j8.displayName = "Fetchers";
var L8 = R.createContext(null);
L8.displayName = "Await";
var $r = R.createContext(null);
$r.displayName = "Navigation";
var od = R.createContext(null);
od.displayName = "Location";
var qr = R.createContext({
    outlet: null,
    matches: [],
    isDataRoute: !1
});
qr.displayName = "Route";
var sw = R.createContext(null);
sw.displayName = "RouteError";
function z8(o, {relative: n}={}) {
    ht(rd(), "useHref() may be used only in the context of a <Router> component.");
    let {basename: a, navigator: c} = R.useContext($r)
      , {hash: u, pathname: p, search: f} = nd(o, {
        relative: n
    })
      , w = p;
    return a !== "/" && (w = p === "/" ? a : kn([a, p])),
    c.createHref({
        pathname: w,
        search: f,
        hash: u
    })
}
function rd() {
    return R.useContext(od) != null
}
function Zt() {
    return ht(rd(), "useLocation() may be used only in the context of a <Router> component."),
    R.useContext(od).location
}
var AM = "You should call navigate() in a React.useEffect(), not when your component is first rendered.";
function vM(o) {
    R.useContext($r).static || R.useLayoutEffect(o)
}
function Lt() {
    let {isDataRoute: o} = R.useContext(qr);
    return o ? J8() : O8()
}
function O8() {
    ht(rd(), "useNavigate() may be used only in the context of a <Router> component.");
    let o = R.useContext(qa)
      , {basename: n, navigator: a} = R.useContext($r)
      , {matches: c} = R.useContext(qr)
      , {pathname: u} = Zt()
      , p = JSON.stringify(fM(c))
      , f = R.useRef(!1);
    return vM( () => {
        f.current = !0
    }
    ),
    R.useCallback( (w, k={}) => {
        if (xr(f.current, AM),
        !f.current)
            return;
        if (typeof w == "number") {
            a.go(w);
            return
        }
        let y = kM(w, JSON.parse(p), u, k.relative === "path");
        o == null && n !== "/" && (y.pathname = y.pathname === "/" ? n : kn([n, y.pathname])),
        (k.replace ? a.replace : a.push)(y, k.state, k)
    }
    , [n, a, p, u, o])
}
var R8 = R.createContext(null);
function F8(o) {
    let n = R.useContext(qr).outlet;
    return R.useMemo( () => n && R.createElement(R8.Provider, {
        value: o
    }, n), [n, o])
}
function nd(o, {relative: n}={}) {
    let {matches: a} = R.useContext(qr)
      , {pathname: c} = Zt()
      , u = JSON.stringify(fM(a));
    return R.useMemo( () => kM(o, JSON.parse(u), c, n === "path"), [o, u, c, n])
}
function V8(o, n) {
    return _M(o, n)
}
function _M(o, n, a, c, u) {
    var p;
    ht(rd(), "useRoutes() may be used only in the context of a <Router> component.");
    let {navigator: f} = R.useContext($r)
      , {matches: w} = R.useContext(qr)
      , k = w[w.length - 1]
      , y = k ? k.params : {}
      , E = k ? k.pathname : "/"
      , S = k ? k.pathnameBase : "/"
      , A = k && k.route;
    {
        let j = A && A.path || "";
        CM(E, !A || j.endsWith("*") || j.endsWith("*?"), `You rendered descendant <Routes> (or called \`useRoutes()\`) at "${E}" (under <Route path="${j}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${j}"> to <Route path="${j === "/" ? "*" : `${j}/*`}">.`)
    }
    let D = Zt(), N;
    if (n) {
        let j = typeof n == "string" ? ms(n) : n;
        ht(S === "/" || ((p = j.pathname) == null ? void 0 : p.startsWith(S)), `When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${S}" but pathname "${j.pathname}" was given in the \`location\` prop.`),
        N = j
    } else
        N = D;
    let L = N.pathname || "/"
      , z = L;
    if (S !== "/") {
        let j = S.replace(/^\//, "").split("/");
        z = "/" + L.replace(/^\//, "").split("/").slice(j.length).join("/")
    }
    let B = mM(o, {
        pathname: z
    });
    xr(A || B != null, `No routes matched location "${N.pathname}${N.search}${N.hash}" `),
    xr(B == null || B[B.length - 1].route.element !== void 0 || B[B.length - 1].route.Component !== void 0 || B[B.length - 1].route.lazy !== void 0, `Matched leaf route at location "${N.pathname}${N.search}${N.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`);
    let M = q8(B && B.map(j => Object.assign({}, j, {
        params: Object.assign({}, y, j.params),
        pathname: kn([S, f.encodeLocation ? f.encodeLocation(j.pathname.replace(/\?/g, "%3F").replace(/#/g, "%23")).pathname : j.pathname]),
        pathnameBase: j.pathnameBase === "/" ? S : kn([S, f.encodeLocation ? f.encodeLocation(j.pathnameBase.replace(/\?/g, "%3F").replace(/#/g, "%23")).pathname : j.pathnameBase])
    })), w, a, c, u);
    return n && M ? R.createElement(od.Provider, {
        value: {
            location: {
                pathname: "/",
                search: "",
                hash: "",
                state: null,
                key: "default",
                ...N
            },
            navigationType: "POP"
        }
    }, M) : M
}
function U8() {
    let o = Z8()
      , n = N8(o) ? `${o.status} ${o.statusText}` : o instanceof Error ? o.message : JSON.stringify(o)
      , a = o instanceof Error ? o.stack : null
      , c = "rgba(200,200,200, 0.5)"
      , u = {
        padding: "0.5rem",
        backgroundColor: c
    }
      , p = {
        padding: "2px 4px",
        backgroundColor: c
    }
      , f = null;
    return console.error("Error handled by React Router default ErrorBoundary:", o),
    f = R.createElement(R.Fragment, null, R.createElement("p", null, "💿 Hey developer 👋"), R.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", R.createElement("code", {
        style: p
    }, "ErrorBoundary"), " or", " ", R.createElement("code", {
        style: p
    }, "errorElement"), " prop on your route.")),
    R.createElement(R.Fragment, null, R.createElement("h2", null, "Unexpected Application Error!"), R.createElement("h3", {
        style: {
            fontStyle: "italic"
        }
    }, n), a ? R.createElement("pre", {
        style: u
    }, a) : null, f)
}
var H8 = R.createElement(U8, null)
  , W8 = class extends R.Component {
    constructor(o) {
        super(o),
        this.state = {
            location: o.location,
            revalidation: o.revalidation,
            error: o.error
        }
    }
    static getDerivedStateFromError(o) {
        return {
            error: o
        }
    }
    static getDerivedStateFromProps(o, n) {
        return n.location !== o.location || n.revalidation !== "idle" && o.revalidation === "idle" ? {
            error: o.error,
            location: o.location,
            revalidation: o.revalidation
        } : {
            error: o.error !== void 0 ? o.error : n.error,
            location: n.location,
            revalidation: o.revalidation || n.revalidation
        }
    }
    componentDidCatch(o, n) {
        this.props.unstable_onError ? this.props.unstable_onError(o, n) : console.error("React Router caught the following error during render", o)
    }
    render() {
        return this.state.error !== void 0 ? R.createElement(qr.Provider, {
            value: this.props.routeContext
        }, R.createElement(sw.Provider, {
            value: this.state.error,
            children: this.props.component
        })) : this.props.children
    }
}
;
function $8({routeContext: o, match: n, children: a}) {
    let c = R.useContext(qa);
    return c && c.static && c.staticContext && (n.route.errorElement || n.route.ErrorBoundary) && (c.staticContext._deepestRenderedBoundaryId = n.route.id),
    R.createElement(qr.Provider, {
        value: o
    }, a)
}
function q8(o, n=[], a=null, c=null, u=null) {
    if (o == null) {
        if (!a)
            return null;
        if (a.errors)
            o = a.matches;
        else if (n.length === 0 && !a.initialized && a.matches.length > 0)
            o = a.matches;
        else
            return null
    }
    let p = o
      , f = a == null ? void 0 : a.errors;
    if (f != null) {
        let y = p.findIndex(E => E.route.id && (f == null ? void 0 : f[E.route.id]) !== void 0);
        ht(y >= 0, `Could not find a matching route for errors on route IDs: ${Object.keys(f).join(",")}`),
        p = p.slice(0, Math.min(p.length, y + 1))
    }
    let w = !1
      , k = -1;
    if (a)
        for (let y = 0; y < p.length; y++) {
            let E = p[y];
            if ((E.route.HydrateFallback || E.route.hydrateFallbackElement) && (k = y),
            E.route.id) {
                let {loaderData: S, errors: A} = a
                  , D = E.route.loader && !S.hasOwnProperty(E.route.id) && (!A || A[E.route.id] === void 0);
                if (E.route.lazy || D) {
                    w = !0,
                    k >= 0 ? p = p.slice(0, k + 1) : p = [p[0]];
                    break
                }
            }
        }
    return p.reduceRight( (y, E, S) => {
        let A, D = !1, N = null, L = null;
        a && (A = f && E.route.id ? f[E.route.id] : void 0,
        N = E.route.errorElement || H8,
        w && (k < 0 && S === 0 ? (CM("route-fallback", !1, "No `HydrateFallback` element provided to render during initial hydration"),
        D = !0,
        L = null) : k === S && (D = !0,
        L = E.route.hydrateFallbackElement || null)));
        let z = n.concat(p.slice(0, S + 1))
          , B = () => {
            let M;
            return A ? M = N : D ? M = L : E.route.Component ? M = R.createElement(E.route.Component, null) : E.route.element ? M = E.route.element : M = y,
            R.createElement($8, {
                match: E,
                routeContext: {
                    outlet: y,
                    matches: z,
                    isDataRoute: a != null
                },
                children: M
            })
        }
        ;
        return a && (E.route.ErrorBoundary || E.route.errorElement || S === 0) ? R.createElement(W8, {
            location: a.location,
            revalidation: a.revalidation,
            component: N,
            error: A,
            children: B(),
            routeContext: {
                outlet: null,
                matches: z,
                isDataRoute: !0
            },
            unstable_onError: c
        }) : B()
    }
    , null)
}
function aw(o) {
    return `${o} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`
}
function G8(o) {
    let n = R.useContext(qa);
    return ht(n, aw(o)),
    n
}
function K8(o) {
    let n = R.useContext(vm);
    return ht(n, aw(o)),
    n
}
function Y8(o) {
    let n = R.useContext(qr);
    return ht(n, aw(o)),
    n
}
function lw(o) {
    let n = Y8(o)
      , a = n.matches[n.matches.length - 1];
    return ht(a.route.id, `${o} can only be used on routes that contain a unique "id"`),
    a.route.id
}
function Q8() {
    return lw("useRouteId")
}
function Z8() {
    var o;
    let n = R.useContext(sw)
      , a = K8("useRouteError")
      , c = lw("useRouteError");
    return n !== void 0 ? n : (o = a.errors) == null ? void 0 : o[c]
}
function J8() {
    let {router: o} = G8("useNavigate")
      , n = lw("useNavigate")
      , a = R.useRef(!1);
    return vM( () => {
        a.current = !0
    }
    ),
    R.useCallback(async (c, u={}) => {
        xr(a.current, AM),
        a.current && (typeof c == "number" ? o.navigate(c) : await o.navigate(c, {
            fromRouteId: n,
            ...u
        }))
    }
    , [o, n])
}
var KS = {};
function CM(o, n, a) {
    !n && !KS[o] && (KS[o] = !0,
    xr(!1, a))
}
R.memo(X8);
function X8({routes: o, future: n, state: a, unstable_onError: c}) {
    return _M(o, void 0, a, c, n)
}
function yM(o) {
    return F8(o.context)
}
function Je(o) {
    ht(!1, "A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.")
}
function eU({basename: o="/", children: n=null, location: a, navigationType: c="POP", navigator: u, static: p=!1}) {
    ht(!rd(), "You cannot render a <Router> inside another <Router>. You should never have more than one in your app.");
    let f = o.replace(/^\/*/, "/")
      , w = R.useMemo( () => ({
        basename: f,
        navigator: u,
        static: p,
        future: {}
    }), [f, u, p]);
    typeof a == "string" && (a = ms(a));
    let {pathname: k="/", search: y="", hash: E="", state: S=null, key: A="default"} = a
      , D = R.useMemo( () => {
        let N = Cn(k, f);
        return N == null ? null : {
            location: {
                pathname: N,
                search: y,
                hash: E,
                state: S,
                key: A
            },
            navigationType: c
        }
    }
    , [f, k, y, E, S, A, c]);
    return xr(D != null, `<Router basename="${f}"> is not able to match the URL "${k}${y}${E}" because it does not start with the basename, so the <Router> won't render anything.`),
    D == null ? null : R.createElement($r.Provider, {
        value: w
    }, R.createElement(od.Provider, {
        children: n,
        value: D
    }))
}
function tU({children: o, location: n}) {
    return V8(Pk(o), n)
}
function Pk(o, n=[]) {
    let a = [];
    return R.Children.forEach(o, (c, u) => {
        if (!R.isValidElement(c))
            return;
        let p = [...n, u];
        if (c.type === R.Fragment) {
            a.push.apply(a, Pk(c.props.children, p));
            return
        }
        ht(c.type === Je, `[${typeof c.type == "string" ? c.type : c.type.name}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`),
        ht(!c.props.index || !c.props.children, "An index route cannot have child routes.");
        let f = {
            id: c.props.id || p.join("-"),
            caseSensitive: c.props.caseSensitive,
            element: c.props.element,
            Component: c.props.Component,
            index: c.props.index,
            path: c.props.path,
            middleware: c.props.middleware,
            loader: c.props.loader,
            action: c.props.action,
            hydrateFallbackElement: c.props.hydrateFallbackElement,
            HydrateFallback: c.props.HydrateFallback,
            errorElement: c.props.errorElement,
            ErrorBoundary: c.props.ErrorBoundary,
            hasErrorBoundary: c.props.hasErrorBoundary === !0 || c.props.ErrorBoundary != null || c.props.errorElement != null,
            shouldRevalidate: c.props.shouldRevalidate,
            handle: c.props.handle,
            lazy: c.props.lazy
        };
        c.props.children && (f.children = Pk(c.props.children, p)),
        a.push(f)
    }
    ),
    a
}
var hh = "get"
  , mh = "application/x-www-form-urlencoded";
function _m(o) {
    return o != null && typeof o.tagName == "string"
}
function oU(o) {
    return _m(o) && o.tagName.toLowerCase() === "button"
}
function rU(o) {
    return _m(o) && o.tagName.toLowerCase() === "form"
}
function nU(o) {
    return _m(o) && o.tagName.toLowerCase() === "input"
}
function iU(o) {
    return !!(o.metaKey || o.altKey || o.ctrlKey || o.shiftKey)
}
function sU(o, n) {
    return o.button === 0 && (!n || n === "_self") && !iU(o)
}
var qu = null;
function aU() {
    if (qu === null)
        try {
            new FormData(document.createElement("form"),0),
            qu = !1
        } catch {
            qu = !0
        }
    return qu
}
var lU = new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]);
function wf(o) {
    return o != null && !lU.has(o) ? (xr(!1, `"${o}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${mh}"`),
    null) : o
}
function cU(o, n) {
    let a, c, u, p, f;
    if (rU(o)) {
        let w = o.getAttribute("action");
        c = w ? Cn(w, n) : null,
        a = o.getAttribute("method") || hh,
        u = wf(o.getAttribute("enctype")) || mh,
        p = new FormData(o)
    } else if (oU(o) || nU(o) && (o.type === "submit" || o.type === "image")) {
        let w = o.form;
        if (w == null)
            throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');
        let k = o.getAttribute("formaction") || w.getAttribute("action");
        if (c = k ? Cn(k, n) : null,
        a = o.getAttribute("formmethod") || w.getAttribute("method") || hh,
        u = wf(o.getAttribute("formenctype")) || wf(w.getAttribute("enctype")) || mh,
        p = new FormData(w,o),
        !aU()) {
            let {name: y, type: E, value: S} = o;
            if (E === "image") {
                let A = y ? `${y}.` : "";
                p.append(`${A}x`, "0"),
                p.append(`${A}y`, "0")
            } else
                y && p.append(y, S)
        }
    } else {
        if (_m(o))
            throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');
        a = hh,
        c = null,
        u = mh,
        f = o
    }
    return p && u === "text/plain" && (f = p,
    p = void 0),
    {
        action: c,
        method: a.toLowerCase(),
        encType: u,
        formData: p,
        body: f
    }
}
Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
function cw(o, n) {
    if (o === !1 || o === null || typeof o > "u")
        throw new Error(n)
}
function dU(o, n, a) {
    let c = typeof o == "string" ? new URL(o,typeof window > "u" ? "server://singlefetch/" : window.location.origin) : o;
    return c.pathname === "/" ? c.pathname = `_root.${a}` : n && Cn(c.pathname, n) === "/" ? c.pathname = `${n.replace(/\/$/, "")}/_root.${a}` : c.pathname = `${c.pathname.replace(/\/$/, "")}.${a}`,
    c
}
async function uU(o, n) {
    if (o.id in n)
        return n[o.id];
    try {
        let a = await import(o.module);
        return n[o.id] = a,
        a
    } catch (a) {
        return console.error(`Error loading route module \`${o.module}\`, reloading page...`),
        console.error(a),
        window.__reactRouterContext && window.__reactRouterContext.isSpaMode,
        window.location.reload(),
        new Promise( () => {}
        )
    }
}
function hU(o) {
    return o == null ? !1 : o.href == null ? o.rel === "preload" && typeof o.imageSrcSet == "string" && typeof o.imageSizes == "string" : typeof o.rel == "string" && typeof o.href == "string"
}
async function mU(o, n, a) {
    let c = await Promise.all(o.map(async u => {
        let p = n.routes[u.route.id];
        if (p) {
            let f = await uU(p, a);
            return f.links ? f.links() : []
        }
        return []
    }
    ));
    return kU(c.flat(1).filter(hU).filter(u => u.rel === "stylesheet" || u.rel === "preload").map(u => u.rel === "stylesheet" ? {
        ...u,
        rel: "prefetch",
        as: "style"
    } : {
        ...u,
        rel: "prefetch"
    }))
}
function YS(o, n, a, c, u, p) {
    let f = (k, y) => a[y] ? k.route.id !== a[y].route.id : !0
      , w = (k, y) => {
        var E;
        return a[y].pathname !== k.pathname || ((E = a[y].route.path) == null ? void 0 : E.endsWith("*")) && a[y].params["*"] !== k.params["*"]
    }
    ;
    return p === "assets" ? n.filter( (k, y) => f(k, y) || w(k, y)) : p === "data" ? n.filter( (k, y) => {
        var E;
        let S = c.routes[k.route.id];
        if (!S || !S.hasLoader)
            return !1;
        if (f(k, y) || w(k, y))
            return !0;
        if (k.route.shouldRevalidate) {
            let A = k.route.shouldRevalidate({
                currentUrl: new URL(u.pathname + u.search + u.hash,window.origin),
                currentParams: ((E = a[0]) == null ? void 0 : E.params) || {},
                nextUrl: new URL(o,window.origin),
                nextParams: k.params,
                defaultShouldRevalidate: !0
            });
            if (typeof A == "boolean")
                return A
        }
        return !0
    }
    ) : []
}
function pU(o, n, {includeHydrateFallback: a}={}) {
    return gU(o.map(c => {
        let u = n.routes[c.route.id];
        if (!u)
            return [];
        let p = [u.module];
        return u.clientActionModule && (p = p.concat(u.clientActionModule)),
        u.clientLoaderModule && (p = p.concat(u.clientLoaderModule)),
        a && u.hydrateFallbackModule && (p = p.concat(u.hydrateFallbackModule)),
        u.imports && (p = p.concat(u.imports)),
        p
    }
    ).flat(1))
}
function gU(o) {
    return [...new Set(o)]
}
function fU(o) {
    let n = {}
      , a = Object.keys(o).sort();
    for (let c of a)
        n[c] = o[c];
    return n
}
function kU(o, n) {
    let a = new Set;
    return new Set(n),
    o.reduce( (c, u) => {
        let p = JSON.stringify(fU(u));
        return a.has(p) || (a.add(p),
        c.push({
            key: p,
            link: u
        })),
        c
    }
    , [])
}
function xM() {
    let o = R.useContext(qa);
    return cw(o, "You must render this element inside a <DataRouterContext.Provider> element"),
    o
}
function bU() {
    let o = R.useContext(vm);
    return cw(o, "You must render this element inside a <DataRouterStateContext.Provider> element"),
    o
}
var dw = R.createContext(void 0);
dw.displayName = "FrameworkContext";
function EM() {
    let o = R.useContext(dw);
    return cw(o, "You must render this element inside a <HydratedRouter> element"),
    o
}
function wU(o, n) {
    let a = R.useContext(dw)
      , [c,u] = R.useState(!1)
      , [p,f] = R.useState(!1)
      , {onFocus: w, onBlur: k, onMouseEnter: y, onMouseLeave: E, onTouchStart: S} = n
      , A = R.useRef(null);
    R.useEffect( () => {
        if (o === "render" && f(!0),
        o === "viewport") {
            let L = B => {
                B.forEach(M => {
                    f(M.isIntersecting)
                }
                )
            }
              , z = new IntersectionObserver(L,{
                threshold: .5
            });
            return A.current && z.observe(A.current),
            () => {
                z.disconnect()
            }
        }
    }
    , [o]),
    R.useEffect( () => {
        if (c) {
            let L = setTimeout( () => {
                f(!0)
            }
            , 100);
            return () => {
                clearTimeout(L)
            }
        }
    }
    , [c]);
    let D = () => {
        u(!0)
    }
      , N = () => {
        u(!1),
        f(!1)
    }
    ;
    return a ? o !== "intent" ? [p, A, {}] : [p, A, {
        onFocus: Yl(w, D),
        onBlur: Yl(k, N),
        onMouseEnter: Yl(y, D),
        onMouseLeave: Yl(E, N),
        onTouchStart: Yl(S, D)
    }] : [!1, A, {}]
}
function Yl(o, n) {
    return a => {
        o && o(a),
        a.defaultPrevented || n(a)
    }
}
function AU({page: o, ...n}) {
    let {router: a} = xM()
      , c = R.useMemo( () => mM(a.routes, o, a.basename), [a.routes, o, a.basename]);
    return c ? R.createElement(_U, {
        page: o,
        matches: c,
        ...n
    }) : null
}
function vU(o) {
    let {manifest: n, routeModules: a} = EM()
      , [c,u] = R.useState([]);
    return R.useEffect( () => {
        let p = !1;
        return mU(o, n, a).then(f => {
            p || u(f)
        }
        ),
        () => {
            p = !0
        }
    }
    , [o, n, a]),
    c
}
function _U({page: o, matches: n, ...a}) {
    let c = Zt()
      , {manifest: u, routeModules: p} = EM()
      , {basename: f} = xM()
      , {loaderData: w, matches: k} = bU()
      , y = R.useMemo( () => YS(o, n, k, u, c, "data"), [o, n, k, u, c])
      , E = R.useMemo( () => YS(o, n, k, u, c, "assets"), [o, n, k, u, c])
      , S = R.useMemo( () => {
        if (o === c.pathname + c.search + c.hash)
            return [];
        let N = new Set
          , L = !1;
        if (n.forEach(B => {
            var M;
            let j = u.routes[B.route.id];
            !j || !j.hasLoader || (!y.some(V => V.route.id === B.route.id) && B.route.id in w && (M = p[B.route.id]) != null && M.shouldRevalidate || j.hasClientLoader ? L = !0 : N.add(B.route.id))
        }
        ),
        N.size === 0)
            return [];
        let z = dU(o, f, "data");
        return L && N.size > 0 && z.searchParams.set("_routes", n.filter(B => N.has(B.route.id)).map(B => B.route.id).join(",")),
        [z.pathname + z.search]
    }
    , [f, w, c, u, y, n, o, p])
      , A = R.useMemo( () => pU(E, u), [E, u])
      , D = vU(E);
    return R.createElement(R.Fragment, null, S.map(N => R.createElement("link", {
        key: N,
        rel: "prefetch",
        as: "fetch",
        href: N,
        ...a
    })), A.map(N => R.createElement("link", {
        key: N,
        rel: "modulepreload",
        href: N,
        ...a
    })), D.map( ({key: N, link: L}) => R.createElement("link", {
        key: N,
        nonce: a.nonce,
        ...L
    })))
}
function CU(...o) {
    return n => {
        o.forEach(a => {
            typeof a == "function" ? a(n) : a != null && (a.current = n)
        }
        )
    }
}
var SM = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
try {
    SM && (window.__reactRouterVersion = "7.9.3")
} catch {}
function yU({basename: o, children: n, window: a}) {
    let c = R.useRef();
    c.current == null && (c.current = d8({
        window: a,
        v5Compat: !0
    }));
    let u = c.current
      , [p,f] = R.useState({
        action: u.action,
        location: u.location
    })
      , w = R.useCallback(k => {
        R.startTransition( () => f(k))
    }
    , [f]);
    return R.useLayoutEffect( () => u.listen(w), [u, w]),
    R.createElement(eU, {
        basename: o,
        children: n,
        location: p.location,
        navigationType: p.action,
        navigator: u
    })
}
var DM = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i
  , Kh = R.forwardRef(function({onClick: o, discover: n="render", prefetch: a="none", relative: c, reloadDocument: u, replace: p, state: f, target: w, to: k, preventScrollReset: y, viewTransition: E, ...S}, A) {
    let {basename: D} = R.useContext($r), N = typeof k == "string" && DM.test(k), L, z = !1;
    if (typeof k == "string" && N && (L = k,
    SM))
        try {
            let K = new URL(window.location.href)
              , Z = k.startsWith("//") ? new URL(K.protocol + k) : new URL(k)
              , H = Cn(Z.pathname, D);
            Z.origin === K.origin && H != null ? k = H + Z.search + Z.hash : z = !0
        } catch {
            xr(!1, `<Link to="${k}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`)
        }
    let B = z8(k, {
        relative: c
    })
      , [M,j,V] = wU(a, S)
      , G = DU(k, {
        replace: p,
        state: f,
        target: w,
        preventScrollReset: y,
        relative: c,
        viewTransition: E
    });
    function Y(K) {
        o && o(K),
        K.defaultPrevented || G(K)
    }
    let $ = R.createElement("a", {
        ...S,
        ...V,
        href: L || B,
        onClick: z || u ? o : Y,
        ref: CU(A, j),
        target: w,
        "data-discover": !N && n === "render" ? "true" : void 0
    });
    return M && !N ? R.createElement(R.Fragment, null, $, R.createElement(AU, {
        page: B
    })) : $
});
Kh.displayName = "Link";
var xU = R.forwardRef(function({"aria-current": o="page", caseSensitive: n=!1, className: a="", end: c=!1, style: u, to: p, viewTransition: f, children: w, ...k}, y) {
    let E = nd(p, {
        relative: k.relative
    })
      , S = Zt()
      , A = R.useContext(vm)
      , {navigator: D, basename: N} = R.useContext($r)
      , L = A != null && NU(E) && f === !0
      , z = D.encodeLocation ? D.encodeLocation(E).pathname : E.pathname
      , B = S.pathname
      , M = A && A.navigation && A.navigation.location ? A.navigation.location.pathname : null;
    n || (B = B.toLowerCase(),
    M = M ? M.toLowerCase() : null,
    z = z.toLowerCase()),
    M && N && (M = Cn(M, N) || M);
    const j = z !== "/" && z.endsWith("/") ? z.length - 1 : z.length;
    let V = B === z || !c && B.startsWith(z) && B.charAt(j) === "/", G = M != null && (M === z || !c && M.startsWith(z) && M.charAt(z.length) === "/"), Y = {
        isActive: V,
        isPending: G,
        isTransitioning: L
    }, $ = V ? o : void 0, K;
    typeof a == "function" ? K = a(Y) : K = [a, V ? "active" : null, G ? "pending" : null, L ? "transitioning" : null].filter(Boolean).join(" ");
    let Z = typeof u == "function" ? u(Y) : u;
    return R.createElement(Kh, {
        ...k,
        "aria-current": $,
        className: K,
        ref: y,
        style: Z,
        to: p,
        viewTransition: f
    }, typeof w == "function" ? w(Y) : w)
});
xU.displayName = "NavLink";
var EU = R.forwardRef( ({discover: o="render", fetcherKey: n, navigate: a, reloadDocument: c, replace: u, state: p, method: f=hh, action: w, onSubmit: k, relative: y, preventScrollReset: E, viewTransition: S, ...A}, D) => {
    let N = MU()
      , L = BU(w, {
        relative: y
    })
      , z = f.toLowerCase() === "get" ? "get" : "post"
      , B = typeof w == "string" && DM.test(w)
      , M = j => {
        if (k && k(j),
        j.defaultPrevented)
            return;
        j.preventDefault();
        let V = j.nativeEvent.submitter
          , G = (V == null ? void 0 : V.getAttribute("formmethod")) || f;
        N(V || j.currentTarget, {
            fetcherKey: n,
            method: G,
            navigate: a,
            replace: u,
            state: p,
            relative: y,
            preventScrollReset: E,
            viewTransition: S
        })
    }
    ;
    return R.createElement("form", {
        ref: D,
        method: z,
        action: L,
        onSubmit: c ? k : M,
        ...A,
        "data-discover": !B && o === "render" ? "true" : void 0
    })
}
);
EU.displayName = "Form";
function SU(o) {
    return `${o} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`
}
function TM(o) {
    let n = R.useContext(qa);
    return ht(n, SU(o)),
    n
}
function DU(o, {target: n, replace: a, state: c, preventScrollReset: u, relative: p, viewTransition: f}={}) {
    let w = Lt()
      , k = Zt()
      , y = nd(o, {
        relative: p
    });
    return R.useCallback(E => {
        if (sU(E, n)) {
            E.preventDefault();
            let S = a !== void 0 ? a : Lc(k) === Lc(y);
            w(o, {
                replace: S,
                state: c,
                preventScrollReset: u,
                relative: p,
                viewTransition: f
            })
        }
    }
    , [k, w, y, a, c, n, o, u, p, f])
}
var TU = 0
  , IU = () => `__${String(++TU)}__`;
function MU() {
    let {router: o} = TM("useSubmit")
      , {basename: n} = R.useContext($r)
      , a = Q8();
    return R.useCallback(async (c, u={}) => {
        let {action: p, method: f, encType: w, formData: k, body: y} = cU(c, n);
        if (u.navigate === !1) {
            let E = u.fetcherKey || IU();
            await o.fetch(E, a, u.action || p, {
                preventScrollReset: u.preventScrollReset,
                formData: k,
                body: y,
                formMethod: u.method || f,
                formEncType: u.encType || w,
                flushSync: u.flushSync
            })
        } else
            await o.navigate(u.action || p, {
                preventScrollReset: u.preventScrollReset,
                formData: k,
                body: y,
                formMethod: u.method || f,
                formEncType: u.encType || w,
                replace: u.replace,
                state: u.state,
                fromRouteId: a,
                flushSync: u.flushSync,
                viewTransition: u.viewTransition
            })
    }
    , [o, n, a])
}
function BU(o, {relative: n}={}) {
    let {basename: a} = R.useContext($r)
      , c = R.useContext(qr);
    ht(c, "useFormAction must be used inside a RouteContext");
    let[u] = c.matches.slice(-1)
      , p = {
        ...nd(o || ".", {
            relative: n
        })
    }
      , f = Zt();
    if (o == null) {
        p.search = f.search;
        let w = new URLSearchParams(p.search)
          , k = w.getAll("index");
        if (k.some(y => y === "")) {
            w.delete("index"),
            k.filter(E => E).forEach(E => w.append("index", E));
            let y = w.toString();
            p.search = y ? `?${y}` : ""
        }
    }
    return (!o || o === ".") && u.route.index && (p.search = p.search ? p.search.replace(/^\?/, "?index&") : "?index"),
    a !== "/" && (p.pathname = p.pathname === "/" ? a : kn([a, p.pathname])),
    Lc(p)
}
function NU(o, {relative: n}={}) {
    let a = R.useContext(wM);
    ht(a != null, "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?");
    let {basename: c} = TM("useViewTransitionState")
      , u = nd(o, {
        relative: n
    });
    if (!a.isTransitioning)
        return !1;
    let p = Cn(a.currentLocation.pathname, c) || a.currentLocation.pathname
      , f = Cn(a.nextLocation.pathname, c) || a.nextLocation.pathname;
    return Gh(u.pathname, f) != null || Gh(u.pathname, p) != null
}
const uw = R.createContext({});
function hw(o) {
    const n = R.useRef(null);
    return n.current === null && (n.current = o()),
    n.current
}
const mw = typeof window < "u"
  , IM = mw ? R.useLayoutEffect : R.useEffect
  , Cm = R.createContext(null);
function pw(o, n) {
    o.indexOf(n) === -1 && o.push(n)
}
function gw(o, n) {
    const a = o.indexOf(n);
    a > -1 && o.splice(a, 1)
}
const yn = (o, n, a) => a > n ? n : a < o ? o : a;
let fw = () => {}
;
const xn = {}
  , MM = o => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(o);
function BM(o) {
    return typeof o == "object" && o !== null
}
const NM = o => /^0[^.\s]+$/u.test(o);
function kw(o) {
    let n;
    return () => (n === void 0 && (n = o()),
    n)
}
const ar = o => o
  , PU = (o, n) => a => n(o(a))
  , id = (...o) => o.reduce(PU)
  , zc = (o, n, a) => {
    const c = n - o;
    return c === 0 ? 1 : (a - o) / c
}
;
class bw {
    constructor() {
        this.subscriptions = []
    }
    add(n) {
        return pw(this.subscriptions, n),
        () => gw(this.subscriptions, n)
    }
    notify(n, a, c) {
        const u = this.subscriptions.length;
        if (u)
            if (u === 1)
                this.subscriptions[0](n, a, c);
            else
                for (let p = 0; p < u; p++) {
                    const f = this.subscriptions[p];
                    f && f(n, a, c)
                }
    }
    getSize() {
        return this.subscriptions.length
    }
    clear() {
        this.subscriptions.length = 0
    }
}
const Vr = o => o * 1e3
  , ir = o => o / 1e3;
function PM(o, n) {
    return n ? o * (1e3 / n) : 0
}
const jM = (o, n, a) => (((1 - 3 * a + 3 * n) * o + (3 * a - 6 * n)) * o + 3 * n) * o
  , jU = 1e-7
  , LU = 12;
function zU(o, n, a, c, u) {
    let p, f, w = 0;
    do
        f = n + (a - n) / 2,
        p = jM(f, c, u) - o,
        p > 0 ? a = f : n = f;
    while (Math.abs(p) > jU && ++w < LU);
    return f
}
function sd(o, n, a, c) {
    if (o === n && a === c)
        return ar;
    const u = p => zU(p, 0, 1, o, a);
    return p => p === 0 || p === 1 ? p : jM(u(p), n, c)
}
const LM = o => n => n <= .5 ? o(2 * n) / 2 : (2 - o(2 * (1 - n))) / 2
  , zM = o => n => 1 - o(1 - n)
  , OM = sd(.33, 1.53, .69, .99)
  , ww = zM(OM)
  , RM = LM(ww)
  , FM = o => (o *= 2) < 1 ? .5 * ww(o) : .5 * (2 - Math.pow(2, -10 * (o - 1)))
  , Aw = o => 1 - Math.sin(Math.acos(o))
  , VM = zM(Aw)
  , UM = LM(Aw)
  , OU = sd(.42, 0, 1, 1)
  , RU = sd(0, 0, .58, 1)
  , HM = sd(.42, 0, .58, 1)
  , FU = o => Array.isArray(o) && typeof o[0] != "number"
  , WM = o => Array.isArray(o) && typeof o[0] == "number"
  , VU = {
    linear: ar,
    easeIn: OU,
    easeInOut: HM,
    easeOut: RU,
    circIn: Aw,
    circInOut: UM,
    circOut: VM,
    backIn: ww,
    backInOut: RM,
    backOut: OM,
    anticipate: FM
}
  , UU = o => typeof o == "string"
  , QS = o => {
    if (WM(o)) {
        fw(o.length === 4);
        const [n,a,c,u] = o;
        return sd(n, a, c, u)
    } else if (UU(o))
        return VU[o];
    return o
}
  , Gu = ["setup", "read", "resolveKeyframes", "preUpdate", "update", "preRender", "render", "postRender"];
function HU(o, n) {
    let a = new Set
      , c = new Set
      , u = !1
      , p = !1;
    const f = new WeakSet;
    let w = {
        delta: 0,
        timestamp: 0,
        isProcessing: !1
    };
    function k(E) {
        f.has(E) && (y.schedule(E),
        o()),
        E(w)
    }
    const y = {
        schedule: (E, S=!1, A=!1) => {
            const D = A && u ? a : c;
            return S && f.add(E),
            D.has(E) || D.add(E),
            E
        }
        ,
        cancel: E => {
            c.delete(E),
            f.delete(E)
        }
        ,
        process: E => {
            if (w = E,
            u) {
                p = !0;
                return
            }
            u = !0,
            [a,c] = [c, a],
            a.forEach(k),
            a.clear(),
            u = !1,
            p && (p = !1,
            y.process(E))
        }
    };
    return y
}
const WU = 40;
function $M(o, n) {
    let a = !1
      , c = !0;
    const u = {
        delta: 0,
        timestamp: 0,
        isProcessing: !1
    }
      , p = () => a = !0
      , f = Gu.reduce( (B, M) => (B[M] = HU(p),
    B), {})
      , {setup: w, read: k, resolveKeyframes: y, preUpdate: E, update: S, preRender: A, render: D, postRender: N} = f
      , L = () => {
        const B = xn.useManualTiming ? u.timestamp : performance.now();
        a = !1,
        xn.useManualTiming || (u.delta = c ? 1e3 / 60 : Math.max(Math.min(B - u.timestamp, WU), 1)),
        u.timestamp = B,
        u.isProcessing = !0,
        w.process(u),
        k.process(u),
        y.process(u),
        E.process(u),
        S.process(u),
        A.process(u),
        D.process(u),
        N.process(u),
        u.isProcessing = !1,
        a && n && (c = !1,
        o(L))
    }
      , z = () => {
        a = !0,
        c = !0,
        u.isProcessing || o(L)
    }
    ;
    return {
        schedule: Gu.reduce( (B, M) => {
            const j = f[M];
            return B[M] = (V, G=!1, Y=!1) => (a || z(),
            j.schedule(V, G, Y)),
            B
        }
        , {}),
        cancel: B => {
            for (let M = 0; M < Gu.length; M++)
                f[Gu[M]].cancel(B)
        }
        ,
        state: u,
        steps: f
    }
}
const {schedule: lt, cancel: hi, state: $t, steps: Af} = $M(typeof requestAnimationFrame < "u" ? requestAnimationFrame : ar, !0);
let ph;
function $U() {
    ph = void 0
}
const wo = {
    now: () => (ph === void 0 && wo.set($t.isProcessing || xn.useManualTiming ? $t.timestamp : performance.now()),
    ph),
    set: o => {
        ph = o,
        queueMicrotask($U)
    }
}
  , qM = o => n => typeof n == "string" && n.startsWith(o)
  , vw = qM("--")
  , qU = qM("var(--")
  , _w = o => qU(o) ? GU.test(o.split("/*")[0].trim()) : !1
  , GU = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu
  , Ga = {
    test: o => typeof o == "number",
    parse: parseFloat,
    transform: o => o
}
  , Oc = {
    ...Ga,
    transform: o => yn(0, 1, o)
}
  , Ku = {
    ...Ga,
    default: 1
}
  , kc = o => Math.round(o * 1e5) / 1e5
  , Cw = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
function KU(o) {
    return o == null
}
const YU = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu
  , yw = (o, n) => a => !!(typeof a == "string" && YU.test(a) && a.startsWith(o) || n && !KU(a) && Object.prototype.hasOwnProperty.call(a, n))
  , GM = (o, n, a) => c => {
    if (typeof c != "string")
        return c;
    const [u,p,f,w] = c.match(Cw);
    return {
        [o]: parseFloat(u),
        [n]: parseFloat(p),
        [a]: parseFloat(f),
        alpha: w !== void 0 ? parseFloat(w) : 1
    }
}
  , QU = o => yn(0, 255, o)
  , vf = {
    ...Ga,
    transform: o => Math.round(QU(o))
}
  , Ki = {
    test: yw("rgb", "red"),
    parse: GM("red", "green", "blue"),
    transform: ({red: o, green: n, blue: a, alpha: c=1}) => "rgba(" + vf.transform(o) + ", " + vf.transform(n) + ", " + vf.transform(a) + ", " + kc(Oc.transform(c)) + ")"
};
function ZU(o) {
    let n = ""
      , a = ""
      , c = ""
      , u = "";
    return o.length > 5 ? (n = o.substring(1, 3),
    a = o.substring(3, 5),
    c = o.substring(5, 7),
    u = o.substring(7, 9)) : (n = o.substring(1, 2),
    a = o.substring(2, 3),
    c = o.substring(3, 4),
    u = o.substring(4, 5),
    n += n,
    a += a,
    c += c,
    u += u),
    {
        red: parseInt(n, 16),
        green: parseInt(a, 16),
        blue: parseInt(c, 16),
        alpha: u ? parseInt(u, 16) / 255 : 1
    }
}
const jk = {
    test: yw("#"),
    parse: ZU,
    transform: Ki.transform
}
  , ad = o => ({
    test: n => typeof n == "string" && n.endsWith(o) && n.split(" ").length === 1,
    parse: parseFloat,
    transform: n => `${n}${o}`
})
  , Rn = ad("deg")
  , Ur = ad("%")
  , be = ad("px")
  , JU = ad("vh")
  , XU = ad("vw")
  , ZS = {
    ...Ur,
    parse: o => Ur.parse(o) / 100,
    transform: o => Ur.transform(o * 100)
}
  , ha = {
    test: yw("hsl", "hue"),
    parse: GM("hue", "saturation", "lightness"),
    transform: ({hue: o, saturation: n, lightness: a, alpha: c=1}) => "hsla(" + Math.round(o) + ", " + Ur.transform(kc(n)) + ", " + Ur.transform(kc(a)) + ", " + kc(Oc.transform(c)) + ")"
}
  , Et = {
    test: o => Ki.test(o) || jk.test(o) || ha.test(o),
    parse: o => Ki.test(o) ? Ki.parse(o) : ha.test(o) ? ha.parse(o) : jk.parse(o),
    transform: o => typeof o == "string" ? o : o.hasOwnProperty("red") ? Ki.transform(o) : ha.transform(o),
    getAnimatableNone: o => {
        const n = Et.parse(o);
        return n.alpha = 0,
        Et.transform(n)
    }
}
  , eH = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
function tH(o) {
    var n, a;
    return isNaN(o) && typeof o == "string" && (((n = o.match(Cw)) == null ? void 0 : n.length) || 0) + (((a = o.match(eH)) == null ? void 0 : a.length) || 0) > 0
}
const KM = "number"
  , YM = "color"
  , oH = "var"
  , rH = "var("
  , JS = "${}"
  , nH = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function Rc(o) {
    const n = o.toString()
      , a = []
      , c = {
        color: [],
        number: [],
        var: []
    }
      , u = [];
    let p = 0;
    const f = n.replace(nH, w => (Et.test(w) ? (c.color.push(p),
    u.push(YM),
    a.push(Et.parse(w))) : w.startsWith(rH) ? (c.var.push(p),
    u.push(oH),
    a.push(w)) : (c.number.push(p),
    u.push(KM),
    a.push(parseFloat(w))),
    ++p,
    JS)).split(JS);
    return {
        values: a,
        split: f,
        indexes: c,
        types: u
    }
}
function QM(o) {
    return Rc(o).values
}
function ZM(o) {
    const {split: n, types: a} = Rc(o)
      , c = n.length;
    return u => {
        let p = "";
        for (let f = 0; f < c; f++)
            if (p += n[f],
            u[f] !== void 0) {
                const w = a[f];
                w === KM ? p += kc(u[f]) : w === YM ? p += Et.transform(u[f]) : p += u[f]
            }
        return p
    }
}
const iH = o => typeof o == "number" ? 0 : Et.test(o) ? Et.getAnimatableNone(o) : o;
function sH(o) {
    const n = QM(o);
    return ZM(o)(n.map(iH))
}
const mi = {
    test: tH,
    parse: QM,
    createTransformer: ZM,
    getAnimatableNone: sH
};
function _f(o, n, a) {
    return a < 0 && (a += 1),
    a > 1 && (a -= 1),
    a < 1 / 6 ? o + (n - o) * 6 * a : a < 1 / 2 ? n : a < 2 / 3 ? o + (n - o) * (2 / 3 - a) * 6 : o
}
function aH({hue: o, saturation: n, lightness: a, alpha: c}) {
    o /= 360,
    n /= 100,
    a /= 100;
    let u = 0
      , p = 0
      , f = 0;
    if (!n)
        u = p = f = a;
    else {
        const w = a < .5 ? a * (1 + n) : a + n - a * n
          , k = 2 * a - w;
        u = _f(k, w, o + 1 / 3),
        p = _f(k, w, o),
        f = _f(k, w, o - 1 / 3)
    }
    return {
        red: Math.round(u * 255),
        green: Math.round(p * 255),
        blue: Math.round(f * 255),
        alpha: c
    }
}
function Yh(o, n) {
    return a => a > 0 ? n : o
}
const ut = (o, n, a) => o + (n - o) * a
  , Cf = (o, n, a) => {
    const c = o * o
      , u = a * (n * n - c) + c;
    return u < 0 ? 0 : Math.sqrt(u)
}
  , lH = [jk, Ki, ha]
  , cH = o => lH.find(n => n.test(o));
function XS(o) {
    const n = cH(o);
    if (!n)
        return !1;
    let a = n.parse(o);
    return n === ha && (a = aH(a)),
    a
}
const e2 = (o, n) => {
    const a = XS(o)
      , c = XS(n);
    if (!a || !c)
        return Yh(o, n);
    const u = {
        ...a
    };
    return p => (u.red = Cf(a.red, c.red, p),
    u.green = Cf(a.green, c.green, p),
    u.blue = Cf(a.blue, c.blue, p),
    u.alpha = ut(a.alpha, c.alpha, p),
    Ki.transform(u))
}
  , Lk = new Set(["none", "hidden"]);
function dH(o, n) {
    return Lk.has(o) ? a => a <= 0 ? o : n : a => a >= 1 ? n : o
}
function uH(o, n) {
    return a => ut(o, n, a)
}
function xw(o) {
    return typeof o == "number" ? uH : typeof o == "string" ? _w(o) ? Yh : Et.test(o) ? e2 : pH : Array.isArray(o) ? JM : typeof o == "object" ? Et.test(o) ? e2 : hH : Yh
}
function JM(o, n) {
    const a = [...o]
      , c = a.length
      , u = o.map( (p, f) => xw(p)(p, n[f]));
    return p => {
        for (let f = 0; f < c; f++)
            a[f] = u[f](p);
        return a
    }
}
function hH(o, n) {
    const a = {
        ...o,
        ...n
    }
      , c = {};
    for (const u in a)
        o[u] !== void 0 && n[u] !== void 0 && (c[u] = xw(o[u])(o[u], n[u]));
    return u => {
        for (const p in c)
            a[p] = c[p](u);
        return a
    }
}
function mH(o, n) {
    const a = []
      , c = {
        color: 0,
        var: 0,
        number: 0
    };
    for (let u = 0; u < n.values.length; u++) {
        const p = n.types[u]
          , f = o.indexes[p][c[p]]
          , w = o.values[f] ?? 0;
        a[u] = w,
        c[p]++
    }
    return a
}
const pH = (o, n) => {
    const a = mi.createTransformer(n)
      , c = Rc(o)
      , u = Rc(n);
    return c.indexes.var.length === u.indexes.var.length && c.indexes.color.length === u.indexes.color.length && c.indexes.number.length >= u.indexes.number.length ? Lk.has(o) && !u.values.length || Lk.has(n) && !c.values.length ? dH(o, n) : id(JM(mH(c, u), u.values), a) : Yh(o, n)
}
;
function XM(o, n, a) {
    return typeof o == "number" && typeof n == "number" && typeof a == "number" ? ut(o, n, a) : xw(o)(o, n)
}
const gH = o => {
    const n = ({timestamp: a}) => o(a);
    return {
        start: (a=!0) => lt.update(n, a),
        stop: () => hi(n),
        now: () => $t.isProcessing ? $t.timestamp : wo.now()
    }
}
  , e5 = (o, n, a=10) => {
    let c = "";
    const u = Math.max(Math.round(n / a), 2);
    for (let p = 0; p < u; p++)
        c += Math.round(o(p / (u - 1)) * 1e4) / 1e4 + ", ";
    return `linear(${c.substring(0, c.length - 2)})`
}
  , Qh = 2e4;
function Ew(o) {
    let n = 0;
    const a = 50;
    let c = o.next(n);
    for (; !c.done && n < Qh; )
        n += a,
        c = o.next(n);
    return n >= Qh ? 1 / 0 : n
}
function fH(o, n=100, a) {
    const c = a({
        ...o,
        keyframes: [0, n]
    })
      , u = Math.min(Ew(c), Qh);
    return {
        type: "keyframes",
        ease: p => c.next(u * p).value / n,
        duration: ir(u)
    }
}
const kH = 5;
function t5(o, n, a) {
    const c = Math.max(n - kH, 0);
    return PM(a - o(c), n - c)
}
const ft = {
    stiffness: 100,
    damping: 10,
    mass: 1,
    velocity: 0,
    duration: 800,
    bounce: .3,
    visualDuration: .3,
    restSpeed: {
        granular: .01,
        default: 2
    },
    restDelta: {
        granular: .005,
        default: .5
    },
    minDuration: .01,
    maxDuration: 10,
    minDamping: .05,
    maxDamping: 1
}
  , yf = .001;
function bH({duration: o=ft.duration, bounce: n=ft.bounce, velocity: a=ft.velocity, mass: c=ft.mass}) {
    let u, p, f = 1 - n;
    f = yn(ft.minDamping, ft.maxDamping, f),
    o = yn(ft.minDuration, ft.maxDuration, ir(o)),
    f < 1 ? (u = y => {
        const E = y * f
          , S = E * o
          , A = E - a
          , D = zk(y, f)
          , N = Math.exp(-S);
        return yf - A / D * N
    }
    ,
    p = y => {
        const E = y * f * o
          , S = E * a + a
          , A = Math.pow(f, 2) * Math.pow(y, 2) * o
          , D = Math.exp(-E)
          , N = zk(Math.pow(y, 2), f);
        return (-u(y) + yf > 0 ? -1 : 1) * ((S - A) * D) / N
    }
    ) : (u = y => {
        const E = Math.exp(-y * o)
          , S = (y - a) * o + 1;
        return -yf + E * S
    }
    ,
    p = y => {
        const E = Math.exp(-y * o)
          , S = (a - y) * (o * o);
        return E * S
    }
    );
    const w = 5 / o
      , k = AH(u, p, w);
    if (o = Vr(o),
    isNaN(k))
        return {
            stiffness: ft.stiffness,
            damping: ft.damping,
            duration: o
        };
    {
        const y = Math.pow(k, 2) * c;
        return {
            stiffness: y,
            damping: f * 2 * Math.sqrt(c * y),
            duration: o
        }
    }
}
const wH = 12;
function AH(o, n, a) {
    let c = a;
    for (let u = 1; u < wH; u++)
        c = c - o(c) / n(c);
    return c
}
function zk(o, n) {
    return o * Math.sqrt(1 - n * n)
}
const vH = ["duration", "bounce"]
  , _H = ["stiffness", "damping", "mass"];
function t2(o, n) {
    return n.some(a => o[a] !== void 0)
}
function CH(o) {
    let n = {
        velocity: ft.velocity,
        stiffness: ft.stiffness,
        damping: ft.damping,
        mass: ft.mass,
        isResolvedFromDuration: !1,
        ...o
    };
    if (!t2(o, _H) && t2(o, vH))
        if (o.visualDuration) {
            const a = o.visualDuration
              , c = 2 * Math.PI / (a * 1.2)
              , u = c * c
              , p = 2 * yn(.05, 1, 1 - (o.bounce || 0)) * Math.sqrt(u);
            n = {
                ...n,
                mass: ft.mass,
                stiffness: u,
                damping: p
            }
        } else {
            const a = bH(o);
            n = {
                ...n,
                ...a,
                mass: ft.mass
            },
            n.isResolvedFromDuration = !0
        }
    return n
}
function Zh(o=ft.visualDuration, n=ft.bounce) {
    const a = typeof o != "object" ? {
        visualDuration: o,
        keyframes: [0, 1],
        bounce: n
    } : o;
    let {restSpeed: c, restDelta: u} = a;
    const p = a.keyframes[0]
      , f = a.keyframes[a.keyframes.length - 1]
      , w = {
        done: !1,
        value: p
    }
      , {stiffness: k, damping: y, mass: E, duration: S, velocity: A, isResolvedFromDuration: D} = CH({
        ...a,
        velocity: -ir(a.velocity || 0)
    })
      , N = A || 0
      , L = y / (2 * Math.sqrt(k * E))
      , z = f - p
      , B = ir(Math.sqrt(k / E))
      , M = Math.abs(z) < 5;
    c || (c = M ? ft.restSpeed.granular : ft.restSpeed.default),
    u || (u = M ? ft.restDelta.granular : ft.restDelta.default);
    let j;
    if (L < 1) {
        const G = zk(B, L);
        j = Y => {
            const $ = Math.exp(-L * B * Y);
            return f - $ * ((N + L * B * z) / G * Math.sin(G * Y) + z * Math.cos(G * Y))
        }
    } else if (L === 1)
        j = G => f - Math.exp(-B * G) * (z + (N + B * z) * G);
    else {
        const G = B * Math.sqrt(L * L - 1);
        j = Y => {
            const $ = Math.exp(-L * B * Y)
              , K = Math.min(G * Y, 300);
            return f - $ * ((N + L * B * z) * Math.sinh(K) + G * z * Math.cosh(K)) / G
        }
    }
    const V = {
        calculatedDuration: D && S || null,
        next: G => {
            const Y = j(G);
            if (D)
                w.done = G >= S;
            else {
                let $ = G === 0 ? N : 0;
                L < 1 && ($ = G === 0 ? Vr(N) : t5(j, G, Y));
                const K = Math.abs($) <= c
                  , Z = Math.abs(f - Y) <= u;
                w.done = K && Z
            }
            return w.value = w.done ? f : Y,
            w
        }
        ,
        toString: () => {
            const G = Math.min(Ew(V), Qh)
              , Y = e5($ => V.next(G * $).value, G, 30);
            return G + "ms " + Y
        }
        ,
        toTransition: () => {}
    };
    return V
}
Zh.applyToOptions = o => {
    const n = fH(o, 100, Zh);
    return o.ease = n.ease,
    o.duration = Vr(n.duration),
    o.type = "keyframes",
    o
}
;
function Ok({keyframes: o, velocity: n=0, power: a=.8, timeConstant: c=325, bounceDamping: u=10, bounceStiffness: p=500, modifyTarget: f, min: w, max: k, restDelta: y=.5, restSpeed: E}) {
    const S = o[0]
      , A = {
        done: !1,
        value: S
    }
      , D = K => w !== void 0 && K < w || k !== void 0 && K > k
      , N = K => w === void 0 ? k : k === void 0 || Math.abs(w - K) < Math.abs(k - K) ? w : k;
    let L = a * n;
    const z = S + L
      , B = f === void 0 ? z : f(z);
    B !== z && (L = B - S);
    const M = K => -L * Math.exp(-K / c)
      , j = K => B + M(K)
      , V = K => {
        const Z = M(K)
          , H = j(K);
        A.done = Math.abs(Z) <= y,
        A.value = A.done ? B : H
    }
    ;
    let G, Y;
    const $ = K => {
        D(A.value) && (G = K,
        Y = Zh({
            keyframes: [A.value, N(A.value)],
            velocity: t5(j, K, A.value),
            damping: u,
            stiffness: p,
            restDelta: y,
            restSpeed: E
        }))
    }
    ;
    return $(0),
    {
        calculatedDuration: null,
        next: K => {
            let Z = !1;
            return !Y && G === void 0 && (Z = !0,
            V(K),
            $(K)),
            G !== void 0 && K >= G ? Y.next(K - G) : (!Z && V(K),
            A)
        }
    }
}
function yH(o, n, a) {
    const c = []
      , u = a || xn.mix || XM
      , p = o.length - 1;
    for (let f = 0; f < p; f++) {
        let w = u(o[f], o[f + 1]);
        if (n) {
            const k = Array.isArray(n) ? n[f] || ar : n;
            w = id(k, w)
        }
        c.push(w)
    }
    return c
}
function xH(o, n, {clamp: a=!0, ease: c, mixer: u}={}) {
    const p = o.length;
    if (fw(p === n.length),
    p === 1)
        return () => n[0];
    if (p === 2 && n[0] === n[1])
        return () => n[1];
    const f = o[0] === o[1];
    o[0] > o[p - 1] && (o = [...o].reverse(),
    n = [...n].reverse());
    const w = yH(n, c, u)
      , k = w.length
      , y = E => {
        if (f && E < o[0])
            return n[0];
        let S = 0;
        if (k > 1)
            for (; S < o.length - 2 && !(E < o[S + 1]); S++)
                ;
        const A = zc(o[S], o[S + 1], E);
        return w[S](A)
    }
    ;
    return a ? E => y(yn(o[0], o[p - 1], E)) : y
}
function EH(o, n) {
    const a = o[o.length - 1];
    for (let c = 1; c <= n; c++) {
        const u = zc(0, n, c);
        o.push(ut(a, 1, u))
    }
}
function SH(o) {
    const n = [0];
    return EH(n, o.length - 1),
    n
}
function DH(o, n) {
    return o.map(a => a * n)
}
function TH(o, n) {
    return o.map( () => n || HM).splice(0, o.length - 1)
}
function bc({duration: o=300, keyframes: n, times: a, ease: c="easeInOut"}) {
    const u = FU(c) ? c.map(QS) : QS(c)
      , p = {
        done: !1,
        value: n[0]
    }
      , f = DH(a && a.length === n.length ? a : SH(n), o)
      , w = xH(f, n, {
        ease: Array.isArray(u) ? u : TH(n, u)
    });
    return {
        calculatedDuration: o,
        next: k => (p.value = w(k),
        p.done = k >= o,
        p)
    }
}
const IH = o => o !== null;
function Sw(o, {repeat: n, repeatType: a="loop"}, c, u=1) {
    const p = o.filter(IH)
      , f = u < 0 || n && a !== "loop" && n % 2 === 1 ? 0 : p.length - 1;
    return !f || c === void 0 ? p[f] : c
}
const MH = {
    decay: Ok,
    inertia: Ok,
    tween: bc,
    keyframes: bc,
    spring: Zh
};
function o5(o) {
    typeof o.type == "string" && (o.type = MH[o.type])
}
class Dw {
    constructor() {
        this.updateFinished()
    }
    get finished() {
        return this._finished
    }
    updateFinished() {
        this._finished = new Promise(n => {
            this.resolve = n
        }
        )
    }
    notifyFinished() {
        this.resolve()
    }
    then(n, a) {
        return this.finished.then(n, a)
    }
}
const BH = o => o / 100;
class Tw extends Dw {
    constructor(n) {
        super(),
        this.state = "idle",
        this.startTime = null,
        this.isStopped = !1,
        this.currentTime = 0,
        this.holdTime = null,
        this.playbackSpeed = 1,
        this.stop = () => {
            var a, c;
            const {motionValue: u} = this.options;
            u && u.updatedAt !== wo.now() && this.tick(wo.now()),
            this.isStopped = !0,
            this.state !== "idle" && (this.teardown(),
            (c = (a = this.options).onStop) == null || c.call(a))
        }
        ,
        this.options = n,
        this.initAnimation(),
        this.play(),
        n.autoplay === !1 && this.pause()
    }
    initAnimation() {
        const {options: n} = this;
        o5(n);
        const {type: a=bc, repeat: c=0, repeatDelay: u=0, repeatType: p, velocity: f=0} = n;
        let {keyframes: w} = n;
        const k = a || bc;
        k !== bc && typeof w[0] != "number" && (this.mixKeyframes = id(BH, XM(w[0], w[1])),
        w = [0, 100]);
        const y = k({
            ...n,
            keyframes: w
        });
        p === "mirror" && (this.mirroredGenerator = k({
            ...n,
            keyframes: [...w].reverse(),
            velocity: -f
        })),
        y.calculatedDuration === null && (y.calculatedDuration = Ew(y));
        const {calculatedDuration: E} = y;
        this.calculatedDuration = E,
        this.resolvedDuration = E + u,
        this.totalDuration = this.resolvedDuration * (c + 1) - u,
        this.generator = y
    }
    updateTime(n) {
        const a = Math.round(n - this.startTime) * this.playbackSpeed;
        this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = a
    }
    tick(n, a=!1) {
        const {generator: c, totalDuration: u, mixKeyframes: p, mirroredGenerator: f, resolvedDuration: w, calculatedDuration: k} = this;
        if (this.startTime === null)
            return c.next(0);
        const {delay: y=0, keyframes: E, repeat: S, repeatType: A, repeatDelay: D, type: N, onUpdate: L, finalKeyframe: z} = this.options;
        this.speed > 0 ? this.startTime = Math.min(this.startTime, n) : this.speed < 0 && (this.startTime = Math.min(n - u / this.speed, this.startTime)),
        a ? this.currentTime = n : this.updateTime(n);
        const B = this.currentTime - y * (this.playbackSpeed >= 0 ? 1 : -1)
          , M = this.playbackSpeed >= 0 ? B < 0 : B > u;
        this.currentTime = Math.max(B, 0),
        this.state === "finished" && this.holdTime === null && (this.currentTime = u);
        let j = this.currentTime
          , V = c;
        if (S) {
            const K = Math.min(this.currentTime, u) / w;
            let Z = Math.floor(K)
              , H = K % 1;
            !H && K >= 1 && (H = 1),
            H === 1 && Z--,
            Z = Math.min(Z, S + 1),
            Z % 2 && (A === "reverse" ? (H = 1 - H,
            D && (H -= D / w)) : A === "mirror" && (V = f)),
            j = yn(0, 1, H) * w
        }
        const G = M ? {
            done: !1,
            value: E[0]
        } : V.next(j);
        p && (G.value = p(G.value));
        let {done: Y} = G;
        !M && k !== null && (Y = this.playbackSpeed >= 0 ? this.currentTime >= u : this.currentTime <= 0);
        const $ = this.holdTime === null && (this.state === "finished" || this.state === "running" && Y);
        return $ && N !== Ok && (G.value = Sw(E, this.options, z, this.speed)),
        L && L(G.value),
        $ && this.finish(),
        G
    }
    then(n, a) {
        return this.finished.then(n, a)
    }
    get duration() {
        return ir(this.calculatedDuration)
    }
    get iterationDuration() {
        const {delay: n=0} = this.options || {};
        return this.duration + ir(n)
    }
    get time() {
        return ir(this.currentTime)
    }
    set time(n) {
        var a;
        n = Vr(n),
        this.currentTime = n,
        this.startTime === null || this.holdTime !== null || this.playbackSpeed === 0 ? this.holdTime = n : this.driver && (this.startTime = this.driver.now() - n / this.playbackSpeed),
        (a = this.driver) == null || a.start(!1)
    }
    get speed() {
        return this.playbackSpeed
    }
    set speed(n) {
        this.updateTime(wo.now());
        const a = this.playbackSpeed !== n;
        this.playbackSpeed = n,
        a && (this.time = ir(this.currentTime))
    }
    play() {
        var n, a;
        if (this.isStopped)
            return;
        const {driver: c=gH, startTime: u} = this.options;
        this.driver || (this.driver = c(f => this.tick(f))),
        (a = (n = this.options).onPlay) == null || a.call(n);
        const p = this.driver.now();
        this.state === "finished" ? (this.updateFinished(),
        this.startTime = p) : this.holdTime !== null ? this.startTime = p - this.holdTime : this.startTime || (this.startTime = u ?? p),
        this.state === "finished" && this.speed < 0 && (this.startTime += this.calculatedDuration),
        this.holdTime = null,
        this.state = "running",
        this.driver.start()
    }
    pause() {
        this.state = "paused",
        this.updateTime(wo.now()),
        this.holdTime = this.currentTime
    }
    complete() {
        this.state !== "running" && this.play(),
        this.state = "finished",
        this.holdTime = null
    }
    finish() {
        var n, a;
        this.notifyFinished(),
        this.teardown(),
        this.state = "finished",
        (a = (n = this.options).onComplete) == null || a.call(n)
    }
    cancel() {
        var n, a;
        this.holdTime = null,
        this.startTime = 0,
        this.tick(0),
        this.teardown(),
        (a = (n = this.options).onCancel) == null || a.call(n)
    }
    teardown() {
        this.state = "idle",
        this.stopDriver(),
        this.startTime = this.holdTime = null
    }
    stopDriver() {
        this.driver && (this.driver.stop(),
        this.driver = void 0)
    }
    sample(n) {
        return this.startTime = 0,
        this.tick(n, !0)
    }
    attachTimeline(n) {
        var a;
        return this.options.allowFlatten && (this.options.type = "keyframes",
        this.options.ease = "linear",
        this.initAnimation()),
        (a = this.driver) == null || a.stop(),
        n.observe(this)
    }
}
function NH(o) {
    for (let n = 1; n < o.length; n++)
        o[n] ?? (o[n] = o[n - 1])
}
const Yi = o => o * 180 / Math.PI
  , Rk = o => {
    const n = Yi(Math.atan2(o[1], o[0]));
    return Fk(n)
}
  , PH = {
    x: 4,
    y: 5,
    translateX: 4,
    translateY: 5,
    scaleX: 0,
    scaleY: 3,
    scale: o => (Math.abs(o[0]) + Math.abs(o[3])) / 2,
    rotate: Rk,
    rotateZ: Rk,
    skewX: o => Yi(Math.atan(o[1])),
    skewY: o => Yi(Math.atan(o[2])),
    skew: o => (Math.abs(o[1]) + Math.abs(o[2])) / 2
}
  , Fk = o => (o = o % 360,
o < 0 && (o += 360),
o)
  , o2 = Rk
  , r2 = o => Math.sqrt(o[0] * o[0] + o[1] * o[1])
  , n2 = o => Math.sqrt(o[4] * o[4] + o[5] * o[5])
  , jH = {
    x: 12,
    y: 13,
    z: 14,
    translateX: 12,
    translateY: 13,
    translateZ: 14,
    scaleX: r2,
    scaleY: n2,
    scale: o => (r2(o) + n2(o)) / 2,
    rotateX: o => Fk(Yi(Math.atan2(o[6], o[5]))),
    rotateY: o => Fk(Yi(Math.atan2(-o[2], o[0]))),
    rotateZ: o2,
    rotate: o2,
    skewX: o => Yi(Math.atan(o[4])),
    skewY: o => Yi(Math.atan(o[1])),
    skew: o => (Math.abs(o[1]) + Math.abs(o[4])) / 2
};
function Vk(o) {
    return o.includes("scale") ? 1 : 0
}
function Uk(o, n) {
    if (!o || o === "none")
        return Vk(n);
    const a = o.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);
    let c, u;
    if (a)
        c = jH,
        u = a;
    else {
        const w = o.match(/^matrix\(([-\d.e\s,]+)\)$/u);
        c = PH,
        u = w
    }
    if (!u)
        return Vk(n);
    const p = c[n]
      , f = u[1].split(",").map(zH);
    return typeof p == "function" ? p(f) : f[p]
}
const LH = (o, n) => {
    const {transform: a="none"} = getComputedStyle(o);
    return Uk(a, n)
}
;
function zH(o) {
    return parseFloat(o.trim())
}
const Ka = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"]
  , Ya = new Set(Ka)
  , i2 = o => o === Ga || o === be
  , OH = new Set(["x", "y", "z"])
  , RH = Ka.filter(o => !OH.has(o));
function FH(o) {
    const n = [];
    return RH.forEach(a => {
        const c = o.getValue(a);
        c !== void 0 && (n.push([a, c.get()]),
        c.set(a.startsWith("scale") ? 1 : 0))
    }
    ),
    n
}
const ts = {
    width: ({x: o}, {paddingLeft: n="0", paddingRight: a="0"}) => o.max - o.min - parseFloat(n) - parseFloat(a),
    height: ({y: o}, {paddingTop: n="0", paddingBottom: a="0"}) => o.max - o.min - parseFloat(n) - parseFloat(a),
    top: (o, {top: n}) => parseFloat(n),
    left: (o, {left: n}) => parseFloat(n),
    bottom: ({y: o}, {top: n}) => parseFloat(n) + (o.max - o.min),
    right: ({x: o}, {left: n}) => parseFloat(n) + (o.max - o.min),
    x: (o, {transform: n}) => Uk(n, "x"),
    y: (o, {transform: n}) => Uk(n, "y")
};
ts.translateX = ts.x;
ts.translateY = ts.y;
const os = new Set;
let Hk = !1
  , Wk = !1
  , $k = !1;
function r5() {
    if (Wk) {
        const o = Array.from(os).filter(c => c.needsMeasurement)
          , n = new Set(o.map(c => c.element))
          , a = new Map;
        n.forEach(c => {
            const u = FH(c);
            u.length && (a.set(c, u),
            c.render())
        }
        ),
        o.forEach(c => c.measureInitialState()),
        n.forEach(c => {
            c.render();
            const u = a.get(c);
            u && u.forEach( ([p,f]) => {
                var w;
                (w = c.getValue(p)) == null || w.set(f)
            }
            )
        }
        ),
        o.forEach(c => c.measureEndState()),
        o.forEach(c => {
            c.suspendedScrollY !== void 0 && window.scrollTo(0, c.suspendedScrollY)
        }
        )
    }
    Wk = !1,
    Hk = !1,
    os.forEach(o => o.complete($k)),
    os.clear()
}
function n5() {
    os.forEach(o => {
        o.readKeyframes(),
        o.needsMeasurement && (Wk = !0)
    }
    )
}
function VH() {
    $k = !0,
    n5(),
    r5(),
    $k = !1
}
class Iw {
    constructor(n, a, c, u, p, f=!1) {
        this.state = "pending",
        this.isAsync = !1,
        this.needsMeasurement = !1,
        this.unresolvedKeyframes = [...n],
        this.onComplete = a,
        this.name = c,
        this.motionValue = u,
        this.element = p,
        this.isAsync = f
    }
    scheduleResolve() {
        this.state = "scheduled",
        this.isAsync ? (os.add(this),
        Hk || (Hk = !0,
        lt.read(n5),
        lt.resolveKeyframes(r5))) : (this.readKeyframes(),
        this.complete())
    }
    readKeyframes() {
        const {unresolvedKeyframes: n, name: a, element: c, motionValue: u} = this;
        if (n[0] === null) {
            const p = u == null ? void 0 : u.get()
              , f = n[n.length - 1];
            if (p !== void 0)
                n[0] = p;
            else if (c && a) {
                const w = c.readValue(a, f);
                w != null && (n[0] = w)
            }
            n[0] === void 0 && (n[0] = f),
            u && p === void 0 && u.set(n[0])
        }
        NH(n)
    }
    setFinalKeyframe() {}
    measureInitialState() {}
    renderEndStyles() {}
    measureEndState() {}
    complete(n=!1) {
        this.state = "complete",
        this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, n),
        os.delete(this)
    }
    cancel() {
        this.state === "scheduled" && (os.delete(this),
        this.state = "pending")
    }
    resume() {
        this.state === "pending" && this.scheduleResolve()
    }
}
const UH = o => o.startsWith("--");
function HH(o, n, a) {
    UH(n) ? o.style.setProperty(n, a) : o.style[n] = a
}
const WH = kw( () => window.ScrollTimeline !== void 0)
  , $H = {};
function qH(o, n) {
    const a = kw(o);
    return () => $H[n] ?? a()
}
const i5 = qH( () => {
    try {
        document.createElement("div").animate({
            opacity: 0
        }, {
            easing: "linear(0, 1)"
        })
    } catch {
        return !1
    }
    return !0
}
, "linearEasing")
  , oc = ([o,n,a,c]) => `cubic-bezier(${o}, ${n}, ${a}, ${c})`
  , s2 = {
    linear: "linear",
    ease: "ease",
    easeIn: "ease-in",
    easeOut: "ease-out",
    easeInOut: "ease-in-out",
    circIn: oc([0, .65, .55, 1]),
    circOut: oc([.55, 0, 1, .45]),
    backIn: oc([.31, .01, .66, -.59]),
    backOut: oc([.33, 1.53, .69, .99])
};
function s5(o, n) {
    if (o)
        return typeof o == "function" ? i5() ? e5(o, n) : "ease-out" : WM(o) ? oc(o) : Array.isArray(o) ? o.map(a => s5(a, n) || s2.easeOut) : s2[o]
}
function GH(o, n, a, {delay: c=0, duration: u=300, repeat: p=0, repeatType: f="loop", ease: w="easeOut", times: k}={}, y=void 0) {
    const E = {
        [n]: a
    };
    k && (E.offset = k);
    const S = s5(w, u);
    Array.isArray(S) && (E.easing = S);
    const A = {
        delay: c,
        duration: u,
        easing: Array.isArray(S) ? "linear" : S,
        fill: "both",
        iterations: p + 1,
        direction: f === "reverse" ? "alternate" : "normal"
    };
    return y && (A.pseudoElement = y),
    o.animate(E, A)
}
function a5(o) {
    return typeof o == "function" && "applyToOptions"in o
}
function KH({type: o, ...n}) {
    return a5(o) && i5() ? o.applyToOptions(n) : (n.duration ?? (n.duration = 300),
    n.ease ?? (n.ease = "easeOut"),
    n)
}
class YH extends Dw {
    constructor(n) {
        if (super(),
        this.finishedTime = null,
        this.isStopped = !1,
        !n)
            return;
        const {element: a, name: c, keyframes: u, pseudoElement: p, allowFlatten: f=!1, finalKeyframe: w, onComplete: k} = n;
        this.isPseudoElement = !!p,
        this.allowFlatten = f,
        this.options = n,
        fw(typeof n.type != "string");
        const y = KH(n);
        this.animation = GH(a, c, u, y, p),
        y.autoplay === !1 && this.animation.pause(),
        this.animation.onfinish = () => {
            if (this.finishedTime = this.time,
            !p) {
                const E = Sw(u, this.options, w, this.speed);
                this.updateMotionValue ? this.updateMotionValue(E) : HH(a, c, E),
                this.animation.cancel()
            }
            k == null || k(),
            this.notifyFinished()
        }
    }
    play() {
        this.isStopped || (this.animation.play(),
        this.state === "finished" && this.updateFinished())
    }
    pause() {
        this.animation.pause()
    }
    complete() {
        var n, a;
        (a = (n = this.animation).finish) == null || a.call(n)
    }
    cancel() {
        try {
            this.animation.cancel()
        } catch {}
    }
    stop() {
        if (this.isStopped)
            return;
        this.isStopped = !0;
        const {state: n} = this;
        n === "idle" || n === "finished" || (this.updateMotionValue ? this.updateMotionValue() : this.commitStyles(),
        this.isPseudoElement || this.cancel())
    }
    commitStyles() {
        var n, a;
        this.isPseudoElement || (a = (n = this.animation).commitStyles) == null || a.call(n)
    }
    get duration() {
        var n, a;
        const c = ((a = (n = this.animation.effect) == null ? void 0 : n.getComputedTiming) == null ? void 0 : a.call(n).duration) || 0;
        return ir(Number(c))
    }
    get iterationDuration() {
        const {delay: n=0} = this.options || {};
        return this.duration + ir(n)
    }
    get time() {
        return ir(Number(this.animation.currentTime) || 0)
    }
    set time(n) {
        this.finishedTime = null,
        this.animation.currentTime = Vr(n)
    }
    get speed() {
        return this.animation.playbackRate
    }
    set speed(n) {
        n < 0 && (this.finishedTime = null),
        this.animation.playbackRate = n
    }
    get state() {
        return this.finishedTime !== null ? "finished" : this.animation.playState
    }
    get startTime() {
        return Number(this.animation.startTime)
    }
    set startTime(n) {
        this.animation.startTime = n
    }
    attachTimeline({timeline: n, observe: a}) {
        var c;
        return this.allowFlatten && ((c = this.animation.effect) == null || c.updateTiming({
            easing: "linear"
        })),
        this.animation.onfinish = null,
        n && WH() ? (this.animation.timeline = n,
        ar) : a(this)
    }
}
const l5 = {
    anticipate: FM,
    backInOut: RM,
    circInOut: UM
};
function QH(o) {
    return o in l5
}
function ZH(o) {
    typeof o.ease == "string" && QH(o.ease) && (o.ease = l5[o.ease])
}
const a2 = 10;
class JH extends YH {
    constructor(n) {
        ZH(n),
        o5(n),
        super(n),
        n.startTime && (this.startTime = n.startTime),
        this.options = n
    }
    updateMotionValue(n) {
        const {motionValue: a, onUpdate: c, onComplete: u, element: p, ...f} = this.options;
        if (!a)
            return;
        if (n !== void 0) {
            a.set(n);
            return
        }
        const w = new Tw({
            ...f,
            autoplay: !1
        })
          , k = Vr(this.finishedTime ?? this.time);
        a.setWithVelocity(w.sample(k - a2).value, w.sample(k).value, a2),
        w.stop()
    }
}
const l2 = (o, n) => n === "zIndex" ? !1 : !!(typeof o == "number" || Array.isArray(o) || typeof o == "string" && (mi.test(o) || o === "0") && !o.startsWith("url("));
function XH(o) {
    const n = o[0];
    if (o.length === 1)
        return !0;
    for (let a = 0; a < o.length; a++)
        if (o[a] !== n)
            return !0
}
function eW(o, n, a, c) {
    const u = o[0];
    if (u === null)
        return !1;
    if (n === "display" || n === "visibility")
        return !0;
    const p = o[o.length - 1]
      , f = l2(u, n)
      , w = l2(p, n);
    return !f || !w ? !1 : XH(o) || (a === "spring" || a5(a)) && c
}
function qk(o) {
    o.duration = 0,
    o.type = "keyframes"
}
const tW = new Set(["opacity", "clipPath", "filter", "transform"])
  , oW = kw( () => Object.hasOwnProperty.call(Element.prototype, "animate"));
function rW(o) {
    var n;
    const {motionValue: a, name: c, repeatDelay: u, repeatType: p, damping: f, type: w} = o;
    if (!(((n = a == null ? void 0 : a.owner) == null ? void 0 : n.current)instanceof HTMLElement))
        return !1;
    const {onUpdate: k, transformTemplate: y} = a.owner.getProps();
    return oW() && c && tW.has(c) && (c !== "transform" || !y) && !k && !u && p !== "mirror" && f !== 0 && w !== "inertia"
}
const nW = 40;
class iW extends Dw {
    constructor({autoplay: n=!0, delay: a=0, type: c="keyframes", repeat: u=0, repeatDelay: p=0, repeatType: f="loop", keyframes: w, name: k, motionValue: y, element: E, ...S}) {
        var A;
        super(),
        this.stop = () => {
            var L, z;
            this._animation && (this._animation.stop(),
            (L = this.stopTimeline) == null || L.call(this)),
            (z = this.keyframeResolver) == null || z.cancel()
        }
        ,
        this.createdAt = wo.now();
        const D = {
            autoplay: n,
            delay: a,
            type: c,
            repeat: u,
            repeatDelay: p,
            repeatType: f,
            name: k,
            motionValue: y,
            element: E,
            ...S
        }
          , N = (E == null ? void 0 : E.KeyframeResolver) || Iw;
        this.keyframeResolver = new N(w, (L, z, B) => this.onKeyframesResolved(L, z, D, !B),k,y,E),
        (A = this.keyframeResolver) == null || A.scheduleResolve()
    }
    onKeyframesResolved(n, a, c, u) {
        this.keyframeResolver = void 0;
        const {name: p, type: f, velocity: w, delay: k, isHandoff: y, onUpdate: E} = c;
        this.resolvedAt = wo.now(),
        eW(n, p, f, w) || ((xn.instantAnimations || !k) && (E == null || E(Sw(n, c, a))),
        n[0] = n[n.length - 1],
        qk(c),
        c.repeat = 0);
        const S = {
            startTime: u ? this.resolvedAt ? this.resolvedAt - this.createdAt > nW ? this.resolvedAt : this.createdAt : this.createdAt : void 0,
            finalKeyframe: a,
            ...c,
            keyframes: n
        }
          , A = !y && rW(S) ? new JH({
            ...S,
            element: S.motionValue.owner.current
        }) : new Tw(S);
        A.finished.then( () => this.notifyFinished()).catch(ar),
        this.pendingTimeline && (this.stopTimeline = A.attachTimeline(this.pendingTimeline),
        this.pendingTimeline = void 0),
        this._animation = A
    }
    get finished() {
        return this._animation ? this.animation.finished : this._finished
    }
    then(n, a) {
        return this.finished.finally(n).then( () => {}
        )
    }
    get animation() {
        var n;
        return this._animation || ((n = this.keyframeResolver) == null || n.resume(),
        VH()),
        this._animation
    }
    get duration() {
        return this.animation.duration
    }
    get iterationDuration() {
        return this.animation.iterationDuration
    }
    get time() {
        return this.animation.time
    }
    set time(n) {
        this.animation.time = n
    }
    get speed() {
        return this.animation.speed
    }
    get state() {
        return this.animation.state
    }
    set speed(n) {
        this.animation.speed = n
    }
    get startTime() {
        return this.animation.startTime
    }
    attachTimeline(n) {
        return this._animation ? this.stopTimeline = this.animation.attachTimeline(n) : this.pendingTimeline = n,
        () => this.stop()
    }
    play() {
        this.animation.play()
    }
    pause() {
        this.animation.pause()
    }
    complete() {
        this.animation.complete()
    }
    cancel() {
        var n;
        this._animation && this.animation.cancel(),
        (n = this.keyframeResolver) == null || n.cancel()
    }
}
const sW = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;
function aW(o) {
    const n = sW.exec(o);
    if (!n)
        return [, ];
    const [,a,c,u] = n;
    return [`--${a ?? c}`, u]
}
function c5(o, n, a=1) {
    const [c,u] = aW(o);
    if (!c)
        return;
    const p = window.getComputedStyle(n).getPropertyValue(c);
    if (p) {
        const f = p.trim();
        return MM(f) ? parseFloat(f) : f
    }
    return _w(u) ? c5(u, n, a + 1) : u
}
function Mw(o, n) {
    return (o == null ? void 0 : o[n]) ?? (o == null ? void 0 : o.default) ?? o
}
const d5 = new Set(["width", "height", "top", "left", "right", "bottom", ...Ka])
  , lW = {
    test: o => o === "auto",
    parse: o => o
}
  , u5 = o => n => n.test(o)
  , h5 = [Ga, be, Ur, Rn, XU, JU, lW]
  , c2 = o => h5.find(u5(o));
function cW(o) {
    return typeof o == "number" ? o === 0 : o !== null ? o === "none" || o === "0" || NM(o) : !0
}
const dW = new Set(["brightness", "contrast", "saturate", "opacity"]);
function uW(o) {
    const [n,a] = o.slice(0, -1).split("(");
    if (n === "drop-shadow")
        return o;
    const [c] = a.match(Cw) || [];
    if (!c)
        return o;
    const u = a.replace(c, "");
    let p = dW.has(n) ? 1 : 0;
    return c !== a && (p *= 100),
    n + "(" + p + u + ")"
}
const hW = /\b([a-z-]*)\(.*?\)/gu
  , Gk = {
    ...mi,
    getAnimatableNone: o => {
        const n = o.match(hW);
        return n ? n.map(uW).join(" ") : o
    }
}
  , d2 = {
    ...Ga,
    transform: Math.round
}
  , mW = {
    rotate: Rn,
    rotateX: Rn,
    rotateY: Rn,
    rotateZ: Rn,
    scale: Ku,
    scaleX: Ku,
    scaleY: Ku,
    scaleZ: Ku,
    skew: Rn,
    skewX: Rn,
    skewY: Rn,
    distance: be,
    translateX: be,
    translateY: be,
    translateZ: be,
    x: be,
    y: be,
    z: be,
    perspective: be,
    transformPerspective: be,
    opacity: Oc,
    originX: ZS,
    originY: ZS,
    originZ: be
}
  , Bw = {
    borderWidth: be,
    borderTopWidth: be,
    borderRightWidth: be,
    borderBottomWidth: be,
    borderLeftWidth: be,
    borderRadius: be,
    radius: be,
    borderTopLeftRadius: be,
    borderTopRightRadius: be,
    borderBottomRightRadius: be,
    borderBottomLeftRadius: be,
    width: be,
    maxWidth: be,
    height: be,
    maxHeight: be,
    top: be,
    right: be,
    bottom: be,
    left: be,
    padding: be,
    paddingTop: be,
    paddingRight: be,
    paddingBottom: be,
    paddingLeft: be,
    margin: be,
    marginTop: be,
    marginRight: be,
    marginBottom: be,
    marginLeft: be,
    backgroundPositionX: be,
    backgroundPositionY: be,
    ...mW,
    zIndex: d2,
    fillOpacity: Oc,
    strokeOpacity: Oc,
    numOctaves: d2
}
  , pW = {
    ...Bw,
    color: Et,
    backgroundColor: Et,
    outlineColor: Et,
    fill: Et,
    stroke: Et,
    borderColor: Et,
    borderTopColor: Et,
    borderRightColor: Et,
    borderBottomColor: Et,
    borderLeftColor: Et,
    filter: Gk,
    WebkitFilter: Gk
}
  , m5 = o => pW[o];
function p5(o, n) {
    let a = m5(o);
    return a !== Gk && (a = mi),
    a.getAnimatableNone ? a.getAnimatableNone(n) : void 0
}
const gW = new Set(["auto", "none", "0"]);
function fW(o, n, a) {
    let c = 0, u;
    for (; c < o.length && !u; ) {
        const p = o[c];
        typeof p == "string" && !gW.has(p) && Rc(p).values.length && (u = o[c]),
        c++
    }
    if (u && a)
        for (const p of n)
            o[p] = p5(a, u)
}
class kW extends Iw {
    constructor(n, a, c, u, p) {
        super(n, a, c, u, p, !0)
    }
    readKeyframes() {
        const {unresolvedKeyframes: n, element: a, name: c} = this;
        if (!a || !a.current)
            return;
        super.readKeyframes();
        for (let k = 0; k < n.length; k++) {
            let y = n[k];
            if (typeof y == "string" && (y = y.trim(),
            _w(y))) {
                const E = c5(y, a.current);
                E !== void 0 && (n[k] = E),
                k === n.length - 1 && (this.finalKeyframe = y)
            }
        }
        if (this.resolveNoneKeyframes(),
        !d5.has(c) || n.length !== 2)
            return;
        const [u,p] = n
          , f = c2(u)
          , w = c2(p);
        if (f !== w)
            if (i2(f) && i2(w))
                for (let k = 0; k < n.length; k++) {
                    const y = n[k];
                    typeof y == "string" && (n[k] = parseFloat(y))
                }
            else
                ts[c] && (this.needsMeasurement = !0)
    }
    resolveNoneKeyframes() {
        const {unresolvedKeyframes: n, name: a} = this
          , c = [];
        for (let u = 0; u < n.length; u++)
            (n[u] === null || cW(n[u])) && c.push(u);
        c.length && fW(n, c, a)
    }
    measureInitialState() {
        const {element: n, unresolvedKeyframes: a, name: c} = this;
        if (!n || !n.current)
            return;
        c === "height" && (this.suspendedScrollY = window.pageYOffset),
        this.measuredOrigin = ts[c](n.measureViewportBox(), window.getComputedStyle(n.current)),
        a[0] = this.measuredOrigin;
        const u = a[a.length - 1];
        u !== void 0 && n.getValue(c, u).jump(u, !1)
    }
    measureEndState() {
        var n;
        const {element: a, name: c, unresolvedKeyframes: u} = this;
        if (!a || !a.current)
            return;
        const p = a.getValue(c);
        p && p.jump(this.measuredOrigin, !1);
        const f = u.length - 1
          , w = u[f];
        u[f] = ts[c](a.measureViewportBox(), window.getComputedStyle(a.current)),
        w !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = w),
        (n = this.removedTransforms) != null && n.length && this.removedTransforms.forEach( ([k,y]) => {
            a.getValue(k).set(y)
        }
        ),
        this.resolveNoneKeyframes()
    }
}
function bW(o, n, a) {
    if (o instanceof EventTarget)
        return [o];
    if (typeof o == "string") {
        const c = document.querySelectorAll(o);
        return c ? Array.from(c) : []
    }
    return Array.from(o)
}
const g5 = (o, n) => n && typeof o == "number" ? n.transform(o) : o;
function f5(o) {
    return BM(o) && "offsetHeight"in o
}
const u2 = 30
  , wW = o => !isNaN(parseFloat(o));
class AW {
    constructor(n, a={}) {
        this.canTrackVelocity = null,
        this.events = {},
        this.updateAndNotify = c => {
            var u;
            const p = wo.now();
            if (this.updatedAt !== p && this.setPrevFrameValue(),
            this.prev = this.current,
            this.setCurrent(c),
            this.current !== this.prev && ((u = this.events.change) == null || u.notify(this.current),
            this.dependents))
                for (const f of this.dependents)
                    f.dirty()
        }
        ,
        this.hasAnimated = !1,
        this.setCurrent(n),
        this.owner = a.owner
    }
    setCurrent(n) {
        this.current = n,
        this.updatedAt = wo.now(),
        this.canTrackVelocity === null && n !== void 0 && (this.canTrackVelocity = wW(this.current))
    }
    setPrevFrameValue(n=this.current) {
        this.prevFrameValue = n,
        this.prevUpdatedAt = this.updatedAt
    }
    onChange(n) {
        return this.on("change", n)
    }
    on(n, a) {
        this.events[n] || (this.events[n] = new bw);
        const c = this.events[n].add(a);
        return n === "change" ? () => {
            c(),
            lt.read( () => {
                this.events.change.getSize() || this.stop()
            }
            )
        }
        : c
    }
    clearListeners() {
        for (const n in this.events)
            this.events[n].clear()
    }
    attach(n, a) {
        this.passiveEffect = n,
        this.stopPassiveEffect = a
    }
    set(n) {
        this.passiveEffect ? this.passiveEffect(n, this.updateAndNotify) : this.updateAndNotify(n)
    }
    setWithVelocity(n, a, c) {
        this.set(a),
        this.prev = void 0,
        this.prevFrameValue = n,
        this.prevUpdatedAt = this.updatedAt - c
    }
    jump(n, a=!0) {
        this.updateAndNotify(n),
        this.prev = n,
        this.prevUpdatedAt = this.prevFrameValue = void 0,
        a && this.stop(),
        this.stopPassiveEffect && this.stopPassiveEffect()
    }
    dirty() {
        var n;
        (n = this.events.change) == null || n.notify(this.current)
    }
    addDependent(n) {
        this.dependents || (this.dependents = new Set),
        this.dependents.add(n)
    }
    removeDependent(n) {
        this.dependents && this.dependents.delete(n)
    }
    get() {
        return this.current
    }
    getPrevious() {
        return this.prev
    }
    getVelocity() {
        const n = wo.now();
        if (!this.canTrackVelocity || this.prevFrameValue === void 0 || n - this.updatedAt > u2)
            return 0;
        const a = Math.min(this.updatedAt - this.prevUpdatedAt, u2);
        return PM(parseFloat(this.current) - parseFloat(this.prevFrameValue), a)
    }
    start(n) {
        return this.stop(),
        new Promise(a => {
            this.hasAnimated = !0,
            this.animation = n(a),
            this.events.animationStart && this.events.animationStart.notify()
        }
        ).then( () => {
            this.events.animationComplete && this.events.animationComplete.notify(),
            this.clearAnimation()
        }
        )
    }
    stop() {
        this.animation && (this.animation.stop(),
        this.events.animationCancel && this.events.animationCancel.notify()),
        this.clearAnimation()
    }
    isAnimating() {
        return !!this.animation
    }
    clearAnimation() {
        delete this.animation
    }
    destroy() {
        var n, a;
        (n = this.dependents) == null || n.clear(),
        (a = this.events.destroy) == null || a.notify(),
        this.clearListeners(),
        this.stop(),
        this.stopPassiveEffect && this.stopPassiveEffect()
    }
}
function La(o, n) {
    return new AW(o,n)
}
const {schedule: Nw} = $M(queueMicrotask, !1)
  , vr = {
    x: !1,
    y: !1
};
function k5() {
    return vr.x || vr.y
}
function vW(o) {
    return o === "x" || o === "y" ? vr[o] ? null : (vr[o] = !0,
    () => {
        vr[o] = !1
    }
    ) : vr.x || vr.y ? null : (vr.x = vr.y = !0,
    () => {
        vr.x = vr.y = !1
    }
    )
}
function b5(o, n) {
    const a = bW(o)
      , c = new AbortController
      , u = {
        passive: !0,
        ...n,
        signal: c.signal
    };
    return [a, u, () => c.abort()]
}
function h2(o) {
    return !(o.pointerType === "touch" || k5())
}
function _W(o, n, a={}) {
    const [c,u,p] = b5(o, a)
      , f = w => {
        if (!h2(w))
            return;
        const {target: k} = w
          , y = n(k, w);
        if (typeof y != "function" || !k)
            return;
        const E = S => {
            h2(S) && (y(S),
            k.removeEventListener("pointerleave", E))
        }
        ;
        k.addEventListener("pointerleave", E, u)
    }
    ;
    return c.forEach(w => {
        w.addEventListener("pointerenter", f, u)
    }
    ),
    p
}
const w5 = (o, n) => n ? o === n ? !0 : w5(o, n.parentElement) : !1
  , Pw = o => o.pointerType === "mouse" ? typeof o.button != "number" || o.button <= 0 : o.isPrimary !== !1
  , CW = new Set(["BUTTON", "INPUT", "SELECT", "TEXTAREA", "A"]);
function yW(o) {
    return CW.has(o.tagName) || o.tabIndex !== -1
}
const gh = new WeakSet;
function m2(o) {
    return n => {
        n.key === "Enter" && o(n)
    }
}
function xf(o, n) {
    o.dispatchEvent(new PointerEvent("pointer" + n,{
        isPrimary: !0,
        bubbles: !0
    }))
}
const xW = (o, n) => {
    const a = o.currentTarget;
    if (!a)
        return;
    const c = m2( () => {
        if (gh.has(a))
            return;
        xf(a, "down");
        const u = m2( () => {
            xf(a, "up")
        }
        )
          , p = () => xf(a, "cancel");
        a.addEventListener("keyup", u, n),
        a.addEventListener("blur", p, n)
    }
    );
    a.addEventListener("keydown", c, n),
    a.addEventListener("blur", () => a.removeEventListener("keydown", c), n)
}
;
function p2(o) {
    return Pw(o) && !k5()
}
function EW(o, n, a={}) {
    const [c,u,p] = b5(o, a)
      , f = w => {
        const k = w.currentTarget;
        if (!p2(w))
            return;
        gh.add(k);
        const y = n(k, w)
          , E = (D, N) => {
            window.removeEventListener("pointerup", S),
            window.removeEventListener("pointercancel", A),
            gh.has(k) && gh.delete(k),
            p2(D) && typeof y == "function" && y(D, {
                success: N
            })
        }
          , S = D => {
            E(D, k === window || k === document || a.useGlobalTarget || w5(k, D.target))
        }
          , A = D => {
            E(D, !1)
        }
        ;
        window.addEventListener("pointerup", S, u),
        window.addEventListener("pointercancel", A, u)
    }
    ;
    return c.forEach(w => {
        (a.useGlobalTarget ? window : w).addEventListener("pointerdown", f, u),
        f5(w) && (w.addEventListener("focus", k => xW(k, u)),
        !yW(w) && !w.hasAttribute("tabindex") && (w.tabIndex = 0))
    }
    ),
    p
}
function A5(o) {
    return BM(o) && "ownerSVGElement"in o
}
function SW(o) {
    return A5(o) && o.tagName === "svg"
}
const to = o => !!(o && o.getVelocity)
  , DW = [...h5, Et, mi]
  , TW = o => DW.find(u5(o))
  , jw = R.createContext({
    transformPagePoint: o => o,
    isStatic: !1,
    reducedMotion: "never"
});
function g2(o, n) {
    if (typeof o == "function")
        return o(n);
    o != null && (o.current = n)
}
function IW(...o) {
    return n => {
        let a = !1;
        const c = o.map(u => {
            const p = g2(u, n);
            return !a && typeof p == "function" && (a = !0),
            p
        }
        );
        if (a)
            return () => {
                for (let u = 0; u < c.length; u++) {
                    const p = c[u];
                    typeof p == "function" ? p() : g2(o[u], null)
                }
            }
    }
}
function MW(...o) {
    return R.useCallback(IW(...o), o)
}
class BW extends R.Component {
    getSnapshotBeforeUpdate(n) {
        const a = this.props.childRef.current;
        if (a && n.isPresent && !this.props.isPresent) {
            const c = a.offsetParent
              , u = f5(c) && c.offsetWidth || 0
              , p = this.props.sizeRef.current;
            p.height = a.offsetHeight || 0,
            p.width = a.offsetWidth || 0,
            p.top = a.offsetTop,
            p.left = a.offsetLeft,
            p.right = u - p.width - p.left
        }
        return null
    }
    componentDidUpdate() {}
    render() {
        return this.props.children
    }
}
function NW({children: o, isPresent: n, anchorX: a, root: c}) {
    const u = R.useId()
      , p = R.useRef(null)
      , f = R.useRef({
        width: 0,
        height: 0,
        top: 0,
        left: 0,
        right: 0
    })
      , {nonce: w} = R.useContext(jw)
      , k = MW(p, o == null ? void 0 : o.ref);
    return R.useInsertionEffect( () => {
        const {width: y, height: E, top: S, left: A, right: D} = f.current;
        if (n || !p.current || !y || !E)
            return;
        const N = a === "left" ? `left: ${A}` : `right: ${D}`;
        p.current.dataset.motionPopId = u;
        const L = document.createElement("style");
        w && (L.nonce = w);
        const z = c ?? document.head;
        return z.appendChild(L),
        L.sheet && L.sheet.insertRule(`
          [data-motion-pop-id="${u}"] {
            position: absolute !important;
            width: ${y}px !important;
            height: ${E}px !important;
            ${N}px !important;
            top: ${S}px !important;
          }
        `),
        () => {
            z.contains(L) && z.removeChild(L)
        }
    }
    , [n]),
    _.jsx(BW, {
        isPresent: n,
        childRef: p,
        sizeRef: f,
        children: R.cloneElement(o, {
            ref: k
        })
    })
}
const PW = ({children: o, initial: n, isPresent: a, onExitComplete: c, custom: u, presenceAffectsLayout: p, mode: f, anchorX: w, root: k}) => {
    const y = hw(jW)
      , E = R.useId();
    let S = !0
      , A = R.useMemo( () => (S = !1,
    {
        id: E,
        initial: n,
        isPresent: a,
        custom: u,
        onExitComplete: D => {
            y.set(D, !0);
            for (const N of y.values())
                if (!N)
                    return;
            c && c()
        }
        ,
        register: D => (y.set(D, !1),
        () => y.delete(D))
    }), [a, y, c]);
    return p && S && (A = {
        ...A
    }),
    R.useMemo( () => {
        y.forEach( (D, N) => y.set(N, !1))
    }
    , [a]),
    R.useEffect( () => {
        !a && !y.size && c && c()
    }
    , [a]),
    f === "popLayout" && (o = _.jsx(NW, {
        isPresent: a,
        anchorX: w,
        root: k,
        children: o
    })),
    _.jsx(Cm.Provider, {
        value: A,
        children: o
    })
}
;
function jW() {
    return new Map
}
function v5(o=!0) {
    const n = R.useContext(Cm);
    if (n === null)
        return [!0, null];
    const {isPresent: a, onExitComplete: c, register: u} = n
      , p = R.useId();
    R.useEffect( () => {
        if (o)
            return u(p)
    }
    , [o]);
    const f = R.useCallback( () => o && c && c(p), [p, c, o]);
    return !a && c ? [!1, f] : [!0]
}
const Yu = o => o.key || "";
function f2(o) {
    const n = [];
    return R.Children.forEach(o, a => {
        R.isValidElement(a) && n.push(a)
    }
    ),
    n
}
const LW = ({children: o, custom: n, initial: a=!0, onExitComplete: c, presenceAffectsLayout: u=!0, mode: p="sync", propagate: f=!1, anchorX: w="left", root: k}) => {
    const [y,E] = v5(f)
      , S = R.useMemo( () => f2(o), [o])
      , A = f && !y ? [] : S.map(Yu)
      , D = R.useRef(!0)
      , N = R.useRef(S)
      , L = hw( () => new Map)
      , [z,B] = R.useState(S)
      , [M,j] = R.useState(S);
    IM( () => {
        D.current = !1,
        N.current = S;
        for (let Y = 0; Y < M.length; Y++) {
            const $ = Yu(M[Y]);
            A.includes($) ? L.delete($) : L.get($) !== !0 && L.set($, !1)
        }
    }
    , [M, A.length, A.join("-")]);
    const V = [];
    if (S !== z) {
        let Y = [...S];
        for (let $ = 0; $ < M.length; $++) {
            const K = M[$]
              , Z = Yu(K);
            A.includes(Z) || (Y.splice($, 0, K),
            V.push(K))
        }
        return p === "wait" && V.length && (Y = V),
        j(f2(Y)),
        B(S),
        null
    }
    const {forceRender: G} = R.useContext(uw);
    return _.jsx(_.Fragment, {
        children: M.map(Y => {
            const $ = Yu(Y)
              , K = f && !y ? !1 : S === M || A.includes($)
              , Z = () => {
                if (L.has($))
                    L.set($, !0);
                else
                    return;
                let H = !0;
                L.forEach(W => {
                    W || (H = !1)
                }
                ),
                H && (G == null || G(),
                j(N.current),
                f && (E == null || E()),
                c && c())
            }
            ;
            return _.jsx(PW, {
                isPresent: K,
                initial: !D.current || a ? void 0 : !1,
                custom: n,
                presenceAffectsLayout: u,
                mode: p,
                root: k,
                onExitComplete: K ? void 0 : Z,
                anchorX: w,
                children: Y
            }, $)
        }
        )
    })
}
  , _5 = R.createContext({
    strict: !1
})
  , k2 = {
    animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"],
    exit: ["exit"],
    drag: ["drag", "dragControls"],
    focus: ["whileFocus"],
    hover: ["whileHover", "onHoverStart", "onHoverEnd"],
    tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
    pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
    inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
    layout: ["layout", "layoutId"]
}
  , za = {};
for (const o in k2)
    za[o] = {
        isEnabled: n => k2[o].some(a => !!n[a])
    };
function zW(o) {
    for (const n in o)
        za[n] = {
            ...za[n],
            ...o[n]
        }
}
const OW = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "custom", "inherit", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "globalTapTarget", "ignoreStrict", "viewport"]);
function Jh(o) {
    return o.startsWith("while") || o.startsWith("drag") && o !== "draggable" || o.startsWith("layout") || o.startsWith("onTap") || o.startsWith("onPan") || o.startsWith("onLayout") || OW.has(o)
}
let C5 = o => !Jh(o);
function RW(o) {
    typeof o == "function" && (C5 = n => n.startsWith("on") ? !Jh(n) : o(n))
}
try {
    RW(require("@emotion/is-prop-valid").default)
} catch {}
function FW(o, n, a) {
    const c = {};
    for (const u in o)
        u === "values" && typeof o.values == "object" || (C5(u) || a === !0 && Jh(u) || !n && !Jh(u) || o.draggable && u.startsWith("onDrag")) && (c[u] = o[u]);
    return c
}
const ym = R.createContext({});
function xm(o) {
    return o !== null && typeof o == "object" && typeof o.start == "function"
}
function Fc(o) {
    return typeof o == "string" || Array.isArray(o)
}
const Lw = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"]
  , zw = ["initial", ...Lw];
function Em(o) {
    return xm(o.animate) || zw.some(n => Fc(o[n]))
}
function y5(o) {
    return !!(Em(o) || o.variants)
}
function VW(o, n) {
    if (Em(o)) {
        const {initial: a, animate: c} = o;
        return {
            initial: a === !1 || Fc(a) ? a : void 0,
            animate: Fc(c) ? c : void 0
        }
    }
    return o.inherit !== !1 ? n : {}
}
function UW(o) {
    const {initial: n, animate: a} = VW(o, R.useContext(ym));
    return R.useMemo( () => ({
        initial: n,
        animate: a
    }), [b2(n), b2(a)])
}
function b2(o) {
    return Array.isArray(o) ? o.join(" ") : o
}
const Vc = {};
function HW(o) {
    for (const n in o)
        Vc[n] = o[n],
        vw(n) && (Vc[n].isCSSVariable = !0)
}
function x5(o, {layout: n, layoutId: a}) {
    return Ya.has(o) || o.startsWith("origin") || (n || a !== void 0) && (!!Vc[o] || o === "opacity")
}
const WW = {
    x: "translateX",
    y: "translateY",
    z: "translateZ",
    transformPerspective: "perspective"
}
  , $W = Ka.length;
function qW(o, n, a) {
    let c = ""
      , u = !0;
    for (let p = 0; p < $W; p++) {
        const f = Ka[p]
          , w = o[f];
        if (w === void 0)
            continue;
        let k = !0;
        if (typeof w == "number" ? k = w === (f.startsWith("scale") ? 1 : 0) : k = parseFloat(w) === 0,
        !k || a) {
            const y = g5(w, Bw[f]);
            if (!k) {
                u = !1;
                const E = WW[f] || f;
                c += `${E}(${y}) `
            }
            a && (n[f] = y)
        }
    }
    return c = c.trim(),
    a ? c = a(n, u ? "" : c) : u && (c = "none"),
    c
}
function Ow(o, n, a) {
    const {style: c, vars: u, transformOrigin: p} = o;
    let f = !1
      , w = !1;
    for (const k in n) {
        const y = n[k];
        if (Ya.has(k)) {
            f = !0;
            continue
        } else if (vw(k)) {
            u[k] = y;
            continue
        } else {
            const E = g5(y, Bw[k]);
            k.startsWith("origin") ? (w = !0,
            p[k] = E) : c[k] = E
        }
    }
    if (n.transform || (f || a ? c.transform = qW(n, o.transform, a) : c.transform && (c.transform = "none")),
    w) {
        const {originX: k="50%", originY: y="50%", originZ: E=0} = p;
        c.transformOrigin = `${k} ${y} ${E}`
    }
}
const Rw = () => ({
    style: {},
    transform: {},
    transformOrigin: {},
    vars: {}
});
function E5(o, n, a) {
    for (const c in n)
        !to(n[c]) && !x5(c, a) && (o[c] = n[c])
}
function GW({transformTemplate: o}, n) {
    return R.useMemo( () => {
        const a = Rw();
        return Ow(a, n, o),
        Object.assign({}, a.vars, a.style)
    }
    , [n])
}
function KW(o, n) {
    const a = o.style || {}
      , c = {};
    return E5(c, a, o),
    Object.assign(c, GW(o, n)),
    c
}
function YW(o, n) {
    const a = {}
      , c = KW(o, n);
    return o.drag && o.dragListener !== !1 && (a.draggable = !1,
    c.userSelect = c.WebkitUserSelect = c.WebkitTouchCallout = "none",
    c.touchAction = o.drag === !0 ? "none" : `pan-${o.drag === "x" ? "y" : "x"}`),
    o.tabIndex === void 0 && (o.onTap || o.onTapStart || o.whileTap) && (a.tabIndex = 0),
    a.style = c,
    a
}
const QW = {
    offset: "stroke-dashoffset",
    array: "stroke-dasharray"
}
  , ZW = {
    offset: "strokeDashoffset",
    array: "strokeDasharray"
};
function JW(o, n, a=1, c=0, u=!0) {
    o.pathLength = 1;
    const p = u ? QW : ZW;
    o[p.offset] = be.transform(-c);
    const f = be.transform(n)
      , w = be.transform(a);
    o[p.array] = `${f} ${w}`
}
function S5(o, {attrX: n, attrY: a, attrScale: c, pathLength: u, pathSpacing: p=1, pathOffset: f=0, ...w}, k, y, E) {
    if (Ow(o, w, y),
    k) {
        o.style.viewBox && (o.attrs.viewBox = o.style.viewBox);
        return
    }
    o.attrs = o.style,
    o.style = {};
    const {attrs: S, style: A} = o;
    S.transform && (A.transform = S.transform,
    delete S.transform),
    (A.transform || S.transformOrigin) && (A.transformOrigin = S.transformOrigin ?? "50% 50%",
    delete S.transformOrigin),
    A.transform && (A.transformBox = (E == null ? void 0 : E.transformBox) ?? "fill-box",
    delete S.transformBox),
    n !== void 0 && (S.x = n),
    a !== void 0 && (S.y = a),
    c !== void 0 && (S.scale = c),
    u !== void 0 && JW(S, u, p, f, !1)
}
const D5 = () => ({
    ...Rw(),
    attrs: {}
})
  , T5 = o => typeof o == "string" && o.toLowerCase() === "svg";
function XW(o, n, a, c) {
    const u = R.useMemo( () => {
        const p = D5();
        return S5(p, n, T5(c), o.transformTemplate, o.style),
        {
            ...p.attrs,
            style: {
                ...p.style
            }
        }
    }
    , [n]);
    if (o.style) {
        const p = {};
        E5(p, o.style, o),
        u.style = {
            ...p,
            ...u.style
        }
    }
    return u
}
const e$ = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"];
function Fw(o) {
    return typeof o != "string" || o.includes("-") ? !1 : !!(e$.indexOf(o) > -1 || /[A-Z]/u.test(o))
}
function t$(o, n, a, {latestValues: c}, u, p=!1) {
    const f = (Fw(o) ? XW : YW)(n, c, u, o)
      , w = FW(n, typeof o == "string", p)
      , k = o !== R.Fragment ? {
        ...w,
        ...f,
        ref: a
    } : {}
      , {children: y} = n
      , E = R.useMemo( () => to(y) ? y.get() : y, [y]);
    return R.createElement(o, {
        ...k,
        children: E
    })
}
function w2(o) {
    const n = [{}, {}];
    return o == null || o.values.forEach( (a, c) => {
        n[0][c] = a.get(),
        n[1][c] = a.getVelocity()
    }
    ),
    n
}
function Vw(o, n, a, c) {
    if (typeof n == "function") {
        const [u,p] = w2(c);
        n = n(a !== void 0 ? a : o.custom, u, p)
    }
    if (typeof n == "string" && (n = o.variants && o.variants[n]),
    typeof n == "function") {
        const [u,p] = w2(c);
        n = n(a !== void 0 ? a : o.custom, u, p)
    }
    return n
}
function fh(o) {
    return to(o) ? o.get() : o
}
function o$({scrapeMotionValuesFromProps: o, createRenderState: n}, a, c, u) {
    return {
        latestValues: r$(a, c, u, o),
        renderState: n()
    }
}
function r$(o, n, a, c) {
    const u = {}
      , p = c(o, {});
    for (const A in p)
        u[A] = fh(p[A]);
    let {initial: f, animate: w} = o;
    const k = Em(o)
      , y = y5(o);
    n && y && !k && o.inherit !== !1 && (f === void 0 && (f = n.initial),
    w === void 0 && (w = n.animate));
    let E = a ? a.initial === !1 : !1;
    E = E || f === !1;
    const S = E ? w : f;
    if (S && typeof S != "boolean" && !xm(S)) {
        const A = Array.isArray(S) ? S : [S];
        for (let D = 0; D < A.length; D++) {
            const N = Vw(o, A[D]);
            if (N) {
                const {transitionEnd: L, transition: z, ...B} = N;
                for (const M in B) {
                    let j = B[M];
                    if (Array.isArray(j)) {
                        const V = E ? j.length - 1 : 0;
                        j = j[V]
                    }
                    j !== null && (u[M] = j)
                }
                for (const M in L)
                    u[M] = L[M]
            }
        }
    }
    return u
}
const I5 = o => (n, a) => {
    const c = R.useContext(ym)
      , u = R.useContext(Cm)
      , p = () => o$(o, n, c, u);
    return a ? p() : hw(p)
}
;
function Uw(o, n, a) {
    var c;
    const {style: u} = o
      , p = {};
    for (const f in u)
        (to(u[f]) || n.style && to(n.style[f]) || x5(f, o) || ((c = a == null ? void 0 : a.getValue(f)) == null ? void 0 : c.liveStyle) !== void 0) && (p[f] = u[f]);
    return p
}
const n$ = I5({
    scrapeMotionValuesFromProps: Uw,
    createRenderState: Rw
});
function M5(o, n, a) {
    const c = Uw(o, n, a);
    for (const u in o)
        if (to(o[u]) || to(n[u])) {
            const p = Ka.indexOf(u) !== -1 ? "attr" + u.charAt(0).toUpperCase() + u.substring(1) : u;
            c[p] = o[u]
        }
    return c
}
const i$ = I5({
    scrapeMotionValuesFromProps: M5,
    createRenderState: D5
})
  , s$ = Symbol.for("motionComponentSymbol");
function ma(o) {
    return o && typeof o == "object" && Object.prototype.hasOwnProperty.call(o, "current")
}
function a$(o, n, a) {
    return R.useCallback(c => {
        c && o.onMount && o.onMount(c),
        n && (c ? n.mount(c) : n.unmount()),
        a && (typeof a == "function" ? a(c) : ma(a) && (a.current = c))
    }
    , [n])
}
const Hw = o => o.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase()
  , l$ = "framerAppearId"
  , B5 = "data-" + Hw(l$)
  , N5 = R.createContext({});
function c$(o, n, a, c, u) {
    var p, f;
    const {visualElement: w} = R.useContext(ym)
      , k = R.useContext(_5)
      , y = R.useContext(Cm)
      , E = R.useContext(jw).reducedMotion
      , S = R.useRef(null);
    c = c || k.renderer,
    !S.current && c && (S.current = c(o, {
        visualState: n,
        parent: w,
        props: a,
        presenceContext: y,
        blockInitialAnimation: y ? y.initial === !1 : !1,
        reducedMotionConfig: E
    }));
    const A = S.current
      , D = R.useContext(N5);
    A && !A.projection && u && (A.type === "html" || A.type === "svg") && d$(S.current, a, u, D);
    const N = R.useRef(!1);
    R.useInsertionEffect( () => {
        A && N.current && A.update(a, y)
    }
    );
    const L = a[B5]
      , z = R.useRef(!!L && !((p = window.MotionHandoffIsComplete) != null && p.call(window, L)) && ((f = window.MotionHasOptimisedAnimation) == null ? void 0 : f.call(window, L)));
    return IM( () => {
        A && (N.current = !0,
        window.MotionIsMounted = !0,
        A.updateFeatures(),
        A.scheduleRenderMicrotask(),
        z.current && A.animationState && A.animationState.animateChanges())
    }
    ),
    R.useEffect( () => {
        A && (!z.current && A.animationState && A.animationState.animateChanges(),
        z.current && (queueMicrotask( () => {
            var B;
            (B = window.MotionHandoffMarkAsComplete) == null || B.call(window, L)
        }
        ),
        z.current = !1),
        A.enteringChildren = void 0)
    }
    ),
    A
}
function d$(o, n, a, c) {
    const {layoutId: u, layout: p, drag: f, dragConstraints: w, layoutScroll: k, layoutRoot: y, layoutCrossfade: E} = n;
    o.projection = new a(o.latestValues,n["data-framer-portal-id"] ? void 0 : P5(o.parent)),
    o.projection.setOptions({
        layoutId: u,
        layout: p,
        alwaysMeasureLayout: !!f || w && ma(w),
        visualElement: o,
        animationType: typeof p == "string" ? p : "both",
        initialPromotionConfig: c,
        crossfade: E,
        layoutScroll: k,
        layoutRoot: y
    })
}
function P5(o) {
    if (o)
        return o.options.allowProjection !== !1 ? o.projection : P5(o.parent)
}
function Ef(o, {forwardMotionProps: n=!1}={}, a, c) {
    a && zW(a);
    const u = Fw(o) ? i$ : n$;
    function p(w, k) {
        let y;
        const E = {
            ...R.useContext(jw),
            ...w,
            layoutId: u$(w)
        }
          , {isStatic: S} = E
          , A = UW(w)
          , D = u(w, S);
        if (!S && mw) {
            h$();
            const N = m$(E);
            y = N.MeasureLayout,
            A.visualElement = c$(o, D, E, c, N.ProjectionNode)
        }
        return _.jsxs(ym.Provider, {
            value: A,
            children: [y && A.visualElement ? _.jsx(y, {
                visualElement: A.visualElement,
                ...E
            }) : null, t$(o, w, a$(D, A.visualElement, k), D, S, n)]
        })
    }
    p.displayName = `motion.${typeof o == "string" ? o : `create(${o.displayName ?? o.name ?? ""})`}`;
    const f = R.forwardRef(p);
    return f[s$] = o,
    f
}
function u$({layoutId: o}) {
    const n = R.useContext(uw).id;
    return n && o !== void 0 ? n + "-" + o : o
}
function h$(o, n) {
    R.useContext(_5).strict
}
function m$(o) {
    const {drag: n, layout: a} = za;
    if (!n && !a)
        return {};
    const c = {
        ...n,
        ...a
    };
    return {
        MeasureLayout: n != null && n.isEnabled(o) || a != null && a.isEnabled(o) ? c.MeasureLayout : void 0,
        ProjectionNode: c.ProjectionNode
    }
}
function p$(o, n) {
    if (typeof Proxy > "u")
        return Ef;
    const a = new Map
      , c = (p, f) => Ef(p, f, o, n)
      , u = (p, f) => c(p, f);
    return new Proxy(u,{
        get: (p, f) => f === "create" ? c : (a.has(f) || a.set(f, Ef(f, void 0, o, n)),
        a.get(f))
    })
}
function j5({top: o, left: n, right: a, bottom: c}) {
    return {
        x: {
            min: n,
            max: a
        },
        y: {
            min: o,
            max: c
        }
    }
}
function g$({x: o, y: n}) {
    return {
        top: n.min,
        right: o.max,
        bottom: n.max,
        left: o.min
    }
}
function f$(o, n) {
    if (!n)
        return o;
    const a = n({
        x: o.left,
        y: o.top
    })
      , c = n({
        x: o.right,
        y: o.bottom
    });
    return {
        top: a.y,
        left: a.x,
        bottom: c.y,
        right: c.x
    }
}
function Sf(o) {
    return o === void 0 || o === 1
}
function Kk({scale: o, scaleX: n, scaleY: a}) {
    return !Sf(o) || !Sf(n) || !Sf(a)
}
function Gi(o) {
    return Kk(o) || L5(o) || o.z || o.rotate || o.rotateX || o.rotateY || o.skewX || o.skewY
}
function L5(o) {
    return A2(o.x) || A2(o.y)
}
function A2(o) {
    return o && o !== "0%"
}
function Xh(o, n, a) {
    const c = o - a
      , u = n * c;
    return a + u
}
function v2(o, n, a, c, u) {
    return u !== void 0 && (o = Xh(o, u, c)),
    Xh(o, a, c) + n
}
function Yk(o, n=0, a=1, c, u) {
    o.min = v2(o.min, n, a, c, u),
    o.max = v2(o.max, n, a, c, u)
}
function z5(o, {x: n, y: a}) {
    Yk(o.x, n.translate, n.scale, n.originPoint),
    Yk(o.y, a.translate, a.scale, a.originPoint)
}
const _2 = .999999999999
  , C2 = 1.0000000000001;
function k$(o, n, a, c=!1) {
    const u = a.length;
    if (!u)
        return;
    n.x = n.y = 1;
    let p, f;
    for (let w = 0; w < u; w++) {
        p = a[w],
        f = p.projectionDelta;
        const {visualElement: k} = p.options;
        k && k.props.style && k.props.style.display === "contents" || (c && p.options.layoutScroll && p.scroll && p !== p.root && ga(o, {
            x: -p.scroll.offset.x,
            y: -p.scroll.offset.y
        }),
        f && (n.x *= f.x.scale,
        n.y *= f.y.scale,
        z5(o, f)),
        c && Gi(p.latestValues) && ga(o, p.latestValues))
    }
    n.x < C2 && n.x > _2 && (n.x = 1),
    n.y < C2 && n.y > _2 && (n.y = 1)
}
function pa(o, n) {
    o.min = o.min + n,
    o.max = o.max + n
}
function y2(o, n, a, c, u=.5) {
    const p = ut(o.min, o.max, u);
    Yk(o, n, a, p, c)
}
function ga(o, n) {
    y2(o.x, n.x, n.scaleX, n.scale, n.originX),
    y2(o.y, n.y, n.scaleY, n.scale, n.originY)
}
function O5(o, n) {
    return j5(f$(o.getBoundingClientRect(), n))
}
function b$(o, n, a) {
    const c = O5(o, a)
      , {scroll: u} = n;
    return u && (pa(c.x, u.offset.x),
    pa(c.y, u.offset.y)),
    c
}
const x2 = () => ({
    translate: 0,
    scale: 1,
    origin: 0,
    originPoint: 0
})
  , fa = () => ({
    x: x2(),
    y: x2()
})
  , E2 = () => ({
    min: 0,
    max: 0
})
  , Ct = () => ({
    x: E2(),
    y: E2()
})
  , Qk = {
    current: null
}
  , R5 = {
    current: !1
};
function w$() {
    if (R5.current = !0,
    !!mw)
        if (window.matchMedia) {
            const o = window.matchMedia("(prefers-reduced-motion)")
              , n = () => Qk.current = o.matches;
            o.addEventListener("change", n),
            n()
        } else
            Qk.current = !1
}
const A$ = new WeakMap;
function v$(o, n, a) {
    for (const c in n) {
        const u = n[c]
          , p = a[c];
        if (to(u))
            o.addValue(c, u);
        else if (to(p))
            o.addValue(c, La(u, {
                owner: o
            }));
        else if (p !== u)
            if (o.hasValue(c)) {
                const f = o.getValue(c);
                f.liveStyle === !0 ? f.jump(u) : f.hasAnimated || f.set(u)
            } else {
                const f = o.getStaticValue(c);
                o.addValue(c, La(f !== void 0 ? f : u, {
                    owner: o
                }))
            }
    }
    for (const c in a)
        n[c] === void 0 && o.removeValue(c);
    return n
}
const S2 = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"];
class _$ {
    scrapeMotionValuesFromProps(n, a, c) {
        return {}
    }
    constructor({parent: n, props: a, presenceContext: c, reducedMotionConfig: u, blockInitialAnimation: p, visualState: f}, w={}) {
        this.current = null,
        this.children = new Set,
        this.isVariantNode = !1,
        this.isControllingVariants = !1,
        this.shouldReduceMotion = null,
        this.values = new Map,
        this.KeyframeResolver = Iw,
        this.features = {},
        this.valueSubscriptions = new Map,
        this.prevMotionValues = {},
        this.events = {},
        this.propEventSubscriptions = {},
        this.notifyUpdate = () => this.notify("Update", this.latestValues),
        this.render = () => {
            this.current && (this.triggerBuild(),
            this.renderInstance(this.current, this.renderState, this.props.style, this.projection))
        }
        ,
        this.renderScheduledAt = 0,
        this.scheduleRender = () => {
            const A = wo.now();
            this.renderScheduledAt < A && (this.renderScheduledAt = A,
            lt.render(this.render, !1, !0))
        }
        ;
        const {latestValues: k, renderState: y} = f;
        this.latestValues = k,
        this.baseTarget = {
            ...k
        },
        this.initialValues = a.initial ? {
            ...k
        } : {},
        this.renderState = y,
        this.parent = n,
        this.props = a,
        this.presenceContext = c,
        this.depth = n ? n.depth + 1 : 0,
        this.reducedMotionConfig = u,
        this.options = w,
        this.blockInitialAnimation = !!p,
        this.isControllingVariants = Em(a),
        this.isVariantNode = y5(a),
        this.isVariantNode && (this.variantChildren = new Set),
        this.manuallyAnimateOnMount = !!(n && n.current);
        const {willChange: E, ...S} = this.scrapeMotionValuesFromProps(a, {}, this);
        for (const A in S) {
            const D = S[A];
            k[A] !== void 0 && to(D) && D.set(k[A])
        }
    }
    mount(n) {
        var a;
        this.current = n,
        A$.set(n, this),
        this.projection && !this.projection.instance && this.projection.mount(n),
        this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)),
        this.values.forEach( (c, u) => this.bindToMotionValue(u, c)),
        R5.current || w$(),
        this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : Qk.current,
        (a = this.parent) == null || a.addChild(this),
        this.update(this.props, this.presenceContext)
    }
    unmount() {
        var n;
        this.projection && this.projection.unmount(),
        hi(this.notifyUpdate),
        hi(this.render),
        this.valueSubscriptions.forEach(a => a()),
        this.valueSubscriptions.clear(),
        this.removeFromVariantTree && this.removeFromVariantTree(),
        (n = this.parent) == null || n.removeChild(this);
        for (const a in this.events)
            this.events[a].clear();
        for (const a in this.features) {
            const c = this.features[a];
            c && (c.unmount(),
            c.isMounted = !1)
        }
        this.current = null
    }
    addChild(n) {
        this.children.add(n),
        this.enteringChildren ?? (this.enteringChildren = new Set),
        this.enteringChildren.add(n)
    }
    removeChild(n) {
        this.children.delete(n),
        this.enteringChildren && this.enteringChildren.delete(n)
    }
    bindToMotionValue(n, a) {
        this.valueSubscriptions.has(n) && this.valueSubscriptions.get(n)();
        const c = Ya.has(n);
        c && this.onBindTransform && this.onBindTransform();
        const u = a.on("change", f => {
            this.latestValues[n] = f,
            this.props.onUpdate && lt.preRender(this.notifyUpdate),
            c && this.projection && (this.projection.isTransformDirty = !0),
            this.scheduleRender()
        }
        );
        let p;
        window.MotionCheckAppearSync && (p = window.MotionCheckAppearSync(this, n, a)),
        this.valueSubscriptions.set(n, () => {
            u(),
            p && p(),
            a.owner && a.stop()
        }
        )
    }
    sortNodePosition(n) {
        return !this.current || !this.sortInstanceNodePosition || this.type !== n.type ? 0 : this.sortInstanceNodePosition(this.current, n.current)
    }
    updateFeatures() {
        let n = "animation";
        for (n in za) {
            const a = za[n];
            if (!a)
                continue;
            const {isEnabled: c, Feature: u} = a;
            if (!this.features[n] && u && c(this.props) && (this.features[n] = new u(this)),
            this.features[n]) {
                const p = this.features[n];
                p.isMounted ? p.update() : (p.mount(),
                p.isMounted = !0)
            }
        }
    }
    triggerBuild() {
        this.build(this.renderState, this.latestValues, this.props)
    }
    measureViewportBox() {
        return this.current ? this.measureInstanceViewportBox(this.current, this.props) : Ct()
    }
    getStaticValue(n) {
        return this.latestValues[n]
    }
    setStaticValue(n, a) {
        this.latestValues[n] = a
    }
    update(n, a) {
        (n.transformTemplate || this.props.transformTemplate) && this.scheduleRender(),
        this.prevProps = this.props,
        this.props = n,
        this.prevPresenceContext = this.presenceContext,
        this.presenceContext = a;
        for (let c = 0; c < S2.length; c++) {
            const u = S2[c];
            this.propEventSubscriptions[u] && (this.propEventSubscriptions[u](),
            delete this.propEventSubscriptions[u]);
            const p = "on" + u
              , f = n[p];
            f && (this.propEventSubscriptions[u] = this.on(u, f))
        }
        this.prevMotionValues = v$(this, this.scrapeMotionValuesFromProps(n, this.prevProps, this), this.prevMotionValues),
        this.handleChildMotionValue && this.handleChildMotionValue()
    }
    getProps() {
        return this.props
    }
    getVariant(n) {
        return this.props.variants ? this.props.variants[n] : void 0
    }
    getDefaultTransition() {
        return this.props.transition
    }
    getTransformPagePoint() {
        return this.props.transformPagePoint
    }
    getClosestVariantNode() {
        return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0
    }
    addVariantChild(n) {
        const a = this.getClosestVariantNode();
        if (a)
            return a.variantChildren && a.variantChildren.add(n),
            () => a.variantChildren.delete(n)
    }
    addValue(n, a) {
        const c = this.values.get(n);
        a !== c && (c && this.removeValue(n),
        this.bindToMotionValue(n, a),
        this.values.set(n, a),
        this.latestValues[n] = a.get())
    }
    removeValue(n) {
        this.values.delete(n);
        const a = this.valueSubscriptions.get(n);
        a && (a(),
        this.valueSubscriptions.delete(n)),
        delete this.latestValues[n],
        this.removeValueFromRenderState(n, this.renderState)
    }
    hasValue(n) {
        return this.values.has(n)
    }
    getValue(n, a) {
        if (this.props.values && this.props.values[n])
            return this.props.values[n];
        let c = this.values.get(n);
        return c === void 0 && a !== void 0 && (c = La(a === null ? void 0 : a, {
            owner: this
        }),
        this.addValue(n, c)),
        c
    }
    readValue(n, a) {
        let c = this.latestValues[n] !== void 0 || !this.current ? this.latestValues[n] : this.getBaseTargetFromProps(this.props, n) ?? this.readValueFromInstance(this.current, n, this.options);
        return c != null && (typeof c == "string" && (MM(c) || NM(c)) ? c = parseFloat(c) : !TW(c) && mi.test(a) && (c = p5(n, a)),
        this.setBaseTarget(n, to(c) ? c.get() : c)),
        to(c) ? c.get() : c
    }
    setBaseTarget(n, a) {
        this.baseTarget[n] = a
    }
    getBaseTarget(n) {
        var a;
        const {initial: c} = this.props;
        let u;
        if (typeof c == "string" || typeof c == "object") {
            const f = Vw(this.props, c, (a = this.presenceContext) == null ? void 0 : a.custom);
            f && (u = f[n])
        }
        if (c && u !== void 0)
            return u;
        const p = this.getBaseTargetFromProps(this.props, n);
        return p !== void 0 && !to(p) ? p : this.initialValues[n] !== void 0 && u === void 0 ? void 0 : this.baseTarget[n]
    }
    on(n, a) {
        return this.events[n] || (this.events[n] = new bw),
        this.events[n].add(a)
    }
    notify(n, ...a) {
        this.events[n] && this.events[n].notify(...a)
    }
    scheduleRenderMicrotask() {
        Nw.render(this.render)
    }
}
class F5 extends _$ {
    constructor() {
        super(...arguments),
        this.KeyframeResolver = kW
    }
    sortInstanceNodePosition(n, a) {
        return n.compareDocumentPosition(a) & 2 ? 1 : -1
    }
    getBaseTargetFromProps(n, a) {
        return n.style ? n.style[a] : void 0
    }
    removeValueFromRenderState(n, {vars: a, style: c}) {
        delete a[n],
        delete c[n]
    }
    handleChildMotionValue() {
        this.childSubscription && (this.childSubscription(),
        delete this.childSubscription);
        const {children: n} = this.props;
        to(n) && (this.childSubscription = n.on("change", a => {
            this.current && (this.current.textContent = `${a}`)
        }
        ))
    }
}
function V5(o, {style: n, vars: a}, c, u) {
    const p = o.style;
    let f;
    for (f in n)
        p[f] = n[f];
    u == null || u.applyProjectionStyles(p, c);
    for (f in a)
        p.setProperty(f, a[f])
}
function C$(o) {
    return window.getComputedStyle(o)
}
class y$ extends F5 {
    constructor() {
        super(...arguments),
        this.type = "html",
        this.renderInstance = V5
    }
    readValueFromInstance(n, a) {
        var c;
        if (Ya.has(a))
            return (c = this.projection) != null && c.isProjecting ? Vk(a) : LH(n, a);
        {
            const u = C$(n)
              , p = (vw(a) ? u.getPropertyValue(a) : u[a]) || 0;
            return typeof p == "string" ? p.trim() : p
        }
    }
    measureInstanceViewportBox(n, {transformPagePoint: a}) {
        return O5(n, a)
    }
    build(n, a, c) {
        Ow(n, a, c.transformTemplate)
    }
    scrapeMotionValuesFromProps(n, a, c) {
        return Uw(n, a, c)
    }
}
const U5 = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]);
function x$(o, n, a, c) {
    V5(o, n, void 0, c);
    for (const u in n.attrs)
        o.setAttribute(U5.has(u) ? u : Hw(u), n.attrs[u])
}
class E$ extends F5 {
    constructor() {
        super(...arguments),
        this.type = "svg",
        this.isSVGTag = !1,
        this.measureInstanceViewportBox = Ct
    }
    getBaseTargetFromProps(n, a) {
        return n[a]
    }
    readValueFromInstance(n, a) {
        if (Ya.has(a)) {
            const c = m5(a);
            return c && c.default || 0
        }
        return a = U5.has(a) ? a : Hw(a),
        n.getAttribute(a)
    }
    scrapeMotionValuesFromProps(n, a, c) {
        return M5(n, a, c)
    }
    build(n, a, c) {
        S5(n, a, this.isSVGTag, c.transformTemplate, c.style)
    }
    renderInstance(n, a, c, u) {
        x$(n, a, c, u)
    }
    mount(n) {
        this.isSVGTag = T5(n.tagName),
        super.mount(n)
    }
}
const S$ = (o, n) => Fw(o) ? new E$(n) : new y$(n,{
    allowProjection: o !== R.Fragment
});
function ya(o, n, a) {
    const c = o.getProps();
    return Vw(c, n, a !== void 0 ? a : c.custom, o)
}
const Zk = o => Array.isArray(o);
function D$(o, n, a) {
    o.hasValue(n) ? o.getValue(n).set(a) : o.addValue(n, La(a))
}
function T$(o) {
    return Zk(o) ? o[o.length - 1] || 0 : o
}
function I$(o, n) {
    const a = ya(o, n);
    let {transitionEnd: c={}, transition: u={}, ...p} = a || {};
    p = {
        ...p,
        ...c
    };
    for (const f in p) {
        const w = T$(p[f]);
        D$(o, f, w)
    }
}
function M$(o) {
    return !!(to(o) && o.add)
}
function Jk(o, n) {
    const a = o.getValue("willChange");
    if (M$(a))
        return a.add(n);
    if (!a && xn.WillChange) {
        const c = new xn.WillChange("auto");
        o.addValue("willChange", c),
        c.add(n)
    }
}
function H5(o) {
    return o.props[B5]
}
const B$ = o => o !== null;
function N$(o, {repeat: n, repeatType: a="loop"}, c) {
    const u = o.filter(B$)
      , p = n && a !== "loop" && n % 2 === 1 ? 0 : u.length - 1;
    return u[p]
}
const P$ = {
    type: "spring",
    stiffness: 500,
    damping: 25,
    restSpeed: 10
}
  , j$ = o => ({
    type: "spring",
    stiffness: 550,
    damping: o === 0 ? 2 * Math.sqrt(550) : 30,
    restSpeed: 10
})
  , L$ = {
    type: "keyframes",
    duration: .8
}
  , z$ = {
    type: "keyframes",
    ease: [.25, .1, .35, 1],
    duration: .3
}
  , O$ = (o, {keyframes: n}) => n.length > 2 ? L$ : Ya.has(o) ? o.startsWith("scale") ? j$(n[1]) : P$ : z$;
function R$({when: o, delay: n, delayChildren: a, staggerChildren: c, staggerDirection: u, repeat: p, repeatType: f, repeatDelay: w, from: k, elapsed: y, ...E}) {
    return !!Object.keys(E).length
}
const Ww = (o, n, a, c={}, u, p) => f => {
    const w = Mw(c, o) || {}
      , k = w.delay || c.delay || 0;
    let {elapsed: y=0} = c;
    y = y - Vr(k);
    const E = {
        keyframes: Array.isArray(a) ? a : [null, a],
        ease: "easeOut",
        velocity: n.getVelocity(),
        ...w,
        delay: -y,
        onUpdate: A => {
            n.set(A),
            w.onUpdate && w.onUpdate(A)
        }
        ,
        onComplete: () => {
            f(),
            w.onComplete && w.onComplete()
        }
        ,
        name: o,
        motionValue: n,
        element: p ? void 0 : u
    };
    R$(w) || Object.assign(E, O$(o, E)),
    E.duration && (E.duration = Vr(E.duration)),
    E.repeatDelay && (E.repeatDelay = Vr(E.repeatDelay)),
    E.from !== void 0 && (E.keyframes[0] = E.from);
    let S = !1;
    if ((E.type === !1 || E.duration === 0 && !E.repeatDelay) && (qk(E),
    E.delay === 0 && (S = !0)),
    (xn.instantAnimations || xn.skipAnimations) && (S = !0,
    qk(E),
    E.delay = 0),
    E.allowFlatten = !w.type && !w.ease,
    S && !p && n.get() !== void 0) {
        const A = N$(E.keyframes, w);
        if (A !== void 0) {
            lt.update( () => {
                E.onUpdate(A),
                E.onComplete()
            }
            );
            return
        }
    }
    return w.isSync ? new Tw(E) : new iW(E)
}
;
function F$({protectedKeys: o, needsAnimating: n}, a) {
    const c = o.hasOwnProperty(a) && n[a] !== !0;
    return n[a] = !1,
    c
}
function W5(o, n, {delay: a=0, transitionOverride: c, type: u}={}) {
    let {transition: p=o.getDefaultTransition(), transitionEnd: f, ...w} = n;
    c && (p = c);
    const k = []
      , y = u && o.animationState && o.animationState.getState()[u];
    for (const E in w) {
        const S = o.getValue(E, o.latestValues[E] ?? null)
          , A = w[E];
        if (A === void 0 || y && F$(y, E))
            continue;
        const D = {
            delay: a,
            ...Mw(p || {}, E)
        }
          , N = S.get();
        if (N !== void 0 && !S.isAnimating && !Array.isArray(A) && A === N && !D.velocity)
            continue;
        let L = !1;
        if (window.MotionHandoffAnimation) {
            const B = H5(o);
            if (B) {
                const M = window.MotionHandoffAnimation(B, E, lt);
                M !== null && (D.startTime = M,
                L = !0)
            }
        }
        Jk(o, E),
        S.start(Ww(E, S, A, o.shouldReduceMotion && d5.has(E) ? {
            type: !1
        } : D, o, L));
        const z = S.animation;
        z && k.push(z)
    }
    return f && Promise.all(k).then( () => {
        lt.update( () => {
            f && I$(o, f)
        }
        )
    }
    ),
    k
}
function $5(o, n, a, c=0, u=1) {
    const p = Array.from(o).sort( (k, y) => k.sortNodePosition(y)).indexOf(n)
      , f = o.size
      , w = (f - 1) * c;
    return typeof a == "function" ? a(p, f) : u === 1 ? p * c : w - p * c
}
function Xk(o, n, a={}) {
    var c;
    const u = ya(o, n, a.type === "exit" ? (c = o.presenceContext) == null ? void 0 : c.custom : void 0);
    let {transition: p=o.getDefaultTransition() || {}} = u || {};
    a.transitionOverride && (p = a.transitionOverride);
    const f = u ? () => Promise.all(W5(o, u, a)) : () => Promise.resolve()
      , w = o.variantChildren && o.variantChildren.size ? (y=0) => {
        const {delayChildren: E=0, staggerChildren: S, staggerDirection: A} = p;
        return V$(o, n, y, E, S, A, a)
    }
    : () => Promise.resolve()
      , {when: k} = p;
    if (k) {
        const [y,E] = k === "beforeChildren" ? [f, w] : [w, f];
        return y().then( () => E())
    } else
        return Promise.all([f(), w(a.delay)])
}
function V$(o, n, a=0, c=0, u=0, p=1, f) {
    const w = [];
    for (const k of o.variantChildren)
        k.notify("AnimationStart", n),
        w.push(Xk(k, n, {
            ...f,
            delay: a + (typeof c == "function" ? 0 : c) + $5(o.variantChildren, k, c, u, p)
        }).then( () => k.notify("AnimationComplete", n)));
    return Promise.all(w)
}
function U$(o, n, a={}) {
    o.notify("AnimationStart", n);
    let c;
    if (Array.isArray(n)) {
        const u = n.map(p => Xk(o, p, a));
        c = Promise.all(u)
    } else if (typeof n == "string")
        c = Xk(o, n, a);
    else {
        const u = typeof n == "function" ? ya(o, n, a.custom) : n;
        c = Promise.all(W5(o, u, a))
    }
    return c.then( () => {
        o.notify("AnimationComplete", n)
    }
    )
}
function q5(o, n) {
    if (!Array.isArray(n))
        return !1;
    const a = n.length;
    if (a !== o.length)
        return !1;
    for (let c = 0; c < a; c++)
        if (n[c] !== o[c])
            return !1;
    return !0
}
const H$ = zw.length;
function G5(o) {
    if (!o)
        return;
    if (!o.isControllingVariants) {
        const a = o.parent ? G5(o.parent) || {} : {};
        return o.props.initial !== void 0 && (a.initial = o.props.initial),
        a
    }
    const n = {};
    for (let a = 0; a < H$; a++) {
        const c = zw[a]
          , u = o.props[c];
        (Fc(u) || u === !1) && (n[c] = u)
    }
    return n
}
const W$ = [...Lw].reverse()
  , $$ = Lw.length;
function q$(o) {
    return n => Promise.all(n.map( ({animation: a, options: c}) => U$(o, a, c)))
}
function G$(o) {
    let n = q$(o)
      , a = D2()
      , c = !0;
    const u = k => (y, E) => {
        var S;
        const A = ya(o, E, k === "exit" ? (S = o.presenceContext) == null ? void 0 : S.custom : void 0);
        if (A) {
            const {transition: D, transitionEnd: N, ...L} = A;
            y = {
                ...y,
                ...L,
                ...N
            }
        }
        return y
    }
    ;
    function p(k) {
        n = k(o)
    }
    function f(k) {
        const {props: y} = o
          , E = G5(o.parent) || {}
          , S = []
          , A = new Set;
        let D = {}
          , N = 1 / 0;
        for (let z = 0; z < $$; z++) {
            const B = W$[z]
              , M = a[B]
              , j = y[B] !== void 0 ? y[B] : E[B]
              , V = Fc(j)
              , G = B === k ? M.isActive : null;
            G === !1 && (N = z);
            let Y = j === E[B] && j !== y[B] && V;
            if (Y && c && o.manuallyAnimateOnMount && (Y = !1),
            M.protectedKeys = {
                ...D
            },
            !M.isActive && G === null || !j && !M.prevProp || xm(j) || typeof j == "boolean")
                continue;
            const $ = K$(M.prevProp, j);
            let K = $ || B === k && M.isActive && !Y && V || z > N && V
              , Z = !1;
            const H = Array.isArray(j) ? j : [j];
            let W = H.reduce(u(B), {});
            G === !1 && (W = {});
            const {prevResolvedValues: ee={}} = M
              , re = {
                ...ee,
                ...W
            }
              , U = te => {
                K = !0,
                A.has(te) && (Z = !0,
                A.delete(te)),
                M.needsAnimating[te] = !0;
                const ue = o.getValue(te);
                ue && (ue.liveStyle = !1)
            }
            ;
            for (const te in re) {
                const ue = W[te]
                  , me = ee[te];
                if (D.hasOwnProperty(te))
                    continue;
                let Ce = !1;
                Zk(ue) && Zk(me) ? Ce = !q5(ue, me) : Ce = ue !== me,
                Ce ? ue != null ? U(te) : A.add(te) : ue !== void 0 && A.has(te) ? U(te) : M.protectedKeys[te] = !0
            }
            M.prevProp = j,
            M.prevResolvedValues = W,
            M.isActive && (D = {
                ...D,
                ...W
            }),
            c && o.blockInitialAnimation && (K = !1);
            const de = Y && $;
            K && (!de || Z) && S.push(...H.map(te => {
                const ue = {
                    type: B
                };
                if (typeof te == "string" && c && !de && o.manuallyAnimateOnMount && o.parent) {
                    const {parent: me} = o
                      , Ce = ya(me, te);
                    if (me.enteringChildren && Ce) {
                        const {delayChildren: Ye} = Ce.transition || {};
                        ue.delay = $5(me.enteringChildren, o, Ye)
                    }
                }
                return {
                    animation: te,
                    options: ue
                }
            }
            ))
        }
        if (A.size) {
            const z = {};
            if (typeof y.initial != "boolean") {
                const B = ya(o, Array.isArray(y.initial) ? y.initial[0] : y.initial);
                B && B.transition && (z.transition = B.transition)
            }
            A.forEach(B => {
                const M = o.getBaseTarget(B)
                  , j = o.getValue(B);
                j && (j.liveStyle = !0),
                z[B] = M ?? null
            }
            ),
            S.push({
                animation: z
            })
        }
        let L = !!S.length;
        return c && (y.initial === !1 || y.initial === y.animate) && !o.manuallyAnimateOnMount && (L = !1),
        c = !1,
        L ? n(S) : Promise.resolve()
    }
    function w(k, y) {
        var E;
        if (a[k].isActive === y)
            return Promise.resolve();
        (E = o.variantChildren) == null || E.forEach(A => {
            var D;
            return (D = A.animationState) == null ? void 0 : D.setActive(k, y)
        }
        ),
        a[k].isActive = y;
        const S = f(k);
        for (const A in a)
            a[A].protectedKeys = {};
        return S
    }
    return {
        animateChanges: f,
        setActive: w,
        setAnimateFunction: p,
        getState: () => a,
        reset: () => {
            a = D2(),
            c = !0
        }
    }
}
function K$(o, n) {
    return typeof n == "string" ? n !== o : Array.isArray(n) ? !q5(n, o) : !1
}
function Ui(o=!1) {
    return {
        isActive: o,
        protectedKeys: {},
        needsAnimating: {},
        prevResolvedValues: {}
    }
}
function D2() {
    return {
        animate: Ui(!0),
        whileInView: Ui(),
        whileHover: Ui(),
        whileTap: Ui(),
        whileDrag: Ui(),
        whileFocus: Ui(),
        exit: Ui()
    }
}
class fi {
    constructor(n) {
        this.isMounted = !1,
        this.node = n
    }
    update() {}
}
class Y$ extends fi {
    constructor(n) {
        super(n),
        n.animationState || (n.animationState = G$(n))
    }
    updateAnimationControlsSubscription() {
        const {animate: n} = this.node.getProps();
        xm(n) && (this.unmountControls = n.subscribe(this.node))
    }
    mount() {
        this.updateAnimationControlsSubscription()
    }
    update() {
        const {animate: n} = this.node.getProps()
          , {animate: a} = this.node.prevProps || {};
        n !== a && this.updateAnimationControlsSubscription()
    }
    unmount() {
        var n;
        this.node.animationState.reset(),
        (n = this.unmountControls) == null || n.call(this)
    }
}
let Q$ = 0;
class Z$ extends fi {
    constructor() {
        super(...arguments),
        this.id = Q$++
    }
    update() {
        if (!this.node.presenceContext)
            return;
        const {isPresent: n, onExitComplete: a} = this.node.presenceContext
          , {isPresent: c} = this.node.prevPresenceContext || {};
        if (!this.node.animationState || n === c)
            return;
        const u = this.node.animationState.setActive("exit", !n);
        a && !n && u.then( () => {
            a(this.id)
        }
        )
    }
    mount() {
        const {register: n, onExitComplete: a} = this.node.presenceContext || {};
        a && a(this.id),
        n && (this.unmount = n(this.id))
    }
    unmount() {}
}
const J$ = {
    animation: {
        Feature: Y$
    },
    exit: {
        Feature: Z$
    }
};
function Uc(o, n, a, c={
    passive: !0
}) {
    return o.addEventListener(n, a, c),
    () => o.removeEventListener(n, a)
}
function ld(o) {
    return {
        point: {
            x: o.pageX,
            y: o.pageY
        }
    }
}
const X$ = o => n => Pw(n) && o(n, ld(n));
function wc(o, n, a, c) {
    return Uc(o, n, X$(a), c)
}
const K5 = 1e-4
  , eq = 1 - K5
  , tq = 1 + K5
  , Y5 = .01
  , oq = 0 - Y5
  , rq = 0 + Y5;
function so(o) {
    return o.max - o.min
}
function nq(o, n, a) {
    return Math.abs(o - n) <= a
}
function T2(o, n, a, c=.5) {
    o.origin = c,
    o.originPoint = ut(n.min, n.max, o.origin),
    o.scale = so(a) / so(n),
    o.translate = ut(a.min, a.max, o.origin) - o.originPoint,
    (o.scale >= eq && o.scale <= tq || isNaN(o.scale)) && (o.scale = 1),
    (o.translate >= oq && o.translate <= rq || isNaN(o.translate)) && (o.translate = 0)
}
function Ac(o, n, a, c) {
    T2(o.x, n.x, a.x, c ? c.originX : void 0),
    T2(o.y, n.y, a.y, c ? c.originY : void 0)
}
function I2(o, n, a) {
    o.min = a.min + n.min,
    o.max = o.min + so(n)
}
function iq(o, n, a) {
    I2(o.x, n.x, a.x),
    I2(o.y, n.y, a.y)
}
function M2(o, n, a) {
    o.min = n.min - a.min,
    o.max = o.min + so(n)
}
function vc(o, n, a) {
    M2(o.x, n.x, a.x),
    M2(o.y, n.y, a.y)
}
function Jo(o) {
    return [o("x"), o("y")]
}
const Q5 = ({current: o}) => o ? o.ownerDocument.defaultView : null
  , B2 = (o, n) => Math.abs(o - n);
function sq(o, n) {
    const a = B2(o.x, n.x)
      , c = B2(o.y, n.y);
    return Math.sqrt(a ** 2 + c ** 2)
}
class Z5 {
    constructor(n, a, {transformPagePoint: c, contextWindow: u=window, dragSnapToOrigin: p=!1, distanceThreshold: f=3}={}) {
        if (this.startEvent = null,
        this.lastMoveEvent = null,
        this.lastMoveEventInfo = null,
        this.handlers = {},
        this.contextWindow = window,
        this.updatePoint = () => {
            if (!(this.lastMoveEvent && this.lastMoveEventInfo))
                return;
            const A = Tf(this.lastMoveEventInfo, this.history)
              , D = this.startEvent !== null
              , N = sq(A.offset, {
                x: 0,
                y: 0
            }) >= this.distanceThreshold;
            if (!D && !N)
                return;
            const {point: L} = A
              , {timestamp: z} = $t;
            this.history.push({
                ...L,
                timestamp: z
            });
            const {onStart: B, onMove: M} = this.handlers;
            D || (B && B(this.lastMoveEvent, A),
            this.startEvent = this.lastMoveEvent),
            M && M(this.lastMoveEvent, A)
        }
        ,
        this.handlePointerMove = (A, D) => {
            this.lastMoveEvent = A,
            this.lastMoveEventInfo = Df(D, this.transformPagePoint),
            lt.update(this.updatePoint, !0)
        }
        ,
        this.handlePointerUp = (A, D) => {
            this.end();
            const {onEnd: N, onSessionEnd: L, resumeAnimation: z} = this.handlers;
            if (this.dragSnapToOrigin && z && z(),
            !(this.lastMoveEvent && this.lastMoveEventInfo))
                return;
            const B = Tf(A.type === "pointercancel" ? this.lastMoveEventInfo : Df(D, this.transformPagePoint), this.history);
            this.startEvent && N && N(A, B),
            L && L(A, B)
        }
        ,
        !Pw(n))
            return;
        this.dragSnapToOrigin = p,
        this.handlers = a,
        this.transformPagePoint = c,
        this.distanceThreshold = f,
        this.contextWindow = u || window;
        const w = ld(n)
          , k = Df(w, this.transformPagePoint)
          , {point: y} = k
          , {timestamp: E} = $t;
        this.history = [{
            ...y,
            timestamp: E
        }];
        const {onSessionStart: S} = a;
        S && S(n, Tf(k, this.history)),
        this.removeListeners = id(wc(this.contextWindow, "pointermove", this.handlePointerMove), wc(this.contextWindow, "pointerup", this.handlePointerUp), wc(this.contextWindow, "pointercancel", this.handlePointerUp))
    }
    updateHandlers(n) {
        this.handlers = n
    }
    end() {
        this.removeListeners && this.removeListeners(),
        hi(this.updatePoint)
    }
}
function Df(o, n) {
    return n ? {
        point: n(o.point)
    } : o
}
function N2(o, n) {
    return {
        x: o.x - n.x,
        y: o.y - n.y
    }
}
function Tf({point: o}, n) {
    return {
        point: o,
        delta: N2(o, J5(n)),
        offset: N2(o, aq(n)),
        velocity: lq(n, .1)
    }
}
function aq(o) {
    return o[0]
}
function J5(o) {
    return o[o.length - 1]
}
function lq(o, n) {
    if (o.length < 2)
        return {
            x: 0,
            y: 0
        };
    let a = o.length - 1
      , c = null;
    const u = J5(o);
    for (; a >= 0 && (c = o[a],
    !(u.timestamp - c.timestamp > Vr(n))); )
        a--;
    if (!c)
        return {
            x: 0,
            y: 0
        };
    const p = ir(u.timestamp - c.timestamp);
    if (p === 0)
        return {
            x: 0,
            y: 0
        };
    const f = {
        x: (u.x - c.x) / p,
        y: (u.y - c.y) / p
    };
    return f.x === 1 / 0 && (f.x = 0),
    f.y === 1 / 0 && (f.y = 0),
    f
}
function cq(o, {min: n, max: a}, c) {
    return n !== void 0 && o < n ? o = c ? ut(n, o, c.min) : Math.max(o, n) : a !== void 0 && o > a && (o = c ? ut(a, o, c.max) : Math.min(o, a)),
    o
}
function P2(o, n, a) {
    return {
        min: n !== void 0 ? o.min + n : void 0,
        max: a !== void 0 ? o.max + a - (o.max - o.min) : void 0
    }
}
function dq(o, {top: n, left: a, bottom: c, right: u}) {
    return {
        x: P2(o.x, a, u),
        y: P2(o.y, n, c)
    }
}
function j2(o, n) {
    let a = n.min - o.min
      , c = n.max - o.max;
    return n.max - n.min < o.max - o.min && ([a,c] = [c, a]),
    {
        min: a,
        max: c
    }
}
function uq(o, n) {
    return {
        x: j2(o.x, n.x),
        y: j2(o.y, n.y)
    }
}
function hq(o, n) {
    let a = .5;
    const c = so(o)
      , u = so(n);
    return u > c ? a = zc(n.min, n.max - c, o.min) : c > u && (a = zc(o.min, o.max - u, n.min)),
    yn(0, 1, a)
}
function mq(o, n) {
    const a = {};
    return n.min !== void 0 && (a.min = n.min - o.min),
    n.max !== void 0 && (a.max = n.max - o.min),
    a
}
const eb = .35;
function pq(o=eb) {
    return o === !1 ? o = 0 : o === !0 && (o = eb),
    {
        x: L2(o, "left", "right"),
        y: L2(o, "top", "bottom")
    }
}
function L2(o, n, a) {
    return {
        min: z2(o, n),
        max: z2(o, a)
    }
}
function z2(o, n) {
    return typeof o == "number" ? o : o[n] || 0
}
const gq = new WeakMap;
class fq {
    constructor(n) {
        this.openDragLock = null,
        this.isDragging = !1,
        this.currentDirection = null,
        this.originPoint = {
            x: 0,
            y: 0
        },
        this.constraints = !1,
        this.hasMutatedConstraints = !1,
        this.elastic = Ct(),
        this.latestPointerEvent = null,
        this.latestPanInfo = null,
        this.visualElement = n
    }
    start(n, {snapToCursor: a=!1, distanceThreshold: c}={}) {
        const {presenceContext: u} = this.visualElement;
        if (u && u.isPresent === !1)
            return;
        const p = S => {
            const {dragSnapToOrigin: A} = this.getProps();
            A ? this.pauseAnimation() : this.stopAnimation(),
            a && this.snapToCursor(ld(S).point)
        }
          , f = (S, A) => {
            const {drag: D, dragPropagation: N, onDragStart: L} = this.getProps();
            if (D && !N && (this.openDragLock && this.openDragLock(),
            this.openDragLock = vW(D),
            !this.openDragLock))
                return;
            this.latestPointerEvent = S,
            this.latestPanInfo = A,
            this.isDragging = !0,
            this.currentDirection = null,
            this.resolveConstraints(),
            this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0,
            this.visualElement.projection.target = void 0),
            Jo(B => {
                let M = this.getAxisMotionValue(B).get() || 0;
                if (Ur.test(M)) {
                    const {projection: j} = this.visualElement;
                    if (j && j.layout) {
                        const V = j.layout.layoutBox[B];
                        V && (M = so(V) * (parseFloat(M) / 100))
                    }
                }
                this.originPoint[B] = M
            }
            ),
            L && lt.postRender( () => L(S, A)),
            Jk(this.visualElement, "transform");
            const {animationState: z} = this.visualElement;
            z && z.setActive("whileDrag", !0)
        }
          , w = (S, A) => {
            this.latestPointerEvent = S,
            this.latestPanInfo = A;
            const {dragPropagation: D, dragDirectionLock: N, onDirectionLock: L, onDrag: z} = this.getProps();
            if (!D && !this.openDragLock)
                return;
            const {offset: B} = A;
            if (N && this.currentDirection === null) {
                this.currentDirection = kq(B),
                this.currentDirection !== null && L && L(this.currentDirection);
                return
            }
            this.updateAxis("x", A.point, B),
            this.updateAxis("y", A.point, B),
            this.visualElement.render(),
            z && z(S, A)
        }
          , k = (S, A) => {
            this.latestPointerEvent = S,
            this.latestPanInfo = A,
            this.stop(S, A),
            this.latestPointerEvent = null,
            this.latestPanInfo = null
        }
          , y = () => Jo(S => {
            var A;
            return this.getAnimationState(S) === "paused" && ((A = this.getAxisMotionValue(S).animation) == null ? void 0 : A.play())
        }
        )
          , {dragSnapToOrigin: E} = this.getProps();
        this.panSession = new Z5(n,{
            onSessionStart: p,
            onStart: f,
            onMove: w,
            onSessionEnd: k,
            resumeAnimation: y
        },{
            transformPagePoint: this.visualElement.getTransformPagePoint(),
            dragSnapToOrigin: E,
            distanceThreshold: c,
            contextWindow: Q5(this.visualElement)
        })
    }
    stop(n, a) {
        const c = n || this.latestPointerEvent
          , u = a || this.latestPanInfo
          , p = this.isDragging;
        if (this.cancel(),
        !p || !u || !c)
            return;
        const {velocity: f} = u;
        this.startAnimation(f);
        const {onDragEnd: w} = this.getProps();
        w && lt.postRender( () => w(c, u))
    }
    cancel() {
        this.isDragging = !1;
        const {projection: n, animationState: a} = this.visualElement;
        n && (n.isAnimationBlocked = !1),
        this.panSession && this.panSession.end(),
        this.panSession = void 0;
        const {dragPropagation: c} = this.getProps();
        !c && this.openDragLock && (this.openDragLock(),
        this.openDragLock = null),
        a && a.setActive("whileDrag", !1)
    }
    updateAxis(n, a, c) {
        const {drag: u} = this.getProps();
        if (!c || !Qu(n, u, this.currentDirection))
            return;
        const p = this.getAxisMotionValue(n);
        let f = this.originPoint[n] + c[n];
        this.constraints && this.constraints[n] && (f = cq(f, this.constraints[n], this.elastic[n])),
        p.set(f)
    }
    resolveConstraints() {
        var n;
        const {dragConstraints: a, dragElastic: c} = this.getProps()
          , u = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (n = this.visualElement.projection) == null ? void 0 : n.layout
          , p = this.constraints;
        a && ma(a) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : a && u ? this.constraints = dq(u.layoutBox, a) : this.constraints = !1,
        this.elastic = pq(c),
        p !== this.constraints && u && this.constraints && !this.hasMutatedConstraints && Jo(f => {
            this.constraints !== !1 && this.getAxisMotionValue(f) && (this.constraints[f] = mq(u.layoutBox[f], this.constraints[f]))
        }
        )
    }
    resolveRefConstraints() {
        const {dragConstraints: n, onMeasureDragConstraints: a} = this.getProps();
        if (!n || !ma(n))
            return !1;
        const c = n.current
          , {projection: u} = this.visualElement;
        if (!u || !u.layout)
            return !1;
        const p = b$(c, u.root, this.visualElement.getTransformPagePoint());
        let f = uq(u.layout.layoutBox, p);
        if (a) {
            const w = a(g$(f));
            this.hasMutatedConstraints = !!w,
            w && (f = j5(w))
        }
        return f
    }
    startAnimation(n) {
        const {drag: a, dragMomentum: c, dragElastic: u, dragTransition: p, dragSnapToOrigin: f, onDragTransitionEnd: w} = this.getProps()
          , k = this.constraints || {}
          , y = Jo(E => {
            if (!Qu(E, a, this.currentDirection))
                return;
            let S = k && k[E] || {};
            f && (S = {
                min: 0,
                max: 0
            });
            const A = u ? 200 : 1e6
              , D = u ? 40 : 1e7
              , N = {
                type: "inertia",
                velocity: c ? n[E] : 0,
                bounceStiffness: A,
                bounceDamping: D,
                timeConstant: 750,
                restDelta: 1,
                restSpeed: 10,
                ...p,
                ...S
            };
            return this.startAxisValueAnimation(E, N)
        }
        );
        return Promise.all(y).then(w)
    }
    startAxisValueAnimation(n, a) {
        const c = this.getAxisMotionValue(n);
        return Jk(this.visualElement, n),
        c.start(Ww(n, c, 0, a, this.visualElement, !1))
    }
    stopAnimation() {
        Jo(n => this.getAxisMotionValue(n).stop())
    }
    pauseAnimation() {
        Jo(n => {
            var a;
            return (a = this.getAxisMotionValue(n).animation) == null ? void 0 : a.pause()
        }
        )
    }
    getAnimationState(n) {
        var a;
        return (a = this.getAxisMotionValue(n).animation) == null ? void 0 : a.state
    }
    getAxisMotionValue(n) {
        const a = `_drag${n.toUpperCase()}`
          , c = this.visualElement.getProps();
        return c[a] || this.visualElement.getValue(n, (c.initial ? c.initial[n] : void 0) || 0)
    }
    snapToCursor(n) {
        Jo(a => {
            const {drag: c} = this.getProps();
            if (!Qu(a, c, this.currentDirection))
                return;
            const {projection: u} = this.visualElement
              , p = this.getAxisMotionValue(a);
            if (u && u.layout) {
                const {min: f, max: w} = u.layout.layoutBox[a];
                p.set(n[a] - ut(f, w, .5))
            }
        }
        )
    }
    scalePositionWithinConstraints() {
        if (!this.visualElement.current)
            return;
        const {drag: n, dragConstraints: a} = this.getProps()
          , {projection: c} = this.visualElement;
        if (!ma(a) || !c || !this.constraints)
            return;
        this.stopAnimation();
        const u = {
            x: 0,
            y: 0
        };
        Jo(f => {
            const w = this.getAxisMotionValue(f);
            if (w && this.constraints !== !1) {
                const k = w.get();
                u[f] = hq({
                    min: k,
                    max: k
                }, this.constraints[f])
            }
        }
        );
        const {transformTemplate: p} = this.visualElement.getProps();
        this.visualElement.current.style.transform = p ? p({}, "") : "none",
        c.root && c.root.updateScroll(),
        c.updateLayout(),
        this.resolveConstraints(),
        Jo(f => {
            if (!Qu(f, n, null))
                return;
            const w = this.getAxisMotionValue(f)
              , {min: k, max: y} = this.constraints[f];
            w.set(ut(k, y, u[f]))
        }
        )
    }
    addListeners() {
        if (!this.visualElement.current)
            return;
        gq.set(this.visualElement, this);
        const n = this.visualElement.current
          , a = wc(n, "pointerdown", k => {
            const {drag: y, dragListener: E=!0} = this.getProps();
            y && E && this.start(k)
        }
        )
          , c = () => {
            const {dragConstraints: k} = this.getProps();
            ma(k) && k.current && (this.constraints = this.resolveRefConstraints())
        }
          , {projection: u} = this.visualElement
          , p = u.addEventListener("measure", c);
        u && !u.layout && (u.root && u.root.updateScroll(),
        u.updateLayout()),
        lt.read(c);
        const f = Uc(window, "resize", () => this.scalePositionWithinConstraints())
          , w = u.addEventListener("didUpdate", ({delta: k, hasLayoutChanged: y}) => {
            this.isDragging && y && (Jo(E => {
                const S = this.getAxisMotionValue(E);
                S && (this.originPoint[E] += k[E].translate,
                S.set(S.get() + k[E].translate))
            }
            ),
            this.visualElement.render())
        }
        );
        return () => {
            f(),
            a(),
            p(),
            w && w()
        }
    }
    getProps() {
        const n = this.visualElement.getProps()
          , {drag: a=!1, dragDirectionLock: c=!1, dragPropagation: u=!1, dragConstraints: p=!1, dragElastic: f=eb, dragMomentum: w=!0} = n;
        return {
            ...n,
            drag: a,
            dragDirectionLock: c,
            dragPropagation: u,
            dragConstraints: p,
            dragElastic: f,
            dragMomentum: w
        }
    }
}
function Qu(o, n, a) {
    return (n === !0 || n === o) && (a === null || a === o)
}
function kq(o, n=10) {
    let a = null;
    return Math.abs(o.y) > n ? a = "y" : Math.abs(o.x) > n && (a = "x"),
    a
}
class bq extends fi {
    constructor(n) {
        super(n),
        this.removeGroupControls = ar,
        this.removeListeners = ar,
        this.controls = new fq(n)
    }
    mount() {
        const {dragControls: n} = this.node.getProps();
        n && (this.removeGroupControls = n.subscribe(this.controls)),
        this.removeListeners = this.controls.addListeners() || ar
    }
    unmount() {
        this.removeGroupControls(),
        this.removeListeners()
    }
}
const O2 = o => (n, a) => {
    o && lt.postRender( () => o(n, a))
}
;
class wq extends fi {
    constructor() {
        super(...arguments),
        this.removePointerDownListener = ar
    }
    onPointerDown(n) {
        this.session = new Z5(n,this.createPanHandlers(),{
            transformPagePoint: this.node.getTransformPagePoint(),
            contextWindow: Q5(this.node)
        })
    }
    createPanHandlers() {
        const {onPanSessionStart: n, onPanStart: a, onPan: c, onPanEnd: u} = this.node.getProps();
        return {
            onSessionStart: O2(n),
            onStart: O2(a),
            onMove: c,
            onEnd: (p, f) => {
                delete this.session,
                u && lt.postRender( () => u(p, f))
            }
        }
    }
    mount() {
        this.removePointerDownListener = wc(this.node.current, "pointerdown", n => this.onPointerDown(n))
    }
    update() {
        this.session && this.session.updateHandlers(this.createPanHandlers())
    }
    unmount() {
        this.removePointerDownListener(),
        this.session && this.session.end()
    }
}
const kh = {
    hasAnimatedSinceResize: !0,
    hasEverUpdated: !1
};
function R2(o, n) {
    return n.max === n.min ? 0 : o / (n.max - n.min) * 100
}
const Ql = {
    correct: (o, n) => {
        if (!n.target)
            return o;
        if (typeof o == "string")
            if (be.test(o))
                o = parseFloat(o);
            else
                return o;
        const a = R2(o, n.target.x)
          , c = R2(o, n.target.y);
        return `${a}% ${c}%`
    }
}
  , Aq = {
    correct: (o, {treeScale: n, projectionDelta: a}) => {
        const c = o
          , u = mi.parse(o);
        if (u.length > 5)
            return c;
        const p = mi.createTransformer(o)
          , f = typeof u[0] != "number" ? 1 : 0
          , w = a.x.scale * n.x
          , k = a.y.scale * n.y;
        u[0 + f] /= w,
        u[1 + f] /= k;
        const y = ut(w, k, .5);
        return typeof u[2 + f] == "number" && (u[2 + f] /= y),
        typeof u[3 + f] == "number" && (u[3 + f] /= y),
        p(u)
    }
};
let If = !1;
class vq extends R.Component {
    componentDidMount() {
        const {visualElement: n, layoutGroup: a, switchLayoutGroup: c, layoutId: u} = this.props
          , {projection: p} = n;
        HW(_q),
        p && (a.group && a.group.add(p),
        c && c.register && u && c.register(p),
        If && p.root.didUpdate(),
        p.addEventListener("animationComplete", () => {
            this.safeToRemove()
        }
        ),
        p.setOptions({
            ...p.options,
            onExitComplete: () => this.safeToRemove()
        })),
        kh.hasEverUpdated = !0
    }
    getSnapshotBeforeUpdate(n) {
        const {layoutDependency: a, visualElement: c, drag: u, isPresent: p} = this.props
          , {projection: f} = c;
        return f && (f.isPresent = p,
        If = !0,
        u || n.layoutDependency !== a || a === void 0 || n.isPresent !== p ? f.willUpdate() : this.safeToRemove(),
        n.isPresent !== p && (p ? f.promote() : f.relegate() || lt.postRender( () => {
            const w = f.getStack();
            (!w || !w.members.length) && this.safeToRemove()
        }
        ))),
        null
    }
    componentDidUpdate() {
        const {projection: n} = this.props.visualElement;
        n && (n.root.didUpdate(),
        Nw.postRender( () => {
            !n.currentAnimation && n.isLead() && this.safeToRemove()
        }
        ))
    }
    componentWillUnmount() {
        const {visualElement: n, layoutGroup: a, switchLayoutGroup: c} = this.props
          , {projection: u} = n;
        If = !0,
        u && (u.scheduleCheckAfterUnmount(),
        a && a.group && a.group.remove(u),
        c && c.deregister && c.deregister(u))
    }
    safeToRemove() {
        const {safeToRemove: n} = this.props;
        n && n()
    }
    render() {
        return null
    }
}
function X5(o) {
    const [n,a] = v5()
      , c = R.useContext(uw);
    return _.jsx(vq, {
        ...o,
        layoutGroup: c,
        switchLayoutGroup: R.useContext(N5),
        isPresent: n,
        safeToRemove: a
    })
}
const _q = {
    borderRadius: {
        ...Ql,
        applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"]
    },
    borderTopLeftRadius: Ql,
    borderTopRightRadius: Ql,
    borderBottomLeftRadius: Ql,
    borderBottomRightRadius: Ql,
    boxShadow: Aq
};
function Cq(o, n, a) {
    const c = to(o) ? o : La(o);
    return c.start(Ww("", c, n, a)),
    c.animation
}
const yq = (o, n) => o.depth - n.depth;
class xq {
    constructor() {
        this.children = [],
        this.isDirty = !1
    }
    add(n) {
        pw(this.children, n),
        this.isDirty = !0
    }
    remove(n) {
        gw(this.children, n),
        this.isDirty = !0
    }
    forEach(n) {
        this.isDirty && this.children.sort(yq),
        this.isDirty = !1,
        this.children.forEach(n)
    }
}
function Eq(o, n) {
    const a = wo.now()
      , c = ({timestamp: u}) => {
        const p = u - a;
        p >= n && (hi(c),
        o(p - n))
    }
    ;
    return lt.setup(c, !0),
    () => hi(c)
}
const eB = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"]
  , Sq = eB.length
  , F2 = o => typeof o == "string" ? parseFloat(o) : o
  , V2 = o => typeof o == "number" || be.test(o);
function Dq(o, n, a, c, u, p) {
    u ? (o.opacity = ut(0, a.opacity ?? 1, Tq(c)),
    o.opacityExit = ut(n.opacity ?? 1, 0, Iq(c))) : p && (o.opacity = ut(n.opacity ?? 1, a.opacity ?? 1, c));
    for (let f = 0; f < Sq; f++) {
        const w = `border${eB[f]}Radius`;
        let k = U2(n, w)
          , y = U2(a, w);
        k === void 0 && y === void 0 || (k || (k = 0),
        y || (y = 0),
        k === 0 || y === 0 || V2(k) === V2(y) ? (o[w] = Math.max(ut(F2(k), F2(y), c), 0),
        (Ur.test(y) || Ur.test(k)) && (o[w] += "%")) : o[w] = y)
    }
    (n.rotate || a.rotate) && (o.rotate = ut(n.rotate || 0, a.rotate || 0, c))
}
function U2(o, n) {
    return o[n] !== void 0 ? o[n] : o.borderRadius
}
const Tq = tB(0, .5, VM)
  , Iq = tB(.5, .95, ar);
function tB(o, n, a) {
    return c => c < o ? 0 : c > n ? 1 : a(zc(o, n, c))
}
function H2(o, n) {
    o.min = n.min,
    o.max = n.max
}
function Zo(o, n) {
    H2(o.x, n.x),
    H2(o.y, n.y)
}
function W2(o, n) {
    o.translate = n.translate,
    o.scale = n.scale,
    o.originPoint = n.originPoint,
    o.origin = n.origin
}
function $2(o, n, a, c, u) {
    return o -= n,
    o = Xh(o, 1 / a, c),
    u !== void 0 && (o = Xh(o, 1 / u, c)),
    o
}
function Mq(o, n=0, a=1, c=.5, u, p=o, f=o) {
    if (Ur.test(n) && (n = parseFloat(n),
    n = ut(f.min, f.max, n / 100) - f.min),
    typeof n != "number")
        return;
    let w = ut(p.min, p.max, c);
    o === p && (w -= n),
    o.min = $2(o.min, n, a, w, u),
    o.max = $2(o.max, n, a, w, u)
}
function q2(o, n, [a,c,u], p, f) {
    Mq(o, n[a], n[c], n[u], n.scale, p, f)
}
const Bq = ["x", "scaleX", "originX"]
  , Nq = ["y", "scaleY", "originY"];
function G2(o, n, a, c) {
    q2(o.x, n, Bq, a ? a.x : void 0, c ? c.x : void 0),
    q2(o.y, n, Nq, a ? a.y : void 0, c ? c.y : void 0)
}
function K2(o) {
    return o.translate === 0 && o.scale === 1
}
function oB(o) {
    return K2(o.x) && K2(o.y)
}
function Y2(o, n) {
    return o.min === n.min && o.max === n.max
}
function Pq(o, n) {
    return Y2(o.x, n.x) && Y2(o.y, n.y)
}
function Q2(o, n) {
    return Math.round(o.min) === Math.round(n.min) && Math.round(o.max) === Math.round(n.max)
}
function rB(o, n) {
    return Q2(o.x, n.x) && Q2(o.y, n.y)
}
function Z2(o) {
    return so(o.x) / so(o.y)
}
function J2(o, n) {
    return o.translate === n.translate && o.scale === n.scale && o.originPoint === n.originPoint
}
class jq {
    constructor() {
        this.members = []
    }
    add(n) {
        pw(this.members, n),
        n.scheduleRender()
    }
    remove(n) {
        if (gw(this.members, n),
        n === this.prevLead && (this.prevLead = void 0),
        n === this.lead) {
            const a = this.members[this.members.length - 1];
            a && this.promote(a)
        }
    }
    relegate(n) {
        const a = this.members.findIndex(u => n === u);
        if (a === 0)
            return !1;
        let c;
        for (let u = a; u >= 0; u--) {
            const p = this.members[u];
            if (p.isPresent !== !1) {
                c = p;
                break
            }
        }
        return c ? (this.promote(c),
        !0) : !1
    }
    promote(n, a) {
        const c = this.lead;
        if (n !== c && (this.prevLead = c,
        this.lead = n,
        n.show(),
        c)) {
            c.instance && c.scheduleRender(),
            n.scheduleRender(),
            n.resumeFrom = c,
            a && (n.resumeFrom.preserveOpacity = !0),
            c.snapshot && (n.snapshot = c.snapshot,
            n.snapshot.latestValues = c.animationValues || c.latestValues),
            n.root && n.root.isUpdating && (n.isLayoutDirty = !0);
            const {crossfade: u} = n.options;
            u === !1 && c.hide()
        }
    }
    exitAnimationComplete() {
        this.members.forEach(n => {
            const {options: a, resumingFrom: c} = n;
            a.onExitComplete && a.onExitComplete(),
            c && c.options.onExitComplete && c.options.onExitComplete()
        }
        )
    }
    scheduleRender() {
        this.members.forEach(n => {
            n.instance && n.scheduleRender(!1)
        }
        )
    }
    removeLeadSnapshot() {
        this.lead && this.lead.snapshot && (this.lead.snapshot = void 0)
    }
}
function Lq(o, n, a) {
    let c = "";
    const u = o.x.translate / n.x
      , p = o.y.translate / n.y
      , f = (a == null ? void 0 : a.z) || 0;
    if ((u || p || f) && (c = `translate3d(${u}px, ${p}px, ${f}px) `),
    (n.x !== 1 || n.y !== 1) && (c += `scale(${1 / n.x}, ${1 / n.y}) `),
    a) {
        const {transformPerspective: y, rotate: E, rotateX: S, rotateY: A, skewX: D, skewY: N} = a;
        y && (c = `perspective(${y}px) ${c}`),
        E && (c += `rotate(${E}deg) `),
        S && (c += `rotateX(${S}deg) `),
        A && (c += `rotateY(${A}deg) `),
        D && (c += `skewX(${D}deg) `),
        N && (c += `skewY(${N}deg) `)
    }
    const w = o.x.scale * n.x
      , k = o.y.scale * n.y;
    return (w !== 1 || k !== 1) && (c += `scale(${w}, ${k})`),
    c || "none"
}
const Mf = ["", "X", "Y", "Z"]
  , zq = 1e3;
let Oq = 0;
function Bf(o, n, a, c) {
    const {latestValues: u} = n;
    u[o] && (a[o] = u[o],
    n.setStaticValue(o, 0),
    c && (c[o] = 0))
}
function nB(o) {
    if (o.hasCheckedOptimisedAppear = !0,
    o.root === o)
        return;
    const {visualElement: n} = o.options;
    if (!n)
        return;
    const a = H5(n);
    if (window.MotionHasOptimisedAnimation(a, "transform")) {
        const {layout: u, layoutId: p} = o.options;
        window.MotionCancelOptimisedAnimation(a, "transform", lt, !(u || p))
    }
    const {parent: c} = o;
    c && !c.hasCheckedOptimisedAppear && nB(c)
}
function iB({attachResizeListener: o, defaultParent: n, measureScroll: a, checkIsScrollRoot: c, resetTransform: u}) {
    return class {
        constructor(p={}, f=n == null ? void 0 : n()) {
            this.id = Oq++,
            this.animationId = 0,
            this.animationCommitId = 0,
            this.children = new Set,
            this.options = {},
            this.isTreeAnimating = !1,
            this.isAnimationBlocked = !1,
            this.isLayoutDirty = !1,
            this.isProjectionDirty = !1,
            this.isSharedProjectionDirty = !1,
            this.isTransformDirty = !1,
            this.updateManuallyBlocked = !1,
            this.updateBlockedByResize = !1,
            this.isUpdating = !1,
            this.isSVG = !1,
            this.needsReset = !1,
            this.shouldResetTransform = !1,
            this.hasCheckedOptimisedAppear = !1,
            this.treeScale = {
                x: 1,
                y: 1
            },
            this.eventHandlers = new Map,
            this.hasTreeAnimated = !1,
            this.updateScheduled = !1,
            this.scheduleUpdate = () => this.update(),
            this.projectionUpdateScheduled = !1,
            this.checkUpdateFailed = () => {
                this.isUpdating && (this.isUpdating = !1,
                this.clearAllSnapshots())
            }
            ,
            this.updateProjection = () => {
                this.projectionUpdateScheduled = !1,
                this.nodes.forEach(Vq),
                this.nodes.forEach($q),
                this.nodes.forEach(qq),
                this.nodes.forEach(Uq)
            }
            ,
            this.resolvedRelativeTargetAt = 0,
            this.hasProjected = !1,
            this.isVisible = !0,
            this.animationProgress = 0,
            this.sharedNodes = new Map,
            this.latestValues = p,
            this.root = f ? f.root || f : this,
            this.path = f ? [...f.path, f] : [],
            this.parent = f,
            this.depth = f ? f.depth + 1 : 0;
            for (let w = 0; w < this.path.length; w++)
                this.path[w].shouldResetTransform = !0;
            this.root === this && (this.nodes = new xq)
        }
        addEventListener(p, f) {
            return this.eventHandlers.has(p) || this.eventHandlers.set(p, new bw),
            this.eventHandlers.get(p).add(f)
        }
        notifyListeners(p, ...f) {
            const w = this.eventHandlers.get(p);
            w && w.notify(...f)
        }
        hasListeners(p) {
            return this.eventHandlers.has(p)
        }
        mount(p) {
            if (this.instance)
                return;
            this.isSVG = A5(p) && !SW(p),
            this.instance = p;
            const {layoutId: f, layout: w, visualElement: k} = this.options;
            if (k && !k.current && k.mount(p),
            this.root.nodes.add(this),
            this.parent && this.parent.children.add(this),
            this.root.hasTreeAnimated && (w || f) && (this.isLayoutDirty = !0),
            o) {
                let y, E = 0;
                const S = () => this.root.updateBlockedByResize = !1;
                lt.read( () => {
                    E = window.innerWidth
                }
                ),
                o(p, () => {
                    const A = window.innerWidth;
                    A !== E && (E = A,
                    this.root.updateBlockedByResize = !0,
                    y && y(),
                    y = Eq(S, 250),
                    kh.hasAnimatedSinceResize && (kh.hasAnimatedSinceResize = !1,
                    this.nodes.forEach(tD)))
                }
                )
            }
            f && this.root.registerSharedNode(f, this),
            this.options.animate !== !1 && k && (f || w) && this.addEventListener("didUpdate", ({delta: y, hasLayoutChanged: E, hasRelativeLayoutChanged: S, layout: A}) => {
                if (this.isTreeAnimationBlocked()) {
                    this.target = void 0,
                    this.relativeTarget = void 0;
                    return
                }
                const D = this.options.transition || k.getDefaultTransition() || Zq
                  , {onLayoutAnimationStart: N, onLayoutAnimationComplete: L} = k.getProps()
                  , z = !this.targetLayout || !rB(this.targetLayout, A)
                  , B = !E && S;
                if (this.options.layoutRoot || this.resumeFrom || B || E && (z || !this.currentAnimation)) {
                    this.resumeFrom && (this.resumingFrom = this.resumeFrom,
                    this.resumingFrom.resumingFrom = void 0);
                    const M = {
                        ...Mw(D, "layout"),
                        onPlay: N,
                        onComplete: L
                    };
                    (k.shouldReduceMotion || this.options.layoutRoot) && (M.delay = 0,
                    M.type = !1),
                    this.startAnimation(M),
                    this.setAnimationOrigin(y, B)
                } else
                    E || tD(this),
                    this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
                this.targetLayout = A
            }
            )
        }
        unmount() {
            this.options.layoutId && this.willUpdate(),
            this.root.nodes.remove(this);
            const p = this.getStack();
            p && p.remove(this),
            this.parent && this.parent.children.delete(this),
            this.instance = void 0,
            this.eventHandlers.clear(),
            hi(this.updateProjection)
        }
        blockUpdate() {
            this.updateManuallyBlocked = !0
        }
        unblockUpdate() {
            this.updateManuallyBlocked = !1
        }
        isUpdateBlocked() {
            return this.updateManuallyBlocked || this.updateBlockedByResize
        }
        isTreeAnimationBlocked() {
            return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1
        }
        startUpdate() {
            this.isUpdateBlocked() || (this.isUpdating = !0,
            this.nodes && this.nodes.forEach(Gq),
            this.animationId++)
        }
        getTransformTemplate() {
            const {visualElement: p} = this.options;
            return p && p.getProps().transformTemplate
        }
        willUpdate(p=!0) {
            if (this.root.hasTreeAnimated = !0,
            this.root.isUpdateBlocked()) {
                this.options.onExitComplete && this.options.onExitComplete();
                return
            }
            if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && nB(this),
            !this.root.isUpdating && this.root.startUpdate(),
            this.isLayoutDirty)
                return;
            this.isLayoutDirty = !0;
            for (let y = 0; y < this.path.length; y++) {
                const E = this.path[y];
                E.shouldResetTransform = !0,
                E.updateScroll("snapshot"),
                E.options.layoutRoot && E.willUpdate(!1)
            }
            const {layoutId: f, layout: w} = this.options;
            if (f === void 0 && !w)
                return;
            const k = this.getTransformTemplate();
            this.prevTransformTemplateValue = k ? k(this.latestValues, "") : void 0,
            this.updateSnapshot(),
            p && this.notifyListeners("willUpdate")
        }
        update() {
            if (this.updateScheduled = !1,
            this.isUpdateBlocked()) {
                this.unblockUpdate(),
                this.clearAllSnapshots(),
                this.nodes.forEach(X2);
                return
            }
            if (this.animationId <= this.animationCommitId) {
                this.nodes.forEach(eD);
                return
            }
            this.animationCommitId = this.animationId,
            this.isUpdating ? (this.isUpdating = !1,
            this.nodes.forEach(Wq),
            this.nodes.forEach(Rq),
            this.nodes.forEach(Fq)) : this.nodes.forEach(eD),
            this.clearAllSnapshots();
            const p = wo.now();
            $t.delta = yn(0, 1e3 / 60, p - $t.timestamp),
            $t.timestamp = p,
            $t.isProcessing = !0,
            Af.update.process($t),
            Af.preRender.process($t),
            Af.render.process($t),
            $t.isProcessing = !1
        }
        didUpdate() {
            this.updateScheduled || (this.updateScheduled = !0,
            Nw.read(this.scheduleUpdate))
        }
        clearAllSnapshots() {
            this.nodes.forEach(Hq),
            this.sharedNodes.forEach(Kq)
        }
        scheduleUpdateProjection() {
            this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0,
            lt.preRender(this.updateProjection, !1, !0))
        }
        scheduleCheckAfterUnmount() {
            lt.postRender( () => {
                this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed()
            }
            )
        }
        updateSnapshot() {
            this.snapshot || !this.instance || (this.snapshot = this.measure(),
            this.snapshot && !so(this.snapshot.measuredBox.x) && !so(this.snapshot.measuredBox.y) && (this.snapshot = void 0))
        }
        updateLayout() {
            if (!this.instance || (this.updateScroll(),
            !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
                return;
            if (this.resumeFrom && !this.resumeFrom.instance)
                for (let w = 0; w < this.path.length; w++)
                    this.path[w].updateScroll();
            const p = this.layout;
            this.layout = this.measure(!1),
            this.layoutCorrected = Ct(),
            this.isLayoutDirty = !1,
            this.projectionDelta = void 0,
            this.notifyListeners("measure", this.layout.layoutBox);
            const {visualElement: f} = this.options;
            f && f.notify("LayoutMeasure", this.layout.layoutBox, p ? p.layoutBox : void 0)
        }
        updateScroll(p="measure") {
            let f = !!(this.options.layoutScroll && this.instance);
            if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === p && (f = !1),
            f && this.instance) {
                const w = c(this.instance);
                this.scroll = {
                    animationId: this.root.animationId,
                    phase: p,
                    isRoot: w,
                    offset: a(this.instance),
                    wasRoot: this.scroll ? this.scroll.isRoot : w
                }
            }
        }
        resetTransform() {
            if (!u)
                return;
            const p = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout
              , f = this.projectionDelta && !oB(this.projectionDelta)
              , w = this.getTransformTemplate()
              , k = w ? w(this.latestValues, "") : void 0
              , y = k !== this.prevTransformTemplateValue;
            p && this.instance && (f || Gi(this.latestValues) || y) && (u(this.instance, k),
            this.shouldResetTransform = !1,
            this.scheduleRender())
        }
        measure(p=!0) {
            const f = this.measurePageBox();
            let w = this.removeElementScroll(f);
            return p && (w = this.removeTransform(w)),
            Jq(w),
            {
                animationId: this.root.animationId,
                measuredBox: f,
                layoutBox: w,
                latestValues: {},
                source: this.id
            }
        }
        measurePageBox() {
            var p;
            const {visualElement: f} = this.options;
            if (!f)
                return Ct();
            const w = f.measureViewportBox();
            if (!((p = this.scroll) != null && p.wasRoot || this.path.some(Xq))) {
                const {scroll: k} = this.root;
                k && (pa(w.x, k.offset.x),
                pa(w.y, k.offset.y))
            }
            return w
        }
        removeElementScroll(p) {
            var f;
            const w = Ct();
            if (Zo(w, p),
            (f = this.scroll) != null && f.wasRoot)
                return w;
            for (let k = 0; k < this.path.length; k++) {
                const y = this.path[k]
                  , {scroll: E, options: S} = y;
                y !== this.root && E && S.layoutScroll && (E.wasRoot && Zo(w, p),
                pa(w.x, E.offset.x),
                pa(w.y, E.offset.y))
            }
            return w
        }
        applyTransform(p, f=!1) {
            const w = Ct();
            Zo(w, p);
            for (let k = 0; k < this.path.length; k++) {
                const y = this.path[k];
                !f && y.options.layoutScroll && y.scroll && y !== y.root && ga(w, {
                    x: -y.scroll.offset.x,
                    y: -y.scroll.offset.y
                }),
                Gi(y.latestValues) && ga(w, y.latestValues)
            }
            return Gi(this.latestValues) && ga(w, this.latestValues),
            w
        }
        removeTransform(p) {
            const f = Ct();
            Zo(f, p);
            for (let w = 0; w < this.path.length; w++) {
                const k = this.path[w];
                if (!k.instance || !Gi(k.latestValues))
                    continue;
                Kk(k.latestValues) && k.updateSnapshot();
                const y = Ct()
                  , E = k.measurePageBox();
                Zo(y, E),
                G2(f, k.latestValues, k.snapshot ? k.snapshot.layoutBox : void 0, y)
            }
            return Gi(this.latestValues) && G2(f, this.latestValues),
            f
        }
        setTargetDelta(p) {
            this.targetDelta = p,
            this.root.scheduleUpdateProjection(),
            this.isProjectionDirty = !0
        }
        setOptions(p) {
            this.options = {
                ...this.options,
                ...p,
                crossfade: p.crossfade !== void 0 ? p.crossfade : !0
            }
        }
        clearMeasurements() {
            this.scroll = void 0,
            this.layout = void 0,
            this.snapshot = void 0,
            this.prevTransformTemplateValue = void 0,
            this.targetDelta = void 0,
            this.target = void 0,
            this.isLayoutDirty = !1
        }
        forceRelativeParentToResolveTarget() {
            this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== $t.timestamp && this.relativeParent.resolveTargetDelta(!0)
        }
        resolveTargetDelta(p=!1) {
            var f;
            const w = this.getLead();
            this.isProjectionDirty || (this.isProjectionDirty = w.isProjectionDirty),
            this.isTransformDirty || (this.isTransformDirty = w.isTransformDirty),
            this.isSharedProjectionDirty || (this.isSharedProjectionDirty = w.isSharedProjectionDirty);
            const k = !!this.resumingFrom || this !== w;
            if (!(p || k && this.isSharedProjectionDirty || this.isProjectionDirty || (f = this.parent) != null && f.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize))
                return;
            const {layout: y, layoutId: E} = this.options;
            if (!(!this.layout || !(y || E))) {
                if (this.resolvedRelativeTargetAt = $t.timestamp,
                !this.targetDelta && !this.relativeTarget) {
                    const S = this.getClosestProjectingParent();
                    S && S.layout && this.animationProgress !== 1 ? (this.relativeParent = S,
                    this.forceRelativeParentToResolveTarget(),
                    this.relativeTarget = Ct(),
                    this.relativeTargetOrigin = Ct(),
                    vc(this.relativeTargetOrigin, this.layout.layoutBox, S.layout.layoutBox),
                    Zo(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
                }
                if (!(!this.relativeTarget && !this.targetDelta) && (this.target || (this.target = Ct(),
                this.targetWithTransforms = Ct()),
                this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(),
                iq(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : Zo(this.target, this.layout.layoutBox),
                z5(this.target, this.targetDelta)) : Zo(this.target, this.layout.layoutBox),
                this.attemptToResolveRelativeTarget)) {
                    this.attemptToResolveRelativeTarget = !1;
                    const S = this.getClosestProjectingParent();
                    S && !!S.resumingFrom == !!this.resumingFrom && !S.options.layoutScroll && S.target && this.animationProgress !== 1 ? (this.relativeParent = S,
                    this.forceRelativeParentToResolveTarget(),
                    this.relativeTarget = Ct(),
                    this.relativeTargetOrigin = Ct(),
                    vc(this.relativeTargetOrigin, this.target, S.target),
                    Zo(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
                }
            }
        }
        getClosestProjectingParent() {
            if (!(!this.parent || Kk(this.parent.latestValues) || L5(this.parent.latestValues)))
                return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent()
        }
        isProjecting() {
            return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout)
        }
        calcProjection() {
            var p;
            const f = this.getLead()
              , w = !!this.resumingFrom || this !== f;
            let k = !0;
            if ((this.isProjectionDirty || (p = this.parent) != null && p.isProjectionDirty) && (k = !1),
            w && (this.isSharedProjectionDirty || this.isTransformDirty) && (k = !1),
            this.resolvedRelativeTargetAt === $t.timestamp && (k = !1),
            k)
                return;
            const {layout: y, layoutId: E} = this.options;
            if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation),
            this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0),
            !this.layout || !(y || E))
                return;
            Zo(this.layoutCorrected, this.layout.layoutBox);
            const S = this.treeScale.x
              , A = this.treeScale.y;
            k$(this.layoutCorrected, this.treeScale, this.path, w),
            f.layout && !f.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (f.target = f.layout.layoutBox,
            f.targetWithTransforms = Ct());
            const {target: D} = f;
            if (!D) {
                this.prevProjectionDelta && (this.createProjectionDeltas(),
                this.scheduleRender());
                return
            }
            !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (W2(this.prevProjectionDelta.x, this.projectionDelta.x),
            W2(this.prevProjectionDelta.y, this.projectionDelta.y)),
            Ac(this.projectionDelta, this.layoutCorrected, D, this.latestValues),
            (this.treeScale.x !== S || this.treeScale.y !== A || !J2(this.projectionDelta.x, this.prevProjectionDelta.x) || !J2(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0,
            this.scheduleRender(),
            this.notifyListeners("projectionUpdate", D))
        }
        hide() {
            this.isVisible = !1
        }
        show() {
            this.isVisible = !0
        }
        scheduleRender(p=!0) {
            var f;
            if ((f = this.options.visualElement) == null || f.scheduleRender(),
            p) {
                const w = this.getStack();
                w && w.scheduleRender()
            }
            this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0)
        }
        createProjectionDeltas() {
            this.prevProjectionDelta = fa(),
            this.projectionDelta = fa(),
            this.projectionDeltaWithTransform = fa()
        }
        setAnimationOrigin(p, f=!1) {
            const w = this.snapshot
              , k = w ? w.latestValues : {}
              , y = {
                ...this.latestValues
            }
              , E = fa();
            (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0),
            this.attemptToResolveRelativeTarget = !f;
            const S = Ct()
              , A = w ? w.source : void 0
              , D = this.layout ? this.layout.source : void 0
              , N = A !== D
              , L = this.getStack()
              , z = !L || L.members.length <= 1
              , B = !!(N && !z && this.options.crossfade === !0 && !this.path.some(Qq));
            this.animationProgress = 0;
            let M;
            this.mixTargetDelta = j => {
                const V = j / 1e3;
                oD(E.x, p.x, V),
                oD(E.y, p.y, V),
                this.setTargetDelta(E),
                this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (vc(S, this.layout.layoutBox, this.relativeParent.layout.layoutBox),
                Yq(this.relativeTarget, this.relativeTargetOrigin, S, V),
                M && Pq(this.relativeTarget, M) && (this.isProjectionDirty = !1),
                M || (M = Ct()),
                Zo(M, this.relativeTarget)),
                N && (this.animationValues = y,
                Dq(y, k, this.latestValues, V, B, z)),
                this.root.scheduleUpdateProjection(),
                this.scheduleRender(),
                this.animationProgress = V
            }
            ,
            this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0)
        }
        startAnimation(p) {
            var f, w, k;
            this.notifyListeners("animationStart"),
            (f = this.currentAnimation) == null || f.stop(),
            (k = (w = this.resumingFrom) == null ? void 0 : w.currentAnimation) == null || k.stop(),
            this.pendingAnimation && (hi(this.pendingAnimation),
            this.pendingAnimation = void 0),
            this.pendingAnimation = lt.update( () => {
                kh.hasAnimatedSinceResize = !0,
                this.motionValue || (this.motionValue = La(0)),
                this.currentAnimation = Cq(this.motionValue, [0, 1e3], {
                    ...p,
                    velocity: 0,
                    isSync: !0,
                    onUpdate: y => {
                        this.mixTargetDelta(y),
                        p.onUpdate && p.onUpdate(y)
                    }
                    ,
                    onStop: () => {}
                    ,
                    onComplete: () => {
                        p.onComplete && p.onComplete(),
                        this.completeAnimation()
                    }
                }),
                this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation),
                this.pendingAnimation = void 0
            }
            )
        }
        completeAnimation() {
            this.resumingFrom && (this.resumingFrom.currentAnimation = void 0,
            this.resumingFrom.preserveOpacity = void 0);
            const p = this.getStack();
            p && p.exitAnimationComplete(),
            this.resumingFrom = this.currentAnimation = this.animationValues = void 0,
            this.notifyListeners("animationComplete")
        }
        finishAnimation() {
            this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(zq),
            this.currentAnimation.stop()),
            this.completeAnimation()
        }
        applyTransformsToTarget() {
            const p = this.getLead();
            let {targetWithTransforms: f, target: w, layout: k, latestValues: y} = p;
            if (!(!f || !w || !k)) {
                if (this !== p && this.layout && k && sB(this.options.animationType, this.layout.layoutBox, k.layoutBox)) {
                    w = this.target || Ct();
                    const E = so(this.layout.layoutBox.x);
                    w.x.min = p.target.x.min,
                    w.x.max = w.x.min + E;
                    const S = so(this.layout.layoutBox.y);
                    w.y.min = p.target.y.min,
                    w.y.max = w.y.min + S
                }
                Zo(f, w),
                ga(f, y),
                Ac(this.projectionDeltaWithTransform, this.layoutCorrected, f, y)
            }
        }
        registerSharedNode(p, f) {
            this.sharedNodes.has(p) || this.sharedNodes.set(p, new jq),
            this.sharedNodes.get(p).add(f);
            const w = f.options.initialPromotionConfig;
            f.promote({
                transition: w ? w.transition : void 0,
                preserveFollowOpacity: w && w.shouldPreserveFollowOpacity ? w.shouldPreserveFollowOpacity(f) : void 0
            })
        }
        isLead() {
            const p = this.getStack();
            return p ? p.lead === this : !0
        }
        getLead() {
            var p;
            const {layoutId: f} = this.options;
            return f ? ((p = this.getStack()) == null ? void 0 : p.lead) || this : this
        }
        getPrevLead() {
            var p;
            const {layoutId: f} = this.options;
            return f ? (p = this.getStack()) == null ? void 0 : p.prevLead : void 0
        }
        getStack() {
            const {layoutId: p} = this.options;
            if (p)
                return this.root.sharedNodes.get(p)
        }
        promote({needsReset: p, transition: f, preserveFollowOpacity: w}={}) {
            const k = this.getStack();
            k && k.promote(this, w),
            p && (this.projectionDelta = void 0,
            this.needsReset = !0),
            f && this.setOptions({
                transition: f
            })
        }
        relegate() {
            const p = this.getStack();
            return p ? p.relegate(this) : !1
        }
        resetSkewAndRotation() {
            const {visualElement: p} = this.options;
            if (!p)
                return;
            let f = !1;
            const {latestValues: w} = p;
            if ((w.z || w.rotate || w.rotateX || w.rotateY || w.rotateZ || w.skewX || w.skewY) && (f = !0),
            !f)
                return;
            const k = {};
            w.z && Bf("z", p, k, this.animationValues);
            for (let y = 0; y < Mf.length; y++)
                Bf(`rotate${Mf[y]}`, p, k, this.animationValues),
                Bf(`skew${Mf[y]}`, p, k, this.animationValues);
            p.render();
            for (const y in k)
                p.setStaticValue(y, k[y]),
                this.animationValues && (this.animationValues[y] = k[y]);
            p.scheduleRender()
        }
        applyProjectionStyles(p, f) {
            if (!this.instance || this.isSVG)
                return;
            if (!this.isVisible) {
                p.visibility = "hidden";
                return
            }
            const w = this.getTransformTemplate();
            if (this.needsReset) {
                this.needsReset = !1,
                p.visibility = "",
                p.opacity = "",
                p.pointerEvents = fh(f == null ? void 0 : f.pointerEvents) || "",
                p.transform = w ? w(this.latestValues, "") : "none";
                return
            }
            const k = this.getLead();
            if (!this.projectionDelta || !this.layout || !k.target) {
                this.options.layoutId && (p.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1,
                p.pointerEvents = fh(f == null ? void 0 : f.pointerEvents) || ""),
                this.hasProjected && !Gi(this.latestValues) && (p.transform = w ? w({}, "") : "none",
                this.hasProjected = !1);
                return
            }
            p.visibility = "";
            const y = k.animationValues || k.latestValues;
            this.applyTransformsToTarget();
            let E = Lq(this.projectionDeltaWithTransform, this.treeScale, y);
            w && (E = w(y, E)),
            p.transform = E;
            const {x: S, y: A} = this.projectionDelta;
            p.transformOrigin = `${S.origin * 100}% ${A.origin * 100}% 0`,
            k.animationValues ? p.opacity = k === this ? y.opacity ?? this.latestValues.opacity ?? 1 : this.preserveOpacity ? this.latestValues.opacity : y.opacityExit : p.opacity = k === this ? y.opacity !== void 0 ? y.opacity : "" : y.opacityExit !== void 0 ? y.opacityExit : 0;
            for (const D in Vc) {
                if (y[D] === void 0)
                    continue;
                const {correct: N, applyTo: L, isCSSVariable: z} = Vc[D]
                  , B = E === "none" ? y[D] : N(y[D], k);
                if (L) {
                    const M = L.length;
                    for (let j = 0; j < M; j++)
                        p[L[j]] = B
                } else
                    z ? this.options.visualElement.renderState.vars[D] = B : p[D] = B
            }
            this.options.layoutId && (p.pointerEvents = k === this ? fh(f == null ? void 0 : f.pointerEvents) || "" : "none")
        }
        clearSnapshot() {
            this.resumeFrom = this.snapshot = void 0
        }
        resetTree() {
            this.root.nodes.forEach(p => {
                var f;
                return (f = p.currentAnimation) == null ? void 0 : f.stop()
            }
            ),
            this.root.nodes.forEach(X2),
            this.root.sharedNodes.clear()
        }
    }
}
function Rq(o) {
    o.updateLayout()
}
function Fq(o) {
    var n;
    const a = ((n = o.resumeFrom) == null ? void 0 : n.snapshot) || o.snapshot;
    if (o.isLead() && o.layout && a && o.hasListeners("didUpdate")) {
        const {layoutBox: c, measuredBox: u} = o.layout
          , {animationType: p} = o.options
          , f = a.source !== o.layout.source;
        p === "size" ? Jo(S => {
            const A = f ? a.measuredBox[S] : a.layoutBox[S]
              , D = so(A);
            A.min = c[S].min,
            A.max = A.min + D
        }
        ) : sB(p, a.layoutBox, c) && Jo(S => {
            const A = f ? a.measuredBox[S] : a.layoutBox[S]
              , D = so(c[S]);
            A.max = A.min + D,
            o.relativeTarget && !o.currentAnimation && (o.isProjectionDirty = !0,
            o.relativeTarget[S].max = o.relativeTarget[S].min + D)
        }
        );
        const w = fa();
        Ac(w, c, a.layoutBox);
        const k = fa();
        f ? Ac(k, o.applyTransform(u, !0), a.measuredBox) : Ac(k, c, a.layoutBox);
        const y = !oB(w);
        let E = !1;
        if (!o.resumeFrom) {
            const S = o.getClosestProjectingParent();
            if (S && !S.resumeFrom) {
                const {snapshot: A, layout: D} = S;
                if (A && D) {
                    const N = Ct();
                    vc(N, a.layoutBox, A.layoutBox);
                    const L = Ct();
                    vc(L, c, D.layoutBox),
                    rB(N, L) || (E = !0),
                    S.options.layoutRoot && (o.relativeTarget = L,
                    o.relativeTargetOrigin = N,
                    o.relativeParent = S)
                }
            }
        }
        o.notifyListeners("didUpdate", {
            layout: c,
            snapshot: a,
            delta: k,
            layoutDelta: w,
            hasLayoutChanged: y,
            hasRelativeLayoutChanged: E
        })
    } else if (o.isLead()) {
        const {onExitComplete: c} = o.options;
        c && c()
    }
    o.options.transition = void 0
}
function Vq(o) {
    o.parent && (o.isProjecting() || (o.isProjectionDirty = o.parent.isProjectionDirty),
    o.isSharedProjectionDirty || (o.isSharedProjectionDirty = !!(o.isProjectionDirty || o.parent.isProjectionDirty || o.parent.isSharedProjectionDirty)),
    o.isTransformDirty || (o.isTransformDirty = o.parent.isTransformDirty))
}
function Uq(o) {
    o.isProjectionDirty = o.isSharedProjectionDirty = o.isTransformDirty = !1
}
function Hq(o) {
    o.clearSnapshot()
}
function X2(o) {
    o.clearMeasurements()
}
function eD(o) {
    o.isLayoutDirty = !1
}
function Wq(o) {
    const {visualElement: n} = o.options;
    n && n.getProps().onBeforeLayoutMeasure && n.notify("BeforeLayoutMeasure"),
    o.resetTransform()
}
function tD(o) {
    o.finishAnimation(),
    o.targetDelta = o.relativeTarget = o.target = void 0,
    o.isProjectionDirty = !0
}
function $q(o) {
    o.resolveTargetDelta()
}
function qq(o) {
    o.calcProjection()
}
function Gq(o) {
    o.resetSkewAndRotation()
}
function Kq(o) {
    o.removeLeadSnapshot()
}
function oD(o, n, a) {
    o.translate = ut(n.translate, 0, a),
    o.scale = ut(n.scale, 1, a),
    o.origin = n.origin,
    o.originPoint = n.originPoint
}
function rD(o, n, a, c) {
    o.min = ut(n.min, a.min, c),
    o.max = ut(n.max, a.max, c)
}
function Yq(o, n, a, c) {
    rD(o.x, n.x, a.x, c),
    rD(o.y, n.y, a.y, c)
}
function Qq(o) {
    return o.animationValues && o.animationValues.opacityExit !== void 0
}
const Zq = {
    duration: .45,
    ease: [.4, 0, .1, 1]
}
  , nD = o => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(o)
  , iD = nD("applewebkit/") && !nD("chrome/") ? Math.round : ar;
function sD(o) {
    o.min = iD(o.min),
    o.max = iD(o.max)
}
function Jq(o) {
    sD(o.x),
    sD(o.y)
}
function sB(o, n, a) {
    return o === "position" || o === "preserve-aspect" && !nq(Z2(n), Z2(a), .2)
}
function Xq(o) {
    var n;
    return o !== o.root && ((n = o.scroll) == null ? void 0 : n.wasRoot)
}
const eG = iB({
    attachResizeListener: (o, n) => Uc(o, "resize", n),
    measureScroll: () => ({
        x: document.documentElement.scrollLeft || document.body.scrollLeft,
        y: document.documentElement.scrollTop || document.body.scrollTop
    }),
    checkIsScrollRoot: () => !0
})
  , Nf = {
    current: void 0
}
  , aB = iB({
    measureScroll: o => ({
        x: o.scrollLeft,
        y: o.scrollTop
    }),
    defaultParent: () => {
        if (!Nf.current) {
            const o = new eG({});
            o.mount(window),
            o.setOptions({
                layoutScroll: !0
            }),
            Nf.current = o
        }
        return Nf.current
    }
    ,
    resetTransform: (o, n) => {
        o.style.transform = n !== void 0 ? n : "none"
    }
    ,
    checkIsScrollRoot: o => window.getComputedStyle(o).position === "fixed"
})
  , tG = {
    pan: {
        Feature: wq
    },
    drag: {
        Feature: bq,
        ProjectionNode: aB,
        MeasureLayout: X5
    }
};
function aD(o, n, a) {
    const {props: c} = o;
    o.animationState && c.whileHover && o.animationState.setActive("whileHover", a === "Start");
    const u = "onHover" + a
      , p = c[u];
    p && lt.postRender( () => p(n, ld(n)))
}
class oG extends fi {
    mount() {
        const {current: n} = this.node;
        n && (this.unmount = _W(n, (a, c) => (aD(this.node, c, "Start"),
        u => aD(this.node, u, "End"))))
    }
    unmount() {}
}
class rG extends fi {
    constructor() {
        super(...arguments),
        this.isActive = !1
    }
    onFocus() {
        let n = !1;
        try {
            n = this.node.current.matches(":focus-visible")
        } catch {
            n = !0
        }
        !n || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0),
        this.isActive = !0)
    }
    onBlur() {
        !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1),
        this.isActive = !1)
    }
    mount() {
        this.unmount = id(Uc(this.node.current, "focus", () => this.onFocus()), Uc(this.node.current, "blur", () => this.onBlur()))
    }
    unmount() {}
}
function lD(o, n, a) {
    const {props: c} = o;
    if (o.current instanceof HTMLButtonElement && o.current.disabled)
        return;
    o.animationState && c.whileTap && o.animationState.setActive("whileTap", a === "Start");
    const u = "onTap" + (a === "End" ? "" : a)
      , p = c[u];
    p && lt.postRender( () => p(n, ld(n)))
}
class nG extends fi {
    mount() {
        const {current: n} = this.node;
        n && (this.unmount = EW(n, (a, c) => (lD(this.node, c, "Start"),
        (u, {success: p}) => lD(this.node, u, p ? "End" : "Cancel")), {
            useGlobalTarget: this.node.props.globalTapTarget
        }))
    }
    unmount() {}
}
const tb = new WeakMap
  , Pf = new WeakMap
  , iG = o => {
    const n = tb.get(o.target);
    n && n(o)
}
  , sG = o => {
    o.forEach(iG)
}
;
function aG({root: o, ...n}) {
    const a = o || document;
    Pf.has(a) || Pf.set(a, {});
    const c = Pf.get(a)
      , u = JSON.stringify(n);
    return c[u] || (c[u] = new IntersectionObserver(sG,{
        root: o,
        ...n
    })),
    c[u]
}
function lG(o, n, a) {
    const c = aG(n);
    return tb.set(o, a),
    c.observe(o),
    () => {
        tb.delete(o),
        c.unobserve(o)
    }
}
const cG = {
    some: 0,
    all: 1
};
class dG extends fi {
    constructor() {
        super(...arguments),
        this.hasEnteredView = !1,
        this.isInView = !1
    }
    startObserver() {
        this.unmount();
        const {viewport: n={}} = this.node.getProps()
          , {root: a, margin: c, amount: u="some", once: p} = n
          , f = {
            root: a ? a.current : void 0,
            rootMargin: c,
            threshold: typeof u == "number" ? u : cG[u]
        }
          , w = k => {
            const {isIntersecting: y} = k;
            if (this.isInView === y || (this.isInView = y,
            p && !y && this.hasEnteredView))
                return;
            y && (this.hasEnteredView = !0),
            this.node.animationState && this.node.animationState.setActive("whileInView", y);
            const {onViewportEnter: E, onViewportLeave: S} = this.node.getProps()
              , A = y ? E : S;
            A && A(k)
        }
        ;
        return lG(this.node.current, f, w)
    }
    mount() {
        this.startObserver()
    }
    update() {
        if (typeof IntersectionObserver > "u")
            return;
        const {props: n, prevProps: a} = this.node;
        ["amount", "margin", "root"].some(uG(n, a)) && this.startObserver()
    }
    unmount() {}
}
function uG({viewport: o={}}, {viewport: n={}}={}) {
    return a => o[a] !== n[a]
}
const hG = {
    inView: {
        Feature: dG
    },
    tap: {
        Feature: nG
    },
    focus: {
        Feature: rG
    },
    hover: {
        Feature: oG
    }
}
  , mG = {
    layout: {
        ProjectionNode: aB,
        MeasureLayout: X5
    }
}
  , pG = {
    ...J$,
    ...hG,
    ...tG,
    ...mG
}
  , gG = p$(pG, S$);
class fG extends Jn.Component {
    constructor(n) {
        super(n),
        this.state = {
            hasError: !1
        }
    }
    static getDerivedStateFromError(n) {
        return {
            hasError: !0
        }
    }
    componentDidCatch(n, a) {
        console.error("Error caught by ErrorBoundary:", n, a)
    }
    render() {
        return this.state.hasError ? _.jsx("h1", {
            children: "Something went wrong."
        }) : this.props.children
    }
}
function kG() {
    return _.jsx("div", {
        className: "iphone-frame",
        children: _.jsx("div", {
            className: "iphone-content",
            children: _.jsx(yM, {})
        })
    })
}
const bG = "/logos/stockloyal.png";
function wG() {
    return _.jsx("header", {
        className: "app-header bg-white flex items-center justify-right h-8 border-b border-gray-200 shadow-sm",
        children: _.jsx("img", {
            src: bG,
            alt: "StockLoyal",
            className: "max-h-3 max-w-[60px] object-contain",
            style: {
                height: "32px",
                width: "auto"
            }
        })
    })
}
/**
* @license lucide-react v0.542.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const AG = o => o.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase()
  , vG = o => o.replace(/^([A-Z])|[\s-_]+(\w)/g, (n, a, c) => c ? c.toUpperCase() : a.toLowerCase())
  , cD = o => {
    const n = vG(o);
    return n.charAt(0).toUpperCase() + n.slice(1)
}
  , lB = (...o) => o.filter( (n, a, c) => !!n && n.trim() !== "" && c.indexOf(n) === a).join(" ").trim()
  , _G = o => {
    for (const n in o)
        if (n.startsWith("aria-") || n === "role" || n === "title")
            return !0
}
;
/**
* @license lucide-react v0.542.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
var CG = {
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: 2,
    strokeLinecap: "round",
    strokeLinejoin: "round"
};
/**
* @license lucide-react v0.542.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const yG = R.forwardRef( ({color: o="currentColor", size: n=24, strokeWidth: a=2, absoluteStrokeWidth: c, className: u="", children: p, iconNode: f, ...w}, k) => R.createElement("svg", {
    ref: k,
    ...CG,
    width: n,
    height: n,
    stroke: o,
    strokeWidth: c ? Number(a) * 24 / Number(n) : a,
    className: lB("lucide", u),
    ...!p && !_G(w) && {
        "aria-hidden": "true"
    },
    ...w
}, [...f.map( ([y,E]) => R.createElement(y, E)), ...Array.isArray(p) ? p : [p]]));
/**
* @license lucide-react v0.542.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const Sr = (o, n) => {
    const a = R.forwardRef( ({className: c, ...u}, p) => R.createElement(yG, {
        ref: p,
        iconNode: n,
        className: lB(`lucide-${AG(cD(o))}`, `lucide-${o}`, c),
        ...u
    }));
    return a.displayName = cD(o),
    a
}
;
/**
* @license lucide-react v0.542.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const xG = [["path", {
    d: "M16 20V4a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v16",
    key: "jecpp"
}], ["rect", {
    width: "20",
    height: "14",
    x: "2",
    y: "6",
    rx: "2",
    key: "i6l2r4"
}]]
  , EG = Sr("briefcase", xG);
/**
* @license lucide-react v0.542.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const SG = [["line", {
    x1: "18",
    x2: "18",
    y1: "20",
    y2: "10",
    key: "1xfpm4"
}], ["line", {
    x1: "12",
    x2: "12",
    y1: "20",
    y2: "4",
    key: "be30l9"
}], ["line", {
    x1: "6",
    x2: "6",
    y1: "20",
    y2: "14",
    key: "1r4le6"
}]]
  , DG = Sr("chart-no-axes-column", SG);
/**
* @license lucide-react v0.542.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const TG = [["rect", {
    width: "20",
    height: "14",
    x: "2",
    y: "5",
    rx: "2",
    key: "ynyp8z"
}], ["line", {
    x1: "2",
    x2: "22",
    y1: "10",
    y2: "10",
    key: "1b3vmo"
}]]
  , IG = Sr("credit-card", TG);
/**
* @license lucide-react v0.542.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const MG = [["circle", {
    cx: "12",
    cy: "12",
    r: "10",
    key: "1mglay"
}], ["path", {
    d: "M12 16v-4",
    key: "1dtifu"
}], ["path", {
    d: "M12 8h.01",
    key: "e9boi3"
}]]
  , BG = Sr("info", MG);
/**
* @license lucide-react v0.542.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const NG = [["path", {
    d: "M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8",
    key: "v9h5vc"
}], ["path", {
    d: "M21 3v5h-5",
    key: "1q7to0"
}], ["path", {
    d: "M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16",
    key: "3uifl3"
}], ["path", {
    d: "M8 16H3v5",
    key: "1cv678"
}]]
  , PG = Sr("refresh-cw", NG);
/**
* @license lucide-react v0.542.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const jG = [["path", {
    d: "m21 21-4.34-4.34",
    key: "14j7rj"
}], ["circle", {
    cx: "11",
    cy: "11",
    r: "8",
    key: "4ej97u"
}]]
  , LG = Sr("search", jG);
/**
* @license lucide-react v0.542.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const zG = [["path", {
    d: "M9.671 4.136a2.34 2.34 0 0 1 4.659 0 2.34 2.34 0 0 0 3.319 1.915 2.34 2.34 0 0 1 2.33 4.033 2.34 2.34 0 0 0 0 3.831 2.34 2.34 0 0 1-2.33 4.033 2.34 2.34 0 0 0-3.319 1.915 2.34 2.34 0 0 1-4.659 0 2.34 2.34 0 0 0-3.32-1.915 2.34 2.34 0 0 1-2.33-4.033 2.34 2.34 0 0 0 0-3.831A2.34 2.34 0 0 1 6.35 6.051a2.34 2.34 0 0 0 3.319-1.915",
    key: "1i5ecw"
}], ["circle", {
    cx: "12",
    cy: "12",
    r: "3",
    key: "1v7zrd"
}]]
  , OG = Sr("settings", zG);
/**
* @license lucide-react v0.542.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const RG = [["path", {
    d: "m15 11-1 9",
    key: "5wnq3a"
}], ["path", {
    d: "m19 11-4-7",
    key: "cnml18"
}], ["path", {
    d: "M2 11h20",
    key: "3eubbj"
}], ["path", {
    d: "m3.5 11 1.6 7.4a2 2 0 0 0 2 1.6h9.8a2 2 0 0 0 2-1.6l1.7-7.4",
    key: "yiazzp"
}], ["path", {
    d: "M4.5 15.5h15",
    key: "13mye1"
}], ["path", {
    d: "m5 11 4-7",
    key: "116ra9"
}], ["path", {
    d: "m9 11 1 9",
    key: "1ojof7"
}]]
  , FG = Sr("shopping-basket", RG);
/**
* @license lucide-react v0.542.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const VG = [["path", {
    d: "M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2",
    key: "975kel"
}], ["circle", {
    cx: "12",
    cy: "7",
    r: "4",
    key: "17ys0d"
}]]
  , UG = Sr("user", VG);
/**
* @license lucide-react v0.542.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const HG = [["path", {
    d: "M19 7V4a1 1 0 0 0-1-1H5a2 2 0 0 0 0 4h15a1 1 0 0 1 1 1v4h-3a2 2 0 0 0 0 4h3a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1",
    key: "18etb6"
}], ["path", {
    d: "M3 5v14a2 2 0 0 0 2 2h15a1 1 0 0 0 1-1v-4",
    key: "xoc0q4"
}]]
  , WG = Sr("wallet", HG);
/**
* @license lucide-react v0.542.0 - ISC
*
* This source code is licensed under the ISC license.
* See the LICENSE file in the root directory of this source tree.
*/
const $G = [["path", {
    d: "M18 6 6 18",
    key: "1bl5f8"
}], ["path", {
    d: "m6 6 12 12",
    key: "d8bk6v"
}]]
  , qG = Sr("x", $G)
  , cB = R.createContext();
function GG({children: o}) {
    const [n,a] = R.useState([])
      , c = f => {
        a(w => w.find(k => k.symbol === f.symbol) ? w : [...w, f])
    }
      , u = f => {
        a(w => w.filter(k => k.symbol !== f))
    }
      , p = () => a([]);
    return _.jsx(cB.Provider, {
        value: {
            basket: n,
            addToBasket: c,
            removeFromBasket: u,
            clearBasket: p
        },
        children: o
    })
}
function cd() {
    return R.useContext(cB)
}
function KG({isOpen: o, onClose: n, title: a, side: c="right", width: u=360, zIndex: p=2e3, anchorSelector: f=".app-container", children: w}) {
    const k = c === "left"
      , [y,E] = R.useState(null)
      , S = Zt()
      , A = () => {
        const j = document.querySelector(f);
        return j ? j.getBoundingClientRect() : null
    }
    ;
    R.useLayoutEffect( () => {
        o && E(A())
    }
    , [o, f]),
    R.useEffect( () => {
        if (!o)
            return;
        const j = () => E(A());
        return window.addEventListener("resize", j, {
            passive: !0
        }),
        window.addEventListener("scroll", j, {
            passive: !0
        }),
        () => {
            window.removeEventListener("resize", j),
            window.removeEventListener("scroll", j)
        }
    }
    , [o, f]),
    R.useEffect( () => {
        o && n()
    }
    , [S]);
    const D = y && {
        position: "fixed",
        top: 37,
        left: 0,
        width: "100%",
        height: "calc(100vh - 37px)",
        background: "rgba(0,0,0,.4)",
        opacity: o ? 1 : 0,
        transition: "opacity 260ms ease",
        zIndex: p,
        pointerEvents: o ? "auto" : "none"
    }
      , N = y && {
        position: "fixed",
        top: 37,
        bottom: 0,
        [k ? "left" : "right"]: 0,
        width: `${u}px`,
        background: "#fff",
        boxShadow: k ? "2px 0 14px rgba(0,0,0,.14)" : "-2px 0 14px rgba(0,0,0,.14)",
        borderLeft: k ? "none" : "1px solid rgba(0,0,0,0.06)",
        borderRight: k ? "1px solid rgba(0,0,0,0.06)" : "none",
        transform: `translateX(${o ? "0%" : k ? "-100%" : "100%"})`,
        transition: "transform 280ms cubic-bezier(.2,.7,.3,1)",
        display: "flex",
        flexDirection: "column",
        maxHeight: "calc(100vh - 37px)",
        zIndex: p + 1
    }
      , L = {
        position: "sticky",
        top: 0,
        zIndex: 1,
        background: "#fff",
        display: "flex",
        alignItems: "center",
        justifyContent: "space-between",
        padding: "12px 14px",
        borderBottom: "1px solid rgba(0,0,0,0.06)"
    }
      , z = {
        margin: 0,
        fontSize: 16,
        fontWeight: 600
    }
      , B = {
        appearance: "none",
        border: "1px solid rgba(0,0,0,0.08)",
        background: "#fff",
        borderRadius: 10,
        padding: "6px",
        cursor: "pointer",
        display: "flex",
        alignItems: "center",
        justifyContent: "center"
    }
      , M = {
        flex: 1,
        overflowY: "auto",
        padding: 14,
        background: "#fff"
    };
    return y ? _.jsxs(_.Fragment, {
        children: [_.jsx("div", {
            style: D,
            onClick: n
        }), _.jsxs("aside", {
            role: "dialog",
            "aria-modal": "true",
            style: N,
            children: [_.jsxs("div", {
                style: L,
                children: [_.jsx("h3", {
                    style: z,
                    children: a
                }), _.jsx("button", {
                    style: B,
                    onClick: n,
                    children: _.jsx(qG, {
                        size: 18,
                        strokeWidth: 2
                    })
                })]
            }), _.jsx("div", {
                className: "slideout-body",
                style: M,
                children: w
            })]
        })]
    }) : null
}
function YG() {
    const o = Zt()
      , {basket: n} = cd()
      , [a,c] = R.useState(!1)
      , u = [{
        to: "/wallet",
        label: "Wallet",
        icon: _.jsx(WG, {
            className: "nav-icon"
        })
    }, {
        to: "/select-broker",
        label: "Select Broker",
        icon: _.jsx(EG, {
            className: "nav-icon"
        })
    }, {
        to: "/about",
        label: "About",
        icon: _.jsx(BG, {
            className: "nav-icon"
        })
    }, {
        to: "/basket",
        label: "Basket",
        icon: _.jsx(FG, {
            className: "nav-icon"
        })
    }, {
        to: "/member-onboard",
        label: "Member Onboard",
        icon: _.jsx(UG, {
            className: "nav-icon"
        })
    }]
      , p = [{
        to: "/promotions",
        label: "Promotions"
    }, {
        to: "/login",
        label: "Login"
    }, {
        to: "/terms",
        label: "Terms & Conditions"
    }, {
        to: "/about",
        label: "About"
    }, {
        to: "/member-onboard",
        label: "Member Profile"
    }, {
        to: "/wallet",
        label: "Wallet"
    }, {
        to: "/order",
        label: "Pending Order"
    }, {
        to: "/order-confirmation",
        label: "Order Confirmation"
    }, {
        to: "/select-broker",
        label: "Select Broker"
    }, {
        to: "/election",
        label: "Investment Election"
    }, {
        to: "/stock-picker",
        label: "Stock Picker"
    }, {
        to: "/basket",
        label: "Basket"
    }, {
        to: "/portfolio",
        label: "StockLoyal Portfolio"
    }, {
        to: "/admin",
        label: "Merchant Admin"
    }, {
        to: "/wallet-admin",
        label: "Wallet Admin"
    }, {
        to: "/ledger-admin",
        label: "Ledger Admin"
    }, {
        to: "/demo-launch",
        label: "Demo Launch"
    }, {
        to: "/goodbye",
        label: "Exit App"
    }];
    return _.jsxs(_.Fragment, {
        children: [_.jsx("footer", {
            className: "nav-bar",
            children: _.jsxs("div", {
                className: "nav-inner",
                children: [u.map( ({to: f, icon: w}) => _.jsx(Kh, {
                    to: f,
                    className: `nav-item ${o.pathname === f ? "nav-item-active" : ""}`,
                    children: _.jsxs("div", {
                        className: "relative",
                        children: [w, f === "/basket" && n.length > 0 && _.jsx("span", {
                            className: "absolute -top-1 -right-2 bg-red-500 text-white text-[10px] font-bold rounded-full px-1",
                            children: n.length
                        })]
                    })
                }, f)), _.jsx("button", {
                    type: "button",
                    onClick: () => c(!0),
                    className: "nav-item",
                    style: {
                        background: "transparent",
                        border: 0,
                        padding: 0,
                        margin: 0,
                        cursor: "pointer",
                        display: "flex",
                        flexDirection: "column",
                        alignItems: "center",
                        justifyContent: "center",
                        color: "inherit"
                    },
                    children: _.jsx("div", {
                        className: "relative",
                        children: _.jsx(OG, {
                            className: "nav-icon"
                        })
                    })
                })]
            })
        }), _.jsx(KG, {
            isOpen: a,
            onClose: () => c(!1),
            title: "Menu",
            side: "right",
            width: 260,
            zIndex: 2200,
            anchorSelector: ".app-container",
            children: _.jsx("ul", {
                style: {
                    listStyle: "none",
                    padding: 0,
                    margin: 0
                },
                children: p.map( ({to: f, label: w}, k) => _.jsx("li", {
                    style: {
                        borderTop: k === 0 ? "none" : "1px solid #e5e7eb"
                    },
                    children: _.jsxs(Kh, {
                        to: f,
                        onClick: () => c(!1),
                        className: `flex items-center w-full text-gray-700 transition hover:bg-gray-100 ${o.pathname === f ? "bg-gray-50 font-medium text-blue-600" : ""}`,
                        style: {
                            display: "flex",
                            alignItems: "center",
                            width: "100%",
                            padding: "6px 12px",
                            textDecoration: "none",
                            fontSize: "0.875rem",
                            lineHeight: 1.2
                        },
                        children: [_.jsx("span", {
                            children: w
                        }), f === "/basket" && n.length > 0 && _.jsx("span", {
                            style: {
                                minWidth: 18,
                                height: 18,
                                fontSize: "0.7rem",
                                display: "inline-flex",
                                alignItems: "center",
                                justifyContent: "center",
                                borderRadius: "9999px",
                                background: "#1f2937",
                                color: "#fff",
                                marginLeft: "auto",
                                padding: "0 4px"
                            },
                            children: n.length
                        })]
                    })
                }, f))
            })
        })]
    })
}
function QG() {
    return _.jsxs("div", {
        className: "iphone-frame relative flex flex-col h-[100dvh]",
        children: [_.jsx(wG, {}), _.jsx("main", {
            className: "iphone-content flex-1 overflow-y-auto",
            children: _.jsx(yM, {})
        }), _.jsx(YG, {})]
    })
}
const ZG = "/api"
  , dB = o => {
    if (o.startsWith("http"))
        return o;
    const n = String(o).replace(/^\/?api\/+/, "");
    return `${ZG}/${n}`
}
;
async function uB(o, n={}) {
    const a = await fetch(o, n);
    if (!a.ok) {
        let c = `HTTP ${a.status} ${a.statusText}`;
        try {
            const p = await a.clone().json();
            p != null && p.error && (c = String(p.error))
        } catch {
            try {
                const p = await a.clone().text();
                p && (c = p)
            } catch {}
        }
        const u = new Error(c);
        throw u.status = a.status,
        u
    }
    try {
        return await a.json()
    } catch {
        const c = await a.text().catch( () => "<no body>");
        throw new Error("Invalid JSON response: " + c)
    }
}
async function Ne(o, n) {
    return uB(dB(o), {
        method: "POST",
        headers: {
            "Content-Type": "application/json"
        },
        body: JSON.stringify(n ?? {})
    })
}
async function Hc(o) {
    return uB(dB(o), {
        method: "GET"
    })
}
function JG() {
    const o = Lt()
      , [n,a] = R.useState(!1);
    return R.useEffect( () => {
        console.log("[Splash] location.href:", window.location.href),
        console.log("[Splash] location.search:", window.location.search),
        console.log("[Splash] location.hash:", window.location.hash);
        const c = new URLSearchParams(window.location.search);
        let u = c.get("member_id")
          , p = c.get("merchant_id")
          , f = parseInt(c.get("points") || "0", 10)
          , w = c.get("action")
          , k = parseFloat(localStorage.getItem("conversion_rate") || "0");
        if ((!k || k <= 0) && (k = .01),
        console.log("[Splash] parsed params:", {
            memberId: u,
            merchantId: p,
            points: f,
            action: w,
            conversionRate: k
        }),
        (!u || !p) && window.location.hash) {
            const A = new URLSearchParams(window.location.hash.replace(/^#\/?/, ""));
            p = p || A.get("merchant_id"),
            u = u || A.get("member_id"),
            A.get("points") && (f = parseInt(A.get("points"), 10))
        }
        u && localStorage.setItem("memberId", u),
        p && localStorage.setItem("merchantId", p),
        f > 0 && localStorage.setItem("points", String(f)),
        k && localStorage.setItem("conversion_rate", String(k)),
        w && localStorage.setItem("action", w);
        const y = setTimeout( () => a(!0), 400)
          , E = setTimeout( () => a(!1), 2600)
          , S = setTimeout(async () => {
            try {
                let A = null
                  , D = !1
                  , N = !1;
                if (p) {
                    console.log("[Splash] Fetching merchant for merchantId:", p);
                    const L = await Ne("get_merchant.php", {
                        merchant_id: p
                    });
                    if (console.log("[Splash] get_merchant response:", L),
                    L && L.success && L.merchant) {
                        A = L.merchant;
                        const z = M => {
                            if (M === !0 || M === 1 || M === "1")
                                return !0;
                            if (typeof M == "string") {
                                const j = M.toLowerCase();
                                return j === "true" || j === "1"
                            }
                            return !1
                        }
                        ;
                        D = z(A.active_status),
                        N = z(A.promotion_active);
                        try {
                            localStorage.setItem("merchant", JSON.stringify(A))
                        } catch (M) {
                            console.warn("[Splash] failed to store merchant in localStorage", M)
                        }
                        let B = parseFloat(A.conversion_rate || "0");
                        (!B || B <= 0) && (B = .01),
                        localStorage.setItem("conversion_rate", B.toString()),
                        console.log("[Splash] merchant conversion_rate set:", B)
                    } else
                        console.warn("[Splash] merchant lookup returned no merchant or success=false", L)
                } else
                    console.log("[Splash] no merchantId provided; skipping merchant fetch.");
                if (u && p && f > 0) {
                    console.log("[Splash] Deep-link present — updating wallet before routing");
                    const L = parseFloat(localStorage.getItem("conversion_rate") || "0.01")
                      , z = Number((f * (L > 0 ? L : .01)).toFixed(2))
                      , B = ["updated_points.php", "update_points.php"];
                    let M = null;
                    for (const j of B)
                        try {
                            console.log(`[Splash] calling ${j} to add points`, {
                                memberId: u,
                                points: f,
                                cash_balance: z
                            });
                            const V = await Ne(j, {
                                member_id: u,
                                points: f,
                                cash_balance: z
                            });
                            if (console.log(`[Splash] ${j} response:`, V),
                            V && V.success) {
                                M = V;
                                break
                            } else
                                console.warn(`[Splash] ${j} returned success=false or invalid body`, V)
                        } catch (V) {
                            console.warn(`[Splash] ${j} network/error:`, V)
                        }
                    if (M) {
                        if (console.log("[Splash] Wallet updated successfully from deep-link:", M),
                        M.wallet)
                            try {
                                localStorage.setItem("points", String(M.wallet.points ?? f)),
                                localStorage.setItem("cashBalance", Number(M.wallet.cash_balance ?? z).toFixed(2)),
                                typeof M.wallet.portfolio_value < "u" && localStorage.setItem("portfolio_value", Number(M.wallet.portfolio_value).toFixed(2))
                            } catch (j) {
                                console.warn("[Splash] failed to sync wallet values to localStorage", j)
                            }
                    } else
                        console.warn("[Splash] Wallet update failed on all endpoints; continuing to route.")
                } else
                    console.log("[Splash] not updating wallet (missing memberId/merchantId/points)");
                p && D && N ? (console.log("[Splash] routing to /promotions"),
                o("/promotions", {
                    state: {
                        memberId: u,
                        merchantId: p,
                        points: f,
                        merchant: A
                    }
                })) : (console.log("[Splash] routing to /login"),
                localStorage.setItem("mode", "login"),
                o("/login"))
            } catch (A) {
                console.error("[Splash] routing flow error:", A),
                localStorage.setItem("mode", "login"),
                o("/login")
            }
        }
        , 3e3);
        return () => {
            clearTimeout(y),
            clearTimeout(E),
            clearTimeout(S)
        }
    }
    , [o]),
    _.jsx("div", {
        className: "splash-screen",
        style: {
            display: "flex",
            justifyContent: "center",
            alignItems: "center",
            height: "100vh",
            width: "100%",
            backgroundColor: "#fff",
            opacity: n ? 1 : 0,
            transition: "opacity 800ms ease-in-out",
            overflow: "hidden"
        },
        children: _.jsx("img", {
            src: "/logos/stockloyal.png",
            alt: "StockLoyal Logo",
            className: "splash-logo",
            style: {
                maxWidth: "60%",
                height: "auto"
            }
        })
    })
}
const em = "/api";
function XG() {
    const o = Lt()
      , [n,a] = R.useState([])
      , [c,u] = R.useState(!0);
    R.useEffect( () => {
        console.log("✅ Start Promotions.jsx");
        const w = localStorage.getItem("merchantId")
          , k = localStorage.getItem("memberId");
        if (console.log("[Promotions] merchantId:", w),
        console.log("[Promotions] memberId:", k),
        !w) {
            u(!1);
            return
        }
        fetch(`${em}/get_promotions.php`, {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify({
                merchant_id: w
            })
        }).then(async y => {
            if (console.log("[Promotions] Fetch status:", y.status),
            !y.ok) {
                const E = await y.text();
                return console.error("[Promotions] Non-200 response:", E),
                null
            }
            try {
                const E = await y.json();
                return console.log("[Promotions] Parsed JSON:", E),
                E
            } catch (E) {
                const S = await y.text();
                return console.error("[Promotions] JSON parse error:", E, "Raw:", S),
                null
            }
        }
        ).then(y => {
            y && y.success ? a(y.promotions || []) : console.warn("[Promotions] No promotions found or API failed")
        }
        ).catch(y => console.error("❌ Error fetching promotions:", y)).finally( () => u(!1))
    }
    , []);
    const p = () => o("/login")
      , f = () => o("/goodbye");
    return c ? _.jsx("p", {
        children: "Loading promotions..."
    }) : _.jsxs("div", {
        className: "promotions-container",
        children: [_.jsx("h2", {
            className: "promotions-heading",
            children: "Exclusive Promotions"
        }), n.length > 0 ? n.map( (w, k) => _.jsxs("div", {
            className: "promotion-block",
            children: [_.jsx("h3", {
                children: w.merchant_name
            }), _.jsx("div", {
                className: "promotion-text",
                dangerouslySetInnerHTML: {
                    __html: w.promotion_text
                }
            })]
        }, k)) : _.jsx("p", {
            children: "No active promotions from your merchant."
        }), _.jsxs("div", {
            className: "promotions-actions",
            children: [_.jsx("button", {
                onClick: p,
                className: "btn-primary",
                children: "Let's Get Started!"
            }), _.jsx("button", {
                onClick: f,
                className: "btn-secondary",
                children: "No Thanks."
            })]
        })]
    })
}
function eK() {
    const o = Lt()
      , [n,a] = R.useState("login")
      , [c,u] = R.useState("")
      , [p,f] = R.useState("")
      , [w,k] = R.useState("")
      , [y,E] = R.useState("")
      , [S,A] = R.useState(!1)
      , [D,N] = R.useState("")
      , [L,z] = R.useState("")
      , [B,M] = R.useState(0)
      , [j,V] = R.useState(.01);
    R.useEffect( () => {
        const Y = localStorage.getItem("mode")
          , $ = localStorage.getItem("memberId")
          , K = localStorage.getItem("memberEmail")
          , Z = localStorage.getItem("merchantId")
          , H = parseInt(localStorage.getItem("points") || "0", 10)
          , W = parseFloat(localStorage.getItem("conversion_rate") || "0");
        Y && a(Y),
        $ && u($),
        K && f(K),
        Z && z(Z),
        H > 0 && M(H),
        V(W > 0 ? W : .01)
    }
    , []);
    const G = async Y => {
        if (Y.preventDefault(),
        N(""),
        !c || !w || n === "create" && !p) {
            N("Please fill in all required fields.");
            return
        }
        if (n === "create" && w !== y) {
            N("Passwords do not match. Please re-enter.");
            return
        }
        if (n === "create")
            try {
                const $ = await Ne("create_member.php", {
                    member_id: c,
                    member_email: p,
                    password: w
                });
                $.success ? (localStorage.setItem("memberId", c),
                localStorage.setItem("memberEmail", p),
                L && localStorage.setItem("merchantId", L),
                o("/member-onboard", {
                    state: {
                        memberId: c,
                        memberEmail: p
                    }
                })) : N($.error || "Account creation failed.")
            } catch ($) {
                console.error("Create member error:", $),
                N("Network error. Please try again.")
            }
        else
            try {
                const $ = await Ne("login.php", {
                    member_id: c,
                    password: w
                });
                $ && $.success && (localStorage.setItem("memberId", c),
                localStorage.setItem("memberEmail", $.member_email || ""),
                L && localStorage.setItem("merchantId", L),
                o("/wallet"))
            } catch ($) {
                $.status === 404 ? N("No account found for this Member ID. Please create an account.") : $.status === 401 ? N("Invalid password.") : (console.error("Login error:", $),
                N("Server error. Please try again later."))
            }
    }
    ;
    return _.jsxs("div", {
        className: "page-container",
        children: [_.jsx("h2", {
            className: "page-title",
            children: n === "login" ? "Login to StockLoyal" : "Create StockLoyal Account"
        }), n === "create" && B > 0 && _.jsxs("p", {
            className: "welcome-points",
            children: ["Welcome! You’ve earned ", _.jsx("strong", {
                children: B
            }), " points from", " ", _.jsx("strong", {
                children: L
            }), " — worth $", (B * j).toFixed(2), ". Create your account to claim them."]
        }), _.jsxs("form", {
            className: "form member-form-grid",
            onSubmit: G,
            children: [_.jsxs("div", {
                className: "member-form-row",
                children: [_.jsx("label", {
                    htmlFor: "memberId",
                    className: "member-form-label",
                    children: "Member ID:"
                }), _.jsx("input", {
                    id: "memberId",
                    type: "text",
                    className: "member-form-input",
                    value: c,
                    onChange: Y => u(Y.target.value),
                    autoComplete: "username"
                })]
            }), n === "create" && _.jsxs("div", {
                className: "member-form-row",
                children: [_.jsx("label", {
                    htmlFor: "email",
                    className: "member-form-label",
                    children: "Email:"
                }), _.jsx("input", {
                    id: "email",
                    type: "email",
                    className: "member-form-input",
                    value: p,
                    onChange: Y => f(Y.target.value)
                })]
            }), _.jsxs("div", {
                className: "member-form-row",
                children: [_.jsx("label", {
                    htmlFor: "password",
                    className: "member-form-label",
                    children: "Password:"
                }), _.jsxs("div", {
                    className: "password-wrapper-inline",
                    style: {
                        flex: 1
                    },
                    children: [_.jsx("input", {
                        id: "password",
                        type: S ? "text" : "password",
                        className: "member-form-input",
                        value: w,
                        onChange: Y => k(Y.target.value),
                        autoComplete: "current-password"
                    }), _.jsx("img", {
                        src: `/icons/${S ? "hide.png" : "show.png"}`,
                        alt: S ? "Hide password" : "Show password",
                        className: "pw-toggle-icon",
                        onClick: () => A(!S)
                    })]
                })]
            }), n === "create" && _.jsxs("div", {
                className: "member-form-row",
                children: [_.jsx("label", {
                    htmlFor: "confirmPassword",
                    className: "member-form-label",
                    children: "Confirm Password:"
                }), _.jsx("input", {
                    id: "confirmPassword",
                    type: S ? "text" : "password",
                    className: "member-form-input",
                    value: y,
                    onChange: Y => E(Y.target.value),
                    autoComplete: "new-password"
                })]
            }), D && _.jsx("p", {
                className: "form-error",
                children: D
            }), _.jsx("button", {
                type: "submit",
                className: "btn-primary",
                children: n === "login" ? "Login" : "Create Account"
            }), _.jsx("button", {
                type: "button",
                className: "btn-secondary",
                onClick: () => a(n === "login" ? "create" : "login"),
                children: n === "login" ? "Need an account?" : "Already have an account?"
            })]
        }), _.jsxs("p", {
            className: "form-disclosure",
            children: [_.jsx("strong", {
                children: "Note:"
            }), " This login is for the ", _.jsx("em", {
                children: "StockLoyal platform"
            }), " ", "only. Your StockLoyal ID and password are used to access StockLoyal features. When linking your brokerage account (e.g., Public.com, Robinhood, Fidelity), you will enter those credentials separately and securely. StockLoyal does ", _.jsx("u", {
                children: "not"
            }), " use your StockLoyal ID or password to access your broker, and your broker login remains independent."]
        })]
    })
}
function tK() {
    var o, n;
    const a = Lt()
      , c = Zt()
      , u = ((o = c.state) == null ? void 0 : o.memberId) || localStorage.getItem("memberId")
      , p = R.useMemo( () => {
        try {
            return Intl.DateTimeFormat().resolvedOptions().timeZone || "America/New_York"
        } catch {
            return "America/New_York"
        }
    }
    , [])
      , f = R.useMemo( () => {
        try {
            if (typeof Intl.supportedValuesOf == "function") {
                const M = Intl.supportedValuesOf("timeZone")
                  , j = M.filter(G => G.startsWith("America/"))
                  , V = M.filter(G => !G.startsWith("America/"));
                return [...j.sort(), ...V.sort()]
            }
        } catch {}
        return ["America/New_York", "America/Chicago", "America/Denver", "America/Los_Angeles", "America/Phoenix", "America/Anchorage", "Pacific/Honolulu", "America/Toronto", "Europe/London", "Europe/Paris", "Europe/Berlin", "Asia/Tokyo", "Asia/Shanghai", "Asia/Kolkata", "Australia/Sydney", "UTC"]
    }
    , [])
      , [w,k] = R.useState({
        first_name: "",
        middle_name: "",
        last_name: "",
        member_email: ((n = c.state) == null ? void 0 : n.memberEmail) || localStorage.getItem("memberEmail") || "",
        member_address_line1: "",
        member_address_line2: "",
        member_town_city: "",
        member_state: "",
        member_zip: "",
        member_country: "",
        member_timezone: ""
    })
      , [y,E] = R.useState("")
      , [S,A] = R.useState(!0)
      , D = [{
        code: "AL",
        name: "Alabama"
    }, {
        code: "AK",
        name: "Alaska"
    }, {
        code: "AS",
        name: "American Samoa"
    }, {
        code: "AZ",
        name: "Arizona"
    }, {
        code: "AR",
        name: "Arkansas"
    }, {
        code: "CA",
        name: "California"
    }, {
        code: "CO",
        name: "Colorado"
    }, {
        code: "CT",
        name: "Connecticut"
    }, {
        code: "DE",
        name: "Delaware"
    }, {
        code: "DC",
        name: "District of Columbia"
    }, {
        code: "FL",
        name: "Florida"
    }, {
        code: "GA",
        name: "Georgia"
    }, {
        code: "GU",
        name: "Guam"
    }, {
        code: "HI",
        name: "Hawaii"
    }, {
        code: "ID",
        name: "Idaho"
    }, {
        code: "IL",
        name: "Illinois"
    }, {
        code: "IN",
        name: "Indiana"
    }, {
        code: "IA",
        name: "Iowa"
    }, {
        code: "KS",
        name: "Kansas"
    }, {
        code: "KY",
        name: "Kentucky"
    }, {
        code: "LA",
        name: "Louisiana"
    }, {
        code: "ME",
        name: "Maine"
    }, {
        code: "MD",
        name: "Maryland"
    }, {
        code: "MA",
        name: "Massachusetts"
    }, {
        code: "MI",
        name: "Michigan"
    }, {
        code: "MN",
        name: "Minnesota"
    }, {
        code: "MS",
        name: "Mississippi"
    }, {
        code: "MO",
        name: "Missouri"
    }, {
        code: "MT",
        name: "Montana"
    }, {
        code: "NE",
        name: "Nebraska"
    }, {
        code: "NV",
        name: "Nevada"
    }, {
        code: "NH",
        name: "New Hampshire"
    }, {
        code: "NJ",
        name: "New Jersey"
    }, {
        code: "NM",
        name: "New Mexico"
    }, {
        code: "NY",
        name: "New York"
    }, {
        code: "NC",
        name: "North Carolina"
    }, {
        code: "ND",
        name: "North Dakota"
    }, {
        code: "MP",
        name: "Northern Mariana Islands"
    }, {
        code: "OH",
        name: "Ohio"
    }, {
        code: "OK",
        name: "Oklahoma"
    }, {
        code: "OR",
        name: "Oregon"
    }, {
        code: "PA",
        name: "Pennsylvania"
    }, {
        code: "PR",
        name: "Puerto Rico"
    }, {
        code: "RI",
        name: "Rhode Island"
    }, {
        code: "SC",
        name: "South Carolina"
    }, {
        code: "SD",
        name: "South Dakota"
    }, {
        code: "TN",
        name: "Tennessee"
    }, {
        code: "TX",
        name: "Texas"
    }, {
        code: "UT",
        name: "Utah"
    }, {
        code: "VT",
        name: "Vermont"
    }, {
        code: "VI",
        name: "U.S. Virgin Islands"
    }, {
        code: "VA",
        name: "Virginia"
    }, {
        code: "WA",
        name: "Washington"
    }, {
        code: "WV",
        name: "West Virginia"
    }, {
        code: "WI",
        name: "Wisconsin"
    }, {
        code: "WY",
        name: "Wyoming"
    }]
      , N = [{
        code: "US",
        name: "United States"
    }, {
        code: "CA",
        name: "Canada"
    }, {
        code: "MX",
        name: "Mexico"
    }, {
        code: "GB",
        name: "United Kingdom"
    }, {
        code: "FR",
        name: "France"
    }, {
        code: "DE",
        name: "Germany"
    }, {
        code: "JP",
        name: "Japan"
    }, {
        code: "CN",
        name: "China"
    }, {
        code: "IN",
        name: "India"
    }, {
        code: "AU",
        name: "Australia"
    }];
    console.log("Start MemberOnboard.jsx"),
    console.log(u),
    R.useEffect( () => {
        if (!u) {
            E("No member ID found — please log in again."),
            A(!1);
            return
        }
        (async () => {
            try {
                const M = await Ne("get-wallet.php", {
                    member_id: u
                });
                M.success && M.wallet ? k(j => {
                    const V = {
                        ...j,
                        ...M.wallet
                    };
                    return V.member_timezone || (V.member_timezone = p),
                    V
                }
                ) : E(M.error || "Failed to load wallet.")
            } catch (M) {
                console.error("MemberOnboard fetch error:", M),
                E("Network error while fetching wallet.")
            } finally {
                A(!1)
            }
        }
        )()
    }
    , [u, p]),
    R.useEffect( () => {
        w.member_timezone || k(M => ({
            ...M,
            member_timezone: p
        }))
    }
    , [p, w.member_timezone]);
    const L = M => {
        const {name: j, value: V} = M.target;
        k(G => ({
            ...G,
            [j]: V
        }))
    }
      , z = async M => {
        M.preventDefault();
        try {
            const j = await Ne("update_wallet.php", {
                member_id: u,
                ...w
            });
            j.success ? (localStorage.setItem("memberEmail", w.member_email),
            a("/wallet")) : E(j.error || "Failed to update wallet.")
        } catch (j) {
            console.error("Update wallet error:", j),
            E("Network error while saving.")
        }
    }
      , B = () => {
        window.history.length > 1 ? a(-1) : a("/wallet")
    }
    ;
    return S ? _.jsxs("div", {
        className: "page-container",
        children: [_.jsx("h2", {
            className: "heading",
            children: "Member Onboarding"
        }), _.jsx("p", {
            children: "Loading profile..."
        })]
    }) : _.jsxs("div", {
        className: "page-container",
        children: [_.jsx("h2", {
            className: "page-title",
            children: "Member Onboarding"
        }), y && _.jsx("p", {
            className: "member-form-error",
            children: y
        }), _.jsxs("form", {
            className: "form member-form-grid",
            onSubmit: z,
            children: [_.jsxs("div", {
                className: "member-form-row",
                children: [_.jsx("label", {
                    className: "member-form-label",
                    children: "Member ID:"
                }), _.jsx("input", {
                    value: u,
                    disabled: !0,
                    className: "member-form-input"
                })]
            }), _.jsxs("div", {
                className: "member-form-row",
                children: [_.jsx("label", {
                    className: "member-form-label",
                    children: "First Name:"
                }), _.jsx("input", {
                    name: "first_name",
                    value: w.first_name,
                    onChange: L,
                    className: "member-form-input"
                })]
            }), _.jsxs("div", {
                className: "member-form-row",
                children: [_.jsx("label", {
                    className: "member-form-label",
                    children: "Middle Name:"
                }), _.jsx("input", {
                    name: "middle_name",
                    value: w.middle_name,
                    onChange: L,
                    className: "member-form-input"
                })]
            }), _.jsxs("div", {
                className: "member-form-row",
                children: [_.jsx("label", {
                    className: "member-form-label",
                    children: "Last Name:"
                }), _.jsx("input", {
                    name: "last_name",
                    value: w.last_name,
                    onChange: L,
                    className: "member-form-input"
                })]
            }), _.jsxs("div", {
                className: "member-form-row",
                children: [_.jsx("label", {
                    className: "member-form-label",
                    children: "Email:"
                }), _.jsx("input", {
                    name: "member_email",
                    type: "email",
                    value: w.member_email,
                    onChange: L,
                    className: "member-form-input"
                })]
            }), _.jsxs("div", {
                className: "member-form-row",
                children: [_.jsx("label", {
                    className: "member-form-label",
                    children: "Address Line 1:"
                }), _.jsx("input", {
                    name: "member_address_line1",
                    value: w.member_address_line1,
                    onChange: L,
                    className: "member-form-input"
                })]
            }), _.jsxs("div", {
                className: "member-form-row",
                children: [_.jsx("label", {
                    className: "member-form-label",
                    children: "Address Line 2:"
                }), _.jsx("input", {
                    name: "member_address_line2",
                    value: w.member_address_line2,
                    onChange: L,
                    className: "member-form-input"
                })]
            }), _.jsxs("div", {
                className: "member-form-row",
                children: [_.jsx("label", {
                    className: "member-form-label",
                    children: "City / Town:"
                }), _.jsx("input", {
                    name: "member_town_city",
                    value: w.member_town_city,
                    onChange: L,
                    className: "member-form-input"
                })]
            }), _.jsxs("div", {
                className: "member-form-row",
                children: [_.jsx("label", {
                    className: "member-form-label",
                    children: "State:"
                }), _.jsxs("select", {
                    name: "member_state",
                    value: w.member_state,
                    onChange: L,
                    className: "member-form-input",
                    children: [_.jsx("option", {
                        value: "",
                        children: "-- Select State --"
                    }), D.map(M => _.jsx("option", {
                        value: M.code,
                        children: M.name
                    }, M.code))]
                })]
            }), _.jsxs("div", {
                className: "member-form-row",
                children: [_.jsx("label", {
                    className: "member-form-label",
                    children: "ZIP Code:"
                }), _.jsx("input", {
                    name: "member_zip",
                    value: w.member_zip,
                    onChange: L,
                    className: "member-form-input"
                })]
            }), _.jsxs("div", {
                className: "member-form-row",
                children: [_.jsx("label", {
                    className: "member-form-label",
                    children: "Country:"
                }), _.jsxs("select", {
                    name: "member_country",
                    value: w.member_country,
                    onChange: L,
                    className: "member-form-input",
                    children: [_.jsx("option", {
                        value: "",
                        children: "-- Select Country --"
                    }), N.map(M => _.jsx("option", {
                        value: M.code,
                        children: M.name
                    }, M.code))]
                })]
            }), _.jsxs("div", {
                className: "member-form-row",
                children: [_.jsx("label", {
                    className: "member-form-label",
                    children: "Local Timezone:"
                }), _.jsxs("select", {
                    name: "member_timezone",
                    value: w.member_timezone || p,
                    onChange: L,
                    className: "member-form-input",
                    children: [!w.member_timezone && _.jsxs("option", {
                        value: p,
                        children: [p, " (Detected)"]
                    }), f.map(M => _.jsx("option", {
                        value: M,
                        children: M
                    }, M))]
                })]
            }), _.jsxs("div", {
                className: "member-form-actions",
                children: [_.jsx("button", {
                    type: "submit",
                    className: "btn-primary",
                    children: "Save & Continue"
                }), _.jsx("button", {
                    type: "button",
                    className: "btn-secondary",
                    onClick: B,
                    children: "Cancel"
                })]
            })]
        })]
    })
}
const oK = () => {
    const o = Lt()
      , n = () => {
        o("/select-broker")
    }
      , a = () => {
        o("/goodbye")
    }
    ;
    return _.jsxs("div", {
        className: "terms-container",
        children: [_.jsx("h2", {
            className: "page-title",
            children: "Terms & Conditions"
        }), _.jsx("p", {
            children: "This application allows investments only in listed securities."
        }), _.jsx("p", {
            children: "Points awarded by merchants are converted to cash-equivalent values as determined by each merchant."
        }), _.jsx("p", {
            children: "The projected value of points can only be used to fund selected brokerage accounts to settle trades based on generated trade orders."
        }), _.jsx("p", {
            children: "Investing in securities is risky, and your principal is at risk."
        }), _.jsx("p", {
            children: "StockLoyal, LLC does not provide investment advice and is not a licensed securities dealer."
        }), _.jsx("p", {
            children: "Merchants are responsible for forwarding payment for settled trades within one day."
        }), _.jsx("p", {
            children: "StockLoyal, LLC will facilitate funds transfer based on available point value at the time of settlement."
        }), _.jsx("h3", {
            className: "terms-subheading",
            children: "Additional Legal Disclaimers"
        }), _.jsx("p", {
            children: "Nothing in this application constitutes tax, legal, insurance, or investment advice. StockLoyal, LLC is not offering or soliciting the sale of any securities or providing personalized recommendations."
        }), _.jsx("p", {
            children: "Investing involves risk, including the possible loss of principal. Past performance is not indicative of future results."
        }), _.jsx("p", {
            children: "You are solely responsible for your investment decisions. Before investing, you should understand the risks involved and consider seeking professional advice."
        }), _.jsxs("div", {
            className: "terms-actions",
            children: [_.jsx("button", {
                onClick: n,
                className: "btn-primary",
                children: "I Agree & Continue"
            }), _.jsx("button", {
                onClick: a,
                className: "btn-secondary",
                children: "No Thanks"
            })]
        })]
    })
}
;
function rK() {
    return _.jsxs("div", {
        className: "goodbye-container",
        children: [_.jsx("h1", {
            className: "goodbye-heading",
            children: "Goodbye!"
        }), _.jsxs("p", {
            className: "goodbye-text",
            children: ["Thank you for exploring ", _.jsx("strong", {
                children: "StockLoyal"
            }), ". We hope to see you again soon."]
        })]
    })
}
function nK() {
    return _.jsxs("div", {
        className: "about-container",
        children: [_.jsx("h2", {
            className: "page-title",
            children: "About StockLoyal"
        }), _.jsxs("section", {
            className: "about-section",
            children: [_.jsx("h3", {
                className: "heading-md",
                children: "Our Mission"
            }), _.jsxs("p", {
                children: ["At ", _.jsx("strong", {
                    children: "StockLoyal LLC"
                }), ", we believe investing should be inclusive, intuitive, and secure. We’re on a mission to empower everyday investors with tools that simplify portfolio management and keep financial wellness in focus."]
            })]
        }), _.jsxs("section", {
            className: "about-section",
            children: [_.jsx("h3", {
                className: "heading-md",
                children: "Why We Exist"
            }), _.jsx("p", {
                children: "Traditional investing platforms can feel overwhelming or fragmented. StockLoyal was built to bridge that gap—providing clean UX, direct integrations with popular brokerages, and features that work for you, not against you."
            })]
        }), _.jsxs("section", {
            className: "about-section",
            children: [_.jsx("h3", {
                className: "heading-md",
                children: "Our Values"
            }), _.jsxs("ul", {
                className: "about-list",
                children: [_.jsxs("li", {
                    children: [_.jsx("strong", {
                        children: "Security first"
                    }), " — We handle credentials securely via APIs controlled by your own back-end."]
                }), _.jsxs("li", {
                    children: [_.jsx("strong", {
                        children: "Simplicity always"
                    }), " — A clean interface helps you focus on what matters most."]
                }), _.jsxs("li", {
                    children: [_.jsx("strong", {
                        children: "Privacy & integrity"
                    }), " — Built as a U.S.-based LLC, we ensure your data stays private and protected."]
                }), _.jsxs("li", {
                    children: [_.jsx("strong", {
                        children: "Customer-driven design"
                    }), " — From broker selection flows to thoughtful hooks like goodbye flows, we center your experience."]
                })]
            })]
        }), _.jsxs("section", {
            className: "about-section",
            children: [_.jsx("h3", {
                className: "heading-md",
                children: "What’s Next"
            }), _.jsx("p", {
                children: "We’re continuously evolving StockLoyal—to add features like in-app portfolio insights, alert systems, and integrations with more brokers and data sources. Stay tuned as we grow with you."
            })]
        }), _.jsxs("footer", {
            className: "about-footer",
            children: ["© ", new Date().getFullYear(), " StockLoyal LLC. All rights reserved."]
        })]
    })
}
function iK() {
    const [o,n] = R.useState(null)
      , [a,c] = R.useState("")
      , [u,p] = R.useState(!0)
      , f = Lt()
      , w = localStorage.getItem("memberId");
    R.useEffect( () => {
        if (!w) {
            c("No member ID found — please log in again."),
            p(!1);
            return
        }
        let j = !0;
        return (async () => {
            var V, G, Y, $;
            p(!0),
            c("");
            try {
                const K = await Ne("get-wallet.php", {
                    member_id: w
                });
                if (!K || !K.success) {
                    j && (c((K == null ? void 0 : K.error) || "Failed to load wallet."),
                    p(!1));
                    return
                }
                j && (n(K.wallet ?? null),
                p(!1));
                try {
                    ((V = K.wallet) == null ? void 0 : V.points) != null && localStorage.setItem("points", String(parseInt(K.wallet.points, 10) || 0)),
                    ((G = K.wallet) == null ? void 0 : G.cash_balance) != null && localStorage.setItem("cashBalance", Number(K.wallet.cash_balance).toFixed(2)),
                    typeof ((Y = K.wallet) == null ? void 0 : Y.portfolio_value) < "u" && localStorage.setItem("portfolio_value", Number(K.wallet.portfolio_value).toFixed(2)),
                    typeof (($ = K.wallet) == null ? void 0 : $.sweep_percentage) < "u" && localStorage.setItem("sweep_percentage", String(K.wallet.sweep_percentage))
                } catch (Z) {
                    console.warn("[Wallet] failed to sync to localStorage", Z)
                }
            } catch (K) {
                console.error("Wallet fetch error:", K),
                j && (c("Network error while fetching wallet."),
                p(!1))
            }
        }
        )(),
        () => {
            j = !1
        }
    }
    , [w]);
    const k = j => (parseFloat(j) || 0).toLocaleString("en-US", {
        style: "currency",
        currency: "USD",
        minimumFractionDigits: 2
    })
      , y = j => (parseInt(j, 10) || 0).toLocaleString("en-US")
      , E = async () => {
        p(!0),
        c("");
        try {
            const j = await Ne("get-wallet.php", {
                member_id: w
            });
            !j || !j.success ? c((j == null ? void 0 : j.error) || "Failed to refresh wallet.") : n(j.wallet ?? null)
        } catch (j) {
            console.error("[Wallet] refresh failed", j),
            c("Network error while refreshing wallet.")
        } finally {
            p(!1)
        }
    }
    ;
    if (u)
        return _.jsxs("div", {
            className: "wallet-container",
            children: [_.jsx("h2", {
                className: "wallet-heading",
                children: "Wallet"
            }), _.jsx("div", {
                className: "card card--compact",
                style: {
                    textAlign: "center"
                },
                children: _.jsx("p", {
                    className: "caption",
                    children: "Loading wallet…"
                })
            })]
        });
    if (a)
        return _.jsxs("div", {
            className: "wallet-container",
            children: [_.jsx("h2", {
                className: "wallet-heading",
                children: "Wallet"
            }), _.jsxs("div", {
                className: "card card--muted",
                children: [_.jsx("p", {
                    className: "form-error",
                    children: a
                }), _.jsxs("div", {
                    style: {
                        display: "flex",
                        gap: 8,
                        justifyContent: "center",
                        marginTop: 12
                    },
                    children: [_.jsx("button", {
                        className: "btn-primary",
                        onClick: E,
                        children: "Retry"
                    }), _.jsx("button", {
                        className: "btn-secondary",
                        onClick: () => f("/login"),
                        children: "Sign In"
                    })]
                })]
            })]
        });
    if (!o)
        return _.jsxs("div", {
            className: "wallet-container",
            children: [_.jsx("h2", {
                className: "wallet-heading",
                children: "Wallet"
            }), _.jsx("p", {
                className: "caption",
                children: "No wallet data available."
            })]
        });
    const S = !o.broker || o.broker === "Not linked" || o.broker === "unlinked"
      , A = parseInt(o.points || 0, 10)
      , D = Number(o.cash_balance || 0)
      , N = Number(o.conversion_rate || 0)
      , L = Number(o.portfolio_value || 0)
      , z = o.sweep_percentage ?? null
      , B = o.merchant_name || "Merchant"
      , M = D + (N > 0 ? A * N : 0);
    return _.jsxs("div", {
        className: "wallet-container",
        children: [_.jsx("h2", {
            className: "page-title",
            style: {
                margin: 0
            },
            children: "Stock-Backed Rewards"
        }), _.jsx("p", {
            className: "page-deck",
            style: {
                marginTop: 8
            },
            children: "Available Points & Cash Value"
        }), _.jsxs("div", {
            className: "card",
            style: {
                marginTop: 12
            },
            children: [_.jsxs("div", {
                style: {
                    display: "flex",
                    justifyContent: "space-between",
                    alignItems: "center",
                    gap: 12
                },
                children: [_.jsxs("div", {
                    style: {
                        display: "flex",
                        alignItems: "center",
                        gap: 12
                    },
                    children: [_.jsx("div", {
                        style: {
                            width: 52,
                            height: 52,
                            borderRadius: 10,
                            background: "#f9fafb",
                            display: "flex",
                            alignItems: "center",
                            justifyContent: "center"
                        },
                        children: _.jsx(IG, {
                            size: 24
                        })
                    }), _.jsxs("div", {
                        children: [_.jsx("div", {
                            style: {
                                fontSize: "0.95rem",
                                fontWeight: 600
                            },
                            children: "Available Cash"
                        }), _.jsx("div", {
                            className: "caption",
                            children: "Spendable balance"
                        })]
                    })]
                }), _.jsxs("div", {
                    style: {
                        textAlign: "right"
                    },
                    children: [_.jsx("div", {
                        className: "wallet-cash",
                        style: {
                            margin: 0
                        },
                        children: k(M)
                    }), _.jsxs("div", {
                        className: "caption",
                        style: {
                            marginTop: 6
                        },
                        children: ["Points from ", _.jsx("strong", {
                            children: B
                        }), ":", " ", _.jsx("strong", {
                            children: y(A)
                        })]
                    }), z !== null && _.jsxs("div", {
                        className: "caption",
                        style: {
                            marginTop: 4
                        },
                        children: ["Sweep: ", Number(z), "%"]
                    })]
                })]
            }), _.jsxs("div", {
                style: {
                    display: "flex",
                    gap: 10,
                    marginTop: 12,
                    justifyContent: "center"
                },
                children: [_.jsx("button", {
                    className: `btn-primary ${S ? "btn-disabled" : ""}`,
                    onClick: () => !S && f("/stock-picker"),
                    disabled: S,
                    style: {
                        opacity: S ? .6 : 1,
                        cursor: S ? "not-allowed" : "pointer"
                    },
                    children: "Convert & Invest"
                }), _.jsx("button", {
                    className: S ? "btn-primary" : "btn-secondary",
                    onClick: () => f("/select-broker"),
                    children: S ? "Link Broker" : `Active Broker: ${o.broker || "Unknown"}`
                })]
            })]
        }), _.jsxs("div", {
            className: "card card--accent",
            style: {
                marginTop: 14
            },
            children: [_.jsxs("div", {
                style: {
                    display: "flex",
                    justifyContent: "space-between",
                    alignItems: "center",
                    gap: 12
                },
                children: [_.jsxs("div", {
                    style: {
                        display: "flex",
                        alignItems: "center",
                        gap: 12
                    },
                    children: [_.jsx("div", {
                        style: {
                            width: 52,
                            height: 52,
                            borderRadius: 10,
                            background: "#f9fafb",
                            display: "flex",
                            alignItems: "center",
                            justifyContent: "center"
                        },
                        children: _.jsx(DG, {
                            size: 24
                        })
                    }), _.jsxs("div", {
                        children: [_.jsx("div", {
                            style: {
                                fontSize: "0.95rem",
                                fontWeight: 600
                            },
                            children: "Portfolio Value"
                        }), _.jsx("div", {
                            className: "caption",
                            children: "Market value of investments"
                        })]
                    })]
                }), _.jsxs("div", {
                    style: {
                        textAlign: "right"
                    },
                    children: [_.jsx("div", {
                        className: "wallet-portfolio",
                        style: {
                            margin: 0
                        },
                        children: k(L)
                    }), _.jsx("div", {
                        className: "caption",
                        style: {
                            marginTop: 6
                        },
                        children: "Updated when trades settle"
                    })]
                })]
            }), _.jsxs("div", {
                style: {
                    display: "flex",
                    gap: 10,
                    marginTop: 12,
                    justifyContent: "flex-end"
                },
                children: [_.jsx("button", {
                    className: "btn-secondary",
                    onClick: () => f("/portfolio"),
                    children: "View Portfolio"
                }), _.jsx("button", {
                    className: "btn-secondary",
                    onClick: () => f("/transactions"),
                    children: "View Transactions"
                })]
            })]
        }), _.jsx("div", {
            style: {
                marginTop: 14
            },
            children: o.election_type === "monthly" ? _.jsx("button", {
                type: "button",
                onClick: () => f("/election"),
                className: "btn-gold",
                children: "You are a Monthly Sweep subscriber"
            }) : _.jsx("button", {
                type: "button",
                onClick: () => f("/election"),
                className: "btn-gold",
                children: "Enroll in Monthly Sweep subscription"
            })
        }), _.jsxs("p", {
            className: "wallet-note",
            style: {
                marginTop: 12
            },
            children: ["Investment portfolio reflects shares purchased through the StockLoyal app only.", " ", o.broker && o.broker_url && _.jsxs(_.Fragment, {
                children: ["To see your full portfolio at ", o.broker, ", click", " ", _.jsx("a", {
                    href: o.broker_url,
                    target: "_blank",
                    rel: "noopener noreferrer",
                    className: "text-blue-600 underline",
                    children: "here"
                }), "."]
            })]
        }), _.jsxs("button", {
            type: "button",
            onClick: E,
            className: "refresh-btn",
            title: "Refresh",
            style: {
                width: "auto",
                padding: "0.4rem 0.6rem"
            },
            children: [_.jsx(PG, {
                size: 16,
                style: {
                    verticalAlign: "middle",
                    marginRight: 6
                }
            }), "Refresh"]
        }), _.jsxs("p", {
            className: "caption",
            style: {
                marginTop: 12
            },
            children: ["StockLoyal Member ID: ", o.member_id]
        })]
    })
}
function sK() {
    return _.jsxs("div", {
        className: "convert-container",
        children: [_.jsx("h2", {
            className: "convert-heading",
            children: "Convert"
        }), _.jsx("p", {
            className: "convert-text",
            children: "[This is where users will be able to convert loyalty points into fractional shares.]"
        })]
    })
}
const hB = R.createContext();
function aK({children: o}) {
    const [n,a] = R.useState( () => localStorage.getItem("broker") || null)
      , c = u => {
        a(u),
        u ? localStorage.setItem("broker", u) : localStorage.removeItem("broker")
    }
    ;
    return _.jsx(hB.Provider, {
        value: {
            broker: n,
            updateBroker: c
        },
        children: o
    })
}
function mB() {
    return R.useContext(hB)
}
function lK() {
    return "basket-" + Date.now() + "-" + Math.floor(Math.random() * 1e6)
}
function cK() {
    var o, n, a;
    const c = Lt()
      , u = Zt()
      , {clearBasket: p} = cd()
      , {broker: f} = mB()
      , w = localStorage.getItem("memberId")
      , k = ((o = u.state) == null ? void 0 : o.basket) || []
      , y = Number(((n = u.state) == null ? void 0 : n.amount) || 0)
      , E = Number(((a = u.state) == null ? void 0 : a.pointsUsed) || 0)
      , [S,A] = R.useState(!1)
      , [D,N] = R.useState("")
      , L = async () => {
        if (N(""),
        !w) {
            alert("No member ID found. Please log in again.");
            return
        }
        if (!Array.isArray(k) || k.length === 0) {
            alert("Your basket is empty.");
            return
        }
        A(!0);
        try {
            console.log("[Order] starting place order flow", {
                memberId: w,
                totalAmount: y,
                pointsUsed: E,
                enrichedBasketCount: k.length
            });
            const z = lK();
            localStorage.setItem("basketId", z);
            const B = k.length > 0 ? y / k.length : 0;
            let M = null;
            try {
                const Z = await Ne("get-wallet.php", {
                    member_id: w
                });
                Z != null && Z.success && Z.wallet && (M = Z.wallet,
                console.log("[Order] fetched wallet from server:", M))
            } catch (Z) {
                console.warn("[Order] get-wallet.php failed, falling back to localStorage", Z)
            }
            const j = Number(M == null ? void 0 : M.points) || parseInt(localStorage.getItem("points") || "0", 10)
              , V = Number(M == null ? void 0 : M.cash_balance) || parseFloat(localStorage.getItem("cashBalance") || "0")
              , G = Number(M == null ? void 0 : M.portfolio_value) || parseFloat(localStorage.getItem("portfolio_value") || "0")
              , Y = Math.max(0, Math.round(j - E))
              , $ = Math.max(0, Number((V - y).toFixed(2)))
              , K = Number((G + y).toFixed(2));
            for (const Z of k) {
                const H = {
                    member_id: w,
                    basket_id: z,
                    symbol: Z.symbol,
                    shares: Z.shares || 0,
                    amount: B,
                    order_type: "market",
                    broker: (f == null ? void 0 : f.id) || f || "Not linked"
                };
                console.log("[Order] place_order.php payload:", H);
                const W = await Ne("place_order.php", H);
                if (!W || !W.success)
                    throw console.error("[Order] place_order.php failure for", Z.symbol, W),
                    new Error((W == null ? void 0 : W.error) || `Failed to place order for ${Z.symbol}`)
            }
            try {
                const Z = {
                    member_id: w,
                    points: Y,
                    cash_balance: $,
                    portfolio_value: K
                };
                console.log("[Order] calling update_balances.php", Z),
                await Ne("update_balances.php", Z),
                localStorage.setItem("points", String(Y)),
                localStorage.setItem("cashBalance", $.toFixed(2)),
                localStorage.setItem("portfolio_value", K.toFixed(2))
            } catch (Z) {
                console.error("[Order] wallet update failed:", Z)
            }
            setTimeout(async () => {
                try {
                    console.log("[Order] Triggering broker_confirm.php after 20s..."),
                    await Ne("broker_confirm.php", {
                        member_id: w
                    })
                } catch (Z) {
                    console.error("[Order] broker_confirm.php failed:", Z)
                }
            }
            , 2e4),
            p(),
            c("/order-confirmation", {
                state: {
                    refreshWallet: !0,
                    placed: !0,
                    amount: y,
                    basketId: z
                }
            })
        } catch (z) {
            console.error("❌ Error placing order:", z),
            alert("Error placing order: " + (z.message || String(z)))
        } finally {
            A(!1)
        }
    }
    ;
    return _.jsxs("div", {
        className: "order-container",
        children: [_.jsxs("h2", {
            className: "page-title",
            children: ["Place Market Order with ", f || "Broker"]
        }), _.jsxs("p", {
            className: "order-subtext",
            children: ["These orders will be executed as ", _.jsx("span", {
                className: "highlight",
                children: "Market Orders"
            }), "."]
        }), k.length === 0 ? _.jsx("p", {
            className: "basket-empty",
            children: "Your basket is empty."
        }) : _.jsxs("div", {
            className: "basket-table-wrapper",
            children: [_.jsxs("p", {
                className: "basket-intro",
                children: ["Total Investment: $", Number(y).toFixed(2)]
            }), _.jsxs("p", {
                className: "basket-intro",
                children: ["Points Used: ", E]
            }), _.jsxs("table", {
                className: "basket-table",
                children: [_.jsx("thead", {
                    children: _.jsxs("tr", {
                        children: [_.jsx("th", {
                            children: "Symbol"
                        }), _.jsx("th", {
                            children: "Name"
                        }), _.jsx("th", {
                            children: "Shares"
                        }), _.jsx("th", {
                            children: "Order Type"
                        })]
                    })
                }), _.jsx("tbody", {
                    children: k.map(z => _.jsxs("tr", {
                        children: [_.jsx("td", {
                            className: "symbol",
                            children: z.symbol
                        }), _.jsx("td", {
                            children: z.name || "-"
                        }), _.jsx("td", {
                            className: "shares",
                            children: z.shares ?? "N/A"
                        }), _.jsx("td", {
                            className: "order-type",
                            children: "Market"
                        })]
                    }, z.symbol))
                })]
            })]
        }), _.jsxs("div", {
            className: "basket-actions",
            style: {
                display: "flex",
                gap: 12
            },
            children: [_.jsx("button", {
                type: "button",
                onClick: L,
                className: "btn-primary",
                disabled: S,
                children: S ? "Placing orders…" : `Place Market Order with ${f || "Broker"}`
            }), _.jsx("button", {
                type: "button",
                onClick: () => c(-1),
                className: "btn-secondary",
                disabled: S,
                children: "Back to Basket"
            })]
        }), _.jsxs("p", {
            className: "form-disclosure",
            children: ["This order is submitted to your broker as a ", _.jsx("strong", {
                children: "market order"
            }), " and is subject to the broker's ability to execute the order at market price and add securities to your portfolio at the brokerage. Orders not filled in the current market day will be held over to the next trading day. The actual confirmation for this order will be provided by your broker directly to you. We will add these settled trades to your StockLoyal portfolio. To execute ", _.jsx("strong", {
                children: "sell market orders"
            }), ", please contact your broker directly through their application or service desk."]
        }), D && _.jsx("p", {
            className: "form-error",
            style: {
                marginTop: 12
            },
            children: D
        })]
    })
}
function dK() {
    var o, n;
    const a = Lt()
      , c = Zt()
      , u = localStorage.getItem("memberId")
      , [p,f] = R.useState([])
      , [w,k] = R.useState("")
      , [y,E] = R.useState("")
      , [S,A] = R.useState(!0)
      , D = Number(((o = c.state) == null ? void 0 : o.amount) || 0)
      , N = ((n = c.state) == null ? void 0 : n.basketId) || localStorage.getItem("basketId") || ""
      , L = R.useMemo( () => {
        try {
            return Intl.DateTimeFormat().resolvedOptions().timeZone || "America/New_York"
        } catch {
            return "America/New_York"
        }
    }
    , []);
    R.useEffect( () => {
        if (!u) {
            E("No member ID found — please log in again."),
            A(!1);
            return
        }
        (async () => {
            var M;
            try {
                const [j,V] = await Promise.all([Ne("get_order_history.php", {
                    member_id: u
                }), Ne("get-wallet.php", {
                    member_id: u
                })]);
                if (!(j != null && j.success))
                    E((j == null ? void 0 : j.error) || "Failed to load orders.");
                else {
                    const Y = String(N || "")
                      , $ = (j.orders || []).filter(K => String(K.basket_id || "") === Y);
                    if (f($),
                    $.length > 0) {
                        const K = $.filter(Z => ["confirmed", "executed"].includes((Z.status || "").toLowerCase())).reduce( (Z, H) => Z + (parseFloat(H.amount) || 0), 0);
                        await Ne("update_balances.php", {
                            member_id: u,
                            points: parseInt(localStorage.getItem("points") || "0", 10),
                            cash_balance: parseFloat(localStorage.getItem("cashBalance") || "0"),
                            portfolio_value: K
                        }),
                        localStorage.setItem("portfolio_value", K.toFixed(2))
                    }
                }
                const G = V != null && V.success && (M = V == null ? void 0 : V.wallet) != null && M.member_timezone && String(V.wallet.member_timezone).trim() !== "" ? V.wallet.member_timezone : L;
                k(G)
            } catch (j) {
                console.error("OrderConfirmation fetch error:", j),
                E("Network error while fetching orders.")
            } finally {
                A(!1)
            }
        }
        )()
    }
    , [u, N, L, D]);
    const z = M => (parseFloat(M) || 0).toLocaleString("en-US", {
        style: "currency",
        currency: "USD",
        minimumFractionDigits: 2
    })
      , B = M => {
        if (!M)
            return "-";
        let j = String(M).trim();
        /Z$|[+-]\d{2}:\d{2}$/.test(j) || (j = j.replace(" ", "T") + "Z");
        const V = new Date(j);
        if (isNaN(V.getTime()))
            return M;
        try {
            return new Intl.DateTimeFormat(void 0,{
                year: "numeric",
                month: "short",
                day: "2-digit",
                hour: "2-digit",
                minute: "2-digit",
                second: "2-digit",
                hour12: !0,
                timeZone: w || L,
                timeZoneName: "short"
            }).format(V)
        } catch {
            return V.toLocaleString()
        }
    }
    ;
    return S ? _.jsxs("div", {
        className: "order-container",
        children: [_.jsx("h2", {
            className: "page-title",
            children: "Order Confirmation"
        }), _.jsx("p", {
            children: "Loading your orders..."
        })]
    }) : y ? _.jsxs("div", {
        className: "order-container",
        children: [_.jsx("h2", {
            className: "page-title",
            children: "Order Confirmation"
        }), _.jsx("p", {
            className: "error-text",
            children: y
        })]
    }) : _.jsxs("div", {
        className: "order-container",
        children: [_.jsx("h2", {
            className: "page-title",
            children: "Your Portfolio Orders"
        }), N && _.jsxs("p", {
            style: {
                fontSize: "0.8rem",
                color: "#555",
                marginTop: 4
            },
            children: ["Basket ID: ", _.jsx("strong", {
                children: N
            })]
        }), _.jsx("p", {
            className: "page-deck",
            children: "Below are the orders placed in this checkout."
        }), _.jsxs("p", {
            className: "subtext",
            style: {
                marginTop: -6,
                marginBottom: 12
            },
            children: ["Showing times in ", _.jsx("strong", {
                children: w || L
            })]
        }), p.length === 0 ? _.jsx("p", {
            children: "No orders found for this basket."
        }) : _.jsx("div", {
            className: "basket-table-wrapper",
            children: _.jsxs("table", {
                className: "basket-table",
                children: [_.jsx("thead", {
                    children: _.jsxs("tr", {
                        children: [_.jsx("th", {
                            children: "Symbol"
                        }), _.jsx("th", {
                            children: "Shares"
                        }), _.jsx("th", {
                            children: "Order Type"
                        }), _.jsx("th", {
                            children: "Status"
                        }), _.jsx("th", {
                            children: "Amount"
                        }), _.jsx("th", {
                            children: "Date (Local)"
                        })]
                    })
                }), _.jsx("tbody", {
                    children: p.map( (M, j) => _.jsxs("tr", {
                        children: [_.jsx("td", {
                            className: "symbol",
                            children: M.symbol
                        }), _.jsx("td", {
                            className: "shares",
                            children: M.shares
                        }), _.jsx("td", {
                            className: "order-type",
                            children: M.order_type || "-"
                        }), _.jsx("td", {
                            className: "status",
                            children: M.status || "Pending"
                        }), _.jsx("td", {
                            className: "amount",
                            children: M.amount ? z(M.amount) : "-"
                        }), _.jsx("td", {
                            className: "date",
                            children: M.placed_at ? B(M.placed_at) : "-"
                        })]
                    }, j))
                })]
            })
        }), _.jsx("div", {
            className: "basket-actions",
            children: _.jsx("button", {
                type: "button",
                className: "btn-primary",
                onClick: () => a("/wallet"),
                children: "Back to Wallet"
            })
        }), _.jsxs("p", {
            className: "form-disclosure",
            children: [_.jsx("strong", {
                children: "Disclosure for Order Confirmation Page"
            }), _.jsx("br", {}), "This confirmation reflects only the orders you just placed in this basket. Your official trade confirmations and records remain with your broker."]
        })]
    })
}
const Ys = o => `/${o.replace(/^\/+/, "")}`
  , jf = [{
    id: "Public.com",
    name: "Public.com",
    logo: Ys("/logos/public.png"),
    url: "https://public.com/"
}, {
    id: "Robinhood",
    name: "Robinhood",
    logo: Ys("/logos/robinhood.png"),
    url: "https://robinhood.com/"
}, {
    id: "Fidelity",
    name: "Fidelity",
    logo: Ys("/logos/fidelity.png"),
    url: "https://www.fidelity.com/"
}, {
    id: "Charles Schwab",
    name: "Charles Schwab",
    logo: Ys("/logos/schwab.png"),
    url: "https://www.schwab.com/"
}, {
    id: "Interactive Brokers",
    name: "Interactive Brokers",
    logo: Ys("/logos/ibkr.png"),
    url: "https://www.interactivebrokers.com/"
}, {
    id: "Betterment",
    name: "Betterment",
    logo: Ys("/logos/betterment.png"),
    url: "https://www.betterment.com/"
}];
function uK() {
    const [o,n] = R.useState("")
      , [a,c] = R.useState("")
      , [u,p] = R.useState("")
      , [f,w] = R.useState(!1)
      , [k,y] = R.useState("")
      , [E,S] = R.useState(!1)
      , [A,D] = R.useState(!0)
      , N = Lt()
      , {updateBroker: L} = mB()
      , z = localStorage.getItem("memberId")
      , B = R.useMemo( () => !!(o && a && u && !E), [o, a, u, E]);
    R.useEffect( () => {
        (async () => {
            try {
                D(!0);
                const G = await Ne("get-wallet.php", {
                    member_id: z
                });
                if (G.success && G.wallet) {
                    const Y = G.wallet.broker || ""
                      , $ = G.broker_credentials || {};
                    Y && (n(Y),
                    c($.username || ""),
                    p($.password || ""))
                }
            } catch (G) {
                console.error("Failed to fetch current broker:", G)
            } finally {
                D(!1)
            }
        }
        )()
    }
    , [z]);
    const M = G => {
        n(G),
        L(G)
    }
      , j = async G => {
        if (G.preventDefault(),
        !!B) {
            y(""),
            S(!0);
            try {
                const Y = jf.find(Z => Z.id === o)
                  , $ = {
                    member_id: z,
                    broker: o,
                    broker_url: (Y == null ? void 0 : Y.url) || "",
                    username: a,
                    password: u
                };
                console.log("Submitting broker payload:", $);
                const K = await Ne("store-broker-credentials.php", $);
                if (!K.success) {
                    y(K.error || "Failed to link broker");
                    return
                }
                K.member_id && localStorage.setItem("memberId", K.member_id),
                L(o),
                N("/wallet")
            } catch (Y) {
                console.error("SelectBroker error:", Y),
                y("Network error — please try again.")
            } finally {
                S(!1)
            }
        }
    }
      , V = jf.find(G => G.id === o);
    return _.jsxs("div", {
        className: "page-container",
        children: [_.jsx("h2", {
            className: "page-title",
            children: "Connect your broker"
        }), _.jsx("p", {
            className: "page-deck",
            children: "Select your broker and enter your existing login to link your investment account to your rewards program."
        }), _.jsx("div", {
            className: "broker-list",
            children: jf.map(G => {
                const Y = o === G.id;
                return _.jsx("button", {
                    type: "button",
                    onClick: () => M(G.id),
                    disabled: E,
                    className: `broker-card ${Y ? "active" : ""} ${E ? "disabled" : ""}`,
                    style: {
                        border: Y ? "3px solid #007bff" : void 0,
                        boxShadow: Y ? "0 0 8px rgba(0,123,255,0.3)" : void 0,
                        transition: "border 0.2s, box-shadow 0.2s"
                    },
                    children: _.jsx("img", {
                        src: G.logo,
                        alt: G.name,
                        className: "broker-logo"
                    })
                }, G.id)
            }
            )
        }), _.jsxs("p", {
            className: "form-disclosure mt-4",
            children: [_.jsx("strong", {
                children: "Security Notice:"
            }), " Your broker login credentials are used only to securely connect your brokerage account with StockLoyal. These credentials are ", _.jsx("u", {
                children: "encrypted and never visible"
            }), " to StockLoyal, the merchant, or any third party. They are stored in encrypted form and protected to maintain your security and privacy. We do not share your login information under any circumstances."]
        }), _.jsxs("form", {
            onSubmit: j,
            className: "form",
            children: [_.jsxs("div", {
                children: [_.jsx("label", {
                    className: "form-label",
                    children: V ? `Username at ${V.name}` : "Username"
                }), _.jsx("input", {
                    type: "text",
                    className: "form-input",
                    value: a,
                    onChange: G => c(G.target.value),
                    disabled: !o || E,
                    required: !0
                })]
            }), _.jsxs("div", {
                children: [_.jsx("label", {
                    className: "form-label",
                    children: V ? `Password for ${V.name}` : "Password"
                }), _.jsxs("div", {
                    className: "password-wrapper",
                    style: {
                        position: "relative"
                    },
                    children: [_.jsx("input", {
                        type: f ? "text" : "password",
                        className: "form-input",
                        value: u,
                        onChange: G => p(G.target.value),
                        disabled: !o || E,
                        required: !0
                    }), _.jsx("img", {
                        src: f ? "/icons/hide.png" : "/icons/show.png",
                        alt: f ? "Hide password" : "Show password",
                        onClick: () => !E && w(G => !G),
                        style: {
                            position: "absolute",
                            right: "10px",
                            top: "50%",
                            transform: "translateY(-50%)",
                            width: "24px",
                            height: "24px",
                            cursor: E ? "not-allowed" : "pointer",
                            opacity: !o || E ? .5 : 1
                        }
                    })]
                })]
            }), _.jsx("button", {
                type: "submit",
                disabled: !B,
                className: "btn-primary",
                children: E ? "Linking…" : "Save and Continue"
            }), k && _.jsx("p", {
                className: "form-error",
                children: k
            })]
        }), _.jsx("div", {
            className: "mt-4",
            children: _.jsx("button", {
                type: "button",
                onClick: () => N(-1),
                disabled: E,
                className: "btn-secondary",
                children: "Go back"
            })
        })]
    })
}
function hK() {
    const [o,n] = R.useState("")
      , [a,c] = R.useState(null)
      , [u,p] = R.useState("")
      , [f,w] = R.useState(!0)
      , k = Lt();
    R.useEffect( () => {
        (async () => {
            try {
                const E = await fetch(`${em}/get-wallet.php`, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({
                        member_id: localStorage.getItem("memberId")
                    })
                })
                  , S = await E.json();
                if (E.ok && S.success) {
                    const A = S.wallet;
                    A.election_type && n(A.election_type),
                    A.sweep_percentage && c(Number(A.sweep_percentage))
                }
            } catch (E) {
                console.error("Election fetch error:", E)
            } finally {
                w(!1)
            }
        }
        )()
    }
    , []);
    const y = async () => {
        if (!o) {
            p("Please select an option.");
            return
        }
        if (o === "monthly" && !a) {
            p("Please select a sweep percentage for Monthly Subscription.");
            return
        }
        try {
            const E = await fetch(`${em}/save-election.php`, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    member_id: localStorage.getItem("memberId"),
                    election: o,
                    sweep_percentage: a
                })
            })
              , S = await E.json();
            E.ok && S.success ? k("/wallet") : p(S.error || "Error saving election")
        } catch {
            p("Network error")
        }
    }
    ;
    return f ? _.jsxs("div", {
        className: "page-container",
        children: [_.jsx("h2", {
            className: "page-title",
            children: "StockLoyal Elections"
        }), _.jsx("p", {
            class: "page-deck",
            children: "Loading your election settings…"
        })]
    }) : _.jsxs("div", {
        className: "page-container",
        children: [_.jsx("h2", {
            className: "page-title",
            children: "StockLoyal Elections"
        }), _.jsx("p", {
            className: "page-deck",
            children: "Choose how you want to invest your loyalty points."
        }), _.jsxs("div", {
            className: "form",
            children: [_.jsxs("label", {
                className: `form-option ${o === "one-time" ? "active" : ""}`,
                children: [_.jsx("input", {
                    type: "radio",
                    value: "one-time",
                    checked: o === "one-time",
                    onChange: () => {
                        n("one-time"),
                        c(null)
                    }
                }), "One-time Transaction (prepare trade orders manually)"]
            }), _.jsxs("label", {
                className: `form-option ${o === "monthly" ? "active" : ""}`,
                children: [_.jsx("input", {
                    type: "radio",
                    value: "monthly",
                    checked: o === "monthly",
                    onChange: () => n("monthly")
                }), "Monthly Subscription (automatic sweep of points & stock order)"]
            })]
        }), o === "monthly" && _.jsxs("div", {
            className: "mt-4",
            children: [_.jsxs("p", {
                className: "body-text mb-4",
                children: ["By selecting the Monthly Sweep option, you authorize", " ", _.jsx("strong", {
                    children: "StockLoyal"
                }), " to automatically convert the loyalty reward points you earn each month into a cash-equivalent amount, which will be invested in your most recent stock allocation. You may update your stock allocation at any time, and any changes will apply to the next scheduled monthly sweep. The percentage of points you select below will determine the portion of monthly rewards converted on an ongoing basis."]
            }), _.jsx("h3", {
                className: "subheading mb-2",
                children: "Choose Monthly Sweep Percentage"
            }), _.jsx("div", {
                className: "points-options",
                children: [100, 50, 25].map(E => _.jsxs("button", {
                    type: "button",
                    onClick: () => c(E),
                    className: `points-option-center ${Number(a) === E ? "active" : ""}`,
                    children: [E, "%"]
                }, E))
            })]
        }), u && _.jsx("p", {
            className: "form-error",
            children: u
        }), _.jsx("button", {
            onClick: y,
            className: "btn-primary",
            children: "Save & Continue"
        }), _.jsx("button", {
            type: "button",
            onClick: () => k("/wallet"),
            className: "btn-secondary",
            children: "Cancel"
        })]
    })
}
function mK() {
    const o = Lt()
      , n = localStorage.getItem("memberId")
      , [a,c] = R.useState(null)
      , [u,p] = R.useState("")
      , [f,w] = R.useState(.01)
      , [k,y] = R.useState(0)
      , [E,S] = R.useState(0);
    R.useEffect( () => {
        let B = parseFloat(localStorage.getItem("conversion_rate") || "0");
        B >= 1 && (B = B / 100),
        w(B > 0 ? B : .01)
    }
    , []),
    R.useEffect( () => {
        (async () => {
            var B, M;
            try {
                if (!n) {
                    p("Please log in again.");
                    return
                }
                const j = await Ne("get-wallet.php", {
                    member_id: n
                });
                if (!j.success) {
                    p(j.error || "Failed to load wallet.");
                    return
                }
                c(j.wallet),
                ((B = j.wallet) == null ? void 0 : B.points) != null && localStorage.setItem("points", String(parseInt(j.wallet.points, 10) || 0)),
                ((M = j.wallet) == null ? void 0 : M.cash_balance) != null && localStorage.setItem("cashBalance", Number(j.wallet.cash_balance).toFixed(2))
            } catch (j) {
                console.error("[PointsSelect] fetch error:", j),
                p("Network error while fetching wallet.")
            }
        }
        )()
    }
    , [n]),
    R.useEffect( () => {
        const B = Math.round(k * f * 100);
        S(B / 100)
    }
    , [k, f]);
    const A = B => {
        let M = parseInt(B ?? "0", 10);
        Number.isNaN(M) && (M = 0);
        const j = parseInt((a == null ? void 0 : a.points) ?? "0", 10) || 0;
        M < 0 && (M = 0),
        M > j && (M = j),
        y(M)
    }
      , D = () => A((a == null ? void 0 : a.points) || 0)
      , N = () => {
        if (k <= 0) {
            alert("Select some points to convert.");
            return
        }
        localStorage.setItem("pendingPointsUsed", String(k)),
        localStorage.setItem("pendingCashAmount", E.toFixed(2)),
        o("/stock-picker", {
            state: {
                pointsUsed: k,
                amount: E
            }
        })
    }
    ;
    if (u)
        return _.jsxs("div", {
            className: "page-container",
            children: [_.jsx("h2", {
                className: "heading",
                children: "Convert Points"
            }), _.jsx("p", {
                className: "form-error",
                children: u
            })]
        });
    if (!a)
        return _.jsxs("div", {
            className: "page-container",
            children: [_.jsx("h2", {
                className: "heading",
                children: "Convert Points"
            }), _.jsx("p", {
                children: "Loading…"
            })]
        });
    const L = parseInt(a.points, 10) || 0
      , z = Number(a.cash_balance) || 0;
    return _.jsxs("div", {
        className: "page-container",
        style: {
            lineHeight: 1.6
        },
        children: [_.jsx("h2", {
            className: "heading",
            style: {
                marginBottom: "1rem"
            },
            children: "Convert Points"
        }), _.jsxs("div", {
            className: "card",
            style: {
                marginBottom: "1.25rem"
            },
            children: [_.jsxs("p", {
                children: [_.jsx("strong", {
                    children: "Available Points:"
                }), " ", L.toLocaleString()]
            }), _.jsxs("p", {
                children: [_.jsx("strong", {
                    children: "Available Cash Balance:"
                }), " $", z.toFixed(2)]
            }), _.jsxs("p", {
                children: [_.jsx("strong", {
                    children: "Conversion Rate:"
                }), " ", f, " per point"]
            })]
        }), _.jsxs("div", {
            className: "card",
            style: {
                marginBottom: "1.25rem"
            },
            children: [_.jsx("label", {
                htmlFor: "pointsToConvert",
                className: "member-form-label",
                style: {
                    marginBottom: "0.5rem",
                    display: "block"
                },
                children: "Points to Convert"
            }), _.jsx("input", {
                id: "pointsToConvert",
                type: "number",
                min: "0",
                max: L,
                step: "1",
                className: "member-form-input",
                value: k,
                onChange: B => A(B.target.value),
                style: {
                    marginBottom: "0.75rem"
                }
            }), _.jsx("input", {
                type: "range",
                min: "0",
                max: L,
                step: "1",
                value: k,
                onChange: B => A(B.target.value),
                style: {
                    width: "100%",
                    marginBottom: "0.75rem"
                }
            }), _.jsxs("div", {
                className: "wallet-actions",
                style: {
                    gap: 12,
                    marginTop: 12
                },
                children: [_.jsx("button", {
                    type: "button",
                    className: "btn-secondary",
                    onClick: () => A(0),
                    children: "Clear"
                }), _.jsx("button", {
                    type: "button",
                    className: "btn-secondary",
                    onClick: D,
                    children: "Use Max"
                })]
            })]
        }), _.jsxs("div", {
            className: "card",
            style: {
                marginBottom: "1.25rem"
            },
            children: [_.jsx("p", {
                className: "wallet-intro",
                style: {
                    marginBottom: "0.5rem"
                },
                children: "Cash-Value"
            }), _.jsxs("p", {
                className: "wallet-cash",
                style: {
                    fontSize: "1.25rem"
                },
                children: ["$", E.toFixed(2)]
            })]
        }), _.jsxs("div", {
            className: "wallet-actions",
            style: {
                gap: 12,
                marginTop: 12
            },
            children: [_.jsx("button", {
                type: "button",
                className: "btn-primary",
                onClick: N,
                children: "Continue"
            }), _.jsx("button", {
                type: "button",
                className: "btn-secondary",
                onClick: () => o(-1),
                children: "Back"
            })]
        })]
    })
}
const pK = {
    "Most Active": "most_actives",
    Trending: "trending_tickers",
    "Day Gainers": "day_gainers",
    "Day Losers": "day_losers",
    "Large Caps": "undervalued_large_caps",
    "Small Caps": "aggressive_small_caps",
    "Growth Tech": "growth_technology_stocks",
    "Mutual Funds": "top_mutual_funds",
    ETFs: "etf",
    "Crypto - Most Active": "most_actives_cryptocurrencies"
};
function gK() {
    const o = Lt()
      , n = Zt()
      , {amount: a=0, pointsUsed: c=0, memberId: u} = n.state || {}
      , p = async (f, w) => {
        var k, y, E, S;
        try {
            const A = await fetch(`${em}/proxy.php?scrId=${w}`);
            if (!A.ok)
                throw new Error(`HTTP ${A.status}`);
            const D = ((S = (E = (y = (k = (await A.json()).finance) == null ? void 0 : k.result) == null ? void 0 : y[0]) == null ? void 0 : E.quotes) == null ? void 0 : S.map(N => ({
                symbol: N.symbol,
                name: N.shortName,
                price: N.regularMarketPrice,
                change: N.regularMarketChangePercent
            }))) || [];
            o("/stock-list", {
                state: {
                    category: f,
                    results: D,
                    amount: a,
                    pointsUsed: c,
                    memberId: u
                }
            })
        } catch (A) {
            console.error("Proxy/Yahoo API error:", A),
            o("/stock-list", {
                state: {
                    category: f,
                    results: [],
                    error: "Failed to fetch stocks",
                    amount: a,
                    pointsUsed: c,
                    memberId: u
                }
            })
        }
    }
    ;
    return _.jsxs("div", {
        className: "categories-page",
        children: [_.jsx("h2", {
            className: "categories-title",
            children: "Select a Category"
        }), _.jsx("div", {
            className: "categories-grid",
            children: Object.entries(pK).map( ([f,w]) => _.jsx("button", {
                type: "button",
                onClick: () => p(f, w),
                className: "category-btn",
                children: f
            }, f))
        }), _.jsx("div", {
            className: "categories-footer",
            children: _.jsx("button", {
                type: "button",
                onClick: () => o("/wallet"),
                className: "btn-secondary",
                children: "Back to Wallet"
            })
        })]
    })
}
const fK = {
    "Most Active": "most_actives",
    "Day Gainers": "day_gainers",
    "Day Losers": "day_losers",
    "Large Caps": "undervalued_large_caps",
    "Small Caps": "aggressive_small_caps",
    "Growth Tech": "growth_technology_stocks",
    "Mutual Funds": "top_mutual_funds",
    ETFs: "etf",
    "Crypto - Most Active": "most_actives_cryptocurrencies"
}
  , kK = {
    "Most Active": "/icons/most-active.jpg",
    "Day Gainers": "/icons/day-gainers.jpg",
    "Day Losers": "/icons/day-losers.jpg",
    "Large Caps": "/icons/large-caps.jpg",
    "Small Caps": "/icons/small-caps.jpg",
    "Growth Tech": "/icons/growth-tech.jpg",
    "Mutual Funds": "/icons/mutual-funds.jpg",
    ETFs: "/icons/etfs.jpg",
    "Crypto - Most Active": "/icons/crypto.jpg"
};
function bK() {
    const o = Lt()
      , n = Zt()
      , {addToBasket: a} = cd()
      , c = localStorage.getItem("memberId")
      , {amount: u=0, pointsUsed: p=0} = n.state || {}
      , [f,w] = R.useState(null)
      , [k,y] = R.useState("")
      , [E,S] = R.useState(.01)
      , [A,D] = R.useState(p)
      , [N,L] = R.useState(u)
      , [z,B] = R.useState(u.toFixed(2))
      , [M,j] = R.useState(!1)
      , [V,G] = R.useState("")
      , [Y,$] = R.useState([])
      , [K,Z] = R.useState("")
      , [H,W] = R.useState([])
      , [ee,re] = R.useState("")
      , [U,de] = R.useState(!1)
      , te = R.useRef(null)
      , ue = R.useRef(null)
      , me = R.useRef(!1)
      , Ce = R.useRef(0)
      , Ye = R.useRef(0)
      , Co = ce => {
        me.current = !0,
        Ce.current = ce.pageX - te.current.offsetLeft,
        Ye.current = te.current.scrollLeft
    }
      , Dr = () => me.current = !1
      , oo = () => me.current = !1
      , Uo = ce => {
        if (!me.current)
            return;
        ce.preventDefault();
        const Re = ce.pageX - te.current.offsetLeft;
        te.current.scrollLeft = Ye.current - (Re - Ce.current)
    }
      , Se = ce => {
        me.current = !0,
        Ce.current = ce.touches[0].pageX - te.current.offsetLeft,
        Ye.current = te.current.scrollLeft
    }
      , dd = ce => {
        if (!me.current)
            return;
        const Re = ce.touches[0].pageX - te.current.offsetLeft;
        te.current.scrollLeft = Ye.current - (Re - Ce.current)
    }
      , Qa = () => me.current = !1;
    R.useEffect( () => {
        (async () => {
            var ce, Re;
            try {
                if (!c) {
                    y("Please log in again.");
                    return
                }
                const Qe = await Ne("get-wallet.php", {
                    member_id: c
                });
                if (!Qe.success) {
                    y(Qe.error || "Failed to load wallet.");
                    return
                }
                if (w(Qe.wallet),
                (ce = Qe.wallet) != null && ce.sweep_percentage && (Re = Qe.wallet) != null && Re.points) {
                    const Gr = Math.round((parseInt(Qe.wallet.points, 10) || 0) * (parseFloat(Qe.wallet.sweep_percentage) / 100));
                    D(Gr)
                }
            } catch (Qe) {
                console.error("[StockPicker] fetch wallet error:", Qe),
                y("Network error while fetching wallet.")
            }
        }
        )()
    }
    , [c]),
    R.useEffect( () => {
        let ce = parseFloat(localStorage.getItem("conversion_rate") || "0");
        ce >= 1 && (ce = ce / 100),
        S(ce > 0 ? ce : .01)
    }
    , []),
    R.useEffect( () => {
        if (!M) {
            const ce = Math.round(A * E * 100) / 100;
            L(ce),
            B(ce.toFixed(2))
        }
    }
    , [A, E, M]);
    const ki = ce => {
        let Re = parseInt(ce ?? "0", 10);
        Number.isNaN(Re) && (Re = 0);
        const Qe = parseInt((f == null ? void 0 : f.points) ?? "0", 10) || 0;
        Re = Math.max(0, Math.min(Re, Qe)),
        D(Re)
    }
      , Za = async (ce, Re) => {
        var Qe, Gr, Sn;
        try {
            G(ce),
            Z(""),
            $([]);
            const ye = await Ne("proxy.php", {
                scrId: Re
            });
            if (!ye || ye.error)
                throw new Error(ye.error || "Failed to load");
            const el = (((Sn = (Gr = (Qe = ye.finance) == null ? void 0 : Qe.result) == null ? void 0 : Gr[0]) == null ? void 0 : Sn.quotes) ?? ye.data ?? ye.results ?? []).map(Ho => ({
                symbol: Ho.symbol,
                name: Ho.shortName || Ho.longName || Ho.symbol,
                price: Ho.regularMarketPrice ?? Ho.postMarketPrice ?? Ho.preMarketPrice ?? null,
                change: Ho.regularMarketChangePercent ?? Ho.postMarketChangePercent ?? Ho.preMarketChangePercent ?? 0
            }));
            $(el),
            setTimeout( () => {
                ue.current && ue.current.scrollIntoView({
                    behavior: "smooth",
                    block: "start"
                })
            }
            , 300)
        } catch (ye) {
            console.error("[StockPicker] proxy error:", ye),
            Z("Failed to fetch stocks.")
        }
    }
      , Ja = async () => {
        if (ee.trim()) {
            de(!0),
            Z(""),
            $([]);
            try {
                const ce = await Ne("symbol-lookup.php", {
                    symbol: ee.trim().toUpperCase()
                });
                if (!ce.success) {
                    Z(ce.error || "Symbol not found.");
                    return
                }
                G(`Symbol: ${ce.symbol}`),
                $([{
                    symbol: ce.symbol,
                    name: ce.name,
                    price: ce.price,
                    change: ce.change
                }]),
                setTimeout( () => {
                    ue.current && ue.current.scrollIntoView({
                        behavior: "smooth",
                        block: "start"
                    })
                }
                , 300)
            } catch (ce) {
                console.error("[StockPicker] symbol search error:", ce),
                Z("Symbol lookup failed.")
            } finally {
                de(!1)
            }
        }
    }
      , ud = ce => W(Re => Re.includes(ce) ? Re.filter(Qe => Qe !== ce) : [...Re, ce])
      , Xa = () => {
        if (H.length === 0) {
            alert("Please select at least one stock to continue.");
            return
        }
        Y.filter(ce => H.includes(ce.symbol)).forEach(ce => a(ce)),
        o("/basket", {
            state: {
                category: V,
                amount: N,
                pointsUsed: A,
                memberId: c
            }
        })
    }
    ;
    if (k)
        return _.jsxs("div", {
            className: "page-container",
            children: [_.jsx("h2", {
                className: "page-title",
                children: "Convert Points to Shares"
            }), _.jsx("p", {
                className: "form-error",
                children: k
            })]
        });
    if (!f)
        return _.jsxs("div", {
            className: "page-container",
            children: [_.jsx("h2", {
                className: "page-title",
                children: "Convert Points"
            }), _.jsx("p", {
                children: "Loading…"
            })]
        });
    const Le = parseInt(f.points, 10) || 0
      , bi = Number(f.cash_balance) || 0;
    return _.jsxs("div", {
        className: "app-container categories-page",
        children: [_.jsx("h2", {
            className: "page-title",
            style: {
                marginBottom: "1rem",
                textAlign: "center"
            },
            children: "Convert Points to Invest"
        }), _.jsxs("div", {
            className: "card",
            style: {
                marginBottom: "1.5rem",
                textAlign: "center",
                padding: "1.25rem",
                borderRadius: "12px",
                background: "linear-gradient(135deg, #2563eb15, #1e40af10)",
                boxShadow: "0 2px 8px rgba(0,0,0,0.05)"
            },
            children: [_.jsx("p", {
                style: {
                    fontSize: "1rem",
                    fontWeight: "600",
                    color: "#1e40af"
                },
                children: "Available Points"
            }), _.jsx("p", {
                style: {
                    fontSize: "1.25rem",
                    fontWeight: "700",
                    marginBottom: "1rem",
                    color: "#111827"
                },
                children: Le.toLocaleString()
            }), _.jsx("p", {
                style: {
                    fontSize: "1rem",
                    fontWeight: "600",
                    color: "#1e40af"
                },
                children: "Available Cash Balance"
            }), _.jsxs("p", {
                style: {
                    fontSize: "1.25rem",
                    fontWeight: "700",
                    margin: 0,
                    color: "#16a34a"
                },
                children: ["$", bi.toFixed(2)]
            })]
        }), _.jsxs("div", {
            className: "card",
            style: {
                marginBottom: "1.25rem",
                textAlign: "center"
            },
            children: [_.jsx("p", {
                style: {
                    fontWeight: "600"
                },
                children: "Points to Convert"
            }), _.jsx("p", {
                style: {
                    fontWeight: "100"
                },
                children: "Use slider to select points or enter a custom amount in the box below:"
            }), _.jsx("input", {
                id: "pointsToConvert",
                type: "number",
                min: "0",
                max: Le,
                step: "1",
                className: "points-to-convert",
                value: A,
                onChange: ce => ki(ce.target.value),
                style: {
                    marginBottom: "0.75rem",
                    textAlign: "center"
                }
            }), _.jsxs("div", {
                className: "range-wrapper",
                style: {
                    marginBottom: "1rem"
                },
                children: [_.jsx("button", {
                    type: "button",
                    className: "range-btn",
                    onClick: () => ki(0),
                    children: "➖"
                }), _.jsx("input", {
                    type: "range",
                    min: "0",
                    max: Le,
                    step: "1",
                    value: A,
                    onChange: ce => ki(ce.target.value),
                    className: "range-slider"
                }), _.jsx("button", {
                    type: "button",
                    className: "range-btn",
                    onClick: () => ki(Le),
                    children: "➕"
                })]
            }), _.jsx("p", {
                className: "wallet-intro",
                style: {
                    marginBottom: "0.25rem",
                    fontWeight: "600"
                },
                children: "Cash-Value used for this Order"
            }), _.jsxs("div", {
                style: {
                    display: "flex",
                    justifyContent: "center",
                    alignItems: "center"
                },
                children: [_.jsx("span", {
                    style: {
                        fontSize: "1.25rem",
                        marginRight: "6px"
                    },
                    children: "$"
                }), _.jsx("input", {
                    id: "cashToConvert",
                    type: "text",
                    inputMode: "decimal",
                    className: "wallet-cash",
                    value: z,
                    onFocus: () => j(!0),
                    onChange: ce => {
                        const Re = ce.target.value;
                        B(Re);
                        const Qe = parseFloat(Re);
                        if (!isNaN(Qe)) {
                            const Gr = (parseInt((f == null ? void 0 : f.points) ?? "0", 10) || 0) * E
                              , Sn = Math.min(Math.max(Qe, 0), Gr);
                            L(Sn),
                            D(Math.floor(Sn / E))
                        }
                    }
                    ,
                    onBlur: () => {
                        j(!1),
                        B(N.toFixed(2))
                    }
                    ,
                    style: {
                        fontSize: "1.25rem",
                        color: "#16a34a",
                        textAlign: "center",
                        border: "1px solid #ccc",
                        borderRadius: "8px",
                        padding: "6px 10px",
                        width: "120px",
                        appearance: "textfield"
                    }
                })]
            })]
        }), _.jsxs("div", {
            className: "card",
            style: {
                marginBottom: "1.25rem"
            },
            children: [_.jsx("div", {
                style: {
                    display: "flex",
                    justifyContent: "center"
                },
                children: _.jsxs("div", {
                    style: {
                        position: "relative",
                        width: "80%",
                        minWidth: 180
                    },
                    children: [_.jsx("input", {
                        type: "text",
                        value: ee,
                        onChange: ce => re(ce.target.value),
                        placeholder: "Enter symbol (e.g., AAPL)",
                        className: "member-form-input",
                        style: {
                            width: "60%",
                            paddingRight: "1rem"
                        },
                        onKeyDown: ce => ce.key === "Enter" && Ja(),
                        "aria-label": "Symbol input"
                    }), _.jsx(LG, {
                        size: 20,
                        style: {
                            position: "absolute",
                            right: "0.1rem",
                            top: "50%",
                            transform: "translateY(-50%)",
                            cursor: "pointer",
                            color: "#6b7280"
                        },
                        onClick: Ja,
                        "aria-label": "Search symbol"
                    })]
                })
            }), U && _.jsx("p", {
                className: "caption",
                style: {
                    marginTop: 8
                },
                children: "Searching…"
            }), K && _.jsx("p", {
                className: "points-error",
                style: {
                    marginTop: 8
                },
                children: K
            })]
        }), _.jsx("h2", {
            className: "categories-title",
            style: {
                textAlign: "center"
            },
            children: "Select a Category"
        }), _.jsx("div", {
            ref: te,
            className: "categories-slider",
            onMouseDown: Co,
            onMouseLeave: Dr,
            onMouseUp: oo,
            onMouseMove: Uo,
            onTouchStart: Se,
            onTouchMove: dd,
            onTouchEnd: Qa,
            style: {
                cursor: "grab"
            },
            children: Object.entries(fK).map( ([ce,Re]) => _.jsx("button", {
                type: "button",
                onClick: () => Za(ce, Re),
                className: "category-btn",
                style: {
                    minWidth: "160px",
                    height: "100px",
                    marginRight: "10px",
                    borderRadius: "8px",
                    backgroundImage: `url(${kK[ce] || "/icons/default.jpg"})`,
                    backgroundSize: "cover",
                    backgroundPosition: "center",
                    position: "relative",
                    overflow: "hidden",
                    color: "white",
                    fontWeight: "600"
                },
                children: _.jsx("span", {
                    style: {
                        position: "absolute",
                        bottom: 0,
                        left: 0,
                        right: 0,
                        padding: "6px",
                        background: "rgba(0,0,0,0.5)",
                        textAlign: "center",
                        fontSize: "0.9rem"
                    },
                    children: ce
                })
            }, ce))
        }), V && _.jsxs("div", {
            ref: ue,
            className: `stocklist-container ${Y.length > 0 ? "show" : ""}`,
            style: {
                marginTop: 16,
                marginBottom: 120
            },
            children: [_.jsxs("h2", {
                className: "stocklist-heading",
                style: {
                    textAlign: "center"
                },
                children: [V, " Stocks"]
            }), K && _.jsx("p", {
                className: "stocklist-error",
                children: K
            }), !K && Y.length === 0 && _.jsx("p", {
                className: "stocklist-empty",
                children: "No stocks found."
            }), Y.length > 0 && _.jsx("div", {
                className: "stocklist-table-wrapper",
                children: _.jsxs("table", {
                    className: "stocklist-table",
                    children: [_.jsx("thead", {
                        children: _.jsxs("tr", {
                            children: [_.jsx("th", {
                                children: "Select"
                            }), _.jsx("th", {
                                children: "Symbol"
                            }), _.jsx("th", {
                                children: "Name"
                            }), _.jsxs("th", {
                                children: ["Price", _.jsx("br", {}), "Change %"]
                            })]
                        })
                    }), _.jsx("tbody", {
                        children: Y.map(ce => _.jsxs("tr", {
                            className: "stock-row",
                            children: [_.jsx("td", {
                                className: "text-center",
                                children: _.jsx("input", {
                                    type: "checkbox",
                                    checked: H.includes(ce.symbol),
                                    onChange: () => ud(ce.symbol)
                                })
                            }), _.jsx("td", {
                                className: "symbol",
                                children: ce.symbol
                            }), _.jsx("td", {
                                className: "text-left",
                                children: ce.name || "-"
                            }), _.jsxs("td", {
                                className: "price-change",
                                children: [_.jsx("div", {
                                    className: "price",
                                    children: ce.price ? `$${ce.price.toFixed(2)}` : "N/A"
                                }), _.jsxs("div", {
                                    className: ce.change > 0 ? "change-positive" : ce.change < 0 ? "change-negative" : "change-neutral",
                                    children: [typeof ce.change == "number" ? ce.change.toFixed(2) : Number(ce.change || 0).toFixed(2), "%"]
                                })]
                            })]
                        }, ce.symbol))
                    })]
                })
            })]
        }), (V || H.length > 0) && _.jsxs("div", {
            className: "floating-actions",
            children: [_.jsx("button", {
                type: "button",
                onClick: Xa,
                className: "btn-primary",
                style: {
                    width: "90%",
                    maxWidth: 320,
                    marginBottom: 8
                },
                children: "Continue with Selected"
            }), _.jsx("button", {
                type: "button",
                onClick: () => o("/wallet"),
                className: "btn-secondary",
                style: {
                    width: "90%",
                    maxWidth: 320
                },
                children: "Back to Wallet"
            })]
        })]
    })
}
function wK() {
    const o = Lt()
      , n = Zt()
      , {category: a, results: c=[], error: u, amount: p, pointsUsed: f, memberId: w} = n.state || {}
      , {addToBasket: k} = cd()
      , [y,E] = R.useState([])
      , S = D => {
        E(N => N.includes(D) ? N.filter(L => L !== D) : [...N, D])
    }
      , A = () => {
        if (y.length === 0) {
            alert("Please select at least one stock to continue.");
            return
        }
        c.filter(D => y.includes(D.symbol)).forEach(D => k(D)),
        o("/basket", {
            state: {
                category: a,
                amount: p,
                pointsUsed: f,
                memberId: w
            }
        })
    }
    ;
    return _.jsxs("div", {
        className: "stocklist-container",
        children: [_.jsx("h2", {
            className: "stocklist-heading",
            children: a ? `${a} Stocks` : "Stocks"
        }), u && _.jsx("p", {
            className: "stocklist-error",
            children: u
        }), !u && c.length === 0 && _.jsx("p", {
            className: "stocklist-empty",
            children: "No stocks found."
        }), c.length > 0 && _.jsx("div", {
            className: "stocklist-table-wrapper",
            children: _.jsxs("table", {
                className: "stocklist-table",
                children: [_.jsx("thead", {
                    children: _.jsxs("tr", {
                        children: [_.jsx("th", {
                            children: "Select"
                        }), _.jsx("th", {
                            children: "Symbol"
                        }), _.jsx("th", {
                            children: "Name"
                        }), _.jsx("th", {
                            children: "Price"
                        }), _.jsx("th", {
                            children: "Change %"
                        })]
                    })
                }), _.jsx("tbody", {
                    children: c.map(D => {
                        var N, L;
                        return _.jsxs("tr", {
                            children: [_.jsx("td", {
                                className: "text-center",
                                children: _.jsx("input", {
                                    type: "checkbox",
                                    checked: y.includes(D.symbol),
                                    onChange: () => S(D.symbol)
                                })
                            }), _.jsx("td", {
                                className: "symbol",
                                children: D.symbol
                            }), _.jsx("td", {
                                className: "text-left",
                                children: D.name || "-"
                            }), _.jsxs("td", {
                                children: ["$", ((N = D.price) == null ? void 0 : N.toFixed(2)) ?? "N/A"]
                            }), _.jsxs("td", {
                                className: D.change > 0 ? "change-positive" : D.change < 0 ? "change-negative" : "change-neutral",
                                children: [((L = D.change) == null ? void 0 : L.toFixed(2)) ?? "0.00", "%"]
                            })]
                        }, D.symbol)
                    }
                    )
                })]
            })
        }), _.jsxs("div", {
            className: "stocklist-actions",
            children: [_.jsx("button", {
                type: "button",
                onClick: A,
                className: "btn-primary",
                children: "Continue with Selected"
            }), _.jsx("button", {
                type: "button",
                onClick: () => o(-1),
                className: "btn-secondary",
                children: "Back"
            })]
        })]
    })
}
function AK() {
    var o, n, a;
    const c = Lt()
      , u = Zt()
      , {basket: p, removeFromBasket: f} = cd()
      , w = ((o = u.state) == null ? void 0 : o.amount) || 0
      , k = ((n = u.state) == null ? void 0 : n.pointsUsed) || 0
      , y = ((a = u.state) == null ? void 0 : a.memberId) || localStorage.getItem("memberId")
      , E = p.length > 0 ? p.map(A => {
        const D = w / p.length
          , N = A.price && A.price > 0 ? D / A.price : 0;
        return {
            ...A,
            allocatedAmount: D,
            shares: parseFloat(N.toFixed(4))
        }
    }
    ) : []
      , S = () => {
        c("/order", {
            state: {
                basket: E,
                amount: w,
                pointsUsed: k,
                memberId: y
            }
        })
    }
    ;
    return p.length === 0 ? _.jsxs("div", {
        className: "basket-container",
        children: [_.jsx("h2", {
            className: "page-title",
            children: "Your Basket"
        }), _.jsx("p", {
            className: "basket-empty",
            children: "Your basket is empty."
        }), _.jsx("button", {
            type: "button",
            onClick: () => c("/stock-picker"),
            className: "btn-primary",
            children: "Browse Categories"
        })]
    }) : _.jsxs("div", {
        className: "basket-container",
        children: [_.jsx("h2", {
            className: "page-title",
            children: "Your Basket"
        }), _.jsxs("p", {
            className: "page-deck",
            children: ["You’re investing ", _.jsxs("strong", {
                children: ["$", w.toFixed(2)]
            }), " across", " ", p.length, " stocks, using ", _.jsx("strong", {
                children: k
            }), " points."]
        }), _.jsx("div", {
            className: "basket-table-wrapper",
            children: _.jsxs("table", {
                className: "basket-table",
                children: [_.jsx("thead", {
                    children: _.jsxs("tr", {
                        children: [_.jsx("th", {
                            children: "Symbol"
                        }), _.jsx("th", {
                            children: "Name"
                        }), _.jsxs("th", {
                            children: ["Allocation", _.jsx("div", {
                                style: {
                                    fontSize: "0.75rem",
                                    fontWeight: "normal",
                                    color: "#6b7280"
                                },
                                children: "Shares"
                            })]
                        }), _.jsx("th", {})]
                    })
                }), _.jsx("tbody", {
                    children: E.map(A => _.jsxs("tr", {
                        className: "stock-row",
                        children: [_.jsx("td", {
                            className: "symbol",
                            children: A.symbol
                        }), _.jsx("td", {
                            className: "text-left",
                            children: A.name || "-"
                        }), _.jsx("td", {
                            className: "shares",
                            children: A.shares
                        }), _.jsx("td", {
                            className: "text-center",
                            children: _.jsx("button", {
                                type: "button",
                                onClick: () => f(A.symbol),
                                className: "remove-icon-btn",
                                title: "Remove",
                                children: "➖"
                            })
                        })]
                    }, A.symbol))
                })]
            })
        }), _.jsxs("div", {
            className: "basket-actions",
            children: [_.jsx("button", {
                type: "button",
                onClick: S,
                className: "btn-primary",
                children: "Proceed to Order"
            }), _.jsx("button", {
                type: "button",
                onClick: () => c("/stock-picker"),
                className: "btn-secondary",
                children: "Add More Stocks"
            })]
        })]
    })
}
function vK() {
    const o = Lt()
      , n = localStorage.getItem("memberId")
      , [a,c] = R.useState([])
      , [u,p] = R.useState(0)
      , [f,w] = R.useState("")
      , [k,y] = R.useState(!0);
    R.useEffect( () => {
        if (!n) {
            w("No member ID found — please log in again."),
            y(!1);
            return
        }
        (async () => {
            try {
                const A = await Ne("get_portfolio_orders.php", {
                    member_id: n
                });
                if (!A.success) {
                    w(A.error || "Failed to load portfolio.");
                    return
                }
                c(A.orders || []),
                p(A.portfolio_value || 0)
            } catch (A) {
                console.error("Portfolio fetch error:", A),
                w("Network error while fetching portfolio.")
            } finally {
                y(!1)
            }
        }
        )()
    }
    , [n]);
    const E = A => (parseFloat(A) || 0).toLocaleString("en-US", {
        style: "currency",
        currency: "USD",
        minimumFractionDigits: 2
    })
      , S = A => {
        const D = parseFloat(A)
          , N = D >= 0 ? "#22c55e" : "#ef4444"
          , L = D > 0 ? "+" : "";
        return _.jsx("span", {
            style: {
                color: N,
                fontWeight: 500
            },
            children: `${L}${D.toFixed(2)}%`
        })
    }
    ;
    return _.jsxs("div", {
        className: "portfolio-container",
        children: [_.jsx("h2", {
            className: "page-title",
            style: {
                textAlign: "center"
            },
            children: "Your StockLoyal Portfolio"
        }), k ? _.jsx("p", {
            children: "Loading your portfolio..."
        }) : f ? _.jsx("p", {
            className: "error-text",
            children: f
        }) : a.length === 0 ? _.jsx("p", {
            className: "portfolio-subtext",
            style: {
                textAlign: "center"
            },
            children: "You have no confirmed holdings yet."
        }) : _.jsxs(_.Fragment, {
            children: [_.jsxs("div", {
                className: "portfolio-total",
                style: {
                    textAlign: "center",
                    marginBottom: "20px",
                    fontSize: "1rem"
                },
                children: [_.jsx("strong", {
                    children: "Total Portfolio Value:"
                }), " ", _.jsx("span", {
                    style: {
                        fontSize: "1.5rem",
                        fontWeight: "bold",
                        color: "#007bff"
                    },
                    children: E(u)
                })]
            }), _.jsx("div", {
                className: "basket-table-wrapper",
                children: _.jsxs("table", {
                    className: "basket-table",
                    children: [_.jsx("thead", {
                        children: _.jsxs("tr", {
                            children: [_.jsx("th", {
                                children: "Symbol"
                            }), _.jsx("th", {
                                children: "Stock Name"
                            }), _.jsx("th", {
                                style: {
                                    textAlign: "right"
                                },
                                children: "Total Shares"
                            }), _.jsx("th", {
                                style: {
                                    textAlign: "right"
                                },
                                children: "Current Price"
                            }), _.jsxs("th", {
                                style: {
                                    textAlign: "right"
                                },
                                children: ["Current Value", _.jsx("br", {}), _.jsx("small", {
                                    style: {
                                        fontWeight: 400,
                                        color: "#666"
                                    },
                                    children: "(and Daily % Change)"
                                })]
                            })]
                        })
                    }), _.jsx("tbody", {
                        children: a.map( (A, D) => {
                            var N;
                            return _.jsxs("tr", {
                                children: [_.jsx("td", {
                                    children: A.symbol
                                }), _.jsx("td", {
                                    children: A.stock_name
                                }), _.jsx("td", {
                                    style: {
                                        textAlign: "right"
                                    },
                                    children: (N = A.total_shares) == null ? void 0 : N.toLocaleString(void 0, {
                                        minimumFractionDigits: 2,
                                        maximumFractionDigits: 4
                                    })
                                }), _.jsx("td", {
                                    style: {
                                        textAlign: "right"
                                    },
                                    children: E(A.current_price)
                                }), _.jsxs("td", {
                                    style: {
                                        textAlign: "right"
                                    },
                                    children: [_.jsx("div", {
                                        children: E(A.current_value)
                                    }), _.jsx("div", {
                                        style: {
                                            fontSize: "0.85rem"
                                        },
                                        children: S(A.daily_change)
                                    })]
                                })]
                            }, D)
                        }
                        )
                    })]
                })
            })]
        }), _.jsxs("div", {
            className: "portfolio-actions",
            style: {
                display: "flex",
                justifyContent: "center",
                gap: "10px",
                marginTop: "20px"
            },
            children: [_.jsx("button", {
                type: "button",
                className: "btn-secondary",
                onClick: () => o("/transactions"),
                children: "View Transactions"
            }), _.jsx("button", {
                type: "button",
                className: "btn-primary",
                onClick: () => o("/wallet"),
                children: "Back to Wallet"
            })]
        }), _.jsxs("p", {
            className: "form-disclosure",
            children: [_.jsx("strong", {
                children: "Disclosure:"
            }), " Your ", _.jsx("em", {
                children: "StockLoyal Portfolio"
            }), " displays only the securities you’ve purchased through the ", _.jsx("strong", {
                children: "StockLoyal app"
            }), ". These holdings are maintained directly with your brokerage firm, ", _.jsx("strong", {
                children: "Charles Schwab"
            }), ". To view your complete investment portfolio, visit", " ", _.jsx("a", {
                href: "https://www.schwab.com",
                target: "_blank",
                rel: "noopener noreferrer",
                style: {
                    color: "#007bff",
                    textDecoration: "underline"
                },
                children: "Charles Schwab"
            }), "."]
        })]
    })
}
function _K() {
    const o = Lt()
      , n = localStorage.getItem("memberId")
      , [a,c] = R.useState([])
      , [u,p] = R.useState("")
      , [f,w] = R.useState("")
      , [k,y] = R.useState(!0)
      , E = R.useMemo( () => {
        try {
            return Intl.DateTimeFormat().resolvedOptions().timeZone || "America/New_York"
        } catch {
            return "America/New_York"
        }
    }
    , []);
    R.useEffect( () => {
        if (!n) {
            w("No member ID found — please log in again."),
            y(!1);
            return
        }
        (async () => {
            var D;
            try {
                const [N,L] = await Promise.all([Ne("get_order_history.php", {
                    member_id: n
                }), Ne("get-wallet.php", {
                    member_id: n
                })]);
                N != null && N.success ? c(N.orders || []) : w((N == null ? void 0 : N.error) || "Failed to load transactions.");
                const z = L != null && L.success && (D = L == null ? void 0 : L.wallet) != null && D.member_timezone && String(L.wallet.member_timezone).trim() !== "" ? L.wallet.member_timezone : E;
                p(z)
            } catch (N) {
                console.error("Transactions fetch error:", N),
                w("Network error while fetching transactions.")
            } finally {
                y(!1)
            }
        }
        )()
    }
    , [n, E]);
    const S = D => (parseFloat(D) || 0).toLocaleString("en-US", {
        style: "currency",
        currency: "USD",
        minimumFractionDigits: 2
    })
      , A = D => {
        if (!D)
            return "-";
        let N = String(D).trim();
        /Z$|[+-]\d{2}:\d{2}$/.test(N) || (N = N.replace(" ", "T") + "Z");
        const L = new Date(N);
        if (isNaN(L.getTime()))
            return D;
        try {
            return new Intl.DateTimeFormat(void 0,{
                year: "numeric",
                month: "short",
                day: "2-digit",
                hour: "2-digit",
                minute: "2-digit",
                second: "2-digit",
                hour12: !0,
                timeZone: u || E,
                timeZoneName: "short"
            }).format(L)
        } catch {
            return L.toLocaleString()
        }
    }
    ;
    return _.jsxs("div", {
        className: "transactions-container",
        children: [_.jsx("h2", {
            className: "page-title",
            style: {
                textAlign: "center"
            },
            children: "Transaction History"
        }), _.jsxs("p", {
            className: "subtext",
            style: {
                textAlign: "center",
                marginTop: -6,
                marginBottom: 12
            },
            children: ["Showing times in ", _.jsx("strong", {
                children: u || E
            })]
        }), k ? _.jsx("p", {
            children: "Loading your transactions..."
        }) : f ? _.jsx("p", {
            className: "error-text",
            children: f
        }) : a.length === 0 ? _.jsx("p", {
            className: "portfolio-subtext",
            style: {
                textAlign: "center"
            },
            children: "No transactions found."
        }) : _.jsx("div", {
            className: "basket-table-wrapper",
            style: {
                overflowX: "auto"
            },
            children: _.jsxs("table", {
                className: "basket-table",
                style: {
                    width: "100%",
                    minWidth: "760px",
                    borderCollapse: "collapse"
                },
                children: [_.jsx("thead", {
                    children: _.jsxs("tr", {
                        children: [_.jsx("th", {
                            children: "Symbol"
                        }), _.jsx("th", {
                            children: "Shares"
                        }), _.jsx("th", {
                            style: {
                                textAlign: "right"
                            },
                            children: "Amount"
                        }), _.jsx("th", {
                            style: {
                                width: "140px"
                            },
                            children: "Order / Status"
                        }), _.jsx("th", {
                            children: "Placed (Local)"
                        })]
                    })
                }), _.jsx("tbody", {
                    children: a.map( (D, N) => _.jsxs("tr", {
                        children: [_.jsx("td", {
                            children: D.symbol
                        }), _.jsx("td", {
                            children: D.shares
                        }), _.jsx("td", {
                            style: {
                                textAlign: "right"
                            },
                            children: D.amount ? S(D.amount) : "-"
                        }), _.jsx("td", {
                            style: {
                                textAlign: "center",
                                lineHeight: "1.3"
                            },
                            children: _.jsxs("div", {
                                style: {
                                    display: "flex",
                                    flexDirection: "column",
                                    alignItems: "center"
                                },
                                children: [_.jsx("span", {
                                    style: {
                                        fontWeight: "600",
                                        color: "#1e3a8a",
                                        fontSize: "0.9rem"
                                    },
                                    children: D.order_type || "-"
                                }), _.jsx("span", {
                                    style: {
                                        fontSize: "0.85rem",
                                        color: D.status === "executed" ? "#16a34a" : D.status === "failed" ? "#dc2626" : D.status === "pending" ? "#ca8a04" : "#6b7280"
                                    },
                                    children: D.status || "-"
                                })]
                            })
                        }), _.jsx("td", {
                            style: {
                                fontSize: "0.9rem"
                            },
                            children: D.placed_at ? A(D.placed_at) : "-"
                        })]
                    }, N))
                })]
            })
        }), _.jsxs("div", {
            className: "transactions-actions",
            style: {
                display: "flex",
                flexDirection: "column",
                alignItems: "center",
                gap: "10px",
                marginTop: "20px"
            },
            children: [_.jsx("button", {
                type: "button",
                className: "btn-secondary",
                onClick: () => o("/portfolio"),
                style: {
                    width: "90%",
                    maxWidth: "320px"
                },
                children: "View StockLoyal Portfolio"
            }), _.jsx("button", {
                type: "button",
                className: "btn-primary",
                onClick: () => o("/wallet"),
                style: {
                    width: "90%",
                    maxWidth: "320px"
                },
                children: "Back to Wallet"
            })]
        })]
    })
}
/**
* @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
* For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
*/
function CK() {
    const o = {
        resolve: null,
        promise: null
    };
    return o.promise = new Promise(n => {
        o.resolve = n
    }
    ),
    o
}
/**
* @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
* For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
*/
function yK(o) {
    let n = null;
    return (...a) => (n || (n = {
        current: o(...a)
    }),
    n.current)
}
/**
* @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
* For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
*/
const eo = new Array(256).fill("").map( (o, n) => ("0" + n.toString(16)).slice(-2));
function xK() {
    const [o,n,a,c] = crypto.getRandomValues(new Uint32Array(4));
    return "e" + eo[o >> 0 & 255] + eo[o >> 8 & 255] + eo[o >> 16 & 255] + eo[o >> 24 & 255] + eo[n >> 0 & 255] + eo[n >> 8 & 255] + eo[n >> 16 & 255] + eo[n >> 24 & 255] + eo[a >> 0 & 255] + eo[a >> 8 & 255] + eo[a >> 16 & 255] + eo[a >> 24 & 255] + eo[c >> 0 & 255] + eo[c >> 8 & 255] + eo[c >> 16 & 255] + eo[c >> 24 & 255]
}
/**
* @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
* For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
*/
function EK(o, n) {
    const a = o.extraPlugins || [];
    return {
        ...o,
        extraPlugins: [...a, ...n.filter(c => !a.includes(c))]
    }
}
/**
* @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
* For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
*/
function pB(o) {
    return !!o && /^\d+\.\d+\.\d+/.test(o)
}
/**
* @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
* For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
*/
function gB(o) {
    return o ? ["nightly", "alpha", "internal", "nightly-", "staging"].some(n => o.includes(n)) : !1
}
function SK(o) {
    return pB(o) || gB(o)
}
/**
* @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
* For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
*/
function DK(o) {
    if (!pB(o))
        throw new Error(`Invalid semantic version: ${o || "<blank>"}.`);
    const [n,a,c] = o.split(".");
    return {
        major: Number.parseInt(n, 10),
        minor: Number.parseInt(a, 10),
        patch: Number.parseInt(c, 10)
    }
}
/**
* @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
* For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
*/
function TK(o) {
    if (gB(o))
        return 3;
    const {major: n} = DK(o);
    switch (!0) {
    case n >= 44:
        return 3;
    case n >= 38:
        return 2;
    default:
        return 1
    }
}
/**
* @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
* For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
*/
function IK() {
    const {CKEDITOR_VERSION: o, CKEDITOR: n} = window;
    return SK(o) ? {
        source: n ? "cdn" : "npm",
        version: o
    } : null
}
/**
* @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
* For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
*/
function MK() {
    const o = IK();
    return o ? TK(o.version) : null
}
/**
* @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
* For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
*/
function fB(o, n) {
    switch (n || (n = MK() || void 0),
    n) {
    case 1:
    case 2:
        return o === void 0;
    case 3:
        return o === "GPL";
    default:
        return !1
    }
}
/**
* @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
* For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
*/
function BK(o, n) {
    return function(a) {
        fB(a.config.get("licenseKey")) || a.on("collectUsageData", (c, {setUsageData: u}) => {
            u(`integration.${o}`, n)
        }
        )
    }
}
var NK = Object.defineProperty
  , PK = (o, n, a) => n in o ? NK(o, n, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: a
}) : o[n] = a
  , bo = (o, n, a) => PK(o, typeof n != "symbol" ? n + "" : n, a);
/**
* @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
* For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
*/
const kB = class bB {
    constructor(n, a) {
        bo(this, "_lifecycle"),
        bo(this, "_element"),
        bo(this, "_releaseLock", null),
        bo(this, "_value", null),
        bo(this, "_afterMountCallbacks", []),
        bo(this, "_state", {
            destroyedBeforeInitialization: !1,
            mountingInProgress: null
        }),
        bo(this, "release", yK( () => {
            const {_releaseLock: c, _state: u, _element: p, _lifecycle: f} = this;
            u.mountingInProgress ? u.mountingInProgress.then( () => f.unmount({
                element: p,
                mountResult: this.value
            })).catch(w => {
                console.error("CKEditor unmounting error:", w)
            }
            ).then(c.resolve).then( () => {
                this._value = null
            }
            ) : (u.destroyedBeforeInitialization = !0,
            c.resolve())
        }
        )),
        this._element = n,
        this._lifecycle = a,
        this._lock()
    }
    get value() {
        return this._value
    }
    discard() {
        this._value = null,
        this._releaseLock = null,
        this._afterMountCallbacks = [],
        this._state = {
            destroyedBeforeInitialization: !1,
            mountingInProgress: null
        }
    }
    unsafeSetValue(n) {
        this._value = n,
        this._afterMountCallbacks.forEach(a => {
            this._lifecycle.isValueValid && !this._lifecycle.isValueValid(n) || a(n)
        }
        ),
        this._afterMountCallbacks = []
    }
    runAfterMount(n) {
        const {_value: a, _afterMountCallbacks: c} = this;
        if (a) {
            if (this._lifecycle.isValueValid && !this._lifecycle.isValueValid(a))
                return;
            n(a)
        } else
            c.push(n)
    }
    _lock() {
        const {_semaphores: n} = bB
          , {_state: a, _element: c, _lifecycle: u} = this
          , p = n.get(c) || Promise.resolve(null)
          , f = CK();
        this._releaseLock = f;
        const w = p.then( () => a.destroyedBeforeInitialization ? Promise.resolve(void 0) : (a.mountingInProgress = u.mount().then(k => (k && this.unsafeSetValue(k),
        k)),
        a.mountingInProgress)).then(async k => {
            k && u.afterMount && await u.afterMount({
                element: c,
                mountResult: k
            })
        }
        ).then( () => f.promise).catch(k => {
            console.error("CKEditor mounting error:", k)
        }
        ).then( () => {
            n.get(c) === w && n.delete(c)
        }
        );
        n.set(c, w)
    }
}
;
bo(kB, "_semaphores", new Map);
let jK = kB;
/**
* @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
* For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
*/
const LK = "$__CKEditorReactContextMetadata";
function zK(o, n) {
    return {
        ...n,
        [LK]: o
    }
}
/**
* @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
* For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
*/
const OK = Jn.createContext(null)
  , RK = o => !!o && typeof o == "object" && "status"in o && ["initializing", "initialized", "error"].includes(o.status)
  , wB = o => n => RK(n) && n.status === o
  , dD = wB("initializing")
  , FK = o => wB("initialized")(o) && o.watchdog.state === "ready";
/**
* @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
* For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
*/
const VK = BK("react", {
    version: "11.0.0",
    frameworkVersion: Jn.version
});
/**
* @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
* For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
*/
function UK(o) {
    return fB(o.licenseKey) ? o : EK(o, [VK])
}
/**
* @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
* For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
*/
const Lf = "Lock from React integration (@ckeditor/ckeditor5-react)";
class AB extends Jn.Component {
    constructor(n) {
        super(n),
        bo(this, "domContainer", Jn.createRef()),
        bo(this, "editorSemaphore", null),
        this._checkVersion()
    }
    _checkVersion() {
        const {CKEDITOR_VERSION: n} = window;
        if (!n)
            return console.warn('Cannot find the "CKEDITOR_VERSION" in the "window" scope.');
        const [a] = n.split(".").map(Number);
        a >= 42 || n.startsWith("0.0.0") || console.warn("The <CKEditor> component requires using CKEditor 5 in version 42+ or nightly build.")
    }
    get _semaphoreValue() {
        const {editorSemaphore: n} = this;
        return n ? n.value : null
    }
    get watchdog() {
        const {_semaphoreValue: n} = this;
        return n ? n.watchdog : null
    }
    get editor() {
        const {_semaphoreValue: n} = this;
        return n ? n.instance : null
    }
    shouldComponentUpdate(n) {
        const {props: a, editorSemaphore: c} = this;
        return n.id !== a.id || n.disableWatchdog !== a.disableWatchdog ? !0 : (c && (c.runAfterMount( ({instance: u}) => {
            this._shouldUpdateEditorData(a, n, u) && u.data.set(n.data)
        }
        ),
        "disabled"in n && c.runAfterMount( ({instance: u}) => {
            n.disabled ? u.enableReadOnlyMode(Lf) : u.disableReadOnlyMode(Lf)
        }
        )),
        !1)
    }
    componentDidMount() {
        dD(this.context) || this._initLifeCycleSemaphore()
    }
    componentDidUpdate() {
        dD(this.context) || this._initLifeCycleSemaphore()
    }
    componentWillUnmount() {
        this._unlockLifeCycleSemaphore()
    }
    _unlockLifeCycleSemaphore() {
        this.editorSemaphore && (this.editorSemaphore.release(),
        this.editorSemaphore = null)
    }
    _initLifeCycleSemaphore() {
        this._unlockLifeCycleSemaphore(),
        this.editorSemaphore = new jK(this.domContainer.current,{
            isValueValid: n => n && !!n.instance,
            mount: async () => {
                var n, a;
                try {
                    return await this._initializeEditor()
                } catch (c) {
                    throw (a = (n = this.props).onError) == null || a.call(n, c, {
                        phase: "initialization",
                        willEditorRestart: !1
                    }),
                    c
                }
            }
            ,
            afterMount: ({mountResult: n}) => {
                const {onReady: a} = this.props;
                a && this.domContainer.current !== null && a(n.instance)
            }
            ,
            unmount: async ({element: n, mountResult: a}) => {
                const {onAfterDestroy: c} = this.props;
                try {
                    await this._destroyEditor(a),
                    n.innerHTML = ""
                } finally {
                    c && c(a.instance)
                }
            }
        })
    }
    render() {
        return Jn.createElement("div", {
            ref: this.domContainer
        })
    }
    async _initializeEditor() {
        if (this.props.disableWatchdog)
            return {
                instance: await this._createEditor(this.domContainer.current, this._getConfig()),
                watchdog: null
            };
        const n = FK(this.context) ? new HK(this.context.watchdog) : new this.props.editor.EditorWatchdog(this.props.editor,this.props.watchdogConfig)
          , a = {
            current: 0
        };
        return n.setCreator(async (c, u) => {
            var p;
            const {editorSemaphore: f} = this
              , {onAfterDestroy: w} = this.props;
            a.current > 0 && w && (p = f == null ? void 0 : f.value) != null && p.instance && w(f.value.instance);
            const k = await this._createEditor(c, u);
            return f && a.current > 0 && (f.unsafeSetValue({
                instance: k,
                watchdog: n
            }),
            setTimeout( () => {
                this.props.onReady && this.props.onReady(n.editor)
            }
            )),
            a.current++,
            k
        }
        ),
        n.on("error", (c, {error: u, causesRestart: p}) => {
            (this.props.onError || console.error)(u, {
                phase: "runtime",
                willEditorRestart: p
            })
        }
        ),
        await n.create(this.domContainer.current, this._getConfig()),
        {
            watchdog: n,
            instance: n.editor
        }
    }
    _createEditor(n, a) {
        const {contextItemMetadata: c} = this.props;
        return c && (a = zK(c, a)),
        this.props.editor.create(n, UK(a)).then(u => {
            if ("disabled"in this.props) {
                /* istanbul ignore else -- @preserve */
                this.props.disabled && u.enableReadOnlyMode(Lf)
            }
            const p = u.model.document
              , f = u.editing.view.document;
            return p.on("change:data", w => {
                /* istanbul ignore else -- @preserve */
                this.props.onChange && this.props.onChange(w, u)
            }
            ),
            f.on("focus", w => {
                /* istanbul ignore else -- @preserve */
                this.props.onFocus && this.props.onFocus(w, u)
            }
            ),
            f.on("blur", w => {
                /* istanbul ignore else -- @preserve */
                this.props.onBlur && this.props.onBlur(w, u)
            }
            ),
            u
        }
        )
    }
    async _destroyEditor(n) {
        const {watchdog: a, instance: c} = n;
        return new Promise( (u, p) => {
            /* istanbul ignore next -- @preserve */
            setTimeout(async () => {
                try {
                    if (a)
                        return await a.destroy(),
                        u();
                    if (c)
                        return await c.destroy(),
                        u();
                    u()
                } catch (f) {
                    console.error(f),
                    p(f)
                }
            }
            )
        }
        )
    }
    _shouldUpdateEditorData(n, a, c) {
        return !(n.data === a.data || c.data.get() === a.data)
    }
    _getConfig() {
        const n = this.props.config || {};
        return this.props.data && n.initialData && console.warn("Editor data should be provided either using `config.initialData` or `content` property. The config value takes precedence over `content` property and will be used when both are specified."),
        {
            ...n,
            initialData: n.initialData || this.props.data || ""
        }
    }
}
bo(AB, "contextType", OK);
class HK {
    constructor(n) {
        bo(this, "_contextWatchdog"),
        bo(this, "_id"),
        bo(this, "_creator"),
        this._contextWatchdog = n,
        this._id = xK()
    }
    setCreator(n) {
        this._creator = n
    }
    create(n, a) {
        return this._contextWatchdog.add({
            sourceElementOrData: n,
            config: a,
            creator: this._creator,
            id: this._id,
            type: "editor"
        })
    }
    on(n, a) {
        this._contextWatchdog.on("itemError", (c, {itemId: u, error: p}) => {
            u === this._id && a(null, {
                error: p,
                causesRestart: void 0
            })
        }
        )
    }
    destroy() {
        return this._contextWatchdog.state === "ready" ? this._contextWatchdog.remove(this._id) : Promise.resolve()
    }
    get editor() {
        return this._contextWatchdog.getItem(this._id)
    }
}
/**
* @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
* For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
*/
function vB(...o) {
    return n => {
        o.forEach(a => {
            typeof a == "function" ? a(n) : a != null && (a.current = n)
        }
        )
    }
}
const WK = R.memo(R.forwardRef( ({id: o, semaphore: n, rootName: a}, c) => {
    const u = R.useRef(null);
    return R.useEffect( () => {
        let p, f;
        return n.runAfterMount( ({instance: w}) => {
            if (!u.current)
                return;
            f = w;
            const {ui: k, model: y} = f
              , E = y.document.getRoot(a);
            E && f.ui.getEditableElement(a) && f.detachEditable(E),
            p = k.view.createEditable(a, u.current),
            k.addEditable(p),
            w.editing.view.forceRender()
        }
        ),
        () => {
            /* istanbul ignore next -- @preserve: It depends on the version of the React and may not happen all of the times. */
            if (f && f.state !== "destroyed" && u.current) {
                const w = f.model.document.getRoot(a);
                /* istanbul ignore else -- @preserve */
                w && f.detachEditable(w)
            }
        }
    }
    , [n.revision]),
    Jn.createElement("div", {
        key: n.revision,
        id: o,
        ref: vB(c, u)
    })
}
));
WK.displayName = "EditorEditable";
const $K = R.forwardRef( ({editor: o}, n) => {
    const a = R.useRef(null);
    return R.useEffect( () => {
        const c = a.current;
        if (!o || !c)
            return;
        const u = o.ui.view.toolbar.element;
        return c.appendChild(u),
        () => {
            c.contains(u) && c.removeChild(u)
        }
    }
    , [o && o.id]),
    Jn.createElement("div", {
        ref: vB(a, n)
    })
}
);
$K.displayName = "EditorToolbarWrapper";
var tm = {
    exports: {}
};
tm.exports;
(function(o, n) {
    (function(a) {
        const c = a.en = a.en || {};
        c.dictionary = Object.assign(c.dictionary || {}, {
            "(may require <kbd>Fn</kbd>)": "(may require <kbd>Fn</kbd>)",
            "%0 of %1": "%0 of %1",
            Accept: "Accept",
            Accessibility: "Accessibility",
            "Accessibility help": "Accessibility help",
            "Align cell text to the bottom": "Align cell text to the bottom",
            "Align cell text to the center": "Align cell text to the center",
            "Align cell text to the left": "Align cell text to the left",
            "Align cell text to the middle": "Align cell text to the middle",
            "Align cell text to the right": "Align cell text to the right",
            "Align cell text to the top": "Align cell text to the top",
            "Align table to the left": "Align table to the left",
            "Align table to the right": "Align table to the right",
            Alignment: "Alignment",
            Aquamarine: "Aquamarine",
            Background: "Background",
            "Below, you can find a list of keyboard shortcuts that can be used in the editor.": "Below, you can find a list of keyboard shortcuts that can be used in the editor.",
            Black: "Black",
            "Block quote": "Block quote",
            Blue: "Blue",
            Bold: "Bold",
            "Bold text": "Bold text",
            Border: "Border",
            "Break text": "Break text",
            "Bulleted List": "Bulleted List",
            "Bulleted list styles toolbar": "Bulleted list styles toolbar",
            Cancel: "Cancel",
            "Cannot access default workspace.": "Cannot access default workspace.",
            "Cannot determine a category for the uploaded file.": "Cannot determine a category for the uploaded file.",
            "Cannot upload file:": "Cannot upload file:",
            "Caption for image: %0": "Caption for image: %0",
            "Caption for the image": "Caption for the image",
            "Cell properties": "Cell properties",
            "Center table": "Center table",
            "Centered image": "Centered image",
            "Change image text alternative": "Change image text alternative",
            "Choose heading": "Choose heading",
            Circle: "Circle",
            Clear: "Clear",
            "Click to edit block": "Click to edit block",
            Close: "Close",
            "Close contextual balloons, dropdowns, and dialogs": "Close contextual balloons, dropdowns, and dialogs",
            Code: "Code",
            Color: "Color",
            "Color picker": "Color picker",
            Column: "Column",
            "Content editing keystrokes": "Content editing keystrokes",
            "Copy selected content": "Copy selected content",
            "Could not insert image at the current position.": "Could not insert image at the current position.",
            "Could not obtain resized image URL.": "Could not obtain resized image URL.",
            "Create link": "Create link",
            Custom: "Custom",
            "Custom image size": "Custom image size",
            Dashed: "Dashed",
            Decimal: "Decimal",
            "Decimal with leading zero": "Decimal with leading zero",
            "Decrease indent": "Decrease indent",
            "Decrease list item indent": "Decrease list item indent",
            "Delete column": "Delete column",
            "Delete row": "Delete row",
            "Dim grey": "Dim grey",
            Dimensions: "Dimensions",
            Disc: "Disc",
            Dotted: "Dotted",
            Double: "Double",
            Downloadable: "Downloadable",
            "Drag to move": "Drag to move",
            "Dropdown toolbar": "Dropdown toolbar",
            "Edit block": "Edit block",
            "Edit image": "Edit image",
            "Edit link": "Edit link",
            "Editor block content toolbar": "Editor block content toolbar",
            "Editor contextual toolbar": "Editor contextual toolbar",
            "Editor dialog": "Editor dialog",
            "Editor editing area: %0": "Editor editing area: %0",
            "Editor menu bar": "Editor menu bar",
            "Editor toolbar": "Editor toolbar",
            "Enter image caption": "Enter image caption",
            "Enter table caption": "Enter table caption",
            "Entering a to-do list": "Entering a to-do list",
            "Error during image upload": "Error during image upload",
            "Execute the currently focused button. Executing buttons that interact with the editor content moves the focus back to the content.": "Execute the currently focused button. Executing buttons that interact with the editor content moves the focus back to the content.",
            "Failed to determine category of edited image.": "Failed to determine category of edited image.",
            File: "File",
            "From computer": "From computer",
            "Full size image": "Full size image",
            Green: "Green",
            Grey: "Grey",
            Groove: "Groove",
            "Header column": "Header column",
            "Header row": "Header row",
            Heading: "Heading",
            "Heading 1": "Heading 1",
            "Heading 2": "Heading 2",
            "Heading 3": "Heading 3",
            "Heading 4": "Heading 4",
            "Heading 5": "Heading 5",
            "Heading 6": "Heading 6",
            Height: "Height",
            "Help Contents. To close this dialog press ESC.": "Help Contents. To close this dialog press ESC.",
            HEX: "HEX",
            "Horizontal text alignment toolbar": "Horizontal text alignment toolbar",
            Image: "Image",
            "Image from computer": "Image from computer",
            "Image resize list": "Image resize list",
            "Image toolbar": "Image toolbar",
            "Image upload complete": "Image upload complete",
            "Image via URL": "Image via URL",
            "image widget": "image widget",
            "In line": "In line",
            "Increase indent": "Increase indent",
            "Increase list item indent": "Increase list item indent",
            "Insert a hard break (a new paragraph)": "Insert a hard break (a new paragraph)",
            "Insert a new paragraph directly after a widget": "Insert a new paragraph directly after a widget",
            "Insert a new paragraph directly before a widget": "Insert a new paragraph directly before a widget",
            "Insert a new table row (when in the last cell of a table)": "Insert a new table row (when in the last cell of a table)",
            "Insert a soft break (a <code>&lt;br&gt;</code> element)": "Insert a soft break (a <code>&lt;br&gt;</code> element)",
            "Insert column left": "Insert column left",
            "Insert column right": "Insert column right",
            "Insert image": "Insert image",
            "Insert image or file": "Insert image or file",
            "Insert image via URL": "Insert image via URL",
            "Insert image with file manager": "Insert image with file manager",
            "Insert media": "Insert media",
            "Insert paragraph after block": "Insert paragraph after block",
            "Insert paragraph before block": "Insert paragraph before block",
            "Insert row above": "Insert row above",
            "Insert row below": "Insert row below",
            "Insert table": "Insert table",
            "Insert via URL": "Insert via URL",
            "Insert with file manager": "Insert with file manager",
            "Inserting image failed": "Inserting image failed",
            Inset: "Inset",
            "Invalid start index value.": "Invalid start index value.",
            Italic: "Italic",
            "Italic text": "Italic text",
            "Justify cell text": "Justify cell text",
            "Keystrokes that can be used in a list": "Keystrokes that can be used in a list",
            "Keystrokes that can be used in a table cell": "Keystrokes that can be used in a table cell",
            "Keystrokes that can be used when a widget is selected (for example: image, table, etc.)": "Keystrokes that can be used when a widget is selected (for example: image, table, etc.)",
            "Leaving a to-do list": "Leaving a to-do list",
            "Left aligned image": "Left aligned image",
            "Light blue": "Light blue",
            "Light green": "Light green",
            "Light grey": "Light grey",
            Link: "Link",
            "Link image": "Link image",
            "Link URL": "Link URL",
            "Link URL must not be empty.": "Link URL must not be empty.",
            "List properties": "List properties",
            "Lower-latin": "Lower-latin",
            "Lower–roman": "Lower–roman",
            Media: "Media",
            "Media toolbar": "Media toolbar",
            "Media URL": "Media URL",
            "media widget": "media widget",
            MENU_BAR_MENU_EDIT: "Edit",
            MENU_BAR_MENU_FILE: "File",
            MENU_BAR_MENU_FONT: "Font",
            MENU_BAR_MENU_FORMAT: "Format",
            MENU_BAR_MENU_HELP: "Help",
            MENU_BAR_MENU_INSERT: "Insert",
            MENU_BAR_MENU_TEXT: "Text",
            MENU_BAR_MENU_TOOLS: "Tools",
            MENU_BAR_MENU_VIEW: "View",
            "Merge cell down": "Merge cell down",
            "Merge cell left": "Merge cell left",
            "Merge cell right": "Merge cell right",
            "Merge cell up": "Merge cell up",
            "Merge cells": "Merge cells",
            "Move focus between form fields (inputs, buttons, etc.)": "Move focus between form fields (inputs, buttons, etc.)",
            "Move focus from an editable area back to the parent widget": "Move focus from an editable area back to the parent widget",
            "Move focus in and out of an active dialog window": "Move focus in and out of an active dialog window",
            "Move focus to the menu bar, navigate between menu bars": "Move focus to the menu bar, navigate between menu bars",
            "Move focus to the toolbar, navigate between toolbars": "Move focus to the toolbar, navigate between toolbars",
            "Move out of a link": "Move out of a link",
            "Move out of an inline code style": "Move out of an inline code style",
            "Move the caret to allow typing directly after a widget": "Move the caret to allow typing directly after a widget",
            "Move the caret to allow typing directly before a widget": "Move the caret to allow typing directly before a widget",
            "Move the selection to the next cell": "Move the selection to the next cell",
            "Move the selection to the previous cell": "Move the selection to the previous cell",
            "Navigate through the table": "Navigate through the table",
            "Navigate through the toolbar or menu bar": "Navigate through the toolbar or menu bar",
            Next: "Next",
            "No results found": "No results found",
            "No searchable items": "No searchable items",
            None: "None",
            "Numbered List": "Numbered List",
            "Numbered list styles toolbar": "Numbered list styles toolbar",
            "Open file manager": "Open file manager",
            "Open in a new tab": "Open in a new tab",
            "Open link in new tab": "Open link in new tab",
            "Open media in new tab": "Open media in new tab",
            "Open the accessibility help dialog": "Open the accessibility help dialog",
            Orange: "Orange",
            Original: "Original",
            Outset: "Outset",
            Padding: "Padding",
            Paragraph: "Paragraph",
            "Paste content": "Paste content",
            "Paste content as plain text": "Paste content as plain text",
            "Paste the media URL in the input.": "Paste the media URL in the input.",
            'Please enter a valid color (e.g. "ff0000").': 'Please enter a valid color (e.g. "ff0000").',
            "Press %0 for help.": "Press %0 for help.",
            "Press Enter to type after or press Shift + Enter to type before the widget": "Press Enter to type after or press Shift + Enter to type before the widget",
            Previous: "Previous",
            "Processing the edited image.": "Processing the edited image.",
            Purple: "Purple",
            Red: "Red",
            Redo: "Redo",
            "Remove color": "Remove color",
            "Replace from computer": "Replace from computer",
            "Replace image": "Replace image",
            "Replace image from computer": "Replace image from computer",
            "Replace image with file manager": "Replace image with file manager",
            "Replace with file manager": "Replace with file manager",
            "Resize image": "Resize image",
            "Resize image (in %0)": "Resize image (in %0)",
            "Resize image to %0": "Resize image to %0",
            "Resize image to the original size": "Resize image to the original size",
            "Restore default": "Restore default",
            "Reversed order": "Reversed order",
            "Revert autoformatting action": "Revert autoformatting action",
            "Rich Text Editor": "Rich Text Editor",
            Ridge: "Ridge",
            "Right aligned image": "Right aligned image",
            Row: "Row",
            Save: "Save",
            "Select all": "Select all",
            "Select column": "Select column",
            "Select row": "Select row",
            "Selecting resized image failed": "Selecting resized image failed",
            "Server failed to process the image.": "Server failed to process the image.",
            "Show more items": "Show more items",
            "Side image": "Side image",
            Solid: "Solid",
            "Split cell horizontally": "Split cell horizontally",
            "Split cell vertically": "Split cell vertically",
            Square: "Square",
            "Start at": "Start at",
            "Start index must be greater than 0.": "Start index must be greater than 0.",
            Strikethrough: "Strikethrough",
            "Strikethrough text": "Strikethrough text",
            Style: "Style",
            Subscript: "Subscript",
            Superscript: "Superscript",
            Table: "Table",
            "Table alignment toolbar": "Table alignment toolbar",
            "Table cell text alignment": "Table cell text alignment",
            "Table properties": "Table properties",
            "Table toolbar": "Table toolbar",
            "Text alternative": "Text alternative",
            'The color is invalid. Try "#FF0000" or "rgb(255,0,0)" or "red".': 'The color is invalid. Try "#FF0000" or "rgb(255,0,0)" or "red".',
            "The URL must not be empty.": "The URL must not be empty.",
            'The value is invalid. Try "10px" or "2em" or simply "2".': 'The value is invalid. Try "10px" or "2em" or simply "2".',
            "The value must not be empty.": "The value must not be empty.",
            "The value should be a plain number.": "The value should be a plain number.",
            "These keyboard shortcuts allow for quick access to content editing features.": "These keyboard shortcuts allow for quick access to content editing features.",
            "This link has no URL": "This link has no URL",
            "This media URL is not supported.": "This media URL is not supported.",
            "Tip: Paste the URL into the content to embed faster.": "Tip: Paste the URL into the content to embed faster.",
            "To-do List": "To-do List",
            "Toggle caption off": "Toggle caption off",
            "Toggle caption on": "Toggle caption on",
            "Toggle the circle list style": "Toggle the circle list style",
            "Toggle the decimal list style": "Toggle the decimal list style",
            "Toggle the decimal with leading zero list style": "Toggle the decimal with leading zero list style",
            "Toggle the disc list style": "Toggle the disc list style",
            "Toggle the lower–latin list style": "Toggle the lower–latin list style",
            "Toggle the lower–roman list style": "Toggle the lower–roman list style",
            "Toggle the square list style": "Toggle the square list style",
            "Toggle the upper–latin list style": "Toggle the upper–latin list style",
            "Toggle the upper–roman list style": "Toggle the upper–roman list style",
            Turquoise: "Turquoise",
            "Type or paste your content here.": "Type or paste your content here.",
            "Type your title": "Type your title",
            Underline: "Underline",
            "Underline text": "Underline text",
            Undo: "Undo",
            Unlink: "Unlink",
            "Update image URL": "Update image URL",
            "Upload failed": "Upload failed",
            "Upload from computer": "Upload from computer",
            "Upload image from computer": "Upload image from computer",
            "Upload in progress": "Upload in progress",
            "Uploading image": "Uploading image",
            "Upper-latin": "Upper-latin",
            "Upper-roman": "Upper-roman",
            "Use the following keystrokes for more efficient navigation in the CKEditor 5 user interface.": "Use the following keystrokes for more efficient navigation in the CKEditor 5 user interface.",
            "User interface and content navigation keystrokes": "User interface and content navigation keystrokes",
            "Vertical text alignment toolbar": "Vertical text alignment toolbar",
            "Via URL": "Via URL",
            White: "White",
            "Widget toolbar": "Widget toolbar",
            Width: "Width",
            "With file manager": "With file manager",
            "Wrap text": "Wrap text",
            Yellow: "Yellow"
        })
    }
    )(window.CKEDITOR_TRANSLATIONS || (window.CKEDITOR_TRANSLATIONS = {})),
    function(a, c) {
        o.exports = c()
    }(self, () => ( () => {
        var a = {
            9246: (f, w, k) => {
                const y = k(6931)
                  , E = {};
                for (const A of Object.keys(y))
                    E[y[A]] = A;
                const S = {
                    rgb: {
                        channels: 3,
                        labels: "rgb"
                    },
                    hsl: {
                        channels: 3,
                        labels: "hsl"
                    },
                    hsv: {
                        channels: 3,
                        labels: "hsv"
                    },
                    hwb: {
                        channels: 3,
                        labels: "hwb"
                    },
                    cmyk: {
                        channels: 4,
                        labels: "cmyk"
                    },
                    xyz: {
                        channels: 3,
                        labels: "xyz"
                    },
                    lab: {
                        channels: 3,
                        labels: "lab"
                    },
                    lch: {
                        channels: 3,
                        labels: "lch"
                    },
                    hex: {
                        channels: 1,
                        labels: ["hex"]
                    },
                    keyword: {
                        channels: 1,
                        labels: ["keyword"]
                    },
                    ansi16: {
                        channels: 1,
                        labels: ["ansi16"]
                    },
                    ansi256: {
                        channels: 1,
                        labels: ["ansi256"]
                    },
                    hcg: {
                        channels: 3,
                        labels: ["h", "c", "g"]
                    },
                    apple: {
                        channels: 3,
                        labels: ["r16", "g16", "b16"]
                    },
                    gray: {
                        channels: 1,
                        labels: ["gray"]
                    }
                };
                f.exports = S;
                for (const A of Object.keys(S)) {
                    if (!("channels"in S[A]))
                        throw new Error("missing channels property: " + A);
                    if (!("labels"in S[A]))
                        throw new Error("missing channel labels property: " + A);
                    if (S[A].labels.length !== S[A].channels)
                        throw new Error("channel and label counts mismatch: " + A);
                    const {channels: D, labels: N} = S[A];
                    delete S[A].channels,
                    delete S[A].labels,
                    Object.defineProperty(S[A], "channels", {
                        value: D
                    }),
                    Object.defineProperty(S[A], "labels", {
                        value: N
                    })
                }
                S.rgb.hsl = function(A) {
                    const D = A[0] / 255
                      , N = A[1] / 255
                      , L = A[2] / 255
                      , z = Math.min(D, N, L)
                      , B = Math.max(D, N, L)
                      , M = B - z;
                    let j, V;
                    B === z ? j = 0 : D === B ? j = (N - L) / M : N === B ? j = 2 + (L - D) / M : L === B && (j = 4 + (D - N) / M),
                    j = Math.min(60 * j, 360),
                    j < 0 && (j += 360);
                    const G = (z + B) / 2;
                    return V = B === z ? 0 : G <= .5 ? M / (B + z) : M / (2 - B - z),
                    [j, 100 * V, 100 * G]
                }
                ,
                S.rgb.hsv = function(A) {
                    let D, N, L, z, B;
                    const M = A[0] / 255
                      , j = A[1] / 255
                      , V = A[2] / 255
                      , G = Math.max(M, j, V)
                      , Y = G - Math.min(M, j, V)
                      , $ = function(K) {
                        return (G - K) / 6 / Y + .5
                    };
                    return Y === 0 ? (z = 0,
                    B = 0) : (B = Y / G,
                    D = $(M),
                    N = $(j),
                    L = $(V),
                    M === G ? z = L - N : j === G ? z = .3333333333333333 + D - L : V === G && (z = .6666666666666666 + N - D),
                    z < 0 ? z += 1 : z > 1 && (z -= 1)),
                    [360 * z, 100 * B, 100 * G]
                }
                ,
                S.rgb.hwb = function(A) {
                    const D = A[0]
                      , N = A[1];
                    let L = A[2];
                    const z = S.rgb.hsl(A)[0]
                      , B = 1 / 255 * Math.min(D, Math.min(N, L));
                    return L = 1 - .00392156862745098 * Math.max(D, Math.max(N, L)),
                    [z, 100 * B, 100 * L]
                }
                ,
                S.rgb.cmyk = function(A) {
                    const D = A[0] / 255
                      , N = A[1] / 255
                      , L = A[2] / 255
                      , z = Math.min(1 - D, 1 - N, 1 - L);
                    return [100 * ((1 - D - z) / (1 - z) || 0), 100 * ((1 - N - z) / (1 - z) || 0), 100 * ((1 - L - z) / (1 - z) || 0), 100 * z]
                }
                ,
                S.rgb.keyword = function(A) {
                    const D = E[A];
                    if (D)
                        return D;
                    let N, L = 1 / 0;
                    for (const M of Object.keys(y)) {
                        const j = y[M]
                          , V = (B = j,
                        ((z = A)[0] - B[0]) ** 2 + (z[1] - B[1]) ** 2 + (z[2] - B[2]) ** 2);
                        V < L && (L = V,
                        N = M)
                    }
                    var z, B;
                    return N
                }
                ,
                S.keyword.rgb = function(A) {
                    return y[A]
                }
                ,
                S.rgb.xyz = function(A) {
                    let D = A[0] / 255
                      , N = A[1] / 255
                      , L = A[2] / 255;
                    return D = D > .04045 ? ((D + .055) / 1.055) ** 2.4 : D / 12.92,
                    N = N > .04045 ? ((N + .055) / 1.055) ** 2.4 : N / 12.92,
                    L = L > .04045 ? ((L + .055) / 1.055) ** 2.4 : L / 12.92,
                    [100 * (.4124 * D + .3576 * N + .1805 * L), 100 * (.2126 * D + .7152 * N + .0722 * L), 100 * (.0193 * D + .1192 * N + .9505 * L)]
                }
                ,
                S.rgb.lab = function(A) {
                    const D = S.rgb.xyz(A);
                    let N = D[0]
                      , L = D[1]
                      , z = D[2];
                    return N /= 95.047,
                    L /= 100,
                    z /= 108.883,
                    N = N > .008856 ? N ** .3333333333333333 : 7.787 * N + .13793103448275862,
                    L = L > .008856 ? L ** .3333333333333333 : 7.787 * L + .13793103448275862,
                    z = z > .008856 ? z ** .3333333333333333 : 7.787 * z + .13793103448275862,
                    [116 * L - 16, 500 * (N - L), 200 * (L - z)]
                }
                ,
                S.hsl.rgb = function(A) {
                    const D = A[0] / 360
                      , N = A[1] / 100
                      , L = A[2] / 100;
                    let z, B, M;
                    if (N === 0)
                        return M = 255 * L,
                        [M, M, M];
                    z = L < .5 ? L * (1 + N) : L + N - L * N;
                    const j = 2 * L - z
                      , V = [0, 0, 0];
                    for (let G = 0; G < 3; G++)
                        B = D + .3333333333333333 * -(G - 1),
                        B < 0 && B++,
                        B > 1 && B--,
                        M = 6 * B < 1 ? j + 6 * (z - j) * B : 2 * B < 1 ? z : 3 * B < 2 ? j + (z - j) * (.6666666666666666 - B) * 6 : j,
                        V[G] = 255 * M;
                    return V
                }
                ,
                S.hsl.hsv = function(A) {
                    const D = A[0];
                    let N = A[1] / 100
                      , L = A[2] / 100
                      , z = N;
                    const B = Math.max(L, .01);
                    return L *= 2,
                    N *= L <= 1 ? L : 2 - L,
                    z *= B <= 1 ? B : 2 - B,
                    [D, 100 * (L === 0 ? 2 * z / (B + z) : 2 * N / (L + N)), 100 * ((L + N) / 2)]
                }
                ,
                S.hsv.rgb = function(A) {
                    const D = A[0] / 60
                      , N = A[1] / 100;
                    let L = A[2] / 100;
                    const z = Math.floor(D) % 6
                      , B = D - Math.floor(D)
                      , M = 255 * L * (1 - N)
                      , j = 255 * L * (1 - N * B)
                      , V = 255 * L * (1 - N * (1 - B));
                    switch (L *= 255,
                    z) {
                    case 0:
                        return [L, V, M];
                    case 1:
                        return [j, L, M];
                    case 2:
                        return [M, L, V];
                    case 3:
                        return [M, j, L];
                    case 4:
                        return [V, M, L];
                    case 5:
                        return [L, M, j]
                    }
                }
                ,
                S.hsv.hsl = function(A) {
                    const D = A[0]
                      , N = A[1] / 100
                      , L = A[2] / 100
                      , z = Math.max(L, .01);
                    let B, M;
                    M = (2 - N) * L;
                    const j = (2 - N) * z;
                    return B = N * z,
                    B /= j <= 1 ? j : 2 - j,
                    B = B || 0,
                    M /= 2,
                    [D, 100 * B, 100 * M]
                }
                ,
                S.hwb.rgb = function(A) {
                    const D = A[0] / 360;
                    let N = A[1] / 100
                      , L = A[2] / 100;
                    const z = N + L;
                    let B;
                    z > 1 && (N /= z,
                    L /= z);
                    const M = Math.floor(6 * D)
                      , j = 1 - L;
                    B = 6 * D - M,
                    1 & M && (B = 1 - B);
                    const V = N + B * (j - N);
                    let G, Y, $;
                    switch (M) {
                    default:
                    case 6:
                    case 0:
                        G = j,
                        Y = V,
                        $ = N;
                        break;
                    case 1:
                        G = V,
                        Y = j,
                        $ = N;
                        break;
                    case 2:
                        G = N,
                        Y = j,
                        $ = V;
                        break;
                    case 3:
                        G = N,
                        Y = V,
                        $ = j;
                        break;
                    case 4:
                        G = V,
                        Y = N,
                        $ = j;
                        break;
                    case 5:
                        G = j,
                        Y = N,
                        $ = V
                    }
                    return [255 * G, 255 * Y, 255 * $]
                }
                ,
                S.cmyk.rgb = function(A) {
                    const D = A[0] / 100
                      , N = A[1] / 100
                      , L = A[2] / 100
                      , z = A[3] / 100;
                    return [255 * (1 - Math.min(1, D * (1 - z) + z)), 255 * (1 - Math.min(1, N * (1 - z) + z)), 255 * (1 - Math.min(1, L * (1 - z) + z))]
                }
                ,
                S.xyz.rgb = function(A) {
                    const D = A[0] / 100
                      , N = A[1] / 100
                      , L = A[2] / 100;
                    let z, B, M;
                    return z = 3.2406 * D + -1.5372 * N + -.4986 * L,
                    B = -.9689 * D + 1.8758 * N + .0415 * L,
                    M = .0557 * D + -.204 * N + 1.057 * L,
                    z = z > .0031308 ? 1.055 * z ** .4166666666666667 - .055 : 12.92 * z,
                    B = B > .0031308 ? 1.055 * B ** .4166666666666667 - .055 : 12.92 * B,
                    M = M > .0031308 ? 1.055 * M ** .4166666666666667 - .055 : 12.92 * M,
                    z = Math.min(Math.max(0, z), 1),
                    B = Math.min(Math.max(0, B), 1),
                    M = Math.min(Math.max(0, M), 1),
                    [255 * z, 255 * B, 255 * M]
                }
                ,
                S.xyz.lab = function(A) {
                    let D = A[0]
                      , N = A[1]
                      , L = A[2];
                    return D /= 95.047,
                    N /= 100,
                    L /= 108.883,
                    D = D > .008856 ? D ** .3333333333333333 : 7.787 * D + .13793103448275862,
                    N = N > .008856 ? N ** .3333333333333333 : 7.787 * N + .13793103448275862,
                    L = L > .008856 ? L ** .3333333333333333 : 7.787 * L + .13793103448275862,
                    [116 * N - 16, 500 * (D - N), 200 * (N - L)]
                }
                ,
                S.lab.xyz = function(A) {
                    let D, N, L;
                    N = (A[0] + 16) / 116,
                    D = A[1] / 500 + N,
                    L = N - A[2] / 200;
                    const z = N ** 3
                      , B = D ** 3
                      , M = L ** 3;
                    return N = z > .008856 ? z : (N - .13793103448275862) / 7.787,
                    D = B > .008856 ? B : (D - .13793103448275862) / 7.787,
                    L = M > .008856 ? M : (L - .13793103448275862) / 7.787,
                    D *= 95.047,
                    N *= 100,
                    L *= 108.883,
                    [D, N, L]
                }
                ,
                S.lab.lch = function(A) {
                    const D = A[0]
                      , N = A[1]
                      , L = A[2];
                    let z;
                    return z = 360 * Math.atan2(L, N) / 2 / Math.PI,
                    z < 0 && (z += 360),
                    [D, Math.sqrt(N * N + L * L), z]
                }
                ,
                S.lch.lab = function(A) {
                    const D = A[0]
                      , N = A[1]
                      , L = A[2] / 360 * 2 * Math.PI;
                    return [D, N * Math.cos(L), N * Math.sin(L)]
                }
                ,
                S.rgb.ansi16 = function(A, D=null) {
                    const [N,L,z] = A;
                    let B = D === null ? S.rgb.hsv(A)[2] : D;
                    if (B = Math.round(B / 50),
                    B === 0)
                        return 30;
                    let M = 30 + (Math.round(z / 255) << 2 | Math.round(L / 255) << 1 | Math.round(N / 255));
                    return B === 2 && (M += 60),
                    M
                }
                ,
                S.hsv.ansi16 = function(A) {
                    return S.rgb.ansi16(S.hsv.rgb(A), A[2])
                }
                ,
                S.rgb.ansi256 = function(A) {
                    const D = A[0]
                      , N = A[1]
                      , L = A[2];
                    return D === N && N === L ? D < 8 ? 16 : D > 248 ? 231 : Math.round((D - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(D / 255 * 5) + 6 * Math.round(N / 255 * 5) + Math.round(L / 255 * 5)
                }
                ,
                S.ansi16.rgb = function(A) {
                    let D = A % 10;
                    if (D === 0 || D === 7)
                        return A > 50 && (D += 3.5),
                        D = D / 10.5 * 255,
                        [D, D, D];
                    const N = .5 * (1 + ~~(A > 50));
                    return [(1 & D) * N * 255, (D >> 1 & 1) * N * 255, (D >> 2 & 1) * N * 255]
                }
                ,
                S.ansi256.rgb = function(A) {
                    if (A >= 232) {
                        const N = 10 * (A - 232) + 8;
                        return [N, N, N]
                    }
                    let D;
                    return A -= 16,
                    [Math.floor(A / 36) / 5 * 255, Math.floor((D = A % 36) / 6) / 5 * 255, D % 6 / 5 * 255]
                }
                ,
                S.rgb.hex = function(A) {
                    const D = (((255 & Math.round(A[0])) << 16) + ((255 & Math.round(A[1])) << 8) + (255 & Math.round(A[2]))).toString(16).toUpperCase();
                    return "000000".substring(D.length) + D
                }
                ,
                S.hex.rgb = function(A) {
                    const D = A.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
                    if (!D)
                        return [0, 0, 0];
                    let N = D[0];
                    D[0].length === 3 && (N = N.split("").map(z => z + z).join(""));
                    const L = parseInt(N, 16);
                    return [L >> 16 & 255, L >> 8 & 255, 255 & L]
                }
                ,
                S.rgb.hcg = function(A) {
                    const D = A[0] / 255
                      , N = A[1] / 255
                      , L = A[2] / 255
                      , z = Math.max(Math.max(D, N), L)
                      , B = Math.min(Math.min(D, N), L)
                      , M = z - B;
                    let j, V;
                    return j = M < 1 ? B / (1 - M) : 0,
                    V = M <= 0 ? 0 : z === D ? (N - L) / M % 6 : z === N ? 2 + (L - D) / M : 4 + (D - N) / M,
                    V /= 6,
                    V %= 1,
                    [360 * V, 100 * M, 100 * j]
                }
                ,
                S.hsl.hcg = function(A) {
                    const D = A[1] / 100
                      , N = A[2] / 100
                      , L = N < .5 ? 2 * D * N : 2 * D * (1 - N);
                    let z = 0;
                    return L < 1 && (z = (N - .5 * L) / (1 - L)),
                    [A[0], 100 * L, 100 * z]
                }
                ,
                S.hsv.hcg = function(A) {
                    const D = A[1] / 100
                      , N = A[2] / 100
                      , L = D * N;
                    let z = 0;
                    return L < 1 && (z = (N - L) / (1 - L)),
                    [A[0], 100 * L, 100 * z]
                }
                ,
                S.hcg.rgb = function(A) {
                    const D = A[0] / 360
                      , N = A[1] / 100
                      , L = A[2] / 100;
                    if (N === 0)
                        return [255 * L, 255 * L, 255 * L];
                    const z = [0, 0, 0]
                      , B = D % 1 * 6
                      , M = B % 1
                      , j = 1 - M;
                    let V = 0;
                    switch (Math.floor(B)) {
                    case 0:
                        z[0] = 1,
                        z[1] = M,
                        z[2] = 0;
                        break;
                    case 1:
                        z[0] = j,
                        z[1] = 1,
                        z[2] = 0;
                        break;
                    case 2:
                        z[0] = 0,
                        z[1] = 1,
                        z[2] = M;
                        break;
                    case 3:
                        z[0] = 0,
                        z[1] = j,
                        z[2] = 1;
                        break;
                    case 4:
                        z[0] = M,
                        z[1] = 0,
                        z[2] = 1;
                        break;
                    default:
                        z[0] = 1,
                        z[1] = 0,
                        z[2] = j
                    }
                    return V = (1 - N) * L,
                    [255 * (N * z[0] + V), 255 * (N * z[1] + V), 255 * (N * z[2] + V)]
                }
                ,
                S.hcg.hsv = function(A) {
                    const D = A[1] / 100
                      , N = D + A[2] / 100 * (1 - D);
                    let L = 0;
                    return N > 0 && (L = D / N),
                    [A[0], 100 * L, 100 * N]
                }
                ,
                S.hcg.hsl = function(A) {
                    const D = A[1] / 100
                      , N = A[2] / 100 * (1 - D) + .5 * D;
                    let L = 0;
                    return N > 0 && N < .5 ? L = D / (2 * N) : N >= .5 && N < 1 && (L = D / (2 * (1 - N))),
                    [A[0], 100 * L, 100 * N]
                }
                ,
                S.hcg.hwb = function(A) {
                    const D = A[1] / 100
                      , N = D + A[2] / 100 * (1 - D);
                    return [A[0], 100 * (N - D), 100 * (1 - N)]
                }
                ,
                S.hwb.hcg = function(A) {
                    const D = A[1] / 100
                      , N = 1 - A[2] / 100
                      , L = N - D;
                    let z = 0;
                    return L < 1 && (z = (N - L) / (1 - L)),
                    [A[0], 100 * L, 100 * z]
                }
                ,
                S.apple.rgb = function(A) {
                    return [A[0] / 65535 * 255, A[1] / 65535 * 255, A[2] / 65535 * 255]
                }
                ,
                S.rgb.apple = function(A) {
                    return [A[0] / 255 * 65535, A[1] / 255 * 65535, A[2] / 255 * 65535]
                }
                ,
                S.gray.rgb = function(A) {
                    return [A[0] / 100 * 255, A[0] / 100 * 255, A[0] / 100 * 255]
                }
                ,
                S.gray.hsl = function(A) {
                    return [0, 0, A[0]]
                }
                ,
                S.gray.hsv = S.gray.hsl,
                S.gray.hwb = function(A) {
                    return [0, 100, A[0]]
                }
                ,
                S.gray.cmyk = function(A) {
                    return [0, 0, 0, A[0]]
                }
                ,
                S.gray.lab = function(A) {
                    return [A[0], 0, 0]
                }
                ,
                S.gray.hex = function(A) {
                    const D = 255 & Math.round(A[0] / 100 * 255)
                      , N = ((D << 16) + (D << 8) + D).toString(16).toUpperCase();
                    return "000000".substring(N.length) + N
                }
                ,
                S.rgb.gray = function(A) {
                    return [(A[0] + A[1] + A[2]) / 3 / 255 * 100]
                }
            }
            ,
            9047: (f, w, k) => {
                const y = k(9246)
                  , E = k(802)
                  , S = {};
                Object.keys(y).forEach(A => {
                    S[A] = {},
                    Object.defineProperty(S[A], "channels", {
                        value: y[A].channels
                    }),
                    Object.defineProperty(S[A], "labels", {
                        value: y[A].labels
                    });
                    const D = E(A);
                    Object.keys(D).forEach(N => {
                        const L = D[N];
                        S[A][N] = function(z) {
                            const B = function(...M) {
                                const j = M[0];
                                if (j == null)
                                    return j;
                                j.length > 1 && (M = j);
                                const V = z(M);
                                if (typeof V == "object")
                                    for (let G = V.length, Y = 0; Y < G; Y++)
                                        V[Y] = Math.round(V[Y]);
                                return V
                            };
                            return "conversion"in z && (B.conversion = z.conversion),
                            B
                        }(L),
                        S[A][N].raw = function(z) {
                            const B = function(...M) {
                                const j = M[0];
                                return j == null ? j : (j.length > 1 && (M = j),
                                z(M))
                            };
                            return "conversion"in z && (B.conversion = z.conversion),
                            B
                        }(L)
                    }
                    )
                }
                ),
                f.exports = S
            }
            ,
            802: (f, w, k) => {
                const y = k(9246);
                function E(D) {
                    const N = function() {
                        const z = {}
                          , B = Object.keys(y);
                        for (let M = B.length, j = 0; j < M; j++)
                            z[B[j]] = {
                                distance: -1,
                                parent: null
                            };
                        return z
                    }()
                      , L = [D];
                    for (N[D].distance = 0; L.length; ) {
                        const z = L.pop()
                          , B = Object.keys(y[z]);
                        for (let M = B.length, j = 0; j < M; j++) {
                            const V = B[j]
                              , G = N[V];
                            G.distance === -1 && (G.distance = N[z].distance + 1,
                            G.parent = z,
                            L.unshift(V))
                        }
                    }
                    return N
                }
                function S(D, N) {
                    return function(L) {
                        return N(D(L))
                    }
                }
                function A(D, N) {
                    const L = [N[D].parent, D];
                    let z = y[N[D].parent][D]
                      , B = N[D].parent;
                    for (; N[B].parent; )
                        L.unshift(N[B].parent),
                        z = S(y[N[B].parent][B], z),
                        B = N[B].parent;
                    return z.conversion = L,
                    z
                }
                f.exports = function(D) {
                    const N = E(D)
                      , L = {}
                      , z = Object.keys(N);
                    for (let B = z.length, M = 0; M < B; M++) {
                        const j = z[M];
                        N[j].parent !== null && (L[j] = A(j, N))
                    }
                    return L
                }
            }
            ,
            6931: f => {
                f.exports = {
                    aliceblue: [240, 248, 255],
                    antiquewhite: [250, 235, 215],
                    aqua: [0, 255, 255],
                    aquamarine: [127, 255, 212],
                    azure: [240, 255, 255],
                    beige: [245, 245, 220],
                    bisque: [255, 228, 196],
                    black: [0, 0, 0],
                    blanchedalmond: [255, 235, 205],
                    blue: [0, 0, 255],
                    blueviolet: [138, 43, 226],
                    brown: [165, 42, 42],
                    burlywood: [222, 184, 135],
                    cadetblue: [95, 158, 160],
                    chartreuse: [127, 255, 0],
                    chocolate: [210, 105, 30],
                    coral: [255, 127, 80],
                    cornflowerblue: [100, 149, 237],
                    cornsilk: [255, 248, 220],
                    crimson: [220, 20, 60],
                    cyan: [0, 255, 255],
                    darkblue: [0, 0, 139],
                    darkcyan: [0, 139, 139],
                    darkgoldenrod: [184, 134, 11],
                    darkgray: [169, 169, 169],
                    darkgreen: [0, 100, 0],
                    darkgrey: [169, 169, 169],
                    darkkhaki: [189, 183, 107],
                    darkmagenta: [139, 0, 139],
                    darkolivegreen: [85, 107, 47],
                    darkorange: [255, 140, 0],
                    darkorchid: [153, 50, 204],
                    darkred: [139, 0, 0],
                    darksalmon: [233, 150, 122],
                    darkseagreen: [143, 188, 143],
                    darkslateblue: [72, 61, 139],
                    darkslategray: [47, 79, 79],
                    darkslategrey: [47, 79, 79],
                    darkturquoise: [0, 206, 209],
                    darkviolet: [148, 0, 211],
                    deeppink: [255, 20, 147],
                    deepskyblue: [0, 191, 255],
                    dimgray: [105, 105, 105],
                    dimgrey: [105, 105, 105],
                    dodgerblue: [30, 144, 255],
                    firebrick: [178, 34, 34],
                    floralwhite: [255, 250, 240],
                    forestgreen: [34, 139, 34],
                    fuchsia: [255, 0, 255],
                    gainsboro: [220, 220, 220],
                    ghostwhite: [248, 248, 255],
                    gold: [255, 215, 0],
                    goldenrod: [218, 165, 32],
                    gray: [128, 128, 128],
                    green: [0, 128, 0],
                    greenyellow: [173, 255, 47],
                    grey: [128, 128, 128],
                    honeydew: [240, 255, 240],
                    hotpink: [255, 105, 180],
                    indianred: [205, 92, 92],
                    indigo: [75, 0, 130],
                    ivory: [255, 255, 240],
                    khaki: [240, 230, 140],
                    lavender: [230, 230, 250],
                    lavenderblush: [255, 240, 245],
                    lawngreen: [124, 252, 0],
                    lemonchiffon: [255, 250, 205],
                    lightblue: [173, 216, 230],
                    lightcoral: [240, 128, 128],
                    lightcyan: [224, 255, 255],
                    lightgoldenrodyellow: [250, 250, 210],
                    lightgray: [211, 211, 211],
                    lightgreen: [144, 238, 144],
                    lightgrey: [211, 211, 211],
                    lightpink: [255, 182, 193],
                    lightsalmon: [255, 160, 122],
                    lightseagreen: [32, 178, 170],
                    lightskyblue: [135, 206, 250],
                    lightslategray: [119, 136, 153],
                    lightslategrey: [119, 136, 153],
                    lightsteelblue: [176, 196, 222],
                    lightyellow: [255, 255, 224],
                    lime: [0, 255, 0],
                    limegreen: [50, 205, 50],
                    linen: [250, 240, 230],
                    magenta: [255, 0, 255],
                    maroon: [128, 0, 0],
                    mediumaquamarine: [102, 205, 170],
                    mediumblue: [0, 0, 205],
                    mediumorchid: [186, 85, 211],
                    mediumpurple: [147, 112, 219],
                    mediumseagreen: [60, 179, 113],
                    mediumslateblue: [123, 104, 238],
                    mediumspringgreen: [0, 250, 154],
                    mediumturquoise: [72, 209, 204],
                    mediumvioletred: [199, 21, 133],
                    midnightblue: [25, 25, 112],
                    mintcream: [245, 255, 250],
                    mistyrose: [255, 228, 225],
                    moccasin: [255, 228, 181],
                    navajowhite: [255, 222, 173],
                    navy: [0, 0, 128],
                    oldlace: [253, 245, 230],
                    olive: [128, 128, 0],
                    olivedrab: [107, 142, 35],
                    orange: [255, 165, 0],
                    orangered: [255, 69, 0],
                    orchid: [218, 112, 214],
                    palegoldenrod: [238, 232, 170],
                    palegreen: [152, 251, 152],
                    paleturquoise: [175, 238, 238],
                    palevioletred: [219, 112, 147],
                    papayawhip: [255, 239, 213],
                    peachpuff: [255, 218, 185],
                    peru: [205, 133, 63],
                    pink: [255, 192, 203],
                    plum: [221, 160, 221],
                    powderblue: [176, 224, 230],
                    purple: [128, 0, 128],
                    rebeccapurple: [102, 51, 153],
                    red: [255, 0, 0],
                    rosybrown: [188, 143, 143],
                    royalblue: [65, 105, 225],
                    saddlebrown: [139, 69, 19],
                    salmon: [250, 128, 114],
                    sandybrown: [244, 164, 96],
                    seagreen: [46, 139, 87],
                    seashell: [255, 245, 238],
                    sienna: [160, 82, 45],
                    silver: [192, 192, 192],
                    skyblue: [135, 206, 235],
                    slateblue: [106, 90, 205],
                    slategray: [112, 128, 144],
                    slategrey: [112, 128, 144],
                    snow: [255, 250, 250],
                    springgreen: [0, 255, 127],
                    steelblue: [70, 130, 180],
                    tan: [210, 180, 140],
                    teal: [0, 128, 128],
                    thistle: [216, 191, 216],
                    tomato: [255, 99, 71],
                    turquoise: [64, 224, 208],
                    violet: [238, 130, 238],
                    wheat: [245, 222, 179],
                    white: [255, 255, 255],
                    whitesmoke: [245, 245, 245],
                    yellow: [255, 255, 0],
                    yellowgreen: [154, 205, 50]
                }
            }
            ,
            4199: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck-content code{background-color:hsla(0,0%,78%,.3);border-radius:2px;padding:.15em}.ck.ck-editor__editable .ck-code_selected{background-color:hsla(0,0%,78%,.5)}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-basic-styles/theme/code.css"],
                    names: [],
                    mappings: "AAKA,iBACC,kCAAuC,CAEvC,iBAAkB,CADlB,aAED,CAEA,0CACC,kCACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck-content code {
	background-color: hsla(0, 0%, 78%, 0.3);
	padding: .15em;
	border-radius: 2px;
}

.ck.ck-editor__editable .ck-code_selected  {
	background-color: hsla(0, 0%, 78%, 0.5);
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            8708: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck-content blockquote{border-left:5px solid #ccc;font-style:italic;margin-left:0;margin-right:0;overflow:hidden;padding-left:1.5em;padding-right:1.5em}.ck-content[dir=rtl] blockquote{border-left:0;border-right:5px solid #ccc}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-block-quote/theme/blockquote.css"],
                    names: [],
                    mappings: "AAKA,uBAWC,0BAAsC,CADtC,iBAAkB,CAFlB,aAAc,CACd,cAAe,CAPf,eAAgB,CAIhB,kBAAmB,CADnB,mBAOD,CAEA,gCACC,aAAc,CACd,2BACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck-content blockquote {
	/* See #12 */
	overflow: hidden;

	/* https://github.com/ckeditor/ckeditor5-block-quote/issues/15 */
	padding-right: 1.5em;
	padding-left: 1.5em;

	margin-left: 0;
	margin-right: 0;
	font-style: italic;
	border-left: solid 5px hsl(0, 0%, 80%);
}

.ck-content[dir="rtl"] blockquote {
	border-left: 0;
	border-right: solid 5px hsl(0, 0%, 80%);
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            1866: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ':root{--ck-image-processing-highlight-color:#f9fafa;--ck-image-processing-background-color:#e3e5e8}.ck.ck-editor__editable .image.image-processing{position:relative}.ck.ck-editor__editable .image.image-processing:before{animation:ck-image-processing-animation 2s linear infinite;background:linear-gradient(90deg,var(--ck-image-processing-background-color),var(--ck-image-processing-highlight-color),var(--ck-image-processing-background-color));background-size:200% 100%;content:"";height:100%;left:0;position:absolute;top:0;width:100%;z-index:1}.ck.ck-editor__editable .image.image-processing img{height:100%}@keyframes ck-image-processing-animation{0%{background-position:200% 0}to{background-position:-200% 0}}', "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ckbox/theme/ckboximageedit.css"],
                    names: [],
                    mappings: "AAKA,MAEC,6CAAyD,CACzD,8CACD,CAIE,gDACC,iBA2BD,CAzBC,uDAmBC,0DAA2D,CAR3D,oKAKC,CACD,yBAA0B,CAhB1B,UAAW,CAOX,WAAY,CAHZ,MAAO,CAFP,iBAAkB,CAClB,KAAM,CAKN,UAAW,CAHX,SAcD,CAEA,oDACC,WACD,CAKH,yCACC,GACC,0BACD,CACA,GACC,2BACD,CACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	/* Based on default CKBox theme colors */
	--ck-image-processing-highlight-color: hsl(220, 10%, 98%);
	--ck-image-processing-background-color: hsl(220, 10%, 90%);
}

.ck.ck-editor__editable {
	& .image {
		&.image-processing {
			position: relative;

			&:before {
				content: '';

				position: absolute;
				top: 0;
				left: 0;
				z-index: 1;

				height: 100%;
				width: 100%;

				background: linear-gradient(
					90deg,
					var(--ck-image-processing-background-color),
					var(--ck-image-processing-highlight-color),
					var(--ck-image-processing-background-color)
				);
				background-size: 200% 100%;

				animation: ck-image-processing-animation 2s linear infinite;
			}

			& img {
				height: 100%;
			}
		}
	}
}

@keyframes ck-image-processing-animation {
	0% {
		background-position: 200% 0;
	}
	100% {
		background-position: -200% 0;
	}
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            7793: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, '.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position{display:inline;pointer-events:none;position:relative}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span{position:absolute;width:0}.ck.ck-editor__editable .ck-widget:-webkit-drag>.ck-widget__selection-handle,.ck.ck-editor__editable .ck-widget:-webkit-drag>.ck-widget__type-around{display:none}.ck.ck-clipboard-drop-target-line{pointer-events:none;position:absolute}:root{--ck-clipboard-drop-target-dot-width:12px;--ck-clipboard-drop-target-dot-height:8px;--ck-clipboard-drop-target-color:var(--ck-color-focus-border)}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span{background:var(--ck-clipboard-drop-target-color);border:1px solid var(--ck-clipboard-drop-target-color);bottom:calc(var(--ck-clipboard-drop-target-dot-height)*-.5);margin-left:-1px;top:calc(var(--ck-clipboard-drop-target-dot-height)*-.5)}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span:after{border-color:var(--ck-clipboard-drop-target-color) transparent transparent transparent;border-style:solid;border-width:calc(var(--ck-clipboard-drop-target-dot-height)) calc(var(--ck-clipboard-drop-target-dot-width)*.5) 0 calc(var(--ck-clipboard-drop-target-dot-width)*.5);content:"";display:block;height:0;left:50%;position:absolute;top:calc(var(--ck-clipboard-drop-target-dot-height)*-.5);transform:translateX(-50%);width:0}.ck.ck-editor__editable .ck-widget.ck-clipboard-drop-target-range{outline:var(--ck-widget-outline-thickness) solid var(--ck-clipboard-drop-target-color)!important}.ck.ck-editor__editable .ck-widget:-webkit-drag{zoom:.6;outline:none!important}.ck.ck-clipboard-drop-target-line{background:var(--ck-clipboard-drop-target-color);border:1px solid var(--ck-clipboard-drop-target-color);height:0;margin-top:-1px}.ck.ck-clipboard-drop-target-line:before{border-style:solid;content:"";height:0;position:absolute;top:calc(var(--ck-clipboard-drop-target-dot-width)*-.5);width:0}[dir=ltr] .ck.ck-clipboard-drop-target-line:before{border-color:transparent transparent transparent var(--ck-clipboard-drop-target-color);border-width:calc(var(--ck-clipboard-drop-target-dot-width)*.5) 0 calc(var(--ck-clipboard-drop-target-dot-width)*.5) var(--ck-clipboard-drop-target-dot-height);left:-1px}[dir=rtl] .ck.ck-clipboard-drop-target-line:before{border-color:transparent var(--ck-clipboard-drop-target-color) transparent transparent;border-width:calc(var(--ck-clipboard-drop-target-dot-width)*.5) var(--ck-clipboard-drop-target-dot-height) calc(var(--ck-clipboard-drop-target-dot-width)*.5) 0;right:-1px}', "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-clipboard/theme/clipboard.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-clipboard/clipboard.css"],
                    names: [],
                    mappings: "AASC,8DACC,cAAe,CAEf,mBAAoB,CADpB,iBAOD,CAJC,mEACC,iBAAkB,CAClB,OACD,CAWA,qJACC,YACD,CAIF,kCAEC,mBAAoB,CADpB,iBAED,CC9BA,MACC,yCAA0C,CAC1C,yCAA0C,CAC1C,6DACD,CAOE,mEAIC,gDAAiD,CADjD,sDAAuD,CAFvD,2DAA8D,CAI9D,gBAAiB,CAHjB,wDAqBD,CAfC,yEAWC,sFAAuF,CAEvF,kBAAmB,CADnB,qKAA0K,CAX1K,UAAW,CAIX,aAAc,CAFd,QAAS,CAIT,QAAS,CADT,iBAAkB,CAElB,wDAA2D,CAE3D,0BAA2B,CAR3B,OAYD,CAOF,kEACC,gGACD,CAKA,gDACC,OAAS,CACT,sBACD,CAGD,kCAGC,gDAAiD,CADjD,sDAAuD,CADvD,QAAS,CAGT,eAwBD,CAtBC,yCAMC,kBAAmB,CALnB,UAAW,CAIX,QAAS,CAHT,iBAAkB,CAClB,uDAA0D,CAC1D,OAiBD,CArBA,mDAYE,sFAAuF,CADvF,+JAAoK,CAFpK,SAYF,CArBA,mDAmBE,sFAAuF,CADvF,+JAAmK,CAFnK,UAKF",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-editor__editable {
	/*
	 * Vertical drop target (in text).
	 */
	& .ck.ck-clipboard-drop-target-position {
		display: inline;
		position: relative;
		pointer-events: none;

		& span {
			position: absolute;
			width: 0;
		}
	}

	/*
	 * Styles of the widget being dragged (its preview).
	 */
	& .ck-widget:-webkit-drag {
		& > .ck-widget__selection-handle {
			display: none;
		}

		& > .ck-widget__type-around {
			display: none;
		}
	}
}

.ck.ck-clipboard-drop-target-line {
	position: absolute;
	pointer-events: none;
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

:root {
	--ck-clipboard-drop-target-dot-width: 12px;
	--ck-clipboard-drop-target-dot-height: 8px;
	--ck-clipboard-drop-target-color: var(--ck-color-focus-border);
}

.ck.ck-editor__editable {
	/*
	 * Vertical drop target (in text).
	 */
	& .ck.ck-clipboard-drop-target-position {
		& span {
			bottom: calc(-.5 * var(--ck-clipboard-drop-target-dot-height));
			top: calc(-.5 * var(--ck-clipboard-drop-target-dot-height));
			border: 1px solid var(--ck-clipboard-drop-target-color);
			background: var(--ck-clipboard-drop-target-color);
			margin-left: -1px;

			/* The triangle above the marker */
			&::after {
				content: '';
				width: 0;
				height: 0;

				display: block;
				position: absolute;
				left: 50%;
				top: calc(-.5 * var(--ck-clipboard-drop-target-dot-height));

				transform: translateX(-50%);
				border-color: var(--ck-clipboard-drop-target-color) transparent transparent transparent;
				border-width: calc(var(--ck-clipboard-drop-target-dot-height)) calc(.5 * var(--ck-clipboard-drop-target-dot-width)) 0 calc(.5 * var(--ck-clipboard-drop-target-dot-width));
				border-style: solid;
			}
		}
	}

	/*
	 * Styles of the widget that it a drop target.
	 */
	& .ck-widget.ck-clipboard-drop-target-range {
		outline: var(--ck-widget-outline-thickness) solid var(--ck-clipboard-drop-target-color) !important;
	}

	/*
	 * Styles of the widget being dragged (its preview).
	 */
	& .ck-widget:-webkit-drag {
		zoom: 0.6;
		outline: none !important;
	}
}

.ck.ck-clipboard-drop-target-line {
	height: 0;
	border: 1px solid var(--ck-clipboard-drop-target-color);
	background: var(--ck-clipboard-drop-target-color);
	margin-top: -1px;

	&::before {
		content: '';
		position: absolute;
		top: calc(-.5 * var(--ck-clipboard-drop-target-dot-width));
		width: 0;
		height: 0;
		border-style: solid;

		@mixin ck-dir ltr {
			left: -1px;

			border-width: calc(.5 * var(--ck-clipboard-drop-target-dot-width)) 0 calc(.5 * var(--ck-clipboard-drop-target-dot-width)) var(--ck-clipboard-drop-target-dot-height);
			border-color: transparent transparent transparent var(--ck-clipboard-drop-target-color);
		}

		@mixin ck-dir rtl {
			right: -1px;

			border-width:calc(.5 * var(--ck-clipboard-drop-target-dot-width)) var(--ck-clipboard-drop-target-dot-height) calc(.5 * var(--ck-clipboard-drop-target-dot-width)) 0;
			border-color: transparent var(--ck-clipboard-drop-target-color) transparent transparent;
		}
	}
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            7388: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck.ck-editor{position:relative}.ck.ck-editor .ck-editor__top .ck-sticky-panel .ck-toolbar{z-index:var(--ck-z-panel)}.ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content{border-radius:0}.ck-rounded-corners .ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content,.ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content.ck-rounded-corners{border-radius:var(--ck-border-radius);border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content{border:solid var(--ck-color-base-border);border-width:1px 1px 0}.ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content.ck-sticky-panel__content_sticky{border-bottom-width:1px}.ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content .ck-menu-bar{border:0;border-bottom:1px solid var(--ck-color-base-border)}.ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content .ck-toolbar{border:0}.ck.ck-editor__main>.ck-editor__editable{background:var(--ck-color-base-background);border-radius:0}.ck-rounded-corners .ck.ck-editor__main>.ck-editor__editable,.ck.ck-editor__main>.ck-editor__editable.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}.ck.ck-editor__main>.ck-editor__editable:not(.ck-focused){border-color:var(--ck-color-base-border)}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-editor-classic/theme/classiceditor.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-editor-classic/classiceditor.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"],
                    names: [],
                    mappings: "AAKA,cAIC,iBAMD,CAJC,2DAEC,yBACD,CCLC,8DCED,eDmBC,CArBA,mKCMA,qCAAsC,CDJpC,2BAA4B,CAC5B,4BAkBF,CArBA,8DAOC,wCAAsB,CAAtB,sBAcD,CAZC,8FACC,uBACD,CAEA,2EACC,QAAS,CACT,mDACD,CAEA,0EACC,QACD,CAMH,yCAEC,0CAA2C,CC1B3C,eDoCD,CAZA,yHCpBE,qCAAsC,CDyBtC,wBAAyB,CACzB,yBAMF,CAHC,0DACC,wCACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-editor {
	/* All the elements within \`.ck-editor\` are positioned relatively to it.
	 If any element needs to be positioned with respect to the <body>, etc.,
	 it must land outside of the \`.ck-editor\` in DOM. */
	position: relative;

	& .ck-editor__top .ck-sticky-panel .ck-toolbar {
		/* https://github.com/ckeditor/ckeditor5-editor-classic/issues/62 */
		z-index: var(--ck-z-panel);
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../mixins/_rounded.css";

.ck.ck-editor__top {
	& .ck-sticky-panel {
		& .ck-sticky-panel__content {
			@mixin ck-rounded-corners {
				border-bottom-left-radius: 0;
				border-bottom-right-radius: 0;
			}

			border: 1px solid var(--ck-color-base-border);
			border-bottom-width: 0;

			&.ck-sticky-panel__content_sticky {
				border-bottom-width: 1px;
			}

			& .ck-menu-bar {
				border: 0;
				border-bottom: 1px solid var(--ck-color-base-border);
			}

			& .ck-toolbar {
				border: 0;
			}
		}
	}
}

/* Note: Use ck-editor__main to make sure these styles don't apply to other editor types */
.ck.ck-editor__main > .ck-editor__editable {
	/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/113 */
	background: var(--ck-color-base-background);

	@mixin ck-rounded-corners {
		border-top-left-radius: 0;
		border-top-right-radius: 0;
	}

	&:not(.ck-focused) {
		border-color: var(--ck-color-base-border);
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            4098: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck .ck-placeholder,.ck.ck-placeholder{position:relative}.ck .ck-placeholder:before,.ck.ck-placeholder:before{content:attr(data-placeholder);left:0;pointer-events:none;position:absolute;right:0}.ck.ck-read-only .ck-placeholder:before{display:none}.ck.ck-reset_all .ck-placeholder{position:relative}@media (forced-colors:active){.ck .ck-placeholder,.ck.ck-placeholder{forced-color-adjust:preserve-parent-color}}.ck .ck-placeholder:before,.ck.ck-placeholder:before{cursor:text}@media (forced-colors:none){.ck .ck-placeholder:before,.ck.ck-placeholder:before{color:var(--ck-color-engine-placeholder-text)}}@media (forced-colors:active){.ck .ck-placeholder:before,.ck.ck-placeholder:before{font-style:italic;margin-left:1px}}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-engine/theme/placeholder.css", "webpack://./../ckeditor5-ui/theme/mixins/_mediacolors.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-engine/placeholder.css"],
                    names: [],
                    mappings: "AAMA,uCAEC,iBAWD,CATC,qDAIC,8BAA+B,CAF/B,MAAO,CAKP,mBAAoB,CANpB,iBAAkB,CAElB,OAKD,CAKA,wCACC,YACD,CAQD,iCACC,iBACD,CC7BC,8BACC,uCCOA,yCDLA,CACD,CCOA,qDACC,WAmBD,CDvBA,4BACC,qDCMC,6CDJD,CACD,CAZA,8BACC,qDCsBC,iBAAkB,CAMlB,eD1BD,CACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/* See ckeditor/ckeditor5#936. */
.ck.ck-placeholder,
.ck .ck-placeholder {
	position: relative;

	&::before {
		position: absolute;
		left: 0;
		right: 0;
		content: attr(data-placeholder);

		/* See ckeditor/ckeditor5#469. */
		pointer-events: none;
	}
}

/* See ckeditor/ckeditor5#1987. */
.ck.ck-read-only .ck-placeholder {
	&::before {
		display: none;
	}
}

/*
 * Rules for the \`ck-placeholder\` are loaded before the rules for \`ck-reset_all\` in the base CKEditor 5 DLL build.
 * This fix overwrites the incorrectly set \`position: static\` from \`ck-reset_all\`.
 * See https://github.com/ckeditor/ckeditor5/issues/11418.
 */
.ck.ck-reset_all .ck-placeholder {
	position: relative;
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@define-mixin ck-media-forced-colors {
	@media (forced-colors: active) {
		& {
			@mixin-content;
		}
	}
}

@define-mixin ck-media-default-colors {
	@media (forced-colors: none) {
		& {
			@mixin-content;
		}
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_mediacolors.css";

/* See ckeditor/ckeditor5#936. */
.ck.ck-placeholder, .ck .ck-placeholder {
	@mixin ck-media-forced-colors {
		/*
		 * This is needed for Edge on Windows to use the right color for the placeholder content (::before).
		 * See https://github.com/ckeditor/ckeditor5/issues/14907.
		 */
		forced-color-adjust: preserve-parent-color;
	}

	&::before {
		cursor: text;

		@mixin ck-media-default-colors {
			color: var(--ck-color-engine-placeholder-text);
		}

		@mixin ck-media-forced-colors {
			/*
			 * In the high contrast mode there is no telling between regular and placeholder text. Using
			 * italic text to address that issue. See https://github.com/ckeditor/ckeditor5/issues/14907.
			 */
			font-style: italic;

			/*
			 * Without this margin, the caret will not show up and blink when the user puts the selection
			 * in the placeholder (Edge on Windows). See https://github.com/ckeditor/ckeditor5/issues/14907.
			 */
			margin-left: 1px;
		}
	}
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            8264: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck.ck-editor__editable span[data-ck-unsafe-element]{display:none}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-engine/theme/renderer.css"],
                    names: [],
                    mappings: "AAMA,qDACC,YACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/* Elements marked by the Renderer as hidden should be invisible in the editor. */
.ck.ck-editor__editable span[data-ck-unsafe-element] {
	display: none;
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            6269: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck.ck-heading_heading1{font-size:20px}.ck.ck-heading_heading2{font-size:17px}.ck.ck-heading_heading3{font-size:14px}.ck[class*=ck-heading_heading]{font-weight:700}.ck.ck-dropdown.ck-heading-dropdown .ck-dropdown__button .ck-button__label{width:8em}.ck.ck-dropdown.ck-heading-dropdown .ck-dropdown__panel .ck-list__item{min-width:18em}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-heading/theme/heading.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-heading/heading.css"],
                    names: [],
                    mappings: "AAKA,wBACC,cACD,CAEA,wBACC,cACD,CAEA,wBACC,cACD,CAEA,+BACC,eACD,CCZC,2EACC,SACD,CAEA,uEACC,cACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-heading_heading1 {
	font-size: 20px;
}

.ck.ck-heading_heading2 {
	font-size: 17px;
}

.ck.ck-heading_heading3 {
	font-size: 14px;
}

.ck[class*="ck-heading_heading"] {
	font-weight: bold;
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/* Resize dropdown's button label. */
.ck.ck-dropdown.ck-heading-dropdown {
	& .ck-dropdown__button .ck-button__label {
		width: 8em;
	}

	& .ck-dropdown__panel .ck-list__item {
		min-width: 18em;
	}
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            265: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck-content .image{clear:both;display:table;margin:.9em auto;min-width:50px;text-align:center}.ck-content .image img{display:block;height:auto;margin:0 auto;max-width:100%;min-width:100%}.ck-content .image-inline{align-items:flex-start;display:inline-flex;max-width:100%}.ck-content .image-inline picture{display:flex}.ck-content .image-inline img,.ck-content .image-inline picture{flex-grow:1;flex-shrink:1;max-width:100%}.ck.ck-editor__editable .image>figcaption.ck-placeholder:before{overflow:hidden;padding-left:inherit;padding-right:inherit;text-overflow:ellipsis;white-space:nowrap}.ck.ck-editor__editable .image{z-index:1}.ck.ck-editor__editable .image.ck-widget_selected{z-index:2}.ck.ck-editor__editable .image-inline{z-index:1}.ck.ck-editor__editable .image-inline.ck-widget_selected{z-index:2}.ck.ck-editor__editable .image-inline.ck-widget_selected ::selection{display:none}.ck.ck-editor__editable .image-inline img{height:auto}.ck.ck-editor__editable td .image-inline img,.ck.ck-editor__editable th .image-inline img{max-width:none}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-image/theme/image.css"],
                    names: [],
                    mappings: "AAMC,mBAEC,UAAW,CADX,aAAc,CAOd,gBAAkB,CAGlB,cAAe,CARf,iBA2BD,CAjBC,uBAEC,aAAc,CAad,WAAY,CAVZ,aAAc,CAGd,cAAe,CAGf,cAKD,CAGD,0BAYC,sBAAuB,CANvB,mBAAoB,CAGpB,cAoBD,CAdC,kCACC,YACD,CAGA,gEAGC,WAAY,CACZ,aAAc,CAGd,cACD,CAUD,gEASC,eAAgB,CARhB,oBAAqB,CACrB,qBAAsB,CAQtB,sBAAuB,CAFvB,kBAGD,CAKA,+BACC,SASD,CAHC,kDACC,SACD,CAMD,sCACC,SAkBD,CAZC,yDACC,SAUD,CAHC,qEACC,YACD,CAMF,0CACC,WACD,CAMC,0FACC,cACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck-content {
	& .image {
		display: table;
		clear: both;
		text-align: center;

		/* Make sure there is some space between the content and the image. Center image by default. */
		/* The first value should be equal to --ck-spacing-large variable if used in the editor context
	 	to avoid the content jumping (See https://github.com/ckeditor/ckeditor5/issues/9825). */
		margin: 0.9em auto;

		/* Make sure the caption will be displayed properly (See: https://github.com/ckeditor/ckeditor5/issues/1870). */
		min-width: 50px;

		& img {
			/* Prevent unnecessary margins caused by line-height (see #44). */
			display: block;

			/* Center the image if its width is smaller than the content's width. */
			margin: 0 auto;

			/* Make sure the image never exceeds the size of the parent container (ckeditor/ckeditor5-ui#67). */
			max-width: 100%;

			/* Make sure the image is never smaller than the parent container (See: https://github.com/ckeditor/ckeditor5/issues/9300). */
			min-width: 100%;

			/* Keep proportions of the block image if the height is set and the image is wider than the editor width.
			See https://github.com/ckeditor/ckeditor5/issues/14542. */
			height: auto;
		}
	}

	& .image-inline {
		/*
		 * Normally, the .image-inline would have "display: inline-block" and "img { width: 100% }" (to follow the wrapper while resizing).
		 * Unfortunately, together with "srcset", it gets automatically stretched up to the width of the editing root.
		 * This strange behavior does not happen with inline-flex.
		 */
		display: inline-flex;

		/* While being resized, don't allow the image to exceed the width of the editing root. */
		max-width: 100%;

		/* This is required by Safari to resize images in a sensible way. Without this, the browser breaks the ratio. */
		align-items: flex-start;

		/* When the picture is present it must act as a flex container to let the img resize properly */
		& picture {
			display: flex;
		}

		/* When the picture is present, it must act like a resizable img. */
		& picture,
		& img {
			/* This is necessary for the img to span the entire .image-inline wrapper and to resize properly. */
			flex-grow: 1;
			flex-shrink: 1;

			/* Prevents overflowing the editing root boundaries when an inline image is very wide. */
			max-width: 100%;
		}
	}
}

.ck.ck-editor__editable {
	/*
	 * Inhertit the content styles padding of the <figcaption> in case the integration overrides \`text-align: center\`
	 * of \`.image\` (e.g. to the left/right). This ensures the placeholder stays at the padding just like the native
	 * caret does, and not at the edge of <figcaption>.
	 */
	& .image > figcaption.ck-placeholder::before {
		padding-left: inherit;
		padding-right: inherit;

		/*
		 * Make sure the image caption placeholder doesn't overflow the placeholder area.
		 * See https://github.com/ckeditor/ckeditor5/issues/9162.
		 */
		white-space: nowrap;
		overflow: hidden;
		text-overflow: ellipsis;
	}

	/*
	 * See https://github.com/ckeditor/ckeditor5/issues/15115.
	 */
	& .image {
		z-index: 1;

		/*
		 * Make sure the selected image always stays on top of its siblings.
		 * See https://github.com/ckeditor/ckeditor5/issues/9108.
		 */
		&.ck-widget_selected {
			z-index: 2;
		}
	}

	/*
	 * See https://github.com/ckeditor/ckeditor5/issues/15115.
	 */
	& .image-inline {
		z-index: 1;

		/*
		 * Make sure the selected inline image always stays on top of its siblings.
		 * See https://github.com/ckeditor/ckeditor5/issues/9108.
		 */
		&.ck-widget_selected {
			z-index: 2;

			/*
			 * Make sure the native browser selection style is not displayed.
			 * Inline image widgets have their own styles for the selected state and
			 * leaving this up to the browser is asking for a visual collision.
			 */
			& ::selection {
				display: none;
			}
		}
	}

	/* Keep proportions of the inline image if the height is set and the image is wider than the editor width.
	See https://github.com/ckeditor/ckeditor5/issues/14542. */
	& .image-inline img {
		height: auto;
	}

	/* The inline image nested in the table should have its original size if not resized.
	See https://github.com/ckeditor/ckeditor5/issues/9117. */
	& td,
	& th {
		& .image-inline img {
			max-width: none;
		}
	}
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            5247: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ":root{--ck-color-image-caption-background:#f7f7f7;--ck-color-image-caption-text:#333;--ck-color-image-caption-highlighted-background:#fd0}.ck-content .image>figcaption{background-color:var(--ck-color-image-caption-background);caption-side:bottom;color:var(--ck-color-image-caption-text);display:table-caption;font-size:.75em;outline-offset:-1px;padding:.6em;word-break:break-word}@media (forced-colors:active){.ck-content .image>figcaption{background-color:unset;color:unset}}@media (forced-colors:none){.ck.ck-editor__editable .image>figcaption.image__caption_highlighted{animation:ck-image-caption-highlight .6s ease-out}}@media (prefers-reduced-motion:reduce){.ck.ck-editor__editable .image>figcaption.image__caption_highlighted{animation:none}}@keyframes ck-image-caption-highlight{0%{background-color:var(--ck-color-image-caption-highlighted-background)}to{background-color:var(--ck-color-image-caption-background)}}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-image/theme/imagecaption.css", "webpack://./../ckeditor5-ui/theme/mixins/_mediacolors.css"],
                    names: [],
                    mappings: "AAOA,MACC,2CAAoD,CACpD,kCAA8C,CAC9C,oDACD,CAGA,8BAKC,yDAA0D,CAH1D,mBAAoB,CAEpB,wCAAyC,CAHzC,qBAAsB,CAMtB,eAAgB,CAChB,mBAAoB,CAFpB,YAAa,CAHb,qBAYD,CAJC,8BAXD,8BAYE,sBAAuB,CACvB,WAEF,CADC,CCdA,4BACC,qEDmBA,iDCjBA,CACD,CDmBA,uCALD,qEAME,cAEF,CADC,CAGD,sCACC,GACC,qEACD,CAEA,GACC,yDACD,CACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_mediacolors.css";

:root {
	--ck-color-image-caption-background: hsl(0, 0%, 97%);
	--ck-color-image-caption-text: hsl(0, 0%, 20%);
	--ck-color-image-caption-highlighted-background: hsl(52deg 100% 50%);
}

/* Content styles */
.ck-content .image > figcaption {
	display: table-caption;
	caption-side: bottom;
	word-break: break-word;
	color: var(--ck-color-image-caption-text);
	background-color: var(--ck-color-image-caption-background);
	padding: .6em;
	font-size: .75em;
	outline-offset: -1px;

	/* Improve placeholder rendering in high-constrast mode (https://github.com/ckeditor/ckeditor5/issues/14907). */
	@media (forced-colors: active) {
		background-color: unset;
		color: unset;
	}
}

/* Editing styles */
.ck.ck-editor__editable .image > figcaption.image__caption_highlighted {
	@mixin ck-media-default-colors {
		animation: ck-image-caption-highlight .6s ease-out;
	}

	@media (prefers-reduced-motion: reduce) {
		animation: none;
	}
}

@keyframes ck-image-caption-highlight {
	0% {
		background-color: var(--ck-color-image-caption-highlighted-background);
	}

	100% {
		background-color: var(--ck-color-image-caption-background);
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@define-mixin ck-media-forced-colors {
	@media (forced-colors: active) {
		& {
			@mixin-content;
		}
	}
}

@define-mixin ck-media-default-colors {
	@media (forced-colors: none) {
		& {
			@mixin-content;
		}
	}
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            4642: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck.ck-image-custom-resize-form{align-items:flex-start;display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-image-custom-resize-form .ck-labeled-field-view{display:inline-block}.ck.ck-image-custom-resize-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-image-custom-resize-form{flex-wrap:wrap}.ck.ck-image-custom-resize-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-image-custom-resize-form .ck-button{flex-basis:50%}}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-image/theme/imagecustomresizeform.css", "webpack://./../ckeditor5-ui/theme/mixins/_rwd.css"],
                    names: [],
                    mappings: "AAOA,gCAIC,sBAAuB,CAHvB,YAAa,CACb,kBAAmB,CACnB,gBAsBD,CAnBC,uDACC,oBACD,CAEA,0CACC,YACD,CCbA,oCDCD,gCAeE,cAUF,CARE,uDACC,eACD,CAEA,2CACC,cACD,CCtBD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";

.ck.ck-image-custom-resize-form {
	display: flex;
	flex-direction: row;
	flex-wrap: nowrap;
	align-items: flex-start;

	& .ck-labeled-field-view {
		display: inline-block;
	}

	& .ck-label {
		display: none;
	}

	@mixin ck-media-phone {
		flex-wrap: wrap;

		& .ck-labeled-field-view {
			flex-basis: 100%;
		}

		& .ck-button {
			flex-basis: 50%;
		}
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@define-mixin ck-media-phone {
	@media screen and (max-width: 600px) {
		@mixin-content;
	}
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            3350: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck.ck-image-insert-url{padding:var(--ck-spacing-large) var(--ck-spacing-large) 0;width:400px}.ck.ck-image-insert-url .ck-image-insert-url__action-row{display:grid;grid-template-columns:repeat(2,1fr)}:root{--ck-image-insert-insert-by-url-width:250px}.ck.ck-image-insert-url{--ck-input-width:100%}.ck.ck-image-insert-url .ck-image-insert-url__action-row{grid-column-gap:var(--ck-spacing-large);margin-top:var(--ck-spacing-large)}.ck.ck-image-insert-url .ck-image-insert-url__action-row .ck-button-cancel,.ck.ck-image-insert-url .ck-image-insert-url__action-row .ck-button-save{justify-content:center;min-width:auto}.ck.ck-image-insert-url .ck-image-insert-url__action-row .ck-button .ck-button__label{color:var(--ck-color-text)}.ck.ck-image-insert-form>.ck.ck-button{display:block;padding:var(--ck-list-button-padding);width:100%}[dir=ltr] .ck.ck-image-insert-form>.ck.ck-button{text-align:left}[dir=rtl] .ck.ck-image-insert-form>.ck.ck-button{text-align:right}.ck.ck-image-insert-form>.ck.ck-collapsible:not(:first-child){border-top:1px solid var(--ck-color-base-border)}.ck.ck-image-insert-form>.ck.ck-collapsible:not(:last-child){border-bottom:1px solid var(--ck-color-base-border)}.ck.ck-image-insert-form>.ck.ck-collapsible,.ck.ck-image-insert-form>.ck.ck-image-insert-url{min-width:var(--ck-image-insert-insert-by-url-width)}.ck.ck-image-insert-form>.ck.ck-image-insert-url{padding:var(--ck-spacing-large)}.ck.ck-image-insert-form:focus{outline:none}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-image/theme/imageinsert.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-image/imageinsert.css"],
                    names: [],
                    mappings: "AAKA,wBAEC,yDAA0D,CAD1D,WAOD,CAJC,yDACC,YAAa,CACb,mCACD,CCLD,MACC,2CACD,CAEA,wBACC,qBAgBD,CAdC,yDACC,uCAAwC,CACxC,kCAWD,CATC,oJAEC,sBAAuB,CACvB,cACD,CAEA,sFACC,0BACD,CAKD,uCACC,aAAc,CAEd,qCAAsC,CADtC,UAUD,CAZA,iDAME,eAMF,CAZA,iDAUE,gBAEF,CAGC,8DACC,gDACD,CAEA,6DACC,mDACD,CAMD,6FAJC,oDAOD,CAHA,iDAEC,+BACD,CAEA,+BACC,YACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-image-insert-url {
	width: 400px;
	padding: var(--ck-spacing-large) var(--ck-spacing-large) 0;

	& .ck-image-insert-url__action-row {
		display: grid;
		grid-template-columns: repeat(2, 1fr);
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

:root {
	--ck-image-insert-insert-by-url-width: 250px;
}

.ck.ck-image-insert-url {
	--ck-input-width: 100%;

	& .ck-image-insert-url__action-row {
		grid-column-gap: var(--ck-spacing-large);
		margin-top: var(--ck-spacing-large);

		& .ck-button-save,
		& .ck-button-cancel {
			justify-content: center;
			min-width: auto;
		}

		& .ck-button .ck-button__label {
			color: var(--ck-color-text);
		}
	}
}

.ck.ck-image-insert-form {
	& > .ck.ck-button {
		display: block;
		width: 100%;
		padding: var(--ck-list-button-padding);

		@mixin ck-dir ltr {
			text-align: left;
		}

		@mixin ck-dir rtl {
			text-align: right;
		}
	}

	& > .ck.ck-collapsible {
		&:not(:first-child) {
			border-top: 1px solid var(--ck-color-base-border);
		}

		&:not(:last-child) {
			border-bottom: 1px solid var(--ck-color-base-border);
		}

		min-width: var(--ck-image-insert-insert-by-url-width);
	}

	/* This is the case when there are no other integrations configured than insert by URL */
	& > .ck.ck-image-insert-url {
		min-width: var(--ck-image-insert-insert-by-url-width);
		padding: var(--ck-spacing-large);
	}

	&:focus {
		outline: none;
	}
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            7378: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck.ck-editor__editable img.image_placeholder{background-size:100% 100%}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-image/theme/imageplaceholder.css"],
                    names: [],
                    mappings: "AAMC,8CACC,yBACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-editor__editable {
	& img.image_placeholder {
		background-size: 100% 100%;
	}
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            3469: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck-content img.image_resized{height:auto}.ck-content .image.image_resized{box-sizing:border-box;display:block;max-width:100%}.ck-content .image.image_resized img{width:100%}.ck-content .image.image_resized>figcaption{display:block}.ck.ck-editor__editable td .image-inline.image_resized img,.ck.ck-editor__editable th .image-inline.image_resized img{max-width:100%}[dir=ltr] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon{margin-right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon{margin-left:var(--ck-spacing-standard)}.ck.ck-dropdown .ck-button.ck-resize-image-button .ck-button__label{width:4em}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-image/theme/imageresize.css"],
                    names: [],
                    mappings: "AAMA,8BACC,WACD,CAEA,iCAQC,qBAAsB,CADtB,aAAc,CANd,cAkBD,CATC,qCAEC,UACD,CAEA,4CAEC,aACD,CAQC,sHACC,cACD,CAIF,oFACC,uCACD,CAEA,oFACC,sCACD,CAEA,oEACC,SACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/* Preserve aspect ratio of the resized image after introducing image height attribute. */
.ck-content img.image_resized {
	height: auto;
}

.ck-content .image.image_resized {
	max-width: 100%;
	/*
	The \`<figure>\` element for resized images must not use \`display:table\` as browsers do not support \`max-width\` for it well.
	See https://stackoverflow.com/questions/4019604/chrome-safari-ignoring-max-width-in-table/14420691#14420691 for more.
	Fortunately, since we control the width, there is no risk that the image will look bad.
	*/
	display: block;
	box-sizing: border-box;

	& img {
		/* For resized images it is the \`<figure>\` element that determines the image width. */
		width: 100%;
	}

	& > figcaption {
		/* The \`<figure>\` element uses \`display:block\`, so \`<figcaption>\` also has to. */
		display: block;
	}
}

.ck.ck-editor__editable {
	/* The resized inline image nested in the table should respect its parent size.
	See https://github.com/ckeditor/ckeditor5/issues/9117. */
	& td,
	& th {
		& .image-inline.image_resized img {
			max-width: 100%;
		}
	}
}

[dir="ltr"] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon {
	margin-right: var(--ck-spacing-standard);
}

[dir="rtl"] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon {
	margin-left: var(--ck-spacing-standard);
}

.ck.ck-dropdown .ck-button.ck-resize-image-button .ck-button__label {
	width: 4em;
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            6386: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ":root{--ck-image-style-spacing:1.5em;--ck-inline-image-style-spacing:calc(var(--ck-image-style-spacing)/2)}.ck-content .image.image-style-block-align-left,.ck-content .image.image-style-block-align-right{max-width:calc(100% - var(--ck-image-style-spacing))}.ck-content .image.image-style-align-left,.ck-content .image.image-style-align-right{clear:none}.ck-content .image.image-style-side{float:right;margin-left:var(--ck-image-style-spacing);max-width:50%}.ck-content .image.image-style-align-left{float:left;margin-right:var(--ck-image-style-spacing)}.ck-content .image.image-style-align-right{float:right;margin-left:var(--ck-image-style-spacing)}.ck-content .image.image-style-block-align-right{margin-left:auto;margin-right:0}.ck-content .image.image-style-block-align-left{margin-left:0;margin-right:auto}.ck-content .image-style-align-center{margin-left:auto;margin-right:auto}.ck-content .image-style-align-left{float:left;margin-right:var(--ck-image-style-spacing)}.ck-content .image-style-align-right{float:right;margin-left:var(--ck-image-style-spacing)}.ck-content p+.image.image-style-align-left,.ck-content p+.image.image-style-align-right,.ck-content p+.image.image-style-side{margin-top:0}.ck-content .image-inline.image-style-align-left,.ck-content .image-inline.image-style-align-right{margin-bottom:var(--ck-inline-image-style-spacing);margin-top:var(--ck-inline-image-style-spacing)}.ck-content .image-inline.image-style-align-left{margin-right:var(--ck-inline-image-style-spacing)}.ck-content .image-inline.image-style-align-right{margin-left:var(--ck-inline-image-style-spacing)}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover){background-color:var(--ck-color-button-on-background)}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__action:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover):after,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__action:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover):after{display:none}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover){background-color:var(--ck-color-button-on-hover-background)}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-image/theme/imagestyle.css"],
                    names: [],
                    mappings: "AAKA,MACC,8BAA+B,CAC/B,qEACD,CAQE,iGAEC,oDACD,CAIA,qFAEC,UACD,CAEA,oCACC,WAAY,CACZ,yCAA0C,CAC1C,aACD,CAEA,0CACC,UAAW,CACX,0CACD,CAEA,2CACC,WAAY,CACZ,yCACD,CAEA,iDAEC,gBAAiB,CADjB,cAED,CAEA,gDACC,aAAc,CACd,iBACD,CAGD,sCACC,gBAAiB,CACjB,iBACD,CAEA,oCACC,UAAW,CACX,0CACD,CAEA,qCACC,WAAY,CACZ,yCACD,CAGA,+HAGC,YACD,CAGC,mGAGC,kDAAmD,CADnD,+CAED,CAEA,iDACC,iDACD,CAEA,kDACC,gDACD,CAUC,0lBAGC,qDAKD,CAHC,8nBACC,YACD,CAKD,oVAGC,2DACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-image-style-spacing: 1.5em;
	--ck-inline-image-style-spacing: calc(var(--ck-image-style-spacing) / 2);
}

.ck-content {
	/* See: https://github.com/ckeditor/ckeditor5/issues/16317 */
	& .image {
		/* Provides a minimal side margin for the left and right aligned images, so that the user has a visual feedback
		confirming successful application of the style if image width exceeds the editor's size.
		See https://github.com/ckeditor/ckeditor5/issues/9342 */
		&.image-style-block-align-left,
		&.image-style-block-align-right {
			max-width: calc(100% - var(--ck-image-style-spacing));
		}

		/* Allows displaying multiple floating images in the same line.
		See https://github.com/ckeditor/ckeditor5/issues/9183#issuecomment-804988132 */
		&.image-style-align-left,
		&.image-style-align-right {
			clear: none;
		}

		&.image-style-side {
			float: right;
			margin-left: var(--ck-image-style-spacing);
			max-width: 50%;
		}

		&.image-style-align-left {
			float: left;
			margin-right: var(--ck-image-style-spacing);
		}

		&.image-style-align-right {
			float: right;
			margin-left: var(--ck-image-style-spacing);
		}

		&.image-style-block-align-right {
			margin-right: 0;
			margin-left: auto;
		}

		&.image-style-block-align-left {
			margin-left: 0;
			margin-right: auto;
		}
	}

	& .image-style-align-center {
		margin-left: auto;
		margin-right: auto;
	}

	& .image-style-align-left {
		float: left;
		margin-right: var(--ck-image-style-spacing);
	}

	& .image-style-align-right {
		float: right;
		margin-left: var(--ck-image-style-spacing);
	}

	/* Simulates margin collapsing with the preceding paragraph, which does not work for the floating elements. */
	& p + .image.image-style-align-left,
	& p + .image.image-style-align-right,
	& p + .image.image-style-side {
		margin-top: 0;
	}

	& .image-inline {
		&.image-style-align-left,
		&.image-style-align-right {
			margin-top: var(--ck-inline-image-style-spacing);
			margin-bottom: var(--ck-inline-image-style-spacing);
		}

		&.image-style-align-left {
			margin-right: var(--ck-inline-image-style-spacing);
		}

		&.image-style-align-right {
			margin-left: var(--ck-inline-image-style-spacing);
		}
	}
}

.ck.ck-splitbutton {
	/* The button should display as a regular drop-down if the action button
	is forced to fire the same action as the arrow button. */
	&.ck-splitbutton_flatten {
		&:hover,
		&.ck-splitbutton_open {
			& > .ck-splitbutton__action:not(.ck-disabled),
			& > .ck-splitbutton__arrow:not(.ck-disabled),
			& > .ck-splitbutton__arrow:not(.ck-disabled):not(:hover) {
				background-color: var(--ck-color-button-on-background);

				&::after {
					display: none;
				}
			}
		}

		&.ck-splitbutton_open:hover {
			& > .ck-splitbutton__action:not(.ck-disabled),
			& > .ck-splitbutton__arrow:not(.ck-disabled),
			& > .ck-splitbutton__arrow:not(.ck-disabled):not(:hover) {
				background-color: var(--ck-color-button-on-hover-background);
			}
		}
	}
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            7693: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, '.ck-image-upload-complete-icon{border-radius:50%;display:block;position:absolute;right:min(var(--ck-spacing-medium),6%);top:min(var(--ck-spacing-medium),6%);z-index:1}.ck-image-upload-complete-icon:after{content:"";position:absolute}:root{--ck-color-image-upload-icon:#fff;--ck-color-image-upload-icon-background:#008a00;--ck-image-upload-icon-size:20;--ck-image-upload-icon-width:2px;--ck-image-upload-icon-is-visible:clamp(0px,100% - 50px,1px)}.ck-image-upload-complete-icon{animation-delay:0ms,3s;animation-duration:.5s,.5s;animation-fill-mode:forwards,forwards;animation-name:ck-upload-complete-icon-show,ck-upload-complete-icon-hide;background:var(--ck-color-image-upload-icon-background);font-size:calc(1px*var(--ck-image-upload-icon-size));height:calc(var(--ck-image-upload-icon-is-visible)*var(--ck-image-upload-icon-size));opacity:0;overflow:hidden;width:calc(var(--ck-image-upload-icon-is-visible)*var(--ck-image-upload-icon-size))}.ck-image-upload-complete-icon:after{animation-delay:.5s;animation-duration:.5s;animation-fill-mode:forwards;animation-name:ck-upload-complete-icon-check;border-right:var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);border-top:var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);box-sizing:border-box;height:0;left:25%;opacity:0;top:50%;transform:scaleX(-1) rotate(135deg);transform-origin:left top;width:0}@media (prefers-reduced-motion:reduce){.ck-image-upload-complete-icon{animation-duration:0ms}.ck-image-upload-complete-icon:after{animation:none;height:.45em;opacity:1;width:.3em}}@keyframes ck-upload-complete-icon-show{0%{opacity:0}to{opacity:1}}@keyframes ck-upload-complete-icon-hide{0%{opacity:1}to{opacity:0}}@keyframes ck-upload-complete-icon-check{0%{height:0;opacity:1;width:0}33%{height:0;width:.3em}to{height:.45em;opacity:1;width:.3em}}', "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-image/theme/imageuploadicon.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadicon.css"],
                    names: [],
                    mappings: "AAKA,+BAUC,iBAAkB,CATlB,aAAc,CACd,iBAAkB,CAOlB,sCAAwC,CADxC,oCAAsC,CAGtC,SAMD,CAJC,qCACC,UAAW,CACX,iBACD,CChBD,MACC,iCAA8C,CAC9C,+CAA4D,CAG5D,8BAA+B,CAC/B,gCAAiC,CACjC,4DACD,CAEA,+BAWC,sBAA4B,CAN5B,0BAAgC,CADhC,qCAAuC,CADvC,wEAA0E,CAD1E,uDAAwD,CAMxD,oDAAuD,CAWvD,oFAAuF,CAlBvF,SAAU,CAgBV,eAAgB,CAChB,mFAqCD,CAjCC,qCAgBC,mBAAsB,CADtB,sBAAyB,CAEzB,4BAA6B,CAH7B,4CAA6C,CAF7C,sFAAuF,CADvF,oFAAqF,CASrF,qBAAsB,CAdtB,QAAS,CAJT,QAAS,CAGT,SAAU,CADV,OAAQ,CAKR,mCAAoC,CACpC,yBAA0B,CAH1B,OAcD,CAEA,uCA7CD,+BA8CE,sBASF,CAPE,qCACC,cAAe,CAGf,YAAc,CAFd,SAAU,CACV,UAED,CACD,CAGD,wCACC,GACC,SACD,CAEA,GACC,SACD,CACD,CAEA,wCACC,GACC,SACD,CAEA,GACC,SACD,CACD,CAEA,yCACC,GAGC,QAAS,CAFT,SAAU,CACV,OAED,CACA,IAEC,QAAS,CADT,UAED,CACA,GAGC,YAAc,CAFd,SAAU,CACV,UAED,CACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck-image-upload-complete-icon {
	display: block;
	position: absolute;

	/*
	 * Smaller images should have the icon closer to the border.
	 * Match the icon position with the linked image indicator brought by the link image feature.
	 */
	top: min(var(--ck-spacing-medium), 6%);
	right: min(var(--ck-spacing-medium), 6%);
	border-radius: 50%;
	z-index: 1;

	&::after {
		content: "";
		position: absolute;
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-color-image-upload-icon: hsl(0, 0%, 100%);
	--ck-color-image-upload-icon-background: hsl(120, 100%, 27%);

	/* Match the icon size with the linked image indicator brought by the link image feature. */
	--ck-image-upload-icon-size: 20;
	--ck-image-upload-icon-width: 2px;
	--ck-image-upload-icon-is-visible: clamp(0px, 100% - 50px, 1px);
}

.ck-image-upload-complete-icon {
	opacity: 0;
	background: var(--ck-color-image-upload-icon-background);
	animation-name: ck-upload-complete-icon-show, ck-upload-complete-icon-hide;
	animation-fill-mode: forwards, forwards;
	animation-duration: 500ms, 500ms;

	/* To make animation scalable. */
	font-size: calc(1px * var(--ck-image-upload-icon-size));

	/* Hide completed upload icon after 3 seconds. */
	animation-delay: 0ms, 3000ms;

	/*
	 * Use CSS math to simulate container queries.
	 * https://css-tricks.com/the-raven-technique-one-step-closer-to-container-queries/#what-about-showing-and-hiding-things
	 */
	overflow: hidden;
	width: calc(var(--ck-image-upload-icon-is-visible) * var(--ck-image-upload-icon-size));
	height: calc(var(--ck-image-upload-icon-is-visible) * var(--ck-image-upload-icon-size));

	/* This is check icon element made from border-width mixed with animations. */
	&::after {
		/* Because of border transformation we need to "hard code" left position. */
		left: 25%;

		top: 50%;
		opacity: 0;
		height: 0;
		width: 0;

		transform: scaleX(-1) rotate(135deg);
		transform-origin: left top;
		border-top: var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);
		border-right: var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);

		animation-name: ck-upload-complete-icon-check;
		animation-duration: 500ms;
		animation-delay: 500ms;
		animation-fill-mode: forwards;

		/* #1095. While reset is not providing proper box-sizing for pseudoelements, we need to handle it. */
		box-sizing: border-box;
	}

	@media (prefers-reduced-motion: reduce) {
		animation-duration: 0ms;

		&::after {
			animation: none;
			opacity: 1;
			width: 0.3em;
			height: 0.45em;
		}
	}
}

@keyframes ck-upload-complete-icon-show {
	from {
		opacity: 0;
	}

	to {
		opacity: 1;
	}
}

@keyframes ck-upload-complete-icon-hide {
	from {
		opacity: 1;
	}

	to {
		opacity: 0;
	}
}

@keyframes ck-upload-complete-icon-check {
	0% {
		opacity: 1;
		width: 0;
		height: 0;
	}
	33% {
		width: 0.3em;
		height: 0;
	}
	100% {
		opacity: 1;
		width: 0.3em;
		height: 0.45em;
	}
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            1559: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, '.ck .ck-upload-placeholder-loader{align-items:center;display:flex;justify-content:center;left:0;position:absolute;top:0}.ck .ck-upload-placeholder-loader:before{content:"";position:relative}:root{--ck-color-upload-placeholder-loader:#b3b3b3;--ck-upload-placeholder-loader-size:32px;--ck-upload-placeholder-image-aspect-ratio:2.8}.ck .ck-image-upload-placeholder{margin:0;width:100%}.ck .ck-image-upload-placeholder.image-inline{width:calc(var(--ck-upload-placeholder-loader-size)*2*var(--ck-upload-placeholder-image-aspect-ratio))}.ck .ck-image-upload-placeholder img{aspect-ratio:var(--ck-upload-placeholder-image-aspect-ratio)}.ck .ck-upload-placeholder-loader{height:100%;width:100%}.ck .ck-upload-placeholder-loader:before{animation:ck-upload-placeholder-loader 1s linear infinite;border-radius:50%;border-right:2px solid transparent;border-top:3px solid var(--ck-color-upload-placeholder-loader);height:var(--ck-upload-placeholder-loader-size);width:var(--ck-upload-placeholder-loader-size)}@keyframes ck-upload-placeholder-loader{to{transform:rotate(1turn)}}', "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-image/theme/imageuploadloader.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadloader.css"],
                    names: [],
                    mappings: "AAKA,kCAGC,kBAAmB,CADnB,YAAa,CAEb,sBAAuB,CAEvB,MAAO,CALP,iBAAkB,CAIlB,KAOD,CAJC,yCACC,UAAW,CACX,iBACD,CCXD,MACC,4CAAqD,CACrD,wCAAyC,CACzC,8CACD,CAEA,iCAGC,QAAS,CADT,UAgBD,CAbC,8CACC,sGACD,CAEA,qCAOC,4DACD,CAGD,kCAEC,WAAY,CADZ,UAWD,CARC,yCAMC,yDAA0D,CAH1D,iBAAkB,CAElB,kCAAmC,CADnC,8DAA+D,CAF/D,+CAAgD,CADhD,8CAMD,CAGD,wCACC,GACC,uBACD,CACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck .ck-upload-placeholder-loader {
	position: absolute;
	display: flex;
	align-items: center;
	justify-content: center;
	top: 0;
	left: 0;

	&::before {
		content: '';
		position: relative;
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-color-upload-placeholder-loader: hsl(0, 0%, 70%);
	--ck-upload-placeholder-loader-size: 32px;
	--ck-upload-placeholder-image-aspect-ratio: 2.8;
}

.ck .ck-image-upload-placeholder {
	/* We need to control the full width of the SVG gray background. */
	width: 100%;
	margin: 0;

	&.image-inline {
		width: calc( 2 * var(--ck-upload-placeholder-loader-size) * var(--ck-upload-placeholder-image-aspect-ratio) );
	}

	& img {
		/*
		 * This is an arbitrary aspect for a 1x1 px GIF to display to the user. Not too tall, not too short.
		 * There's nothing special about this number except that it should make the image placeholder look like
		 * a real image during this short period after the upload started and before the image was read from the
		 * file system (and a rich preview was loaded).
		 */
		aspect-ratio: var(--ck-upload-placeholder-image-aspect-ratio);
	}
}

.ck .ck-upload-placeholder-loader {
	width: 100%;
	height: 100%;

	&::before {
		width: var(--ck-upload-placeholder-loader-size);
		height: var(--ck-upload-placeholder-loader-size);
		border-radius: 50%;
		border-top: 3px solid var(--ck-color-upload-placeholder-loader);
		border-right: 2px solid transparent;
		animation: ck-upload-placeholder-loader 1s linear infinite;
	}
}

@keyframes ck-upload-placeholder-loader {
	to {
		transform: rotate( 360deg );
	}
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            2267: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck.ck-editor__editable .image,.ck.ck-editor__editable .image-inline{position:relative}.ck.ck-editor__editable .image .ck-progress-bar,.ck.ck-editor__editable .image-inline .ck-progress-bar{left:0;position:absolute;top:0}.ck.ck-editor__editable .image-inline.ck-appear,.ck.ck-editor__editable .image.ck-appear{animation:fadeIn .7s}@media (prefers-reduced-motion:reduce){.ck.ck-editor__editable .image-inline.ck-appear,.ck.ck-editor__editable .image.ck-appear{animation:none;opacity:1}}.ck.ck-editor__editable .image .ck-progress-bar,.ck.ck-editor__editable .image-inline .ck-progress-bar{background:var(--ck-color-upload-bar-background);height:2px;transition:width .1s;width:0}@keyframes fadeIn{0%{opacity:0}to{opacity:1}}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-image/theme/imageuploadprogress.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadprogress.css"],
                    names: [],
                    mappings: "AAMC,qEAEC,iBACD,CAGA,uGAIC,MAAO,CAFP,iBAAkB,CAClB,KAED,CCRC,yFACC,oBAMD,CAJC,uCAHD,yFAKE,cAAe,CADf,SAGF,CADC,CAKF,uGAIC,gDAAiD,CAFjD,UAAW,CAGX,oBAAuB,CAFvB,OAGD,CAGD,kBACC,GAAO,SAAY,CACnB,GAAO,SAAY,CACpB",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-editor__editable {
	& .image,
	& .image-inline {
		position: relative;
	}

	/* Upload progress bar. */
	& .image .ck-progress-bar,
	& .image-inline .ck-progress-bar {
		position: absolute;
		top: 0;
		left: 0;
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-editor__editable {
	& .image,
	& .image-inline {
		/* Showing animation. */
		&.ck-appear {
			animation: fadeIn 700ms;

			@media (prefers-reduced-motion: reduce) {
				opacity: 1;
				animation: none;
			}
		}
	}

	/* Upload progress bar. */
	& .image .ck-progress-bar,
	& .image-inline .ck-progress-bar {
		height: 2px;
		width: 0;
		background: var(--ck-color-upload-bar-background);
		transition: width 100ms;
	}
}

@keyframes fadeIn {
	from { opacity: 0; }
	to   { opacity: 1; }
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            4062: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck.ck-text-alternative-form{display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-text-alternative-form .ck-labeled-field-view{display:inline-block}.ck.ck-text-alternative-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-text-alternative-form{flex-wrap:wrap}.ck.ck-text-alternative-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-text-alternative-form .ck-button{flex-basis:50%}}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-image/theme/textalternativeform.css", "webpack://./../ckeditor5-ui/theme/mixins/_rwd.css"],
                    names: [],
                    mappings: "AAOA,6BACC,YAAa,CACb,kBAAmB,CACnB,gBAqBD,CAnBC,oDACC,oBACD,CAEA,uCACC,YACD,CCZA,oCDCD,6BAcE,cAUF,CARE,oDACC,eACD,CAEA,wCACC,cACD,CCrBD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";

.ck.ck-text-alternative-form {
	display: flex;
	flex-direction: row;
	flex-wrap: nowrap;

	& .ck-labeled-field-view {
		display: inline-block;
	}

	& .ck-label {
		display: none;
	}

	@mixin ck-media-phone {
		flex-wrap: wrap;

		& .ck-labeled-field-view {
			flex-basis: 100%;
		}

		& .ck-button {
			flex-basis: 50%;
		}
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@define-mixin ck-media-phone {
	@media screen and (max-width: 600px) {
		@mixin-content;
	}
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            7719: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck .ck-link_selected{background:var(--ck-color-link-selected-background)}.ck .ck-link_selected span.image-inline{outline:var(--ck-widget-outline-thickness) solid var(--ck-color-link-selected-background)}.ck .ck-fake-link-selection{background:var(--ck-color-link-fake-selection)}.ck .ck-fake-link-selection_collapsed{border-right:1px solid var(--ck-color-base-text);height:100%;margin-right:-1px;outline:1px solid hsla(0,0%,100%,.5)}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-link/link.css"],
                    names: [],
                    mappings: "AAMA,sBACC,mDAMD,CAHC,wCACC,yFACD,CAOD,4BACC,8CACD,CAGA,sCAEC,gDAAiD,CADjD,WAAY,CAEZ,iBAAkB,CAClB,oCACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/* Class added to span element surrounding currently selected link. */
.ck .ck-link_selected {
	background: var(--ck-color-link-selected-background);

	/* Give linked inline images some outline to let the user know they are also part of the link. */
	& span.image-inline {
		outline: var(--ck-widget-outline-thickness) solid var(--ck-color-link-selected-background);
	}
}

/*
 * Classes used by the "fake visual selection" displayed in the content when an input
 * in the link UI has focus (the browser does not render the native selection in this state).
 */
.ck .ck-fake-link-selection {
	background: var(--ck-color-link-fake-selection);
}

/* A collapsed fake visual selection. */
.ck .ck-fake-link-selection_collapsed {
	height: 100%;
	border-right: 1px solid var(--ck-color-base-text);
	margin-right: -1px;
	outline: solid 1px hsla(0, 0%, 100%, .5);
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            8762: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck.ck-link-actions{display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-link-actions .ck-link-actions__preview{display:inline-block}.ck.ck-link-actions .ck-link-actions__preview .ck-button__label{overflow:hidden}@media screen and (max-width:600px){.ck.ck-link-actions{flex-wrap:wrap}.ck.ck-link-actions .ck-link-actions__preview{flex-basis:100%}.ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){flex-basis:50%}}.ck.ck-link-actions .ck-button.ck-link-actions__preview{padding-left:0;padding-right:0}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label{color:var(--ck-color-link-default);cursor:pointer;max-width:var(--ck-input-width);min-width:3em;padding:0 var(--ck-spacing-medium);text-align:center;text-overflow:ellipsis}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label:hover{text-decoration:underline}.ck.ck-link-actions .ck-button.ck-link-actions__preview,.ck.ck-link-actions .ck-button.ck-link-actions__preview:active,.ck.ck-link-actions .ck-button.ck-link-actions__preview:focus,.ck.ck-link-actions .ck-button.ck-link-actions__preview:hover{background:none}.ck.ck-link-actions .ck-button.ck-link-actions__preview:active{box-shadow:none}.ck.ck-link-actions .ck-button.ck-link-actions__preview:focus .ck-button__label{text-decoration:underline}[dir=ltr] .ck.ck-link-actions .ck-button:not(:first-child),[dir=rtl] .ck.ck-link-actions .ck-button:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-link-actions .ck-button.ck-link-actions__preview{margin:var(--ck-spacing-standard) var(--ck-spacing-standard) 0}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label{max-width:100%;min-width:0}[dir=ltr] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview),[dir=rtl] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){margin-left:0}}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-link/theme/linkactions.css", "webpack://./../ckeditor5-ui/theme/mixins/_rwd.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-link/linkactions.css"],
                    names: [],
                    mappings: "AAOA,oBACC,YAAa,CACb,kBAAmB,CACnB,gBAqBD,CAnBC,8CACC,oBAKD,CAHC,gEACC,eACD,CCXD,oCDCD,oBAcE,cAUF,CARE,8CACC,eACD,CAEA,8DACC,cACD,CCrBD,CCIA,wDACC,cAAe,CACf,eAmCD,CAjCC,0EAEC,kCAAmC,CAEnC,cAAe,CAIf,+BAAgC,CAChC,aAAc,CARd,kCAAmC,CASnC,iBAAkB,CAPlB,sBAYD,CAHC,gFACC,yBACD,CAGD,mPAIC,eACD,CAEA,+DACC,eACD,CAGC,gFACC,yBACD,CAWD,qHACC,sCACD,CDtDD,oCC0DC,wDACC,8DAMD,CAJC,0EAEC,cAAe,CADf,WAED,CAGD,gJAME,aAEF,CDzED",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";

.ck.ck-link-actions {
	display: flex;
	flex-direction: row;
	flex-wrap: nowrap;

	& .ck-link-actions__preview {
		display: inline-block;

		& .ck-button__label {
			overflow: hidden;
		}
	}

	@mixin ck-media-phone {
		flex-wrap: wrap;

		& .ck-link-actions__preview {
			flex-basis: 100%;
		}

		& .ck-button:not(.ck-link-actions__preview) {
			flex-basis: 50%;
		}
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@define-mixin ck-media-phone {
	@media screen and (max-width: 600px) {
		@mixin-content;
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";
@import "../mixins/_focus.css";
@import "../mixins/_shadow.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";

.ck.ck-link-actions {
	& .ck-button.ck-link-actions__preview {
		padding-left: 0;
		padding-right: 0;

		& .ck-button__label {
			padding: 0 var(--ck-spacing-medium);
			color: var(--ck-color-link-default);
			text-overflow: ellipsis;
			cursor: pointer;

			/* Match the box model of the link editor form's input so the balloon
			does not change width when moving between actions and the form. */
			max-width: var(--ck-input-width);
			min-width: 3em;
			text-align: center;

			&:hover {
				text-decoration: underline;
			}
		}

		&,
		&:hover,
		&:focus,
		&:active {
			background: none;
		}

		&:active {
			box-shadow: none;
		}

		&:focus {
			& .ck-button__label {
				text-decoration: underline;
			}
		}
	}

	@mixin ck-dir ltr {
		& .ck-button:not(:first-child) {
			margin-left: var(--ck-spacing-standard);
		}
	}

	@mixin ck-dir rtl {
		& .ck-button:not(:last-child) {
			margin-left: var(--ck-spacing-standard);
		}
	}

	@mixin ck-media-phone {
		& .ck-button.ck-link-actions__preview {
			margin: var(--ck-spacing-standard) var(--ck-spacing-standard) 0;

			& .ck-button__label {
				min-width: 0;
				max-width: 100%;
			}
		}

		& .ck-button:not(.ck-link-actions__preview) {
			@mixin ck-dir ltr {
				margin-left: 0;
			}

			@mixin ck-dir rtl {
				margin-left: 0;
			}
		}
	}
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            3817: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck.ck-link-form{align-items:flex-start;display:flex}.ck.ck-link-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-link-form{flex-wrap:wrap}.ck.ck-link-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-link-form .ck-button{flex-basis:50%}}.ck.ck-link-form_layout-vertical{display:block}.ck.ck-link-form_layout-vertical .ck-button.ck-button-cancel,.ck.ck-link-form_layout-vertical .ck-button.ck-button-save{margin-top:var(--ck-spacing-medium)}.ck.ck-link-form_layout-vertical{min-width:var(--ck-input-width);padding:0}.ck.ck-link-form_layout-vertical .ck-labeled-field-view{margin:var(--ck-spacing-large) var(--ck-spacing-large) var(--ck-spacing-small)}.ck.ck-link-form_layout-vertical .ck-labeled-field-view .ck-input-text{min-width:0;width:100%}.ck.ck-link-form_layout-vertical>.ck-button{border-radius:0;margin:0;padding:var(--ck-spacing-standard);width:50%}.ck.ck-link-form_layout-vertical>.ck-button:not(:focus){border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-link-form_layout-vertical>.ck-button,[dir=rtl] .ck.ck-link-form_layout-vertical>.ck-button{margin-left:0}[dir=rtl] .ck.ck-link-form_layout-vertical>.ck-button:last-of-type{border-right:1px solid var(--ck-color-base-border)}.ck.ck-link-form_layout-vertical .ck.ck-list{margin:var(--ck-spacing-standard) var(--ck-spacing-large)}.ck.ck-link-form_layout-vertical .ck.ck-list .ck-button.ck-switchbutton{padding:0;width:100%}.ck.ck-link-form_layout-vertical .ck.ck-list .ck-button.ck-switchbutton:hover{background:none}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-link/theme/linkform.css", "webpack://./../ckeditor5-ui/theme/mixins/_rwd.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-link/linkform.css"],
                    names: [],
                    mappings: "AAOA,iBAEC,sBAAuB,CADvB,YAkBD,CAfC,2BACC,YACD,CCPA,oCDCD,iBASE,cAUF,CARE,wCACC,eACD,CAEA,4BACC,cACD,CChBD,CDwBD,iCACC,aAYD,CALE,wHAEC,mCACD,CEhCF,iCAEC,+BAAgC,CADhC,SAgDD,CA7CC,wDACC,8EAMD,CAJC,uEACC,WAAY,CACZ,UACD,CAGD,4CAIC,eAAgB,CAFhB,QAAS,CADT,kCAAmC,CAEnC,SAkBD,CAfC,wDACC,gDACD,CARD,4GAeE,aAMF,CAJE,mEACC,kDACD,CAKF,6CACC,yDAUD,CARC,wEACC,SAAU,CACV,UAKD,CAHC,8EACC,eACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";

.ck.ck-link-form {
	display: flex;
	align-items: flex-start;

	& .ck-label {
		display: none;
	}

	@mixin ck-media-phone {
		flex-wrap: wrap;

		& .ck-labeled-field-view {
			flex-basis: 100%;
		}

		& .ck-button {
			flex-basis: 50%;
		}
	}
}

/*
 * Style link form differently when manual decorators are available.
 * See: https://github.com/ckeditor/ckeditor5-link/issues/186.
 */
.ck.ck-link-form_layout-vertical {
	display: block;

	/*
	 * Whether the form is in the responsive mode or not, if there are decorator buttons
	 * keep the top margin of action buttons medium.
	 */
	& .ck-button {
		&.ck-button-save,
		&.ck-button-cancel {
			margin-top: var(--ck-spacing-medium);
		}
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@define-mixin ck-media-phone {
	@media screen and (max-width: 600px) {
		@mixin-content;
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

/*
 * Style link form differently when manual decorators are available.
 * See: https://github.com/ckeditor/ckeditor5-link/issues/186.
 */
.ck.ck-link-form_layout-vertical {
	padding: 0;
	min-width: var(--ck-input-width);

	& .ck-labeled-field-view {
		margin: var(--ck-spacing-large) var(--ck-spacing-large) var(--ck-spacing-small);

		& .ck-input-text {
			min-width: 0;
			width: 100%;
		}
	}

	& > .ck-button {
		padding: var(--ck-spacing-standard);
		margin: 0;
		width: 50%;
		border-radius: 0;

		&:not(:focus) {
			border-top: 1px solid var(--ck-color-base-border);
		}

		@mixin ck-dir ltr {
			margin-left: 0;
		}

		@mixin ck-dir rtl {
			margin-left: 0;

			&:last-of-type {
				border-right: 1px solid var(--ck-color-base-border);
			}
		}
	}

	/* Using additional \`.ck\` class for stronger CSS specificity than \`.ck.ck-link-form > :not(:first-child)\`. */
	& .ck.ck-list {
		margin: var(--ck-spacing-standard) var(--ck-spacing-large);

		& .ck-button.ck-switchbutton {
			padding: 0;
			width: 100%;

			&:hover {
				background: none;
			}
		}
	}
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            4808: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, '.ck.ck-editor__editable a span.image-inline:after,.ck.ck-editor__editable figure.image>a:after{display:block;position:absolute}:root{--ck-link-image-indicator-icon-size:20;--ck-link-image-indicator-icon-is-visible:clamp(0px,100% - 50px,1px)}.ck.ck-editor__editable a span.image-inline:after,.ck.ck-editor__editable figure.image>a:after{background-color:rgba(0,0,0,.4);background-image:url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAyMCI+PHBhdGggZmlsbD0iI2ZmZiIgZD0ibTExLjA3NyAxNSAuOTkxLTEuNDE2YS43NS43NSAwIDEgMSAxLjIyOS44NmwtMS4xNDggMS42NGEuNzUuNzUgMCAwIDEtLjIxNy4yMDYgNS4yNTEgNS4yNTEgMCAwIDEtOC41MDMtNS45NTUuNy43IDAgMCAxIC4xMi0uMjc0bDEuMTQ3LTEuNjM5YS43NS43NSAwIDEgMSAxLjIyOC44Nkw0LjkzMyAxMC43bC4wMDYuMDAzYTMuNzUgMy43NSAwIDAgMCA2LjEzMiA0LjI5NHptNS40OTQtNS4zMzVhLjc1Ljc1IDAgMCAxLS4xMi4yNzRsLTEuMTQ3IDEuNjM5YS43NS43NSAwIDEgMS0xLjIyOC0uODZsLjg2LTEuMjNhMy43NSAzLjc1IDAgMCAwLTYuMTQ0LTQuMzAxbC0uODYgMS4yMjlhLjc1Ljc1IDAgMCAxLTEuMjI5LS44NmwxLjE0OC0xLjY0YS43NS43NSAwIDAgMSAuMjE3LS4yMDYgNS4yNTEgNS4yNTEgMCAwIDEgOC41MDMgNS45NTVtLTQuNTYzLTIuNTMyYS43NS43NSAwIDAgMSAuMTg0IDEuMDQ1bC0zLjE1NSA0LjUwNWEuNzUuNzUgMCAxIDEtMS4yMjktLjg2bDMuMTU1LTQuNTA2YS43NS43NSAwIDAgMSAxLjA0NS0uMTg0Ii8+PC9zdmc+");background-position:50%;background-repeat:no-repeat;background-size:14px;border-radius:100%;content:"";height:calc(var(--ck-link-image-indicator-icon-is-visible)*var(--ck-link-image-indicator-icon-size));overflow:hidden;right:min(var(--ck-spacing-medium),6%);top:min(var(--ck-spacing-medium),6%);width:calc(var(--ck-link-image-indicator-icon-is-visible)*var(--ck-link-image-indicator-icon-size))}', "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-link/theme/linkimage.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-link/linkimage.css"],
                    names: [],
                    mappings: "AASE,+FACC,aAAc,CACd,iBACD,CCPF,MAEC,sCAAuC,CACvC,oEACD,CAME,+FAUC,+BAAqC,CACrC,k2BAA+3B,CAG/3B,uBAA2B,CAD3B,2BAA4B,CAD5B,oBAAqB,CAGrB,kBAAmB,CAdnB,UAAW,CAsBX,oGAAuG,CAFvG,eAAgB,CAbhB,sCAAwC,CADxC,oCAAsC,CAetC,mGAED",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-editor__editable {
	/* Linked image indicator */
	& figure.image > a,
	& a span.image-inline {
		&::after {
			display: block;
			position: absolute;
		}
	}
}

`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	/* Match the icon size with the upload indicator brought by the image upload feature. */
	--ck-link-image-indicator-icon-size: 20;
	--ck-link-image-indicator-icon-is-visible: clamp(0px, 100% - 50px, 1px);
}

.ck.ck-editor__editable {
	/* Linked image indicator */
	& figure.image > a,
	& a span.image-inline {
		&::after {
			content: "";

			/*
			 * Smaller images should have the icon closer to the border.
			 * Match the icon position with the upload indicator brought by the image upload feature.
			 */
			top: min(var(--ck-spacing-medium), 6%);
			right: min(var(--ck-spacing-medium), 6%);

			background-color: hsla(0, 0%, 0%, .4);
			background-image: url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjAgMjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbD0iI2ZmZiIgZD0ibTExLjA3NyAxNSAuOTkxLTEuNDE2YS43NS43NSAwIDEgMSAxLjIyOS44NmwtMS4xNDggMS42NGEuNzQ4Ljc0OCAwIDAgMS0uMjE3LjIwNiA1LjI1MSA1LjI1MSAwIDAgMS04LjUwMy01Ljk1NS43NDEuNzQxIDAgMCAxIC4xMi0uMjc0bDEuMTQ3LTEuNjM5YS43NS43NSAwIDEgMSAxLjIyOC44Nkw0LjkzMyAxMC43bC4wMDYuMDAzYTMuNzUgMy43NSAwIDAgMCA2LjEzMiA0LjI5NGwuMDA2LjAwNHptNS40OTQtNS4zMzVhLjc0OC43NDggMCAwIDEtLjEyLjI3NGwtMS4xNDcgMS42MzlhLjc1Ljc1IDAgMSAxLTEuMjI4LS44NmwuODYtMS4yM2EzLjc1IDMuNzUgMCAwIDAtNi4xNDQtNC4zMDFsLS44NiAxLjIyOWEuNzUuNzUgMCAwIDEtMS4yMjktLjg2bDEuMTQ4LTEuNjRhLjc0OC43NDggMCAwIDEgLjIxNy0uMjA2IDUuMjUxIDUuMjUxIDAgMCAxIDguNTAzIDUuOTU1em0tNC41NjMtMi41MzJhLjc1Ljc1IDAgMCAxIC4xODQgMS4wNDVsLTMuMTU1IDQuNTA1YS43NS43NSAwIDEgMS0xLjIyOS0uODZsMy4xNTUtNC41MDZhLjc1Ljc1IDAgMCAxIDEuMDQ1LS4xODR6Ii8+PC9zdmc+");
			background-size: 14px;
			background-repeat: no-repeat;
			background-position: center;
			border-radius: 100%;

			/*
			* Use CSS math to simulate container queries.
			* https://css-tricks.com/the-raven-technique-one-step-closer-to-container-queries/#what-about-showing-and-hiding-things
			*/
			overflow: hidden;
			width: calc(var(--ck-link-image-indicator-icon-is-visible) * var(--ck-link-image-indicator-icon-size));
			height: calc(var(--ck-link-image-indicator-icon-is-visible) * var(--ck-link-image-indicator-icon-size));
		}
	}
}

`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            1232: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck-editor__editable .ck-list-bogus-paragraph{display:block}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-list/theme/documentlist.css"],
                    names: [],
                    mappings: "AAKA,8CACC,aACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck-editor__editable .ck-list-bogus-paragraph {
	display: block;
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            6903: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck-content ol{list-style-type:decimal}.ck-content ol ol{list-style-type:lower-latin}.ck-content ol ol ol{list-style-type:lower-roman}.ck-content ol ol ol ol{list-style-type:upper-latin}.ck-content ol ol ol ol ol{list-style-type:upper-roman}.ck-content ul{list-style-type:disc}.ck-content ul ul{list-style-type:circle}.ck-content ul ul ul,.ck-content ul ul ul ul{list-style-type:square}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-list/theme/list.css"],
                    names: [],
                    mappings: "AAKA,eACC,uBAiBD,CAfC,kBACC,2BAaD,CAXC,qBACC,2BASD,CAPC,wBACC,2BAKD,CAHC,2BACC,2BACD,CAMJ,eACC,oBAaD,CAXC,kBACC,sBASD,CAJE,6CACC,sBACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck-content ol {
	list-style-type: decimal;

	& ol {
		list-style-type: lower-latin;

		& ol {
			list-style-type: lower-roman;

			& ol {
				list-style-type: upper-latin;

				& ol {
					list-style-type: upper-roman;
				}
			}
		}
	}
}

.ck-content ul {
	list-style-type: disc;

	& ul {
		list-style-type: circle;

		& ul {
			list-style-type: square;

			& ul {
				list-style-type: square;
			}
		}
	}
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            9968: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck.ck-list-properties.ck-list-properties_without-styles{padding:var(--ck-spacing-large)}.ck.ck-list-properties.ck-list-properties_without-styles>*{min-width:14em}.ck.ck-list-properties.ck-list-properties_without-styles>*+*{margin-top:var(--ck-spacing-standard)}.ck.ck-list-properties.ck-list-properties_with-numbered-properties>.ck-list-styles-list{grid-template-columns:repeat(4,auto)}.ck.ck-list-properties.ck-list-properties_with-numbered-properties>.ck-collapsible{border-top:1px solid var(--ck-color-base-border)}.ck.ck-list-properties.ck-list-properties_with-numbered-properties>.ck-collapsible>.ck-collapsible__children>*{width:100%}.ck.ck-list-properties.ck-list-properties_with-numbered-properties>.ck-collapsible>.ck-collapsible__children>*+*{margin-top:var(--ck-spacing-standard)}.ck.ck-list-properties .ck.ck-numbered-list-properties__start-index .ck-input{min-width:auto;width:100%}.ck.ck-list-properties .ck.ck-numbered-list-properties__reversed-order{background:transparent;margin-bottom:calc(var(--ck-spacing-tiny)*-1);padding-left:0;padding-right:0}.ck.ck-list-properties .ck.ck-numbered-list-properties__reversed-order:active,.ck.ck-list-properties .ck.ck-numbered-list-properties__reversed-order:hover{background:none;border-color:transparent;box-shadow:none}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-list/listproperties.css"],
                    names: [],
                    mappings: "AAOC,yDACC,+BASD,CAPC,2DACC,cAKD,CAHC,6DACC,qCACD,CASD,wFACC,oCACD,CAGA,mFACC,gDAWD,CARE,+GACC,UAKD,CAHC,iHACC,qCACD,CAMJ,8EACC,cAAe,CACf,UACD,CAEA,uEACC,sBAAuB,CAGvB,6CAAgD,CAFhD,cAAe,CACf,eAQD,CALC,2JAGC,eAAgB,CADhB,wBAAyB,CADzB,eAGD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-list-properties {
	/* When there are no list styles and there is no collapsible. */
	&.ck-list-properties_without-styles {
		padding: var(--ck-spacing-large);

		& > * {
			min-width: 14em;

			& + * {
				margin-top: var(--ck-spacing-standard);
			}
		}
	}

	/*
	 * When the numbered list property fields (start at, reversed) should be displayed,
	 * more horizontal space is needed. Reconfigure the style grid to create that space.
	 */
	&.ck-list-properties_with-numbered-properties {
		& > .ck-list-styles-list {
			grid-template-columns: repeat( 4, auto );
		}

		/* When list styles are rendered and property fields are in a collapsible. */
		& > .ck-collapsible {
			border-top: 1px solid var(--ck-color-base-border);

			& > .ck-collapsible__children {
				& > * {
					width: 100%;

					& + * {
						margin-top: var(--ck-spacing-standard);
					}
				}
			}
		}
	}

	& .ck.ck-numbered-list-properties__start-index .ck-input {
		min-width: auto;
		width: 100%;
	}

	& .ck.ck-numbered-list-properties__reversed-order {
		background: transparent;
		padding-left: 0;
		padding-right: 0;
		margin-bottom: calc(-1 * var(--ck-spacing-tiny));

		&:active, &:hover {
			box-shadow: none;
			border-color: transparent;
			background: none;
		}
	}
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            7141: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck.ck-list-styles-list{display:grid}:root{--ck-list-style-button-size:44px}.ck.ck-list-styles-list{column-gap:var(--ck-spacing-medium);grid-template-columns:repeat(3,auto);padding:var(--ck-spacing-large);row-gap:var(--ck-spacing-medium)}.ck.ck-list-styles-list .ck-button{box-sizing:content-box;margin:0;padding:0}.ck.ck-list-styles-list .ck-button,.ck.ck-list-styles-list .ck-button .ck-icon{height:var(--ck-list-style-button-size);width:var(--ck-list-style-button-size)}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-list/theme/liststyles.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-list/liststyles.css"],
                    names: [],
                    mappings: "AAKA,wBACC,YACD,CCFA,MACC,gCACD,CAEA,wBAGC,mCAAoC,CAFpC,oCAAwC,CAGxC,+BAAgC,CAFhC,gCA4BD,CAxBC,mCAiBC,sBAAuB,CAPvB,QAAS,CANT,SAmBD,CAJC,+EAhBA,uCAAwC,CADxC,sCAoBA",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-list-styles-list {
	display: grid;
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-list-style-button-size: 44px;
}

.ck.ck-list-styles-list {
	grid-template-columns: repeat( 3, auto );
	row-gap: var(--ck-spacing-medium);
	column-gap: var(--ck-spacing-medium);
	padding: var(--ck-spacing-large);

	& .ck-button {
		/* Make the button look like a thumbnail (the icon "takes it all"). */
		width: var(--ck-list-style-button-size);
		height: var(--ck-list-style-button-size);
		padding: 0;

		/*
		 * Buttons are aligned by the grid so disable default button margins to not collide with the
		 * gaps in the grid.
		 */
		margin: 0;

		/*
		 * Make sure the button border (which is displayed on focus, BTW) does not steal pixels
		 * from the button dimensions and, as a result, decrease the size of the icon
		 * (which becomes blurry as it scales down).
		 */
		box-sizing: content-box;

		& .ck-icon {
			width: var(--ck-list-style-button-size);
			height: var(--ck-list-style-button-size);
		}
	}
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            8991: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ':root{--ck-todo-list-checkmark-size:16px}.ck-content .todo-list{list-style:none}.ck-content .todo-list li{margin-bottom:5px;position:relative}.ck-content .todo-list li .todo-list{margin-top:5px}.ck-content .todo-list .todo-list__label>input{-webkit-appearance:none;border:0;display:inline-block;height:var(--ck-todo-list-checkmark-size);left:-25px;margin-left:0;margin-right:-15px;position:relative;right:0;vertical-align:middle;width:var(--ck-todo-list-checkmark-size)}.ck-content[dir=rtl] .todo-list .todo-list__label>input{left:0;margin-left:-15px;margin-right:0;right:-25px}.ck-content .todo-list .todo-list__label>input:before{border:1px solid #333;border-radius:2px;box-sizing:border-box;content:"";display:block;height:100%;position:absolute;transition:box-shadow .25s ease-in-out;width:100%}@media (prefers-reduced-motion:reduce){.ck-content .todo-list .todo-list__label>input:before{transition:none}}.ck-content .todo-list .todo-list__label>input:after{border-color:transparent;border-style:solid;border-width:0 calc(var(--ck-todo-list-checkmark-size)/8) calc(var(--ck-todo-list-checkmark-size)/8) 0;box-sizing:content-box;content:"";display:block;height:calc(var(--ck-todo-list-checkmark-size)/2.6);left:calc(var(--ck-todo-list-checkmark-size)/3);pointer-events:none;position:absolute;top:calc(var(--ck-todo-list-checkmark-size)/5.3);transform:rotate(45deg);width:calc(var(--ck-todo-list-checkmark-size)/5.3)}.ck-content .todo-list .todo-list__label>input[checked]:before{background:#26ab33;border-color:#26ab33}.ck-content .todo-list .todo-list__label>input[checked]:after{border-color:#fff}.ck-content .todo-list .todo-list__label .todo-list__label__description{vertical-align:middle}.ck-content .todo-list .todo-list__label.todo-list__label_without-description input[type=checkbox]{position:absolute}.ck-editor__editable.ck-content .todo-list .todo-list__label>input,.ck-editor__editable.ck-content .todo-list .todo-list__label>span[contenteditable=false]>input{cursor:pointer}.ck-editor__editable.ck-content .todo-list .todo-list__label>input:hover:before,.ck-editor__editable.ck-content .todo-list .todo-list__label>span[contenteditable=false]>input:hover:before{box-shadow:0 0 0 5px rgba(0,0,0,.1)}.ck-editor__editable.ck-content .todo-list .todo-list__label>span[contenteditable=false]>input{-webkit-appearance:none;border:0;display:inline-block;height:var(--ck-todo-list-checkmark-size);left:-25px;margin-left:0;margin-right:-15px;position:relative;right:0;vertical-align:middle;width:var(--ck-todo-list-checkmark-size)}.ck-editor__editable.ck-content[dir=rtl] .todo-list .todo-list__label>span[contenteditable=false]>input{left:0;margin-left:-15px;margin-right:0;right:-25px}.ck-editor__editable.ck-content .todo-list .todo-list__label>span[contenteditable=false]>input:before{border:1px solid #333;border-radius:2px;box-sizing:border-box;content:"";display:block;height:100%;position:absolute;transition:box-shadow .25s ease-in-out;width:100%}@media (prefers-reduced-motion:reduce){.ck-editor__editable.ck-content .todo-list .todo-list__label>span[contenteditable=false]>input:before{transition:none}}.ck-editor__editable.ck-content .todo-list .todo-list__label>span[contenteditable=false]>input:after{border-color:transparent;border-style:solid;border-width:0 calc(var(--ck-todo-list-checkmark-size)/8) calc(var(--ck-todo-list-checkmark-size)/8) 0;box-sizing:content-box;content:"";display:block;height:calc(var(--ck-todo-list-checkmark-size)/2.6);left:calc(var(--ck-todo-list-checkmark-size)/3);pointer-events:none;position:absolute;top:calc(var(--ck-todo-list-checkmark-size)/5.3);transform:rotate(45deg);width:calc(var(--ck-todo-list-checkmark-size)/5.3)}.ck-editor__editable.ck-content .todo-list .todo-list__label>span[contenteditable=false]>input[checked]:before{background:#26ab33;border-color:#26ab33}.ck-editor__editable.ck-content .todo-list .todo-list__label>span[contenteditable=false]>input[checked]:after{border-color:#fff}.ck-editor__editable.ck-content .todo-list .todo-list__label.todo-list__label_without-description input[type=checkbox]{position:absolute}', "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-list/theme/todolist.css"],
                    names: [],
                    mappings: "AAKA,MACC,kCACD,CA4EA,uBACC,eAwBD,CAtBC,0BAEC,iBAAkB,CADlB,iBAMD,CAHC,qCACC,cACD,CAIA,+CAtFD,uBAAwB,CAQxB,QAAS,CAPT,oBAAqB,CAGrB,yCAA0C,CAO1C,UAAW,CAGX,aAAc,CAFd,kBAAmB,CAVnB,iBAAkB,CAWlB,OAAQ,CARR,qBAAsB,CAFtB,wCAqFC,CAFA,wDApEA,MAAO,CAGP,iBAAkB,CAFlB,cAAe,CACf,WAoEA,CAhED,sDAOC,qBAAiC,CACjC,iBAAkB,CALlB,qBAAsB,CACtB,UAAW,CAHX,aAAc,CAKd,WAAY,CAJZ,iBAAkB,CAOlB,sCAAwC,CAJxC,UASD,CAHC,uCAXD,sDAYE,eAEF,CADC,CAGD,qDAaC,wBAAyB,CADzB,kBAAmB,CAEnB,sGAA+G,CAX/G,sBAAuB,CAEvB,UAAW,CAJX,aAAc,CAUd,mDAAwD,CAHxD,+CAAoD,CAJpD,mBAAoB,CAFpB,iBAAkB,CAOlB,gDAAqD,CAMrD,uBAAwB,CALxB,kDAMD,CAGC,+DACC,kBAA8B,CAC9B,oBACD,CAEA,8DACC,iBACD,CAwBA,wEACC,qBACD,CAEA,mGACC,iBACD,CAYD,kKAEC,cAKD,CAHC,4LACC,mCACD,CAMD,+FAxHA,uBAAwB,CAQxB,QAAS,CAPT,oBAAqB,CAGrB,yCAA0C,CAO1C,UAAW,CAGX,aAAc,CAFd,kBAAmB,CAVnB,iBAAkB,CAWlB,OAAQ,CARR,qBAAsB,CAFtB,wCAuHA,CAFA,wGAtGC,MAAO,CAGP,iBAAkB,CAFlB,cAAe,CACf,WAsGD,CAlGA,sGAOC,qBAAiC,CACjC,iBAAkB,CALlB,qBAAsB,CACtB,UAAW,CAHX,aAAc,CAKd,WAAY,CAJZ,iBAAkB,CAOlB,sCAAwC,CAJxC,UASD,CAHC,uCAXD,sGAYE,eAEF,CADC,CAGD,qGAaC,wBAAyB,CADzB,kBAAmB,CAEnB,sGAA+G,CAX/G,sBAAuB,CAEvB,UAAW,CAJX,aAAc,CAUd,mDAAwD,CAHxD,+CAAoD,CAJpD,mBAAoB,CAFpB,iBAAkB,CAOlB,gDAAqD,CAMrD,uBAAwB,CALxB,kDAMD,CAGC,+GACC,kBAA8B,CAC9B,oBACD,CAEA,8GACC,iBACD,CA2DA,uHACC,iBACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-todo-list-checkmark-size: 16px;
}

@define-mixin todo-list-checkbox {
	-webkit-appearance: none;
	display: inline-block;
	position: relative;
	width: var(--ck-todo-list-checkmark-size);
	height: var(--ck-todo-list-checkmark-size);
	vertical-align: middle;

	/* Needed on iOS */
	border: 0;

	/* LTR styles */
	left: -25px;
	margin-right: -15px;
	right: 0;
	margin-left: 0;

	/* RTL styles */
	@nest [dir=rtl]& {
		left: 0;
		margin-right: 0;
		right: -25px;
		margin-left: -15px;
	}

	&::before {
		display: block;
		position: absolute;
		box-sizing: border-box;
		content: '';
		width: 100%;
		height: 100%;
		border: 1px solid hsl(0, 0%, 20%);
		border-radius: 2px;
		transition: 250ms ease-in-out box-shadow;

		@media (prefers-reduced-motion: reduce) {
			transition: none;
		}
	}

	&::after {
		display: block;
		position: absolute;
		box-sizing: content-box;
		pointer-events: none;
		content: '';

		/* Calculate tick position, size and border-width proportional to the checkmark size. */
		left: calc( var(--ck-todo-list-checkmark-size) / 3 );
		top: calc( var(--ck-todo-list-checkmark-size) / 5.3 );
		width: calc( var(--ck-todo-list-checkmark-size) / 5.3 );
		height: calc( var(--ck-todo-list-checkmark-size) / 2.6 );
		border-style: solid;
		border-color: transparent;
		border-width: 0 calc( var(--ck-todo-list-checkmark-size) / 8 ) calc( var(--ck-todo-list-checkmark-size) / 8 ) 0;
		transform: rotate(45deg);
	}

	&[checked] {
		&::before {
			background: hsl(126, 64%, 41%);
			border-color: hsl(126, 64%, 41%);
		}

		&::after {
			border-color: hsl(0, 0%, 100%);
		}
	}
}

/*
 * To-do list content styles.
 */
.ck-content .todo-list {
	list-style: none;

	& li {
		position: relative;
		margin-bottom: 5px;

		& .todo-list {
			margin-top: 5px;
		}
	}

	& .todo-list__label {
		& > input {
			@mixin todo-list-checkbox;
		}

		& .todo-list__label__description {
			vertical-align: middle;
		}

		&.todo-list__label_without-description input[type=checkbox] {
			position: absolute;
		}
	}
}

/*
 * To-do list editing view styles.
 */
.ck-editor__editable.ck-content .todo-list .todo-list__label {
	/*
	 * To-do list should be interactive only during the editing
	 * (https://github.com/ckeditor/ckeditor5/issues/2090).
	 */
	& > input,
	& > span[contenteditable=false] > input {
		cursor: pointer;

		&:hover::before {
			box-shadow: 0 0 0 5px hsla(0, 0%, 0%, 0.1);
		}
	}

	/*
	 * Document Lists - editing view has an additional span around checkbox.
	 */
	& > span[contenteditable=false] > input {
		@mixin todo-list-checkbox;
	}

	&.todo-list__label_without-description {
		& input[type=checkbox] {
			position: absolute;
		}
	}
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            70: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck-content .media{clear:both;display:block;margin:.9em 0;min-width:15em}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-media-embed/theme/mediaembed.css"],
                    names: [],
                    mappings: "AAKA,mBAGC,UAAW,CASX,aAAc,CAJd,aAAe,CAQf,cACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck-content .media {
	/* Don't allow floated content overlap the media.
	https://github.com/ckeditor/ckeditor5-media-embed/issues/53 */
	clear: both;

	/* Make sure there is some space between the content and the media. */
	/* The first value should be equal to --ck-spacing-large variable if used in the editor context
	to avoid the content jumping (See https://github.com/ckeditor/ckeditor5/issues/9825). */
	margin: 0.9em 0;

	/* Make sure media is not overriden with Bootstrap default \`flex\` value.
	See: https://github.com/ckeditor/ckeditor5/issues/1373. */
	display: block;

	/* Give the media some minimal width in the content to prevent them
	from being "squashed" in tight spaces, e.g. in table cells (#44) */
	min-width: 15em;
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            7048: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, '.ck-media__wrapper .ck-media__placeholder{align-items:center;display:flex;flex-direction:column}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url{max-width:100%;position:relative}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url .ck-media__placeholder__url__text{display:block;overflow:hidden}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="goo.gl/maps"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="google.com/maps"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="maps.app.goo.gl"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="maps.google.com"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck-media__placeholder__icon *{display:none}.ck-editor__editable:not(.ck-read-only) .ck-media__wrapper>:not(.ck-media__placeholder),.ck-editor__editable:not(.ck-read-only) .ck-widget:not(.ck-widget_selected) .ck-media__placeholder{pointer-events:none}:root{--ck-media-embed-placeholder-icon-size:3em;--ck-color-media-embed-placeholder-url-text:#757575;--ck-color-media-embed-placeholder-url-text-hover:var(--ck-color-base-text)}.ck-media__wrapper{margin:0 auto}.ck-media__wrapper .ck-media__placeholder{background:var(--ck-color-base-foreground);padding:calc(var(--ck-spacing-standard)*3)}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__icon{background-position:50%;background-size:cover;height:var(--ck-media-embed-placeholder-icon-size);margin-bottom:var(--ck-spacing-large);min-width:var(--ck-media-embed-placeholder-icon-size)}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__icon .ck-icon{height:100%;width:100%}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url__text{color:var(--ck-color-media-embed-placeholder-url-text);font-style:italic;text-align:center;text-overflow:ellipsis;white-space:nowrap}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url__text:hover{color:var(--ck-color-media-embed-placeholder-url-text-hover);cursor:pointer;text-decoration:underline}.ck-media__wrapper[data-oembed-url*="open.spotify.com"]{max-height:380px;max-width:300px}.ck-media__wrapper[data-oembed-url*="goo.gl/maps"] .ck-media__placeholder__icon,.ck-media__wrapper[data-oembed-url*="google.com/maps"] .ck-media__placeholder__icon,.ck-media__wrapper[data-oembed-url*="maps.app.goo.gl"] .ck-media__placeholder__icon,.ck-media__wrapper[data-oembed-url*="maps.google.com"] .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNTAuMzc4IiBoZWlnaHQ9IjI1NC4xNjciIHZpZXdCb3g9IjAgMCA2Ni4yNDYgNjcuMjQ4Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTcyLjUzMSAtMjE4LjQ1NSlzY2FsZSguOTgwMTIpIj48cmVjdCB3aWR0aD0iNjAuMDk5IiBoZWlnaHQ9IjYwLjA5OSIgeD0iMTc2LjAzMSIgeT0iMjMxLjM5OSIgZmlsbD0iIzM0YTY2OCIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiIHJ4PSI1LjIzOCIgcnk9IjUuMjM4Ii8+PHBhdGggZmlsbD0iIzVjODhjNSIgZD0ibTIwNi40NzcgMjYwLjktMjguOTg3IDI4Ljk4N2E1LjIyIDUuMjIgMCAwIDAgMy43OCAxLjYxaDQ5LjYyMWMxLjY5NCAwIDMuMTktLjc5OCA0LjE0Ni0yLjAzN3oiLz48cGF0aCBmaWxsPSIjZGQ0YjNlIiBkPSJNMjI2Ljc0MiAyMjIuOTg4Yy05LjI2NiAwLTE2Ljc3NyA3LjE3LTE2Ljc3NyAxNi4wMTQuMDA3IDIuNzYyLjY2MyA1LjQ3NCAyLjA5MyA3Ljg3NS40My43MDMuODMgMS40MDggMS4xOSAyLjEwN3EuNS43NTMuOTUgMS41MDguNTE1LjcxNS45ODggMS40NGMxLjMxIDEuNzY5IDIuNSAzLjUwMiAzLjYzNyA1LjE2OC43OTMgMS4yNzUgMS42ODMgMi42NCAyLjQ2NiAzLjk5IDIuMzYzIDQuMDk0IDQuMDA3IDguMDkyIDQuNiAxMy45MTR2LjAxMmMuMTgyLjQxMi41MTYuNjY2Ljg3OS42NjcuNDAzLS4wMDEuNzY4LS4zMTQuOTMtLjc5OS42MDMtNS43NTYgMi4yMzgtOS43MjkgNC41ODUtMTMuNzk0Ljc4Mi0xLjM1IDEuNjczLTIuNzE1IDIuNDY1LTMuOTkgMS4xMzctMS42NjYgMi4zMjgtMy40IDMuNjM4LTUuMTY5cS40NzMtLjcyMy45ODgtMS40MzkuNDUtLjc1NS45NS0xLjUwOGMuMzU5LS43Ljc2LTEuNDA0IDEuMTktMi4xMDcgMS40MjYtMi40MDIgMi01LjExNCAyLjAwNC03Ljg3NSAwLTguODQ0LTcuNTExLTE2LjAxNC0xNi43NzYtMTYuMDE0IiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjxlbGxpcHNlIGN4PSIyMjYuNzQyIiBjeT0iMjM5LjAwMiIgZmlsbD0iIzgwMmQyNyIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiIHJ4PSI1LjgyOCIgcnk9IjUuNTY0Ii8+PHBhdGggZmlsbD0iI2ZmZiIgZD0iTTE5MC4zMDEgMjM3LjI4M2MtNC42NyAwLTguNDU3IDMuODUzLTguNDU3IDguNjA2czMuNzg2IDguNjA3IDguNDU3IDguNjA3YzMuMDQzIDAgNC44MDYtLjk1OCA2LjMzNy0yLjUxNiAxLjUzLTEuNTU3IDIuMDg3LTMuOTEzIDIuMDg3LTYuMjlxLS4wMDEtLjU0My0uMDY0LTEuMDc5aC04LjI1N3YzLjA0M2g0Ljg1Yy0uMTk3Ljc1OS0uNTMxIDEuNDUtMS4wNTggMS45ODYtLjk0Mi45NTgtMi4wMjggMS41NDgtMy45MDEgMS41NDgtMi44NzYgMC01LjIwOC0yLjM3Mi01LjIwOC01LjI5OSAwLTIuOTI2IDIuMzMyLTUuMjk5IDUuMjA4LTUuMjk5IDEuMzk5IDAgMi42MTguNDA3IDMuNTg0IDEuMjkzbDIuMzgxLTIuMzhxLS4wMDEtLjAwMy0uMDA0LS4wMDVjLTEuNTg4LTEuNTI0LTMuNjItMi4yMTUtNS45NTUtMi4yMTVtNC40MyA1LjY2LjAwMy4wMDZ2LS4wMDN6IiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjxwYXRoIGZpbGw9IiNjM2MzYzMiIGQ9Im0yMTUuMTg0IDI1MS45MjktNy45OCA3Ljk3OSAyOC40NzcgMjguNDc1YTUuMiA1LjIgMCAwIDAgLjQ0OS0yLjEyM3YtMzEuMTY1Yy0uNDY5LjY3NS0uOTM0IDEuMzQ5LTEuMzgyIDIuMDA1LS43OTIgMS4yNzUtMS42ODIgMi42NC0yLjQ2NSAzLjk5LTIuMzQ3IDQuMDY1LTMuOTgyIDguMDM4LTQuNTg1IDEzLjc5NC0uMTYyLjQ4NS0uNTI3Ljc5OC0uOTMuNzk5LS4zNjMtLjAwMS0uNjk3LS4yNTUtLjg3OS0uNjY3di0uMDEyYy0uNTkzLTUuODIyLTIuMjM3LTkuODItNC42LTEzLjkxNC0uNzgzLTEuMzUtMS42NzMtMi43MTUtMi40NjYtMy45OS0xLjEzNy0xLjY2Ni0yLjMyNy0zLjQtMy42MzctNS4xNjl6Ii8+PHBhdGggZmlsbD0iI2ZkZGM0ZiIgZD0ibTIxMi45ODMgMjQ4LjQ5NS0zNi45NTIgMzYuOTUzdi44MTJhNS4yMjcgNS4yMjcgMCAwIDAgNS4yMzggNS4yMzhoMS4wMTVsMzUuNjY2LTM1LjY2NmExMzYgMTM2IDAgMCAwLTIuNzY0LTMuOSAzOCAzOCAwIDAgMC0uOTg5LTEuNDQgMzUgMzUgMCAwIDAtLjk1LTEuNTA4Yy0uMDgzLS4xNjItLjE3Ni0uMzI2LS4yNjQtLjQ4OSIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48cGF0aCBmaWxsPSIjZmZmIiBkPSJtMjExLjk5OCAyNjEuMDgzLTYuMTUyIDYuMTUxIDI0LjI2NCAyNC4yNjRoLjc4MWE1LjIyNyA1LjIyNyAwIDAgMCA1LjIzOS01LjIzOHYtMS4wNDV6IiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjwvZz48L3N2Zz4=)}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder{background:#4268b3}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDI0IiBoZWlnaHQ9IjEwMjQiPjxwYXRoIGZpbGw9IiNGRkZGRkUiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTk2Ny40ODQgMEg1Ni41MTdDMjUuMzA0IDAgMCAyNS4zMDQgMCA1Ni41MTd2OTEwLjk2NkMwIDk5OC42OTQgMjUuMjk3IDEwMjQgNTYuNTIyIDEwMjRINTQ3VjYyOEg0MTRWNDczaDEzM1YzNTkuMDI5YzAtMTMyLjI2MiA4MC43NzMtMjA0LjI4MiAxOTguNzU2LTIwNC4yODIgNTYuNTEzIDAgMTA1LjA4NiA0LjIwOCAxMTkuMjQ0IDYuMDg5VjI5OWwtODEuNjE2LjAzN2MtNjMuOTkzIDAtNzYuMzg0IDMwLjQ5Mi03Ni4zODQgNzUuMjM2VjQ3M2gxNTMuNDg3bC0xOS45ODYgMTU1SDcwN3YzOTZoMjYwLjQ4NGMzMS4yMTMgMCA1Ni41MTYtMjUuMzAzIDU2LjUxNi01Ni41MTZWNTYuNTE1QzEwMjQgMjUuMzAzIDk5OC42OTcgMCA5NjcuNDg0IDAiLz48L3N2Zz4=)}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder .ck-media__placeholder__url__text{color:#cdf}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder .ck-media__placeholder__url__text:hover{color:#fff}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder{background:linear-gradient(-135deg,#1400c7,#b800b1,#f50000)}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iNTA0IiBoZWlnaHQ9IjUwNCI+PGRlZnM+PHBhdGggaWQ9ImEiIGQ9Ik0wIC4xNTloNTAzLjg0MVY1MDMuOTRIMHoiLz48L2RlZnM+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj48bWFzayBpZD0iYiIgZmlsbD0iI2ZmZiI+PHVzZSB4bGluazpocmVmPSIjYSIvPjwvbWFzaz48cGF0aCBmaWxsPSIjRkZGIiBkPSJNMjUxLjkyMS4xNTljLTY4LjQxOCAwLTc2Ljk5Ny4yOS0xMDMuODY3IDEuNTE2LTI2LjgxNCAxLjIyMy00NS4xMjcgNS40ODItNjEuMTUxIDExLjcxLTE2LjU2NiA2LjQzNy0zMC42MTUgMTUuMDUxLTQ0LjYyMSAyOS4wNTYtMTQuMDA1IDE0LjAwNi0yMi42MTkgMjguMDU1LTI5LjA1NiA0NC42MjEtNi4yMjggMTYuMDI0LTEwLjQ4NyAzNC4zMzctMTEuNzEgNjEuMTUxQy4yOSAxNzUuMDgzIDAgMTgzLjY2MiAwIDI1Mi4wOGMwIDY4LjQxNy4yOSA3Ni45OTYgMS41MTYgMTAzLjg2NiAxLjIyMyAyNi44MTQgNS40ODIgNDUuMTI3IDExLjcxIDYxLjE1MSA2LjQzNyAxNi41NjYgMTUuMDUxIDMwLjYxNSAyOS4wNTYgNDQuNjIxIDE0LjAwNiAxNC4wMDUgMjguMDU1IDIyLjYxOSA0NC42MjEgMjkuMDU3IDE2LjAyNCA2LjIyNyAzNC4zMzcgMTAuNDg2IDYxLjE1MSAxMS43MDkgMjYuODcgMS4yMjYgMzUuNDQ5IDEuNTE2IDEwMy44NjcgMS41MTYgNjguNDE3IDAgNzYuOTk2LS4yOSAxMDMuODY2LTEuNTE2IDI2LjgxNC0xLjIyMyA0NS4xMjctNS40ODIgNjEuMTUxLTExLjcwOSAxNi41NjYtNi40MzggMzAuNjE1LTE1LjA1MiA0NC42MjEtMjkuMDU3IDE0LjAwNS0xNC4wMDYgMjIuNjE5LTI4LjA1NSAyOS4wNTctNDQuNjIxIDYuMjI3LTE2LjAyNCAxMC40ODYtMzQuMzM3IDExLjcwOS02MS4xNTEgMS4yMjYtMjYuODcgMS41MTYtMzUuNDQ5IDEuNTE2LTEwMy44NjYgMC02OC40MTgtLjI5LTc2Ljk5Ny0xLjUxNi0xMDMuODY3LTEuMjIzLTI2LjgxNC01LjQ4Mi00NS4xMjctMTEuNzA5LTYxLjE1MS02LjQzOC0xNi41NjYtMTUuMDUyLTMwLjYxNS0yOS4wNTctNDQuNjIxLTE0LjAwNi0xNC4wMDUtMjguMDU1LTIyLjYxOS00NC42MjEtMjkuMDU2LTE2LjAyNC02LjIyOC0zNC4zMzctMTAuNDg3LTYxLjE1MS0xMS43MUMzMjguOTE3LjQ0OSAzMjAuMzM4LjE1OSAyNTEuOTIxLjE1OW0wIDQ1LjM5MWM2Ny4yNjUgMCA3NS4yMzMuMjU3IDEwMS43OTcgMS40NjkgMjQuNTYyIDEuMTIgMzcuOTAxIDUuMjI0IDQ2Ljc3OCA4LjY3NCAxMS43NTkgNC41NyAyMC4xNTEgMTAuMDI5IDI4Ljk2NiAxOC44NDVzMTQuMjc1IDE3LjIwNyAxOC44NDUgMjguOTY2YzMuNDUgOC44NzcgNy41NTQgMjIuMjE2IDguNjc0IDQ2Ljc3OCAxLjIxMiAyNi41NjQgMS40NjkgMzQuNTMyIDEuNDY5IDEwMS43OTggMCA2Ny4yNjUtLjI1NyA3NS4yMzMtMS40NjkgMTAxLjc5Ny0xLjEyIDI0LjU2Mi01LjIyNCAzNy45MDEtOC42NzQgNDYuNzc4LTQuNTcgMTEuNzU5LTEwLjAyOSAyMC4xNTEtMTguODQ1IDI4Ljk2NnMtMTcuMjA3IDE0LjI3NS0yOC45NjYgMTguODQ1Yy04Ljg3NyAzLjQ1LTIyLjIxNiA3LjU1NC00Ni43NzggOC42NzQtMjYuNTYgMS4yMTItMzQuNTI3IDEuNDY5LTEwMS43OTcgMS40NjktNjcuMjcxIDAtNzUuMjM3LS4yNTctMTAxLjc5OC0xLjQ2OS0yNC41NjItMS4xMi0zNy45MDEtNS4yMjQtNDYuNzc4LTguNjc0LTExLjc1OS00LjU3LTIwLjE1MS0xMC4wMjktMjguOTY2LTE4Ljg0NXMtMTQuMjc1LTE3LjIwNy0xOC44NDUtMjguOTY2Yy0zLjQ1LTguODc3LTcuNTU0LTIyLjIxNi04LjY3NC00Ni43NzgtMS4yMTItMjYuNTY0LTEuNDY5LTM0LjUzMi0xLjQ2OS0xMDEuNzk3IDAtNjcuMjY2LjI1Ny03NS4yMzQgMS40NjktMTAxLjc5OCAxLjEyLTI0LjU2MiA1LjIyNC0zNy45MDEgOC42NzQtNDYuNzc4IDQuNTctMTEuNzU5IDEwLjAyOS0yMC4xNTEgMTguODQ1LTI4Ljk2NnMxNy4yMDctMTQuMjc1IDI4Ljk2Ni0xOC44NDVjOC44NzctMy40NSAyMi4yMTYtNy41NTQgNDYuNzc4LTguNjc0IDI2LjU2NC0xLjIxMiAzNC41MzItMS40NjkgMTAxLjc5OC0xLjQ2OSIgbWFzaz0idXJsKCNiKSIvPjxwYXRoIGZpbGw9IiNGRkYiIGQ9Ik0yNTEuOTIxIDMzNi4wNTNjLTQ2LjM3OCAwLTgzLjk3NC0zNy41OTYtODMuOTc0LTgzLjk3M3MzNy41OTYtODMuOTc0IDgzLjk3NC04My45NzRjNDYuMzc3IDAgODMuOTczIDM3LjU5NiA4My45NzMgODMuOTc0IDAgNDYuMzc3LTM3LjU5NiA4My45NzMtODMuOTczIDgzLjk3M20wLTIxMy4zMzhjLTcxLjQ0NyAwLTEyOS4zNjUgNTcuOTE4LTEyOS4zNjUgMTI5LjM2NSAwIDcxLjQ0NiA1Ny45MTggMTI5LjM2NCAxMjkuMzY1IDEyOS4zNjQgNzEuNDQ2IDAgMTI5LjM2NC01Ny45MTggMTI5LjM2NC0xMjkuMzY0IDAtNzEuNDQ3LTU3LjkxOC0xMjkuMzY1LTEyOS4zNjQtMTI5LjM2NU00MTYuNjI3IDExNy42MDRjMCAxNi42OTYtMTMuNTM1IDMwLjIzLTMwLjIzMSAzMC4yMy0xNi42OTUgMC0zMC4yMy0xMy41MzQtMzAuMjMtMzAuMjNzMTMuNTM1LTMwLjIzMSAzMC4yMy0zMC4yMzFjMTYuNjk2IDAgMzAuMjMxIDEzLjUzNSAzMC4yMzEgMzAuMjMxIi8+PC9nPjwvc3ZnPg==)}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder .ck-media__placeholder__url__text{color:#ffe0fe}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder .ck-media__placeholder__url__text:hover{color:#fff}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder{background:linear-gradient(90deg,#71c6f4,#0d70a5)}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbDpzcGFjZT0icHJlc2VydmUiIHZpZXdCb3g9IjAgMCA0MDAgNDAwIj48cGF0aCBkPSJNNDAwIDIwMGMwIDExMC41LTg5LjUgMjAwLTIwMCAyMDBTMCAzMTAuNSAwIDIwMCA4OS41IDAgMjAwIDBzMjAwIDg5LjUgMjAwIDIwME0xNjMuNCAzMDUuNWM4OC43IDAgMTM3LjItNzMuNSAxMzcuMi0xMzcuMiAwLTIuMSAwLTQuMi0uMS02LjIgOS40LTYuOCAxNy42LTE1LjMgMjQuMS0yNS04LjYgMy44LTE3LjkgNi40LTI3LjcgNy42IDEwLTYgMTcuNi0xNS40IDIxLjItMjYuNy05LjMgNS41LTE5LjYgOS41LTMwLjYgMTEuNy04LjgtOS40LTIxLjMtMTUuMi0zNS4yLTE1LjItMjYuNiAwLTQ4LjIgMjEuNi00OC4yIDQ4LjIgMCAzLjguNCA3LjUgMS4zIDExLTQwLjEtMi03NS42LTIxLjItOTkuNC01MC40LTQuMSA3LjEtNi41IDE1LjQtNi41IDI0LjIgMCAxNi43IDguNSAzMS41IDIxLjUgNDAuMS03LjktLjItMTUuMy0yLjQtMjEuOC02di42YzAgMjMuNCAxNi42IDQyLjggMzguNyA0Ny4zLTQgMS4xLTguMyAxLjctMTIuNyAxLjctMy4xIDAtNi4xLS4zLTkuMS0uOSA2LjEgMTkuMiAyMy45IDMzLjEgNDUgMzMuNS0xNi41IDEyLjktMzcuMyAyMC42LTU5LjkgMjAuNi0zLjkgMC03LjctLjItMTEuNS0uNyAyMS4xIDEzLjggNDYuNSAyMS44IDczLjcgMjEuOCIgc3R5bGU9ImZpbGw6I2ZmZiIvPjwvc3ZnPg==)}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder .ck-media__placeholder__url__text{color:#b8e6ff}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder .ck-media__placeholder__url__text:hover{color:#fff}', "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-media-embed/theme/mediaembedediting.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-media-embed/mediaembedediting.css"],
                    names: [],
                    mappings: "AAMC,0CAGC,kBAAmB,CAFnB,YAAa,CACb,qBAcD,CAXC,sEAEC,cAAe,CAEf,iBAMD,CAJC,wGAEC,aAAc,CADd,eAED,CAWD,6kBACC,YACD,CAYF,2LACC,mBACD,CC1CA,MACC,0CAA2C,CAE3C,mDAA4D,CAC5D,2EACD,CAEA,mBACC,aA+FD,CA7FC,0CAEC,0CAA2C,CAD3C,0CA6BD,CA1BC,uEAIC,uBAA2B,CAC3B,qBAAsB,CAHtB,kDAAmD,CACnD,qCAAsC,CAFtC,qDAUD,CAJC,gFAEC,WAAY,CADZ,UAED,CAGD,4EACC,sDAAuD,CAGvD,iBAAkB,CADlB,iBAAkB,CAElB,sBAAuB,CAHvB,kBAUD,CALC,kFACC,4DAA6D,CAC7D,cAAe,CACf,yBACD,CAIF,wDAEC,gBAAiB,CADjB,eAED,CAEA,4UAIC,goGACD,CAEA,2EACC,kBAaD,CAXC,wGACC,orBACD,CAEA,6GACC,UAKD,CAHC,mHACC,UACD,CAIF,4EACC,2DAcD,CAZC,yGACC,o+GACD,CAGA,8GACC,aAKD,CAHC,oHACC,UACD,CAIF,6EAEC,iDAaD,CAXC,0GACC,g/BACD,CAEA,+GACC,aAKD,CAHC,qHACC,UACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck-media__wrapper {
	& .ck-media__placeholder {
		display: flex;
		flex-direction: column;
		align-items: center;

		& .ck-media__placeholder__url {
			/* Otherwise the URL will overflow when the content is very narrow. */
			max-width: 100%;

			position: relative;

			& .ck-media__placeholder__url__text {
				overflow: hidden;
				display: block;
			}
		}
	}

	&[data-oembed-url*="twitter.com"],
	&[data-oembed-url*="google.com/maps"],
	&[data-oembed-url*="goo.gl/maps"],
	&[data-oembed-url*="maps.google.com"],
	&[data-oembed-url*="maps.app.goo.gl"],
	&[data-oembed-url*="facebook.com"],
	&[data-oembed-url*="instagram.com"] {
		& .ck-media__placeholder__icon * {
			display: none;
		}
	}
}

/* Disable all mouse interaction as long as the editor is not read–only.
   https://github.com/ckeditor/ckeditor5-media-embed/issues/58 */
.ck-editor__editable:not(.ck-read-only) .ck-media__wrapper > *:not(.ck-media__placeholder) {
	pointer-events: none;
}

/* Disable all mouse interaction when the widget is not selected (e.g. to avoid opening links by accident).
   https://github.com/ckeditor/ckeditor5-media-embed/issues/18 */
.ck-editor__editable:not(.ck-read-only) .ck-widget:not(.ck-widget_selected) .ck-media__placeholder {
	pointer-events: none;
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-media-embed-placeholder-icon-size: 3em;

	--ck-color-media-embed-placeholder-url-text: hsl(0, 0%, 46%);
	--ck-color-media-embed-placeholder-url-text-hover: var(--ck-color-base-text);
}

.ck-media__wrapper {
	margin: 0 auto;

	& .ck-media__placeholder {
		padding: calc( 3 * var(--ck-spacing-standard) );
		background: var(--ck-color-base-foreground);

		& .ck-media__placeholder__icon {
			min-width: var(--ck-media-embed-placeholder-icon-size);
			height: var(--ck-media-embed-placeholder-icon-size);
			margin-bottom: var(--ck-spacing-large);
			background-position: center;
			background-size: cover;

			& .ck-icon {
				width: 100%;
				height: 100%;
			}
		}

		& .ck-media__placeholder__url__text {
			color: var(--ck-color-media-embed-placeholder-url-text);
			white-space: nowrap;
			text-align: center;
			font-style: italic;
			text-overflow: ellipsis;

			&:hover {
				color: var(--ck-color-media-embed-placeholder-url-text-hover);
				cursor: pointer;
				text-decoration: underline;
			}
		}
	}

	&[data-oembed-url*="open.spotify.com"] {
		max-width: 300px;
		max-height: 380px;
	}

	&[data-oembed-url*="google.com/maps"] .ck-media__placeholder__icon,
	&[data-oembed-url*="goo.gl/maps"] .ck-media__placeholder__icon,
	&[data-oembed-url*="maps.google.com"] .ck-media__placeholder__icon,
	&[data-oembed-url*="maps.app.goo.gl"] .ck-media__placeholder__icon {
		background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNTAuMzc4IiBoZWlnaHQ9IjI1NC4xNjciIHZpZXdCb3g9IjAgMCA2Ni4yNDYgNjcuMjQ4Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTcyLjUzMSAtMjE4LjQ1NSkgc2NhbGUoLjk4MDEyKSI+PHJlY3Qgcnk9IjUuMjM4IiByeD0iNS4yMzgiIHk9IjIzMS4zOTkiIHg9IjE3Ni4wMzEiIGhlaWdodD0iNjAuMDk5IiB3aWR0aD0iNjAuMDk5IiBmaWxsPSIjMzRhNjY4IiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjxwYXRoIGQ9Ik0yMDYuNDc3IDI2MC45bC0yOC45ODcgMjguOTg3YTUuMjE4IDUuMjE4IDAgMCAwIDMuNzggMS42MWg0OS42MjFjMS42OTQgMCAzLjE5LS43OTggNC4xNDYtMi4wMzd6IiBmaWxsPSIjNWM4OGM1Ii8+PHBhdGggZD0iTTIyNi43NDIgMjIyLjk4OGMtOS4yNjYgMC0xNi43NzcgNy4xNy0xNi43NzcgMTYuMDE0LjAwNyAyLjc2Mi42NjMgNS40NzQgMi4wOTMgNy44NzUuNDMuNzAzLjgzIDEuNDA4IDEuMTkgMi4xMDcuMzMzLjUwMi42NSAxLjAwNS45NSAxLjUwOC4zNDMuNDc3LjY3My45NTcuOTg4IDEuNDQgMS4zMSAxLjc2OSAyLjUgMy41MDIgMy42MzcgNS4xNjguNzkzIDEuMjc1IDEuNjgzIDIuNjQgMi40NjYgMy45OSAyLjM2MyA0LjA5NCA0LjAwNyA4LjA5MiA0LjYgMTMuOTE0di4wMTJjLjE4Mi40MTIuNTE2LjY2Ni44NzkuNjY3LjQwMy0uMDAxLjc2OC0uMzE0LjkzLS43OTkuNjAzLTUuNzU2IDIuMjM4LTkuNzI5IDQuNTg1LTEzLjc5NC43ODItMS4zNSAxLjY3My0yLjcxNSAyLjQ2NS0zLjk5IDEuMTM3LTEuNjY2IDIuMzI4LTMuNCAzLjYzOC01LjE2OS4zMTUtLjQ4Mi42NDUtLjk2Mi45ODgtMS40MzkuMy0uNTAzLjYxNy0xLjAwNi45NS0xLjUwOC4zNTktLjcuNzYtMS40MDQgMS4xOS0yLjEwNyAxLjQyNi0yLjQwMiAyLTUuMTE0IDIuMDA0LTcuODc1IDAtOC44NDQtNy41MTEtMTYuMDE0LTE2Ljc3Ni0xNi4wMTR6IiBmaWxsPSIjZGQ0YjNlIiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjxlbGxpcHNlIHJ5PSI1LjU2NCIgcng9IjUuODI4IiBjeT0iMjM5LjAwMiIgY3g9IjIyNi43NDIiIGZpbGw9IiM4MDJkMjciIHBhaW50LW9yZGVyPSJtYXJrZXJzIHN0cm9rZSBmaWxsIi8+PHBhdGggZD0iTTE5MC4zMDEgMjM3LjI4M2MtNC42NyAwLTguNDU3IDMuODUzLTguNDU3IDguNjA2czMuNzg2IDguNjA3IDguNDU3IDguNjA3YzMuMDQzIDAgNC44MDYtLjk1OCA2LjMzNy0yLjUxNiAxLjUzLTEuNTU3IDIuMDg3LTMuOTEzIDIuMDg3LTYuMjkgMC0uMzYyLS4wMjMtLjcyMi0uMDY0LTEuMDc5aC04LjI1N3YzLjA0M2g0Ljg1Yy0uMTk3Ljc1OS0uNTMxIDEuNDUtMS4wNTggMS45ODYtLjk0Mi45NTgtMi4wMjggMS41NDgtMy45MDEgMS41NDgtMi44NzYgMC01LjIwOC0yLjM3Mi01LjIwOC01LjI5OSAwLTIuOTI2IDIuMzMyLTUuMjk5IDUuMjA4LTUuMjk5IDEuMzk5IDAgMi42MTguNDA3IDMuNTg0IDEuMjkzbDIuMzgxLTIuMzhjMC0uMDAyLS4wMDMtLjAwNC0uMDA0LS4wMDUtMS41ODgtMS41MjQtMy42Mi0yLjIxNS01Ljk1NS0yLjIxNXptNC40MyA1LjY2bC4wMDMuMDA2di0uMDAzeiIgZmlsbD0iI2ZmZiIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48cGF0aCBkPSJNMjE1LjE4NCAyNTEuOTI5bC03Ljk4IDcuOTc5IDI4LjQ3NyAyOC40NzVjLjI4Ny0uNjQ5LjQ0OS0xLjM2Ni40NDktMi4xMjN2LTMxLjE2NWMtLjQ2OS42NzUtLjkzNCAxLjM0OS0xLjM4MiAyLjAwNS0uNzkyIDEuMjc1LTEuNjgyIDIuNjQtMi40NjUgMy45OS0yLjM0NyA0LjA2NS0zLjk4MiA4LjAzOC00LjU4NSAxMy43OTQtLjE2Mi40ODUtLjUyNy43OTgtLjkzLjc5OS0uMzYzLS4wMDEtLjY5Ny0uMjU1LS44NzktLjY2N3YtLjAxMmMtLjU5My01LjgyMi0yLjIzNy05LjgyLTQuNi0xMy45MTQtLjc4My0xLjM1LTEuNjczLTIuNzE1LTIuNDY2LTMuOTktMS4xMzctMS42NjYtMi4zMjctMy40LTMuNjM3LTUuMTY5bC0uMDAyLS4wMDN6IiBmaWxsPSIjYzNjM2MzIi8+PHBhdGggZD0iTTIxMi45ODMgMjQ4LjQ5NWwtMzYuOTUyIDM2Ljk1M3YuODEyYTUuMjI3IDUuMjI3IDAgMCAwIDUuMjM4IDUuMjM4aDEuMDE1bDM1LjY2Ni0zNS42NjZhMTM2LjI3NSAxMzYuMjc1IDAgMCAwLTIuNzY0LTMuOSAzNy41NzUgMzcuNTc1IDAgMCAwLS45ODktMS40NGMtLjI5OS0uNTAzLS42MTYtMS4wMDYtLjk1LTEuNTA4LS4wODMtLjE2Mi0uMTc2LS4zMjYtLjI2NC0uNDg5eiIgZmlsbD0iI2ZkZGM0ZiIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48cGF0aCBkPSJNMjExLjk5OCAyNjEuMDgzbC02LjE1MiA2LjE1MSAyNC4yNjQgMjQuMjY0aC43ODFhNS4yMjcgNS4yMjcgMCAwIDAgNS4yMzktNS4yMzh2LTEuMDQ1eiIgZmlsbD0iI2ZmZiIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48L2c+PC9zdmc+);
	}

	&[data-oembed-url*="facebook.com"] .ck-media__placeholder {
		background: hsl(220, 46%, 48%);

		& .ck-media__placeholder__icon {
			background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIHdpZHRoPSIxMDI0cHgiIGhlaWdodD0iMTAyNHB4IiB2aWV3Qm94PSIwIDAgMTAyNCAxMDI0IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPiAgICAgICAgPHRpdGxlPkZpbGwgMTwvdGl0bGU+ICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPiAgICA8ZGVmcz48L2RlZnM+ICAgIDxnIGlkPSJQYWdlLTEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPiAgICAgICAgPGcgaWQ9ImZMb2dvX1doaXRlIiBmaWxsPSIjRkZGRkZFIj4gICAgICAgICAgICA8cGF0aCBkPSJNOTY3LjQ4NCwwIEw1Ni41MTcsMCBDMjUuMzA0LDAgMCwyNS4zMDQgMCw1Ni41MTcgTDAsOTY3LjQ4MyBDMCw5OTguNjk0IDI1LjI5NywxMDI0IDU2LjUyMiwxMDI0IEw1NDcsMTAyNCBMNTQ3LDYyOCBMNDE0LDYyOCBMNDE0LDQ3MyBMNTQ3LDQ3MyBMNTQ3LDM1OS4wMjkgQzU0NywyMjYuNzY3IDYyNy43NzMsMTU0Ljc0NyA3NDUuNzU2LDE1NC43NDcgQzgwMi4yNjksMTU0Ljc0NyA4NTAuODQyLDE1OC45NTUgODY1LDE2MC44MzYgTDg2NSwyOTkgTDc4My4zODQsMjk5LjAzNyBDNzE5LjM5MSwyOTkuMDM3IDcwNywzMjkuNTI5IDcwNywzNzQuMjczIEw3MDcsNDczIEw4NjAuNDg3LDQ3MyBMODQwLjUwMSw2MjggTDcwNyw2MjggTDcwNywxMDI0IEw5NjcuNDg0LDEwMjQgQzk5OC42OTcsMTAyNCAxMDI0LDk5OC42OTcgMTAyNCw5NjcuNDg0IEwxMDI0LDU2LjUxNSBDMTAyNCwyNS4zMDMgOTk4LjY5NywwIDk2Ny40ODQsMCIgaWQ9IkZpbGwtMSI+PC9wYXRoPiAgICAgICAgPC9nPiAgICA8L2c+PC9zdmc+);
		}

		& .ck-media__placeholder__url__text {
			color: hsl(220, 100%, 90%);

			&:hover {
				color: hsl(0, 0%, 100%);
			}
		}
	}

	&[data-oembed-url*="instagram.com"] .ck-media__placeholder {
		background: linear-gradient(-135deg,hsl(246, 100%, 39%),hsl(302, 100%, 36%),hsl(0, 100%, 48%));

		& .ck-media__placeholder__icon {
			background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIHdpZHRoPSI1MDRweCIgaGVpZ2h0PSI1MDRweCIgdmlld0JveD0iMCAwIDUwNCA1MDQiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+ICAgICAgICA8dGl0bGU+Z2x5cGgtbG9nb19NYXkyMDE2PC90aXRsZT4gICAgPGRlc2M+Q3JlYXRlZCB3aXRoIFNrZXRjaC48L2Rlc2M+ICAgIDxkZWZzPiAgICAgICAgPHBvbHlnb24gaWQ9InBhdGgtMSIgcG9pbnRzPSIwIDAuMTU5IDUwMy44NDEgMC4xNTkgNTAzLjg0MSA1MDMuOTQgMCA1MDMuOTQiPjwvcG9seWdvbj4gICAgPC9kZWZzPiAgICA8ZyBpZD0iZ2x5cGgtbG9nb19NYXkyMDE2IiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4gICAgICAgIDxnIGlkPSJHcm91cC0zIj4gICAgICAgICAgICA8bWFzayBpZD0ibWFzay0yIiBmaWxsPSJ3aGl0ZSI+ICAgICAgICAgICAgICAgIDx1c2UgeGxpbms6aHJlZj0iI3BhdGgtMSI+PC91c2U+ICAgICAgICAgICAgPC9tYXNrPiAgICAgICAgICAgIDxnIGlkPSJDbGlwLTIiPjwvZz4gICAgICAgICAgICA8cGF0aCBkPSJNMjUxLjkyMSwwLjE1OSBDMTgzLjUwMywwLjE1OSAxNzQuOTI0LDAuNDQ5IDE0OC4wNTQsMS42NzUgQzEyMS4yNCwyLjg5OCAxMDIuOTI3LDcuMTU3IDg2LjkwMywxMy4zODUgQzcwLjMzNywxOS44MjIgNTYuMjg4LDI4LjQzNiA0Mi4yODIsNDIuNDQxIEMyOC4yNzcsNTYuNDQ3IDE5LjY2Myw3MC40OTYgMTMuMjI2LDg3LjA2MiBDNi45OTgsMTAzLjA4NiAyLjczOSwxMjEuMzk5IDEuNTE2LDE0OC4yMTMgQzAuMjksMTc1LjA4MyAwLDE4My42NjIgMCwyNTIuMDggQzAsMzIwLjQ5NyAwLjI5LDMyOS4wNzYgMS41MTYsMzU1Ljk0NiBDMi43MzksMzgyLjc2IDYuOTk4LDQwMS4wNzMgMTMuMjI2LDQxNy4wOTcgQzE5LjY2Myw0MzMuNjYzIDI4LjI3Nyw0NDcuNzEyIDQyLjI4Miw0NjEuNzE4IEM1Ni4yODgsNDc1LjcyMyA3MC4zMzcsNDg0LjMzNyA4Ni45MDMsNDkwLjc3NSBDMTAyLjkyNyw0OTcuMDAyIDEyMS4yNCw1MDEuMjYxIDE0OC4wNTQsNTAyLjQ4NCBDMTc0LjkyNCw1MDMuNzEgMTgzLjUwMyw1MDQgMjUxLjkyMSw1MDQgQzMyMC4zMzgsNTA0IDMyOC45MTcsNTAzLjcxIDM1NS43ODcsNTAyLjQ4NCBDMzgyLjYwMSw1MDEuMjYxIDQwMC45MTQsNDk3LjAwMiA0MTYuOTM4LDQ5MC43NzUgQzQzMy41MDQsNDg0LjMzNyA0NDcuNTUzLDQ3NS43MjMgNDYxLjU1OSw0NjEuNzE4IEM0NzUuNTY0LDQ0Ny43MTIgNDg0LjE3OCw0MzMuNjYzIDQ5MC42MTYsNDE3LjA5NyBDNDk2Ljg0Myw0MDEuMDczIDUwMS4xMDIsMzgyLjc2IDUwMi4zMjUsMzU1Ljk0NiBDNTAzLjU1MSwzMjkuMDc2IDUwMy44NDEsMzIwLjQ5NyA1MDMuODQxLDI1Mi4wOCBDNTAzLjg0MSwxODMuNjYyIDUwMy41NTEsMTc1LjA4MyA1MDIuMzI1LDE0OC4yMTMgQzUwMS4xMDIsMTIxLjM5OSA0OTYuODQzLDEwMy4wODYgNDkwLjYxNiw4Ny4wNjIgQzQ4NC4xNzgsNzAuNDk2IDQ3NS41NjQsNTYuNDQ3IDQ2MS41NTksNDIuNDQxIEM0NDcuNTUzLDI4LjQzNiA0MzMuNTA0LDE5LjgyMiA0MTYuOTM4LDEzLjM4NSBDNDAwLjkxNCw3LjE1NyAzODIuNjAxLDIuODk4IDM1NS43ODcsMS42NzUgQzMyOC45MTcsMC40NDkgMzIwLjMzOCwwLjE1OSAyNTEuOTIxLDAuMTU5IFogTTI1MS45MjEsNDUuNTUgQzMxOS4xODYsNDUuNTUgMzI3LjE1NCw0NS44MDcgMzUzLjcxOCw0Ny4wMTkgQzM3OC4yOCw0OC4xMzkgMzkxLjYxOSw1Mi4yNDMgNDAwLjQ5Niw1NS42OTMgQzQxMi4yNTUsNjAuMjYzIDQyMC42NDcsNjUuNzIyIDQyOS40NjIsNzQuNTM4IEM0MzguMjc4LDgzLjM1MyA0NDMuNzM3LDkxLjc0NSA0NDguMzA3LDEwMy41MDQgQzQ1MS43NTcsMTEyLjM4MSA0NTUuODYxLDEyNS43MiA0NTYuOTgxLDE1MC4yODIgQzQ1OC4xOTMsMTc2Ljg0NiA0NTguNDUsMTg0LjgxNCA0NTguNDUsMjUyLjA4IEM0NTguNDUsMzE5LjM0NSA0NTguMTkzLDMyNy4zMTMgNDU2Ljk4MSwzNTMuODc3IEM0NTUuODYxLDM3OC40MzkgNDUxLjc1NywzOTEuNzc4IDQ0OC4zMDcsNDAwLjY1NSBDNDQzLjczNyw0MTIuNDE0IDQzOC4yNzgsNDIwLjgwNiA0MjkuNDYyLDQyOS42MjEgQzQyMC42NDcsNDM4LjQzNyA0MTIuMjU1LDQ0My44OTYgNDAwLjQ5Niw0NDguNDY2IEMzOTEuNjE5LDQ1MS45MTYgMzc4LjI4LDQ1Ni4wMiAzNTMuNzE4LDQ1Ny4xNCBDMzI3LjE1OCw0NTguMzUyIDMxOS4xOTEsNDU4LjYwOSAyNTEuOTIxLDQ1OC42MDkgQzE4NC42NSw0NTguNjA5IDE3Ni42ODQsNDU4LjM1MiAxNTAuMTIzLDQ1Ny4xNCBDMTI1LjU2MSw0NTYuMDIgMTEyLjIyMiw0NTEuOTE2IDEwMy4zNDUsNDQ4LjQ2NiBDOTEuNTg2LDQ0My44OTYgODMuMTk0LDQzOC40MzcgNzQuMzc5LDQyOS42MjEgQzY1LjU2NCw0MjAuODA2IDYwLjEwNCw0MTIuNDE0IDU1LjUzNCw0MDAuNjU1IEM1Mi4wODQsMzkxLjc3OCA0Ny45OCwzNzguNDM5IDQ2Ljg2LDM1My44NzcgQzQ1LjY0OCwzMjcuMzEzIDQ1LjM5MSwzMTkuMzQ1IDQ1LjM5MSwyNTIuMDggQzQ1LjM5MSwxODQuODE0IDQ1LjY0OCwxNzYuODQ2IDQ2Ljg2LDE1MC4yODIgQzQ3Ljk4LDEyNS43MiA1Mi4wODQsMTEyLjM4MSA1NS41MzQsMTAzLjUwNCBDNjAuMTA0LDkxLjc0NSA2NS41NjMsODMuMzUzIDc0LjM3OSw3NC41MzggQzgzLjE5NCw2NS43MjIgOTEuNTg2LDYwLjI2MyAxMDMuMzQ1LDU1LjY5MyBDMTEyLjIyMiw1Mi4yNDMgMTI1LjU2MSw0OC4xMzkgMTUwLjEyMyw0Ny4wMTkgQzE3Ni42ODcsNDUuODA3IDE4NC42NTUsNDUuNTUgMjUxLjkyMSw0NS41NSBaIiBpZD0iRmlsbC0xIiBmaWxsPSIjRkZGRkZGIiBtYXNrPSJ1cmwoI21hc2stMikiPjwvcGF0aD4gICAgICAgIDwvZz4gICAgICAgIDxwYXRoIGQ9Ik0yNTEuOTIxLDMzNi4wNTMgQzIwNS41NDMsMzM2LjA1MyAxNjcuOTQ3LDI5OC40NTcgMTY3Ljk0NywyNTIuMDggQzE2Ny45NDcsMjA1LjcwMiAyMDUuNTQzLDE2OC4xMDYgMjUxLjkyMSwxNjguMTA2IEMyOTguMjk4LDE2OC4xMDYgMzM1Ljg5NCwyMDUuNzAyIDMzNS44OTQsMjUyLjA4IEMzMzUuODk0LDI5OC40NTcgMjk4LjI5OCwzMzYuMDUzIDI1MS45MjEsMzM2LjA1MyBaIE0yNTEuOTIxLDEyMi43MTUgQzE4MC40NzQsMTIyLjcxNSAxMjIuNTU2LDE4MC42MzMgMTIyLjU1NiwyNTIuMDggQzEyMi41NTYsMzIzLjUyNiAxODAuNDc0LDM4MS40NDQgMjUxLjkyMSwzODEuNDQ0IEMzMjMuMzY3LDM4MS40NDQgMzgxLjI4NSwzMjMuNTI2IDM4MS4yODUsMjUyLjA4IEMzODEuMjg1LDE4MC42MzMgMzIzLjM2NywxMjIuNzE1IDI1MS45MjEsMTIyLjcxNSBaIiBpZD0iRmlsbC00IiBmaWxsPSIjRkZGRkZGIj48L3BhdGg+ICAgICAgICA8cGF0aCBkPSJNNDE2LjYyNywxMTcuNjA0IEM0MTYuNjI3LDEzNC4zIDQwMy4wOTIsMTQ3LjgzNCAzODYuMzk2LDE0Ny44MzQgQzM2OS43MDEsMTQ3LjgzNCAzNTYuMTY2LDEzNC4zIDM1Ni4xNjYsMTE3LjYwNCBDMzU2LjE2NiwxMDAuOTA4IDM2OS43MDEsODcuMzczIDM4Ni4zOTYsODcuMzczIEM0MDMuMDkyLDg3LjM3MyA0MTYuNjI3LDEwMC45MDggNDE2LjYyNywxMTcuNjA0IiBpZD0iRmlsbC01IiBmaWxsPSIjRkZGRkZGIj48L3BhdGg+ICAgIDwvZz48L3N2Zz4=);
		}

		/* stylelint-disable-next-line no-descending-specificity */
		& .ck-media__placeholder__url__text {
			color: hsl(302, 100%, 94%);

			&:hover {
				color: hsl(0, 0%, 100%);
			}
		}
	}

	&[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder {
		/* Use gradient to contrast with focused widget (ckeditor/ckeditor5-media-embed#22). */
		background: linear-gradient( to right, hsl(201, 85%, 70%), hsl(201, 85%, 35%) );

		& .ck-media__placeholder__icon {
			background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48c3ZnIHZlcnNpb249IjEuMSIgaWQ9IldoaXRlIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCIgdmlld0JveD0iMCAwIDQwMCA0MDAiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDQwMCA0MDA7IiB4bWw6c3BhY2U9InByZXNlcnZlIj48c3R5bGUgdHlwZT0idGV4dC9jc3MiPi5zdDB7ZmlsbDojRkZGRkZGO308L3N0eWxlPjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik00MDAsMjAwYzAsMTEwLjUtODkuNSwyMDAtMjAwLDIwMFMwLDMxMC41LDAsMjAwUzg5LjUsMCwyMDAsMFM0MDAsODkuNSw0MDAsMjAweiBNMTYzLjQsMzA1LjVjODguNywwLDEzNy4yLTczLjUsMTM3LjItMTM3LjJjMC0yLjEsMC00LjItMC4xLTYuMmM5LjQtNi44LDE3LjYtMTUuMywyNC4xLTI1Yy04LjYsMy44LTE3LjksNi40LTI3LjcsNy42YzEwLTYsMTcuNi0xNS40LDIxLjItMjYuN2MtOS4zLDUuNS0xOS42LDkuNS0zMC42LDExLjdjLTguOC05LjQtMjEuMy0xNS4yLTM1LjItMTUuMmMtMjYuNiwwLTQ4LjIsMjEuNi00OC4yLDQ4LjJjMCwzLjgsMC40LDcuNSwxLjMsMTFjLTQwLjEtMi03NS42LTIxLjItOTkuNC01MC40Yy00LjEsNy4xLTYuNSwxNS40LTYuNSwyNC4yYzAsMTYuNyw4LjUsMzEuNSwyMS41LDQwLjFjLTcuOS0wLjItMTUuMy0yLjQtMjEuOC02YzAsMC4yLDAsMC40LDAsMC42YzAsMjMuNCwxNi42LDQyLjgsMzguNyw0Ny4zYy00LDEuMS04LjMsMS43LTEyLjcsMS43Yy0zLjEsMC02LjEtMC4zLTkuMS0wLjljNi4xLDE5LjIsMjMuOSwzMy4xLDQ1LDMzLjVjLTE2LjUsMTIuOS0zNy4zLDIwLjYtNTkuOSwyMC42Yy0zLjksMC03LjctMC4yLTExLjUtMC43QzExMC44LDI5Ny41LDEzNi4yLDMwNS41LDE2My40LDMwNS41Ii8+PC9zdmc+);
		}

		& .ck-media__placeholder__url__text {
			color: hsl(201, 100%, 86%);

			&:hover {
				color: hsl(0, 0%, 100%);
			}
		}
	}
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            5651: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck.ck-media-form{align-items:flex-start;display:flex;flex-direction:row;flex-wrap:nowrap;width:400px}.ck.ck-media-form .ck-labeled-field-view{display:inline-block;width:100%}.ck.ck-media-form .ck-label{display:none}.ck.ck-media-form .ck-input{width:100%}@media screen and (max-width:600px){.ck.ck-media-form{flex-wrap:wrap}.ck.ck-media-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-media-form .ck-button{flex-basis:50%}}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-media-embed/theme/mediaform.css", "webpack://./../ckeditor5-ui/theme/mixins/_rwd.css"],
                    names: [],
                    mappings: "AAOA,kBAEC,sBAAuB,CADvB,YAAa,CAEb,kBAAmB,CACnB,gBAAiB,CACjB,WA0BD,CAxBC,yCACC,oBAAqB,CACrB,UACD,CAEA,4BACC,YACD,CAEA,4BACC,UACD,CCnBA,oCDCD,kBAqBE,cAUF,CARE,yCACC,eACD,CAEA,6BACC,cACD,CC5BD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";

.ck.ck-media-form {
	display: flex;
	align-items: flex-start;
	flex-direction: row;
	flex-wrap: nowrap;
	width: 400px;

	& .ck-labeled-field-view {
		display: inline-block;
		width: 100%;
	}

	& .ck-label {
		display: none;
	}

	& .ck-input {
		width: 100%;
	}

	@mixin ck-media-phone {
		flex-wrap: wrap;

		& .ck-labeled-field-view {
			flex-basis: 100%;
		}

		& .ck-button {
			flex-basis: 50%;
		}
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@define-mixin ck-media-phone {
	@media screen and (max-width: 600px) {
		@mixin-content;
	}
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            5506: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck.ck-input-color{display:flex;flex-direction:row-reverse;width:100%}.ck.ck-input-color>input.ck.ck-input-text{flex-grow:1;min-width:auto}.ck.ck-input-color>div.ck.ck-dropdown{min-width:auto}.ck.ck-input-color>div.ck.ck-dropdown>.ck-input-color__button .ck-dropdown__arrow{display:none}.ck.ck-input-color .ck.ck-input-color__button{display:flex}.ck.ck-input-color .ck.ck-input-color__button .ck.ck-input-color__button__preview{overflow:hidden;position:relative}.ck.ck-input-color .ck.ck-input-color__button .ck.ck-input-color__button__preview>.ck.ck-input-color__button__preview__no-color-indicator{display:block;position:absolute}[dir=ltr] .ck.ck-input-color>.ck.ck-input-text{border-bottom-right-radius:0;border-top-right-radius:0}[dir=rtl] .ck.ck-input-color>.ck.ck-input-text{border-bottom-left-radius:0;border-top-left-radius:0}.ck.ck-input-color>.ck.ck-input-text:focus{z-index:0}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button{padding:0}[dir=ltr] .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button{border-bottom-left-radius:0;border-top-left-radius:0}[dir=ltr] .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button:not(:focus){border-left:1px solid transparent}[dir=rtl] .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button{border-bottom-right-radius:0;border-top-right-radius:0}[dir=rtl] .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button:not(:focus){border-right:1px solid transparent}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button.ck-disabled{background:var(--ck-color-input-disabled-background)}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview{border-radius:0}.ck-rounded-corners .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview,.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview{border:1px solid var(--ck-color-input-border);height:20px;width:20px}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview>.ck.ck-input-color__button__preview__no-color-indicator{background:red;border-radius:2px;height:150%;left:50%;top:-30%;transform:rotate(45deg);transform-origin:50%;width:8%}.ck.ck-input-color .ck.ck-input-color__remove-color{border-bottom-left-radius:0;border-bottom-right-radius:0;padding:calc(var(--ck-spacing-standard)/2) var(--ck-spacing-standard);width:100%}.ck.ck-input-color .ck.ck-input-color__remove-color:not(:focus){border-bottom:1px solid var(--ck-color-input-border)}[dir=ltr] .ck.ck-input-color .ck.ck-input-color__remove-color{border-top-right-radius:0}[dir=rtl] .ck.ck-input-color .ck.ck-input-color__remove-color{border-top-left-radius:0}.ck.ck-input-color .ck.ck-input-color__remove-color .ck.ck-icon{margin-right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-input-color .ck.ck-input-color__remove-color .ck.ck-icon{margin-left:var(--ck-spacing-standard);margin-right:0}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-table/theme/colorinput.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/colorinput.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"],
                    names: [],
                    mappings: "AAKA,mBAEC,YAAa,CACb,0BAA2B,CAF3B,UAgCD,CA5BC,0CAEC,WAAY,CADZ,cAED,CAEA,sCACC,cAMD,CAHC,kFACC,YACD,CAGD,8CAEC,YAWD,CATC,kFAEC,eAAgB,CADhB,iBAOD,CAJC,0IAEC,aAAc,CADd,iBAED,CC1BF,+CAGE,4BAA6B,CAD7B,yBAcF,CAhBA,+CAQE,2BAA4B,CAD5B,wBASF,CAHC,2CACC,SACD,CAIA,wEACC,SA0CD,CA3CA,kFAKE,2BAA4B,CAD5B,wBAuCF,CApCE,8FACC,iCACD,CATF,kFAcE,4BAA6B,CAD7B,yBA8BF,CA3BE,8FACC,kCACD,CAGD,oFACC,oDACD,CAEA,4GC1CF,eD2DE,CAjBA,+PCtCD,qCDuDC,CAjBA,4GAKC,6CAA8C,CAD9C,WAAY,CADZ,UAcD,CAVC,oKAKC,cAA6B,CAC7B,iBAAkB,CAHlB,WAAY,CADZ,QAAS,CADT,QAAS,CAMT,uBAAwB,CACxB,oBAAqB,CAJrB,QAKD,CAKH,oDAIC,2BAA4B,CAC5B,4BAA6B,CAH7B,qEAAwE,CADxE,UA0BD,CApBC,gEACC,oDACD,CATD,8DAYE,yBAeF,CA3BA,8DAgBE,wBAWF,CARC,gEACC,uCAMD,CAPA,0EAKE,sCAAuC,CADvC,cAGF",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-input-color {
	width: 100%;
	display: flex;
	flex-direction: row-reverse;

	& > input.ck.ck-input-text {
		min-width: auto;
		flex-grow: 1;
	}

	& > div.ck.ck-dropdown {
		min-width: auto;

		/* This dropdown has no arrow but a color preview instead. */
		& > .ck-input-color__button .ck-dropdown__arrow {
			display: none;
		}
	}

	& .ck.ck-input-color__button {
		/* Resolving issue with misaligned buttons on Safari (see #10589) */
		display: flex;

		& .ck.ck-input-color__button__preview {
			position: relative;
			overflow: hidden;

			& > .ck.ck-input-color__button__preview__no-color-indicator {
				position: absolute;
				display: block;
			}
		}
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";
@import "../mixins/_rounded.css";

.ck.ck-input-color {
	& > .ck.ck-input-text {
		@mixin ck-dir ltr {
			border-top-right-radius: 0;
			border-bottom-right-radius: 0;
		}

		@mixin ck-dir rtl {
			border-top-left-radius: 0;
			border-bottom-left-radius: 0;
		}

		/* Make sure the focused input is always on top of the dropdown button so its
		   outline and border are never cropped (also when the input is read-only). */
		&:focus {
			z-index: 0;
		}
	}

	& > .ck.ck-dropdown {
		& > .ck.ck-button.ck-input-color__button {
			padding: 0;

			@mixin ck-dir ltr {
				border-top-left-radius: 0;
				border-bottom-left-radius: 0;

				&:not(:focus) {
					border-left: 1px solid transparent;
				}
			}

			@mixin ck-dir rtl {
				border-top-right-radius: 0;
				border-bottom-right-radius: 0;

				&:not(:focus) {
					border-right: 1px solid transparent;
				}
			}

			&.ck-disabled {
				background: var(--ck-color-input-disabled-background);
			}

			& > .ck.ck-input-color__button__preview {
				@mixin ck-rounded-corners;

				width: 20px;
				height: 20px;
				border: 1px solid var(--ck-color-input-border);

				& > .ck.ck-input-color__button__preview__no-color-indicator {
					top: -30%;
					left: 50%;
					height: 150%;
					width: 8%;
					background: hsl(0, 100%, 50%);
					border-radius: 2px;
					transform: rotate(45deg);
					transform-origin: 50%;
				}
			}
		}
	}

	& .ck.ck-input-color__remove-color {
		width: 100%;
		padding: calc(var(--ck-spacing-standard) / 2) var(--ck-spacing-standard);

		border-bottom-left-radius: 0;
		border-bottom-right-radius: 0;

		&:not(:focus) {
			border-bottom: 1px solid var(--ck-color-input-border);
		}

		@mixin ck-dir ltr {
			border-top-right-radius: 0;
		}

		@mixin ck-dir rtl {
			border-top-left-radius: 0;
		}

		& .ck.ck-icon {
			margin-right: var(--ck-spacing-standard);

			@mixin ck-dir rtl {
				margin-right: 0;
				margin-left: var(--ck-spacing-standard);
			}
		}
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            4043: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck.ck-form{padding:0 0 var(--ck-spacing-large)}.ck.ck-form:focus{outline:none}.ck.ck-form .ck.ck-input-text{min-width:100%;width:0}.ck.ck-form .ck.ck-dropdown{min-width:100%}.ck.ck-form .ck.ck-dropdown .ck-dropdown__button:not(:focus){border:1px solid var(--ck-color-base-border)}.ck.ck-form .ck.ck-dropdown .ck-dropdown__button .ck-button__label{width:100%}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/form.css"],
                    names: [],
                    mappings: "AAKA,YACC,mCAyBD,CAvBC,kBAEC,YACD,CAEA,8BACC,cAAe,CACf,OACD,CAEA,4BACC,cAWD,CARE,6DACC,4CACD,CAEA,mEACC,UACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-form {
	padding: 0 0 var(--ck-spacing-large);

	&:focus {
		/* See: https://github.com/ckeditor/ckeditor5/issues/4773 */
		outline: none;
	}

	& .ck.ck-input-text {
		min-width: 100%;
		width: 0;
	}

	& .ck.ck-dropdown {
		min-width: 100%;

		& .ck-dropdown__button {
			&:not(:focus) {
				border: 1px solid var(--ck-color-base-border);
			}

			& .ck-button__label {
				width: 100%;
			}
		}
	}
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            2655: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck.ck-form__row{display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between}.ck.ck-form__row>:not(.ck-label){flex-grow:1}.ck.ck-form__row.ck-table-form__action-row .ck-button-cancel,.ck.ck-form__row.ck-table-form__action-row .ck-button-save{justify-content:center}.ck.ck-form__row{padding:var(--ck-spacing-standard) var(--ck-spacing-large) 0}[dir=ltr] .ck.ck-form__row>:not(.ck-label)+*{margin-left:var(--ck-spacing-large)}[dir=rtl] .ck.ck-form__row>:not(.ck-label)+*{margin-right:var(--ck-spacing-large)}.ck.ck-form__row>.ck-label{min-width:100%;width:100%}.ck.ck-form__row.ck-table-form__action-row{margin-top:var(--ck-spacing-large)}.ck.ck-form__row.ck-table-form__action-row .ck-button .ck-button__label{color:var(--ck-color-text)}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-table/theme/formrow.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/formrow.css"],
                    names: [],
                    mappings: "AAKA,iBACC,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CACjB,6BAaD,CAVC,iCACC,WACD,CAGC,wHAEC,sBACD,CCbF,iBACC,4DA2BD,CAvBE,6CAEE,mCAMF,CARA,6CAME,oCAEF,CAGD,2BAEC,cAAe,CADf,UAED,CAEA,2CACC,kCAKD,CAHC,wEACC,0BACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-form__row {
	display: flex;
	flex-direction: row;
	flex-wrap: nowrap;
	justify-content: space-between;

	/* Ignore labels that work as fieldset legends */
	& > *:not(.ck-label) {
		flex-grow: 1;
	}

	&.ck-table-form__action-row {
		& .ck-button-save,
		& .ck-button-cancel {
			justify-content: center;
		}
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

.ck.ck-form__row {
	padding: var(--ck-spacing-standard) var(--ck-spacing-large) 0;

	/* Ignore labels that work as fieldset legends */
	& > *:not(.ck-label) {
		& + * {
			@mixin ck-dir ltr {
				margin-left: var(--ck-spacing-large);
			}

			@mixin ck-dir rtl {
				margin-right: var(--ck-spacing-large);
			}
		}
	}

	& > .ck-label {
		width: 100%;
		min-width: 100%;
	}

	&.ck-table-form__action-row {
		margin-top: var(--ck-spacing-large);

		& .ck-button .ck-button__label {
			color: var(--ck-color-text);
		}
	}
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            5032: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck .ck-insert-table-dropdown__grid{display:flex;flex-direction:row;flex-wrap:wrap}:root{--ck-insert-table-dropdown-padding:10px;--ck-insert-table-dropdown-box-height:11px;--ck-insert-table-dropdown-box-width:12px;--ck-insert-table-dropdown-box-margin:1px}.ck .ck-insert-table-dropdown__grid{padding:var(--ck-insert-table-dropdown-padding) var(--ck-insert-table-dropdown-padding) 0;width:calc(var(--ck-insert-table-dropdown-box-width)*10 + var(--ck-insert-table-dropdown-box-margin)*20 + var(--ck-insert-table-dropdown-padding)*2)}.ck .ck-insert-table-dropdown__label,.ck[dir=rtl] .ck-insert-table-dropdown__label{text-align:center}.ck .ck-insert-table-dropdown-grid-box{border:1px solid var(--ck-color-base-border);border-radius:1px;margin:var(--ck-insert-table-dropdown-box-margin);min-height:var(--ck-insert-table-dropdown-box-height);min-width:var(--ck-insert-table-dropdown-box-width);outline:none;transition:none}@media (prefers-reduced-motion:reduce){.ck .ck-insert-table-dropdown-grid-box{transition:none}}.ck .ck-insert-table-dropdown-grid-box:focus{box-shadow:none}.ck .ck-insert-table-dropdown-grid-box.ck-on{background:var(--ck-color-focus-outer-shadow);border-color:var(--ck-color-focus-border)}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-table/theme/inserttable.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/inserttable.css"],
                    names: [],
                    mappings: "AAKA,oCACC,YAAa,CACb,kBAAmB,CACnB,cACD,CCJA,MACC,uCAAwC,CACxC,0CAA2C,CAC3C,yCAA0C,CAC1C,yCACD,CAEA,oCAGC,yFAA0F,CAD1F,oJAED,CAEA,mFAEC,iBACD,CAEA,uCAIC,4CAA6C,CAC7C,iBAAkB,CAFlB,iDAAkD,CADlD,qDAAsD,CADtD,mDAAoD,CAKpD,YAAa,CACb,eAcD,CAZC,uCATD,uCAUE,eAWF,CAVC,CAEA,6CACC,eACD,CAEA,6CAEC,6CAA8C,CAD9C,yCAED",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck .ck-insert-table-dropdown__grid {
	display: flex;
	flex-direction: row;
	flex-wrap: wrap;
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-insert-table-dropdown-padding: 10px;
	--ck-insert-table-dropdown-box-height: 11px;
	--ck-insert-table-dropdown-box-width: 12px;
	--ck-insert-table-dropdown-box-margin: 1px;
}

.ck .ck-insert-table-dropdown__grid {
	/* The width of a container should match 10 items in a row so there will be a 10x10 grid. */
	width: calc(var(--ck-insert-table-dropdown-box-width) * 10 + var(--ck-insert-table-dropdown-box-margin) * 20 + var(--ck-insert-table-dropdown-padding) * 2);
	padding: var(--ck-insert-table-dropdown-padding) var(--ck-insert-table-dropdown-padding) 0;
}

.ck .ck-insert-table-dropdown__label,
.ck[dir=rtl] .ck-insert-table-dropdown__label {
	text-align: center;
}

.ck .ck-insert-table-dropdown-grid-box {
	min-width: var(--ck-insert-table-dropdown-box-width);
	min-height: var(--ck-insert-table-dropdown-box-height);
	margin: var(--ck-insert-table-dropdown-box-margin);
	border: 1px solid var(--ck-color-base-border);
	border-radius: 1px;
	outline: none;
	transition: none;

	@media (prefers-reduced-motion: reduce) {
		transition: none;
	}

	&:focus {
		box-shadow: none;
	}

	&.ck-on {
		border-color: var(--ck-color-focus-border);
		background: var(--ck-color-focus-outer-shadow);
	}
}

`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            2329: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck-content .table{display:table;margin:.9em auto}.ck-content .table table{border:1px double #b3b3b3;border-collapse:collapse;border-spacing:0;height:100%;width:100%}.ck-content .table table td,.ck-content .table table th{border:1px solid #bfbfbf;min-width:2em;padding:.4em}.ck-content .table table th{background:rgba(0,0,0,.05);font-weight:700}.ck-content[dir=rtl] .table th{text-align:right}.ck-content[dir=ltr] .table th{text-align:left}.ck-editor__editable .ck-table-bogus-paragraph{display:inline-block;width:100%}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-table/theme/table.css"],
                    names: [],
                    mappings: "AAKA,mBAKC,aAAc,CADd,gBAiCD,CA9BC,yBAYC,yBAAkC,CAVlC,wBAAyB,CACzB,gBAAiB,CAKjB,WAAY,CADZ,UAsBD,CAfC,wDAQC,wBAAiC,CANjC,aAAc,CACd,YAMD,CAEA,4BAEC,0BAA+B,CAD/B,eAED,CAMF,+BACC,gBACD,CAEA,+BACC,eACD,CAEA,+CAKC,oBAAqB,CAMrB,UACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck-content .table {
	/* Give the table widget some air and center it horizontally */
	/* The first value should be equal to --ck-spacing-large variable if used in the editor context
	to avoid the content jumping (See https://github.com/ckeditor/ckeditor5/issues/9825). */
	margin: 0.9em auto;
	display: table;

	& table {
		/* The table cells should have slight borders */
		border-collapse: collapse;
		border-spacing: 0;

		/* Table width and height are set on the parent <figure>. Make sure the table inside stretches
		to the full dimensions of the container (https://github.com/ckeditor/ckeditor5/issues/6186). */
		width: 100%;
		height: 100%;

		/* The outer border of the table should be slightly darker than the inner lines.
		Also see https://github.com/ckeditor/ckeditor5-table/issues/50. */
		border: 1px double hsl(0, 0%, 70%);

		& td,
		& th {
			min-width: 2em;
			padding: .4em;

			/* The border is inherited from .ck-editor__nested-editable styles, so theoretically it's not necessary here.
			However, the border is a content style, so it should use .ck-content (so it works outside the editor).
			Hence, the duplication. See https://github.com/ckeditor/ckeditor5/issues/6314 */
			border: 1px solid hsl(0, 0%, 75%);
		}

		& th {
			font-weight: bold;
			background: hsla(0, 0%, 0%, 5%);
		}
	}
}

/* Text alignment of the table header should match the editor settings and override the native browser styling,
when content is available outside the editor. See https://github.com/ckeditor/ckeditor5/issues/6638 */
.ck-content[dir="rtl"] .table th {
	text-align: right;
}

.ck-content[dir="ltr"] .table th {
	text-align: left;
}

.ck-editor__editable .ck-table-bogus-paragraph {
	/*
	 * Use display:inline-block to force Chrome/Safari to limit text mutations to this element.
	 * See https://github.com/ckeditor/ckeditor5/issues/6062.
	 */
	display: inline-block;

	/*
	 * Inline HTML elements nested in the span should always be dimensioned in relation to the whole cell width.
	 * See https://github.com/ckeditor/ckeditor5/issues/9117.
	 */
	width: 100%;
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            4143: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ":root{--ck-color-selector-caption-background:#f7f7f7;--ck-color-selector-caption-text:#333;--ck-color-selector-caption-highlighted-background:#fd0}.ck-content .table>figcaption{background-color:var(--ck-color-selector-caption-background);caption-side:top;color:var(--ck-color-selector-caption-text);display:table-caption;font-size:.75em;outline-offset:-1px;padding:.6em;text-align:center;word-break:break-word}@media (forced-colors:active){.ck-content .table>figcaption{background-color:unset;color:unset}}@media (forced-colors:none){.ck.ck-editor__editable .table>figcaption.table__caption_highlighted{animation:ck-table-caption-highlight .6s ease-out}}.ck.ck-editor__editable .table>figcaption.ck-placeholder:before{overflow:hidden;padding-left:inherit;padding-right:inherit;text-overflow:ellipsis;white-space:nowrap}@keyframes ck-table-caption-highlight{0%{background-color:var(--ck-color-selector-caption-highlighted-background)}to{background-color:var(--ck-color-selector-caption-background)}}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-table/theme/tablecaption.css", "webpack://./../ckeditor5-ui/theme/mixins/_mediacolors.css"],
                    names: [],
                    mappings: "AAOA,MACC,8CAAuD,CACvD,qCAAiD,CACjD,uDACD,CAGA,8BAMC,4DAA6D,CAJ7D,gBAAiB,CAGjB,2CAA4C,CAJ5C,qBAAsB,CAOtB,eAAgB,CAChB,mBAAoB,CAFpB,YAAa,CAHb,iBAAkB,CADlB,qBAaD,CCxBC,8BACC,8BDoBA,sBAAuB,CACvB,WCnBA,CACD,CAIA,4BDqBC,qEACC,iDACD,CCnBD,CDsBA,gEASC,eAAgB,CARhB,oBAAqB,CACrB,qBAAsB,CAQtB,sBAAuB,CAFvB,kBAGD,CAGD,sCACC,GACC,wEACD,CAEA,GACC,4DACD,CACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_mediacolors.css";

:root {
	--ck-color-selector-caption-background: hsl(0, 0%, 97%);
	--ck-color-selector-caption-text: hsl(0, 0%, 20%);
	--ck-color-selector-caption-highlighted-background: hsl(52deg 100% 50%);
}

/* Content styles */
.ck-content .table > figcaption {
	display: table-caption;
	caption-side: top;
	word-break: break-word;
	text-align: center;
	color: var(--ck-color-selector-caption-text);
	background-color: var(--ck-color-selector-caption-background);
	padding: .6em;
	font-size: .75em;
	outline-offset: -1px;

	/* Improve placeholder rendering in high-constrast mode (https://github.com/ckeditor/ckeditor5/issues/14907). */
	@mixin ck-media-forced-colors {
		background-color: unset;
		color: unset;
	}
}

/* Editing styles */
.ck.ck-editor__editable .table > figcaption {
	@mixin ck-media-default-colors {
		&.table__caption_highlighted {
			animation: ck-table-caption-highlight .6s ease-out;
		}
	}

	&.ck-placeholder::before {
		padding-left: inherit;
		padding-right: inherit;

		/*
		 * Make sure the table caption placeholder doesn't overflow the placeholder area.
		 * See https://github.com/ckeditor/ckeditor5/issues/9162.
		 */
		white-space: nowrap;
		overflow: hidden;
		text-overflow: ellipsis;
	}
}

@keyframes ck-table-caption-highlight {
	0% {
		background-color: var(--ck-color-selector-caption-highlighted-background);
	}

	100% {
		background-color: var(--ck-color-selector-caption-background);
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@define-mixin ck-media-forced-colors {
	@media (forced-colors: active) {
		& {
			@mixin-content;
		}
	}
}

@define-mixin ck-media-default-colors {
	@media (forced-colors: none) {
		& {
			@mixin-content;
		}
	}
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            8986: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row{flex-wrap:wrap}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row .ck.ck-toolbar:first-of-type{flex-grow:0.57}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row .ck.ck-toolbar:last-of-type{flex-grow:0.43}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row .ck.ck-toolbar .ck-button{flex-grow:1}.ck.ck-table-cell-properties-form{width:320px}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__padding-row{align-self:flex-end;padding:0;width:25%}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row .ck.ck-toolbar{background:none;margin-top:var(--ck-spacing-standard)}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-table/theme/tablecellproperties.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/tablecellproperties.css"],
                    names: [],
                    mappings: "AAOE,6FACC,cAiBD,CAdE,0HAEC,cACD,CAEA,yHAEC,cACD,CAEA,uHACC,WACD,CClBJ,kCACC,WAkBD,CAfE,2FACC,mBAAoB,CACpB,SAAU,CACV,SACD,CAGC,4GACC,eAAgB,CAGhB,qCACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-table-cell-properties-form {
	& .ck-form__row {
		&.ck-table-cell-properties-form__alignment-row {
			flex-wrap: wrap;

			& .ck.ck-toolbar {
				&:first-of-type {
					/* 4 buttons out of 7 (h-alignment + v-alignment) = 0.57 */
					flex-grow: 0.57;
				}

				&:last-of-type {
					/* 3 buttons out of 7 (h-alignment + v-alignment) = 0.43 */
					flex-grow: 0.43;
				}

				& .ck-button {
					flex-grow: 1;
				}
			}
		}
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-table-cell-properties-form {
	width: 320px;

	& .ck-form__row {
		&.ck-table-cell-properties-form__padding-row {
			align-self: flex-end;
			padding: 0;
			width: 25%;
		}

		&.ck-table-cell-properties-form__alignment-row {
			& .ck.ck-toolbar {
				background: none;

				/* Compensate for missing input label that would push the margin (toolbar has no inputs). */
				margin-top: var(--ck-spacing-standard);
			}
		}
	}
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            8795: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ":root{--ck-color-selector-column-resizer-hover:var(--ck-color-base-active);--ck-table-column-resizer-width:7px;--ck-table-column-resizer-position-offset:calc(var(--ck-table-column-resizer-width)*-0.5 - 0.5px)}.ck-content .table .ck-table-resized{table-layout:fixed}.ck-content .table table{overflow:hidden}.ck-content .table td,.ck-content .table th{overflow-wrap:break-word;position:relative}.ck.ck-editor__editable .table .ck-table-column-resizer{bottom:0;cursor:col-resize;position:absolute;right:var(--ck-table-column-resizer-position-offset);top:0;user-select:none;width:var(--ck-table-column-resizer-width);z-index:var(--ck-z-default)}.ck.ck-editor__editable .table[draggable] .ck-table-column-resizer,.ck.ck-editor__editable.ck-column-resize_disabled .table .ck-table-column-resizer{display:none}.ck.ck-editor__editable .table .ck-table-column-resizer:hover,.ck.ck-editor__editable .table .ck-table-column-resizer__active{background-color:var(--ck-color-selector-column-resizer-hover);bottom:-999999px;opacity:.25;top:-999999px}.ck.ck-editor__editable[dir=rtl] .table .ck-table-column-resizer{left:var(--ck-table-column-resizer-position-offset);right:unset}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-table/theme/tablecolumnresize.css"],
                    names: [],
                    mappings: "AAKA,MACC,oEAAqE,CACrE,mCAAoC,CAIpC,iGACD,CAEA,qCACC,kBACD,CAEA,yBACC,eACD,CAEA,4CAIC,wBAAyB,CACzB,iBACD,CAEA,wDAGC,QAAS,CAGT,iBAAkB,CALlB,iBAAkB,CAGlB,oDAAqD,CAFrD,KAAM,CAKN,gBAAiB,CAFjB,0CAA2C,CAG3C,2BACD,CAQA,qJACC,YACD,CAEA,8HAEC,8DAA+D,CAO/D,gBAAiB,CANjB,WAAa,CAKb,aAED,CAEA,iEACC,mDAAoD,CACpD,WACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-color-selector-column-resizer-hover: var(--ck-color-base-active);
	--ck-table-column-resizer-width: 7px;

	/* The offset used for absolute positioning of the resizer element, so that it is placed exactly above the cell border.
	   The value is: minus half the width of the resizer decreased additionaly by the half the width of the border (0.5px). */
	--ck-table-column-resizer-position-offset: calc(var(--ck-table-column-resizer-width) * -0.5 - 0.5px);
}

.ck-content .table .ck-table-resized {
	table-layout: fixed;
}

.ck-content .table table {
	overflow: hidden;
}

.ck-content .table td,
.ck-content .table th {
	/* To prevent text overflowing beyond its cell when columns are resized by resize handler
	(https://github.com/ckeditor/ckeditor5/pull/14379#issuecomment-1589460978). */
	overflow-wrap: break-word;
	position: relative;
}

.ck.ck-editor__editable .table .ck-table-column-resizer {
	position: absolute;
	top: 0;
	bottom: 0;
	right: var(--ck-table-column-resizer-position-offset);
	width: var(--ck-table-column-resizer-width);
	cursor: col-resize;
	user-select: none;
	z-index: var(--ck-z-default);
}

.ck.ck-editor__editable.ck-column-resize_disabled .table .ck-table-column-resizer {
	display: none;
}

/* The resizer elements, which are extended to an extremely high height, break the drag & drop feature in Chrome. To make it work again,
   all resizers must be hidden while the table is dragged. */
.ck.ck-editor__editable .table[draggable] .ck-table-column-resizer {
	display: none;
}

.ck.ck-editor__editable .table .ck-table-column-resizer:hover,
.ck.ck-editor__editable .table .ck-table-column-resizer__active {
	background-color: var(--ck-color-selector-column-resizer-hover);
	opacity: 0.25;
	/* The resizer element resides in each cell so to occupy the entire height of the table, which is unknown from a CSS point of view,
	   it is extended to an extremely high height. Even for screens with a very high pixel density, the resizer will fulfill its role as
	   it should, i.e. for a screen of 476 ppi the total height of the resizer will take over 350 sheets of A4 format, which is totally
	   unrealistic height for a single table. */
	top: -999999px;
	bottom: -999999px;
}

.ck.ck-editor__editable[dir=rtl] .table .ck-table-column-resizer {
	left: var(--ck-table-column-resizer-position-offset);
	right: unset;
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            8137: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ":root{--ck-color-selector-focused-cell-background:rgba(158,201,250,.3)}.ck-widget.table td.ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck-widget.table td.ck-editor__nested-editable:focus,.ck-widget.table th.ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck-widget.table th.ck-editor__nested-editable:focus{background:var(--ck-color-selector-focused-cell-background);border-style:none;outline:1px solid var(--ck-color-focus-border);outline-offset:-1px}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/tableediting.css"],
                    names: [],
                    mappings: "AAKA,MACC,gEACD,CAKE,8QAGC,2DAA4D,CAK5D,iBAAkB,CAClB,8CAA+C,CAC/C,mBACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-color-selector-focused-cell-background: hsla(212, 90%, 80%, .3);
}

.ck-widget.table {
	& td,
	& th {
		&.ck-editor__nested-editable.ck-editor__nested-editable_focused,
		&.ck-editor__nested-editable:focus {
			/* A very slight background to highlight the focused cell */
			background: var(--ck-color-selector-focused-cell-background);

			/* Fixes the problem where surrounding cells cover the focused cell's border.
			It does not fix the problem in all places but the UX is improved.
			See https://github.com/ckeditor/ckeditor5-table/issues/29. */
			border-style: none;
			outline: 1px solid var(--ck-color-focus-border);
			outline-offset: -1px; /* progressive enhancement - no IE support */
		}
	}
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            1623: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, '.ck.ck-table-form .ck-form__row.ck-table-form__background-row,.ck.ck-table-form .ck-form__row.ck-table-form__border-row{flex-wrap:wrap}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row{align-items:center;flex-wrap:wrap}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-labeled-field-view{align-items:center;display:flex;flex-direction:column-reverse}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-labeled-field-view .ck.ck-dropdown,.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimension-operator{flex-grow:0}.ck.ck-table-form .ck.ck-labeled-field-view{position:relative}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{bottom:calc(var(--ck-table-properties-error-arrow-size)*-1);left:50%;position:absolute;transform:translate(-50%,100%);z-index:1}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status:after{content:"";left:50%;position:absolute;top:calc(var(--ck-table-properties-error-arrow-size)*-1);transform:translateX(-50%)}:root{--ck-table-properties-error-arrow-size:6px;--ck-table-properties-min-error-width:150px}.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-labeled-field-view>.ck-label{font-size:var(--ck-font-size-tiny);text-align:center}.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-table-form__border-style,.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-table-form__border-width{max-width:80px;min-width:80px;width:80px}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row{padding:0}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimensions-row__height,.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimensions-row__width{margin:0}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimension-operator{align-self:flex-end;display:inline-block;height:var(--ck-ui-component-min-height);line-height:var(--ck-ui-component-min-height);margin:0 var(--ck-spacing-small)}.ck.ck-table-form .ck.ck-labeled-field-view{padding-top:var(--ck-spacing-standard)}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{border-radius:0}.ck-rounded-corners .ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status,.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{background:var(--ck-color-base-error);color:var(--ck-color-base-background);min-width:var(--ck-table-properties-min-error-width);padding:var(--ck-spacing-small) var(--ck-spacing-medium);text-align:center}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status:after{border-color:transparent transparent var(--ck-color-base-error) transparent;border-style:solid;border-width:0 var(--ck-table-properties-error-arrow-size) var(--ck-table-properties-error-arrow-size) var(--ck-table-properties-error-arrow-size)}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{animation:ck-table-form-labeled-view-status-appear .15s ease both}@media (prefers-reduced-motion:reduce){.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{animation:none}}.ck.ck-table-form .ck.ck-labeled-field-view .ck-input.ck-error:not(:focus)+.ck.ck-labeled-field-view__status{display:none}@keyframes ck-table-form-labeled-view-status-appear{0%{opacity:0}to{opacity:1}}', "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-table/theme/tableform.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/tableform.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"],
                    names: [],
                    mappings: "AAWE,wHACC,cACD,CAEA,8DAEC,kBAAmB,CADnB,cAgBD,CAbC,qFAGC,kBAAmB,CAFnB,YAAa,CACb,6BAMD,CAEA,sMACC,WACD,CAIF,4CAEC,iBAoBD,CAlBC,8EAGC,2DAAgE,CADhE,QAAS,CADT,iBAAkB,CAGlB,8BAA+B,CAG/B,SAUD,CAPC,oFACC,UAAW,CAGX,QAAS,CAFT,iBAAkB,CAClB,wDAA6D,CAE7D,0BACD,CChDH,MACC,0CAA2C,CAC3C,2CACD,CAMI,2FACC,kCAAmC,CACnC,iBACD,CAGD,8KAIC,cAAe,CADf,cAAe,CADf,UAGD,CAGD,8DACC,SAcD,CAZC,yMAEC,QACD,CAEA,iGACC,mBAAoB,CACpB,oBAAqB,CACrB,wCAAyC,CACzC,6CAA8C,CAC9C,gCACD,CAIF,4CACC,sCA6BD,CA3BC,8ECxCD,eD6DC,CArBA,mMCpCA,qCDyDA,CArBA,8EAGC,qCAAsC,CACtC,qCAAsC,CAEtC,oDAAqD,CADrD,wDAAyD,CAEzD,iBAcD,CAXC,oFACC,2EAA4E,CAE5E,kBAAmB,CADnB,kJAED,CAdD,8EAgBC,iEAKD,CAHC,uCAlBD,8EAmBE,cAEF,CADC,CAID,6GACC,YACD,CAIF,oDACC,GACC,SACD,CAEA,GACC,SACD,CACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-table-form {
	& .ck-form__row {
		&.ck-table-form__border-row {
			flex-wrap: wrap;
		}

		&.ck-table-form__background-row {
			flex-wrap: wrap;
		}

		&.ck-table-form__dimensions-row {
			flex-wrap: wrap;
			align-items: center;

			& .ck-labeled-field-view {
				display: flex;
				flex-direction: column-reverse;
				align-items: center;

				& .ck.ck-dropdown {
					flex-grow: 0;
				}
			}

			& .ck-table-form__dimension-operator {
				flex-grow: 0;
			}
		}
	}

	& .ck.ck-labeled-field-view {
		/* Allow absolute positioning of the status (error) balloons. */
		position: relative;

		& .ck.ck-labeled-field-view__status {
			position: absolute;
			left: 50%;
			bottom: calc( -1 * var(--ck-table-properties-error-arrow-size) );
			transform: translate(-50%,100%);

			/* Make sure the balloon status stays on top of other form elements. */
			z-index: 1;

			/* The arrow pointing towards the field. */
			&::after {
				content: "";
				position: absolute;
				top: calc( -1 * var(--ck-table-properties-error-arrow-size) );
				left: 50%;
				transform: translateX( -50% );
			}
		}
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../mixins/_rounded.css";

:root {
	--ck-table-properties-error-arrow-size: 6px;
	--ck-table-properties-min-error-width: 150px;
}

.ck.ck-table-form {
	& .ck-form__row {
		&.ck-table-form__border-row {
			& .ck-labeled-field-view {
				& > .ck-label {
					font-size: var(--ck-font-size-tiny);
					text-align: center;
				}
			}

			& .ck-table-form__border-style,
			& .ck-table-form__border-width {
				width: 80px;
				min-width: 80px;
				max-width: 80px;
			}
		}

		&.ck-table-form__dimensions-row {
			padding: 0;

			& .ck-table-form__dimensions-row__width,
			& .ck-table-form__dimensions-row__height {
				margin: 0
			}

			& .ck-table-form__dimension-operator {
				align-self: flex-end;
				display: inline-block;
				height: var(--ck-ui-component-min-height);
				line-height: var(--ck-ui-component-min-height);
				margin: 0 var(--ck-spacing-small);
			}
		}
	}

	& .ck.ck-labeled-field-view {
		padding-top: var(--ck-spacing-standard);

		& .ck.ck-labeled-field-view__status {
			@mixin ck-rounded-corners;

			background: var(--ck-color-base-error);
			color: var(--ck-color-base-background);
			padding: var(--ck-spacing-small) var(--ck-spacing-medium);
			min-width: var(--ck-table-properties-min-error-width);
			text-align: center;

			/* The arrow pointing towards the field. */
			&::after {
				border-color: transparent transparent var(--ck-color-base-error) transparent;
				border-width: 0 var(--ck-table-properties-error-arrow-size) var(--ck-table-properties-error-arrow-size) var(--ck-table-properties-error-arrow-size);
				border-style: solid;
			}

			animation: ck-table-form-labeled-view-status-appear .15s ease both;

			@media (prefers-reduced-motion: reduce) {
				animation: none;
			}
		}

		/* Hide the error balloon when the field is blurred. Makes the experience much more clear. */
		& .ck-input.ck-error:not(:focus) + .ck.ck-labeled-field-view__status {
			display: none;
		}
	}
}

@keyframes ck-table-form-labeled-view-status-appear {
	0% {
		opacity: 0;
	}

	100% {
		opacity: 1;
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            5562: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row{align-content:baseline;flex-basis:0;flex-wrap:wrap}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row .ck.ck-toolbar .ck-toolbar__items{flex-wrap:nowrap}.ck.ck-table-properties-form{width:320px}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row{align-self:flex-end;padding:0}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row .ck.ck-toolbar{background:none;margin-top:var(--ck-spacing-standard)}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row .ck.ck-toolbar .ck-toolbar__items>*{width:40px}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-table/theme/tableproperties.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/tableproperties.css"],
                    names: [],
                    mappings: "AAOE,mFAGC,sBAAuB,CADvB,YAAa,CADb,cAOD,CAHC,qHACC,gBACD,CCTH,6BACC,WAmBD,CAhBE,mFACC,mBAAoB,CACpB,SAYD,CAVC,kGACC,eAAgB,CAGhB,qCAKD,CAHC,uHACC,UACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-table-properties-form {
	& .ck-form__row {
		&.ck-table-properties-form__alignment-row {
			flex-wrap: wrap;
			flex-basis: 0;
			align-content: baseline;

			& .ck.ck-toolbar .ck-toolbar__items {
				flex-wrap: nowrap;
			}
		}
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-table-properties-form {
	width: 320px;

	& .ck-form__row {
		&.ck-table-properties-form__alignment-row {
			align-self: flex-end;
			padding: 0;

			& .ck.ck-toolbar {
				background: none;

				/* Compensate for missing input label that would push the margin (toolbar has no inputs). */
				margin-top: var(--ck-spacing-standard);

				& .ck-toolbar__items > * {
					width: 40px;
				}
			}
		}
	}
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            8423: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ':root{--ck-table-selected-cell-background:rgba(158,207,250,.3)}.ck.ck-editor__editable .table table td.ck-editor__editable_selected,.ck.ck-editor__editable .table table th.ck-editor__editable_selected{box-shadow:unset;caret-color:transparent;outline:unset;position:relative}.ck.ck-editor__editable .table table td.ck-editor__editable_selected:after,.ck.ck-editor__editable .table table th.ck-editor__editable_selected:after{background-color:var(--ck-table-selected-cell-background);bottom:0;content:"";left:0;pointer-events:none;position:absolute;right:0;top:0}.ck.ck-editor__editable .table table td.ck-editor__editable_selected ::selection,.ck.ck-editor__editable .table table td.ck-editor__editable_selected:focus,.ck.ck-editor__editable .table table th.ck-editor__editable_selected ::selection,.ck.ck-editor__editable .table table th.ck-editor__editable_selected:focus{background-color:transparent}.ck.ck-editor__editable .table table td.ck-editor__editable_selected .ck-widget,.ck.ck-editor__editable .table table th.ck-editor__editable_selected .ck-widget{outline:unset}.ck.ck-editor__editable .table table td.ck-editor__editable_selected .ck-widget>.ck-widget__selection-handle,.ck.ck-editor__editable .table table th.ck-editor__editable_selected .ck-widget>.ck-widget__selection-handle{display:none}', "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/tableselection.css"],
                    names: [],
                    mappings: "AAKA,MACC,wDACD,CAGC,0IAKC,gBAAiB,CAFjB,uBAAwB,CACxB,aAAc,CAFd,iBAiCD,CA3BC,sJAGC,yDAA0D,CAK1D,QAAS,CAPT,UAAW,CAKX,MAAO,CAJP,mBAAoB,CAEpB,iBAAkB,CAGlB,OAAQ,CAFR,KAID,CAEA,wTAEC,4BACD,CAMA,gKACC,aAKD,CAHC,0NACC,YACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-table-selected-cell-background: hsla(208, 90%, 80%, .3);
}

.ck.ck-editor__editable .table table {
	& td.ck-editor__editable_selected,
	& th.ck-editor__editable_selected {
		position: relative;
		caret-color: transparent;
		outline: unset;
		box-shadow: unset;

		/* https://github.com/ckeditor/ckeditor5/issues/6446 */
		&:after {
			content: '';
			pointer-events: none;
			background-color: var(--ck-table-selected-cell-background);
			position: absolute;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
		}

		& ::selection,
		&:focus {
			background-color: transparent;
		}

		/*
		 * To reduce the amount of noise, all widgets in the table selection have no outline and no selection handle.
		 * See https://github.com/ckeditor/ckeditor5/issues/9491.
		 */
		& .ck-widget {
			outline: unset;

			& > .ck-widget__selection-handle {
				display: none;
			}
		}
	}
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            1801: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck.ck-aria-live-announcer{left:-10000px;position:absolute;top:-10000px}.ck.ck-aria-live-region-list{list-style-type:none}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/arialiveannouncer/arialiveannouncer.css"],
                    names: [],
                    mappings: "AAKA,2BAEC,aAAc,CADd,iBAAkB,CAElB,YACD,CAEA,6BACC,oBACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-aria-live-announcer {
	position: absolute;
	left: -10000px;
	top: -10000px;
}

.ck.ck-aria-live-region-list {
	list-style-type: none;
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            5727: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck.ck-autocomplete{position:relative}.ck.ck-autocomplete>.ck-search__results{position:absolute;z-index:var(--ck-z-panel)}.ck.ck-autocomplete>.ck-search__results.ck-search__results_n{bottom:100%}.ck.ck-autocomplete>.ck-search__results.ck-search__results_s{bottom:auto;top:100%}.ck.ck-autocomplete>.ck-search__results{border-radius:0}.ck-rounded-corners .ck.ck-autocomplete>.ck-search__results,.ck.ck-autocomplete>.ck-search__results.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-autocomplete>.ck-search__results{background:var(--ck-color-base-background);border:1px solid var(--ck-color-dropdown-panel-border);box-shadow:var(--ck-drop-shadow),0 0;max-height:200px;min-width:auto;overflow-y:auto}.ck.ck-autocomplete>.ck-search__results.ck-search__results_n{border-bottom-left-radius:0;border-bottom-right-radius:0;margin-bottom:-1px}.ck.ck-autocomplete>.ck-search__results.ck-search__results_s{border-top-left-radius:0;border-top-right-radius:0;margin-top:-1px}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/autocomplete/autocomplete.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/autocomplete/autocomplete.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"],
                    names: [],
                    mappings: "AAKA,oBACC,iBAeD,CAbC,wCACC,iBAAkB,CAClB,yBAUD,CARC,6DACC,WACD,CAEA,6DAEC,WAAY,CADZ,QAED,CCVD,wCCEA,eDuBA,CAzBA,uHCMC,qCDmBD,CAzBA,wCAMC,0CAA2C,CAC3C,sDAAuD,CEPxD,oCAA8B,CFI7B,gBAAiB,CAIjB,cAAe,CAHf,eAoBD,CAfC,6DACC,2BAA4B,CAC5B,4BAA6B,CAG7B,kBACD,CAEA,6DACC,wBAAyB,CACzB,yBAA0B,CAG1B,eACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-autocomplete {
	position: relative;

	& > .ck-search__results {
		position: absolute;
		z-index: var(--ck-z-panel);

		&.ck-search__results_n {
			bottom: 100%;
		}

		&.ck-search__results_s {
			top: 100%;
			bottom: auto;
		}
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css";
@import "@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css";

.ck.ck-autocomplete {
	& > .ck-search__results {
		@mixin ck-rounded-corners;
		@mixin ck-drop-shadow;

		max-height: 200px;
		overflow-y: auto;
		background: var(--ck-color-base-background);
		border: 1px solid var(--ck-color-dropdown-panel-border);
		min-width: auto;

		&.ck-search__results_n {
			border-bottom-left-radius: 0;
			border-bottom-right-radius: 0;

			/* Prevent duplicated borders between the input and the results pane. */
			margin-bottom: -1px;
		}

		&.ck-search__results_s {
			border-top-left-radius: 0;
			border-top-right-radius: 0;

			/* Prevent duplicated borders between the input and the results pane. */
			margin-top: -1px;
		}
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A helper to combine multiple shadows.
 */
@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {
	box-shadow: $shadowA, $shadowB;
}

/**
 * Gives an element a drop shadow so it looks like a floating panel.
 */
@define-mixin ck-drop-shadow {
	@mixin ck-box-shadow var(--ck-drop-shadow);
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            9715: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck.ck-button,a.ck.ck-button{align-items:center;display:inline-flex;position:relative;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}[dir=ltr] .ck.ck-button,[dir=ltr] a.ck.ck-button{justify-content:left}[dir=rtl] .ck.ck-button,[dir=rtl] a.ck.ck-button{justify-content:right}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{display:none}.ck.ck-button.ck-button_with-text .ck-button__label,a.ck.ck-button.ck-button_with-text .ck-button__label{display:inline-block}.ck.ck-button:not(.ck-button_with-text),a.ck.ck-button:not(.ck-button_with-text){justify-content:center}.ck.ck-button,a.ck.ck-button{background:var(--ck-color-button-default-background)}.ck.ck-button:not(.ck-disabled):hover,a.ck.ck-button:not(.ck-disabled):hover{background:var(--ck-color-button-default-hover-background)}.ck.ck-button:not(.ck-disabled):active,a.ck.ck-button:not(.ck-disabled):active{background:var(--ck-color-button-default-active-background)}.ck.ck-button.ck-disabled,a.ck.ck-button.ck-disabled{background:var(--ck-color-button-default-disabled-background)}.ck.ck-button,a.ck.ck-button{border-radius:0}.ck-rounded-corners .ck.ck-button,.ck-rounded-corners a.ck.ck-button,.ck.ck-button.ck-rounded-corners,a.ck.ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-button,a.ck.ck-button{-webkit-appearance:none;border:1px solid transparent;cursor:default;font-size:inherit;line-height:1;min-height:var(--ck-ui-component-min-height);min-width:var(--ck-ui-component-min-height);padding:var(--ck-spacing-tiny);text-align:center;transition:box-shadow .2s ease-in-out,border .2s ease-in-out;vertical-align:middle;white-space:nowrap}@media (prefers-reduced-motion:reduce){.ck.ck-button,a.ck.ck-button{transition:none}}.ck.ck-button:active,.ck.ck-button:focus,a.ck.ck-button:active,a.ck.ck-button:focus{border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0;outline:none}.ck.ck-button .ck-button__icon use,.ck.ck-button .ck-button__icon use *,a.ck.ck-button .ck-button__icon use,a.ck.ck-button .ck-button__icon use *{color:inherit}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{color:inherit;cursor:inherit;font-size:inherit;font-weight:inherit;vertical-align:middle}[dir=ltr] .ck.ck-button .ck-button__label,[dir=ltr] a.ck.ck-button .ck-button__label{text-align:left}[dir=rtl] .ck.ck-button .ck-button__label,[dir=rtl] a.ck.ck-button .ck-button__label{text-align:right}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{color:inherit}[dir=ltr] .ck.ck-button .ck-button__keystroke,[dir=ltr] a.ck.ck-button .ck-button__keystroke{margin-left:var(--ck-spacing-large)}[dir=rtl] .ck.ck-button .ck-button__keystroke,[dir=rtl] a.ck.ck-button .ck-button__keystroke{margin-right:var(--ck-spacing-large)}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{opacity:.5}.ck.ck-button.ck-disabled:active,.ck.ck-button.ck-disabled:focus,a.ck.ck-button.ck-disabled:active,a.ck.ck-button.ck-disabled:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),0 0}.ck.ck-button.ck-disabled .ck-button__icon,.ck.ck-button.ck-disabled .ck-button__label,a.ck.ck-button.ck-disabled .ck-button__icon,a.ck.ck-button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-disabled .ck-button__keystroke,a.ck.ck-button.ck-disabled .ck-button__keystroke{opacity:.3}.ck.ck-button.ck-button_with-text,a.ck.ck-button.ck-button_with-text{padding:var(--ck-spacing-tiny) var(--ck-spacing-standard)}[dir=ltr] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=ltr] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-left:calc(var(--ck-spacing-small)*-1);margin-right:var(--ck-spacing-small)}[dir=rtl] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=rtl] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-left:var(--ck-spacing-small);margin-right:calc(var(--ck-spacing-small)*-1)}.ck.ck-button.ck-button_with-keystroke .ck-button__label,a.ck.ck-button.ck-button_with-keystroke .ck-button__label{flex-grow:1}.ck.ck-button.ck-on,a.ck.ck-button.ck-on{background:var(--ck-color-button-on-background)}.ck.ck-button.ck-on:not(.ck-disabled):hover,a.ck.ck-button.ck-on:not(.ck-disabled):hover{background:var(--ck-color-button-on-hover-background)}.ck.ck-button.ck-on:not(.ck-disabled):active,a.ck.ck-button.ck-on:not(.ck-disabled):active{background:var(--ck-color-button-on-active-background)}.ck.ck-button.ck-on.ck-disabled,a.ck.ck-button.ck-on.ck-disabled{background:var(--ck-color-button-on-disabled-background)}.ck.ck-button.ck-on,a.ck.ck-button.ck-on{color:var(--ck-color-button-on-color)}.ck.ck-button.ck-button-save,a.ck.ck-button.ck-button-save{color:var(--ck-color-button-save)}.ck.ck-button.ck-button-cancel,a.ck.ck-button.ck-button-cancel{color:var(--ck-color-button-cancel)}.ck.ck-button-action,a.ck.ck-button-action{background:var(--ck-color-button-action-background)}.ck.ck-button-action:not(.ck-disabled):hover,a.ck.ck-button-action:not(.ck-disabled):hover{background:var(--ck-color-button-action-hover-background)}.ck.ck-button-action:not(.ck-disabled):active,a.ck.ck-button-action:not(.ck-disabled):active{background:var(--ck-color-button-action-active-background)}.ck.ck-button-action.ck-disabled,a.ck.ck-button-action.ck-disabled{background:var(--ck-color-button-action-disabled-background)}.ck.ck-button-action,a.ck.ck-button-action{color:var(--ck-color-button-action-text)}.ck.ck-button-bold,a.ck.ck-button-bold{font-weight:700}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/button/button.css", "webpack://./../ckeditor5-ui/theme/mixins/_unselectable.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/button/button.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/mixins/_button.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_disabled.css"],
                    names: [],
                    mappings: "AAQA,6BAMC,kBAAmB,CADnB,mBAAoB,CADpB,iBAAkB,CCHlB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBD0BD,CA9BA,iDASE,oBAqBF,CA9BA,iDAaE,qBAiBF,CAdC,iEACC,YACD,CAGC,yGACC,oBACD,CAID,iFACC,sBACD,CEzBD,6BCAC,oDD+ID,CC5IE,6EACC,0DACD,CAEA,+EACC,2DACD,CAID,qDACC,6DACD,CDfD,6BEDC,eFgJD,CA/IA,wIEGE,qCF4IF,CA/IA,6BA6BC,uBAAwB,CANxB,4BAA6B,CAjB7B,cAAe,CAcf,iBAAkB,CAHlB,aAAc,CAJd,4CAA6C,CAD7C,2CAA4C,CAJ5C,8BAA+B,CAC/B,iBAAkB,CAiBlB,4DAA8D,CAnB9D,qBAAsB,CAFtB,kBA0ID,CAhHC,uCA/BD,6BAgCE,eA+GF,CA9GC,CAEA,oFGpCA,2BAA2B,CCF3B,2CAA8B,CDC9B,YHyCA,CAIC,kJAEC,aACD,CAGD,iEAIC,aAAc,CACd,cAAe,CAHf,iBAAkB,CAClB,mBAAoB,CAMpB,qBASD,CAlBA,qFAYE,eAMF,CAlBA,qFAgBE,gBAEF,CAEA,yEACC,aAWD,CAZA,6FAIE,mCAQF,CAZA,6FAQE,oCAIF,CAZA,yEAWC,UACD,CAIC,oIIxFD,oDJ4FC,CAOA,gLKnGD,kCLqGC,CAEA,iGACC,UACD,CAGD,qEACC,yDAcD,CAXC,2HAEE,4CAA+C,CAC/C,oCAOF,CAVA,2HAQE,mCAAoC,CADpC,6CAGF,CAKA,mHACC,WACD,CAID,yCClIA,+CDsIA,CCnIC,yFACC,qDACD,CAEA,2FACC,sDACD,CAID,iEACC,wDACD,CDmHA,yCAGC,qCACD,CAEA,2DACC,iCACD,CAEA,+DACC,mCACD,CAID,2CClJC,mDDuJD,CCpJE,2FACC,yDACD,CAEA,6FACC,0DACD,CAID,mEACC,4DACD,CDmID,2CAIC,wCACD,CAEA,uCAEC,eACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../mixins/_unselectable.css";
@import "../../mixins/_dir.css";

.ck.ck-button,
a.ck.ck-button {
	@mixin ck-unselectable;

	position: relative;
	display: inline-flex;
	align-items: center;

	@mixin ck-dir ltr {
		justify-content: left;
	}

	@mixin ck-dir rtl {
		justify-content: right;
	}

	& .ck-button__label {
		display: none;
	}

	&.ck-button_with-text {
		& .ck-button__label {
			display: inline-block;
		}
	}

	/* Center the icon horizontally in a button without text. */
	&:not(.ck-button_with-text)  {
		justify-content: center;
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Makes element unselectable.
 */
@define-mixin ck-unselectable {
	-moz-user-select: none;
	-webkit-user-select: none;
	-ms-user-select: none;
	user-select: none
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_focus.css";
@import "../../../mixins/_shadow.css";
@import "../../../mixins/_disabled.css";
@import "../../../mixins/_rounded.css";
@import "../../mixins/_button.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

.ck.ck-button,
a.ck.ck-button {
	@mixin ck-button-colors --ck-color-button-default;
	@mixin ck-rounded-corners;

	white-space: nowrap;
	cursor: default;
	vertical-align: middle;
	padding: var(--ck-spacing-tiny);
	text-align: center;

	/* A very important piece of styling. Go to variable declaration to learn more. */
	min-width: var(--ck-ui-component-min-height);
	min-height: var(--ck-ui-component-min-height);

	/* Normalize the height of the line. Removing this will break consistent height
	among text and text-less buttons (with icons). */
	line-height: 1;

	/* Enable font size inheritance, which allows fluid UI scaling. */
	font-size: inherit;

	/* Avoid flickering when the foucs border shows up. */
	border: 1px solid transparent;

	/* Apply some smooth transition to the box-shadow and border. */
	transition: box-shadow .2s ease-in-out, border .2s ease-in-out;

	/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/189 */
	-webkit-appearance: none;

	@media (prefers-reduced-motion: reduce) {
		transition: none;
	}

	&:active,
	&:focus {
		@mixin ck-focus-ring;
		@mixin ck-box-shadow var(--ck-focus-outer-shadow);
	}

	/* Allow icon coloring using the text "color" property. */
	& .ck-button__icon {
		& use,
		& use * {
			color: inherit;
		}
	}

	& .ck-button__label {
		/* Enable font size inheritance, which allows fluid UI scaling. */
		font-size: inherit;
		font-weight: inherit;
		color: inherit;
		cursor: inherit;

		/* Must be consistent with .ck-icon's vertical align. Otherwise, buttons with and
		without labels (but with icons) have different sizes in Chrome */
		vertical-align: middle;

		@mixin ck-dir ltr {
			text-align: left;
		}

		@mixin ck-dir rtl {
			text-align: right;
		}
	}

	& .ck-button__keystroke {
		color: inherit;

		@mixin ck-dir ltr {
			margin-left: var(--ck-spacing-large);
		}

		@mixin ck-dir rtl {
			margin-right: var(--ck-spacing-large);
		}

		opacity: .5;
	}

	/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/70 */
	&.ck-disabled {
		&:active,
		&:focus {
			/* The disabled button should have a slightly less visible shadow when focused. */
			@mixin ck-box-shadow var(--ck-focus-disabled-outer-shadow);
		}

		& .ck-button__icon {
			@mixin ck-disabled;
		}

		/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/98 */
		& .ck-button__label {
			@mixin ck-disabled;
		}

		& .ck-button__keystroke {
			opacity: .3;
		}
	}

	&.ck-button_with-text {
		padding: var(--ck-spacing-tiny) var(--ck-spacing-standard);

		/* stylelint-disable-next-line no-descending-specificity */
		& .ck-button__icon {
			@mixin ck-dir ltr {
				margin-left: calc(-1 * var(--ck-spacing-small));
				margin-right: var(--ck-spacing-small);
			}

			@mixin ck-dir rtl {
				margin-right: calc(-1 * var(--ck-spacing-small));
				margin-left: var(--ck-spacing-small);
			}
		}
	}

	&.ck-button_with-keystroke {
		/* stylelint-disable-next-line no-descending-specificity */
		& .ck-button__label {
			flex-grow: 1;
		}
	}

	/* A style of the button which is currently on, e.g. its feature is active. */
	&.ck-on {
		@mixin ck-button-colors --ck-color-button-on;

		color: var(--ck-color-button-on-color);
	}

	&.ck-button-save {
		color: var(--ck-color-button-save);
	}

	&.ck-button-cancel {
		color: var(--ck-color-button-cancel);
	}
}

/* A style of the button which handles the primary action. */
.ck.ck-button-action,
a.ck.ck-button-action {
	@mixin ck-button-colors --ck-color-button-action;

	color: var(--ck-color-button-action-text);
}

.ck.ck-button-bold,
a.ck.ck-button-bold {
	font-weight: bold;
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements a button of given background color.
 *
 * @param {String} $background - Background color of the button.
 * @param {String} $border - Border color of the button.
 */
@define-mixin ck-button-colors $prefix {
	background: var($(prefix)-background);

	&:not(.ck-disabled) {
		&:hover {
			background: var($(prefix)-hover-background);
		}

		&:active {
			background: var($(prefix)-active-background);
		}
	}

	/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/98 */
	&.ck-disabled {
		background: var($(prefix)-disabled-background);
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A visual style of focused element's border.
 */
@define-mixin ck-focus-ring {
	/* Disable native outline. */
	outline: none;
	border: var(--ck-focus-ring)
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A helper to combine multiple shadows.
 */
@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {
	box-shadow: $shadowA, $shadowB;
}

/**
 * Gives an element a drop shadow so it looks like a floating panel.
 */
@define-mixin ck-drop-shadow {
	@mixin ck-box-shadow var(--ck-drop-shadow);
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A class which indicates that an element holding it is disabled.
 */
@define-mixin ck-disabled {
	opacity: var(--ck-disabled-opacity);
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            4391: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{display:block}:root{--ck-switch-button-toggle-width:2.6153846154em;--ck-switch-button-toggle-inner-size:calc(1.07692em + 1px);--ck-switch-button-translation:calc(var(--ck-switch-button-toggle-width) - var(--ck-switch-button-toggle-inner-size) - 2px);--ck-switch-button-inner-hover-shadow:0 0 0 5px var(--ck-color-switch-button-inner-shadow)}.ck.ck-button.ck-switchbutton,.ck.ck-button.ck-switchbutton.ck-on:active,.ck.ck-button.ck-switchbutton.ck-on:focus,.ck.ck-button.ck-switchbutton.ck-on:hover,.ck.ck-button.ck-switchbutton:active,.ck.ck-button.ck-switchbutton:focus,.ck.ck-button.ck-switchbutton:hover{background:transparent;color:inherit}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__label{margin-right:calc(var(--ck-spacing-large)*2)}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__label{margin-left:calc(var(--ck-spacing-large)*2)}.ck.ck-button.ck-switchbutton .ck-button__toggle{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle.ck-rounded-corners{border-radius:var(--ck-border-radius)}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-left:auto}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-right:auto}.ck.ck-button.ck-switchbutton .ck-button__toggle{background:var(--ck-color-switch-button-off-background);border:1px solid transparent;transition:background .4s ease,box-shadow .2s ease-in-out,outline .2s ease-in-out;width:var(--ck-switch-button-toggle-width)}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner.ck-rounded-corners{border-radius:var(--ck-border-radius);border-radius:calc(var(--ck-border-radius)*.5)}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{background:var(--ck-color-switch-button-inner-background);height:var(--ck-switch-button-toggle-inner-size);transition:all .3s ease;width:var(--ck-switch-button-toggle-inner-size)}@media (prefers-reduced-motion:reduce){.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{transition:none}}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover{background:var(--ck-color-switch-button-off-hover-background)}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover .ck-button__toggle__inner{box-shadow:var(--ck-switch-button-inner-hover-shadow)}.ck.ck-button.ck-switchbutton.ck-disabled .ck-button__toggle{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-switchbutton:focus{border-color:transparent;box-shadow:none;outline:none}.ck.ck-button.ck-switchbutton:focus .ck-button__toggle{box-shadow:0 0 0 1px var(--ck-color-base-background),0 0 0 5px var(--ck-color-focus-outer-shadow);outline:var(--ck-focus-ring);outline-offset:1px}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle{background:var(--ck-color-switch-button-on-background)}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle:hover{background:var(--ck-color-switch-button-on-hover-background)}[dir=ltr] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(var( --ck-switch-button-translation ))}[dir=rtl] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(calc(var( --ck-switch-button-translation )*-1))}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/button/switchbutton.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/button/switchbutton.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_disabled.css"],
                    names: [],
                    mappings: "AASE,4HACC,aACD,CCCF,MAEC,8CAA+C,CAE/C,0DAAgE,CAChE,2HAIC,CACD,0FACD,CAOC,0QAEC,sBAAuB,CADvB,aAED,CAEA,0DAGE,4CAOF,CAVA,0DAQE,2CAEF,CAEA,iDCpCA,eDgFA,CA5CA,yIChCC,qCD4ED,CA5CA,2DAKE,gBAuCF,CA5CA,2DAUE,iBAkCF,CA5CA,iDAkBC,uDAAwD,CAFxD,4BAA6B,CAD7B,iFAAsF,CAEtF,0CA2BD,CAxBC,2ECxDD,eDuEC,CAfA,6LCpDA,qCAAsC,CDsDpC,8CAaF,CAfA,2EAOC,yDAA0D,CAD1D,gDAAiD,CAIjD,uBAA0B,CAL1B,+CAUD,CAHC,uCAZD,2EAaE,eAEF,CADC,CAGD,uDACC,6DAKD,CAHC,iFACC,qDACD,CAIF,6DEpFA,kCFsFA,CAGA,oCACC,wBAAyB,CAEzB,eAAgB,CADhB,YAQD,CALC,uDACC,iGAAmG,CAEnG,4BAA6B,CAD7B,kBAED,CAKA,uDACC,sDAkBD,CAhBC,6DACC,4DACD,CAEA,2FAKE,2DAMF,CAXA,2FASE,oEAEF",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-button.ck-switchbutton {
	& .ck-button__toggle {
		display: block;

		& .ck-button__toggle__inner {
			display: block;
		}
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";
@import "../../../mixins/_disabled.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

/* Note: To avoid rendering issues (aliasing) but to preserve the responsive nature
of the component, floating–point numbers have been used which, for the default font size
(see: --ck-font-size-base), will generate simple integers. */
:root {
	/* 34px at 13px font-size */
	--ck-switch-button-toggle-width: 2.6153846154em;
	/* 14px at 13px font-size */
	--ck-switch-button-toggle-inner-size: calc(1.0769230769em + 1px);
	--ck-switch-button-translation: calc(
		var(--ck-switch-button-toggle-width) -
		var(--ck-switch-button-toggle-inner-size) -
		2px /* Border */
	);
	--ck-switch-button-inner-hover-shadow: 0 0 0 5px var(--ck-color-switch-button-inner-shadow);
}

.ck.ck-button.ck-switchbutton {
	/* Unlike a regular button, the switch button text color and background should never change.
	 * Changing toggle switch (background, outline) is enough to carry the information about the
	 * state of the entire component (https://github.com/ckeditor/ckeditor5/issues/12519)
	 */
	&, &:hover, &:focus, &:active, &.ck-on:hover, &.ck-on:focus, &.ck-on:active {
		color: inherit;
		background: transparent;
	}

	& .ck-button__label {
		@mixin ck-dir ltr {
			/* Separate the label from the switch */
			margin-right: calc(2 * var(--ck-spacing-large));
		}

		@mixin ck-dir rtl {
			/* Separate the label from the switch */
			margin-left: calc(2 * var(--ck-spacing-large));
		}
	}

	& .ck-button__toggle {
		@mixin ck-rounded-corners;

		@mixin ck-dir ltr {
			/* Make sure the toggle is always to the right as far as possible. */
			margin-left: auto;
		}

		@mixin ck-dir rtl {
			/* Make sure the toggle is always to the left as far as possible. */
			margin-right: auto;
		}

		/* Apply some smooth transition to the box-shadow and border. */
		/* Gently animate the background color of the toggle switch */
		transition: background 400ms ease, box-shadow .2s ease-in-out, outline .2s ease-in-out;
		border: 1px solid transparent;
		width: var(--ck-switch-button-toggle-width);
		background: var(--ck-color-switch-button-off-background);

		& .ck-button__toggle__inner {
			@mixin ck-rounded-corners {
				border-radius: calc(.5 * var(--ck-border-radius));
			}

			width: var(--ck-switch-button-toggle-inner-size);
			height: var(--ck-switch-button-toggle-inner-size);
			background: var(--ck-color-switch-button-inner-background);

			/* Gently animate the inner part of the toggle switch */
			transition: all 300ms ease;

			@media (prefers-reduced-motion: reduce) {
				transition: none;
			}
		}

		&:hover {
			background: var(--ck-color-switch-button-off-hover-background);

			& .ck-button__toggle__inner {
				box-shadow: var(--ck-switch-button-inner-hover-shadow);
			}
		}
	}

	&.ck-disabled .ck-button__toggle {
		@mixin ck-disabled;
	}

	/* Overriding default .ck-button:focus styles + an outline around the toogle */
	&:focus {
		border-color: transparent;
		outline: none;
		box-shadow: none;

		& .ck-button__toggle {
			box-shadow: 0 0 0 1px var(--ck-color-base-background), 0 0 0 5px var(--ck-color-focus-outer-shadow);
			outline-offset: 1px;
			outline: var(--ck-focus-ring);
		}
	}

	/* stylelint-disable-next-line no-descending-specificity */
	&.ck-on {
		& .ck-button__toggle {
			background: var(--ck-color-switch-button-on-background);

			&:hover {
				background: var(--ck-color-switch-button-on-hover-background);
			}

			& .ck-button__toggle__inner {
				/*
				* Move the toggle switch to the right. It will be animated.
				*/
				@mixin ck-dir ltr {
					transform: translateX( var( --ck-switch-button-translation ) );
				}

				@mixin ck-dir rtl {
					transform: translateX( calc( -1 * var( --ck-switch-button-translation ) ) );
				}
			}
		}
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A class which indicates that an element holding it is disabled.
 */
@define-mixin ck-disabled {
	opacity: var(--ck-disabled-opacity);
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            25: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck.ck-collapsible.ck-collapsible_collapsed>.ck-collapsible__children{display:none}:root{--ck-collapsible-arrow-size:calc(var(--ck-icon-size)*0.5)}.ck.ck-collapsible>.ck.ck-button{border-radius:0;color:inherit;font-weight:700;padding:var(--ck-list-button-padding);width:100%}.ck.ck-collapsible>.ck.ck-button:focus{background:transparent}.ck.ck-collapsible>.ck.ck-button:active,.ck.ck-collapsible>.ck.ck-button:hover:not(:focus),.ck.ck-collapsible>.ck.ck-button:not(:focus){background:transparent;border-color:transparent;box-shadow:none}.ck.ck-collapsible>.ck.ck-button>.ck-icon{margin-right:var(--ck-spacing-medium);width:var(--ck-collapsible-arrow-size)}.ck.ck-collapsible>.ck-collapsible__children{padding:var(--ck-spacing-medium) var(--ck-spacing-large) var(--ck-spacing-large)}.ck.ck-collapsible.ck-collapsible_collapsed>.ck.ck-button .ck-icon{transform:rotate(-90deg)}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/collapsible/collapsible.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/collapsible/collapsible.css"],
                    names: [],
                    mappings: "AAMC,sEACC,YACD,CCHD,MACC,yDACD,CAGC,iCAIC,eAAgB,CAChB,aAAc,CAHd,eAAiB,CACjB,qCAAsC,CAFtC,UAoBD,CAdC,uCACC,sBACD,CAEA,wIACC,sBAAuB,CACvB,wBAAyB,CACzB,eACD,CAEA,0CACC,qCAAsC,CACtC,sCACD,CAGD,6CACC,gFACD,CAGC,mEACC,wBACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-collapsible.ck-collapsible_collapsed {
	& > .ck-collapsible__children {
		display: none;
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-collapsible-arrow-size: calc(0.5 * var(--ck-icon-size));
}

.ck.ck-collapsible {
	& > .ck.ck-button {
		width: 100%;
		font-weight: bold;
		padding: var(--ck-list-button-padding);
		border-radius: 0;
		color: inherit;

		&:focus {
			background: transparent;
		}

		&:active, &:not(:focus), &:hover:not(:focus) {
			background: transparent;
			border-color: transparent;
			box-shadow: none;
		}

		& > .ck-icon {
			margin-right: var(--ck-spacing-medium);
			width: var(--ck-collapsible-arrow-size);
		}
	}

	& > .ck-collapsible__children {
		padding: var(--ck-spacing-medium) var(--ck-spacing-large) var(--ck-spacing-large);
	}

	&.ck-collapsible_collapsed {
		& > .ck.ck-button .ck-icon {
			transform: rotate(-90deg);
		}
	}
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            7317: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck.ck-color-grid{display:grid}:root{--ck-color-grid-tile-size:24px;--ck-color-color-grid-check-icon:#166fd4}.ck.ck-color-grid{grid-gap:5px;padding:8px}.ck.ck-color-grid__tile{transition:box-shadow .2s ease}@media (forced-colors:none){.ck.ck-color-grid__tile{border:0;height:var(--ck-color-grid-tile-size);min-height:var(--ck-color-grid-tile-size);min-width:var(--ck-color-grid-tile-size);padding:0;width:var(--ck-color-grid-tile-size)}.ck.ck-color-grid__tile.ck-on,.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){border:0}.ck.ck-color-grid__tile.ck-color-selector__color-tile_bordered{box-shadow:0 0 0 1px var(--ck-color-base-border)}.ck.ck-color-grid__tile.ck-on{box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-base-text)}.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-focus-border)}}@media (forced-colors:active){.ck.ck-color-grid__tile{height:unset;min-height:unset;min-width:unset;padding:0 var(--ck-spacing-small);width:unset}.ck.ck-color-grid__tile .ck-button__label{display:inline-block}}@media (prefers-reduced-motion:reduce){.ck.ck-color-grid__tile{transition:none}}.ck.ck-color-grid__tile.ck-disabled{cursor:unset;transition:unset}.ck.ck-color-grid__tile .ck.ck-icon{color:var(--ck-color-color-grid-check-icon);display:none}.ck.ck-color-grid__tile.ck-on .ck.ck-icon{display:block}.ck.ck-color-grid__label{padding:0 var(--ck-spacing-standard)}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/colorgrid/colorgrid.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/colorgrid/colorgrid.css", "webpack://./../ckeditor5-ui/theme/mixins/_mediacolors.css"],
                    names: [],
                    mappings: "AAKA,kBACC,YACD,CCCA,MACC,8BAA+B,CAK/B,wCACD,CAEA,kBACC,YAAa,CACb,WACD,CAEA,wBACC,8BAkED,CC3EC,4BACC,wBDgBA,QAAS,CAJT,qCAAsC,CAEtC,yCAA0C,CAD1C,wCAAyC,CAEzC,SAAU,CAJV,oCCTA,CDgBA,8HAIC,QACD,CAEA,+DACC,gDACD,CAEA,8BACC,8FACD,CAEA,gGAEC,iGACD,CCjCD,CAZA,8BACC,wBDqDA,YAAa,CAEb,gBAAiB,CADjB,eAAgB,CAEhB,iCAAkC,CAJlC,WClDA,CDwDA,0CACC,oBACD,CCzDD,CD4DA,uCAhDD,wBAiDE,eAkBF,CAjBC,CAEA,oCACC,YAAa,CACb,gBACD,CAEA,oCAEC,2CAA4C,CAD5C,YAED,CAGC,0CACC,aACD,CAIF,yBACC,oCACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-color-grid {
	display: grid;
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_mediacolors.css";

:root {
	--ck-color-grid-tile-size: 24px;

	/* Not using global colors here because these may change but some colors in a pallette
	 * require special treatment. For instance, this ensures no matter what the UI text color is,
	 * the check icon will look good on the black color tile. */
	--ck-color-color-grid-check-icon: hsl(212, 81%, 46%);
}

.ck.ck-color-grid {
	grid-gap: 5px;
	padding: 8px;
}

.ck.ck-color-grid__tile {
	transition: .2s ease box-shadow;

	@mixin ck-media-default-colors {
		width: var(--ck-color-grid-tile-size);
		height: var(--ck-color-grid-tile-size);
		min-width: var(--ck-color-grid-tile-size);
		min-height: var(--ck-color-grid-tile-size);
		padding: 0;
		border: 0;

		&.ck-on,
		&:focus:not( .ck-disabled ),
		&:hover:not( .ck-disabled ) {
			/* Disable the default .ck-button's border ring. */
			border: 0;
		}

		&.ck-color-selector__color-tile_bordered {
			box-shadow: 0 0 0 1px var(--ck-color-base-border);
		}

		&.ck-on {
			box-shadow: inset 0 0 0 1px var(--ck-color-base-background), 0 0 0 2px var(--ck-color-base-text);
		}

		&:focus:not( .ck-disabled ),
		&:hover:not( .ck-disabled ) {
			box-shadow: inset 0 0 0 1px var(--ck-color-base-background), 0 0 0 2px var(--ck-color-focus-border);
		}
	}

	/*
	 * In high contrast mode, the colors are replaced with text labels.
	 * See https://github.com/ckeditor/ckeditor5/issues/14907.
	 */
	@mixin ck-media-forced-colors {
		width: unset;
		height: unset;
		min-width: unset;
		min-height: unset;
		padding: 0 var(--ck-spacing-small);

		& .ck-button__label {
			display: inline-block;
		}
	}

	@media (prefers-reduced-motion: reduce) {
		transition: none;
	}

	&.ck-disabled {
		cursor: unset;
		transition: unset;
	}

	& .ck.ck-icon {
		display: none;
		color: var(--ck-color-color-grid-check-icon);
	}

	&.ck-on {
		& .ck.ck-icon {
			display: block;
		}
	}
}

.ck.ck-color-grid__label {
	padding: 0 var(--ck-spacing-standard);
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@define-mixin ck-media-forced-colors {
	@media (forced-colors: active) {
		& {
			@mixin-content;
		}
	}
}

@define-mixin ck-media-default-colors {
	@media (forced-colors: none) {
		& {
			@mixin-content;
		}
	}
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            1905: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".color-picker-hex-input{width:max-content}.color-picker-hex-input .ck.ck-input{min-width:unset}.ck.ck-color-picker__row{display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between;margin:var(--ck-spacing-large) 0 0;width:unset}.ck.ck-color-picker__row .ck.ck-labeled-field-view{padding-top:unset}.ck.ck-color-picker__row .ck.ck-input-text{width:unset}.ck.ck-color-picker__row .ck-color-picker__hash-view{padding-right:var(--ck-spacing-medium);padding-top:var(--ck-spacing-tiny)}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/colorpicker/colorpicker.css"],
                    names: [],
                    mappings: "AAKA,wBACC,iBAKD,CAHC,qCACC,eACD,CAGD,yBACC,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CACjB,6BAA8B,CAC9B,kCAAmC,CACnC,WAcD,CAZC,mDACC,iBACD,CAEA,2CACC,WACD,CAEA,qDAEC,sCAAuC,CADvC,kCAED",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.color-picker-hex-input {
	width: max-content;

	& .ck.ck-input {
		min-width: unset;
	}
}

.ck.ck-color-picker__row {
	display: flex;
	flex-direction: row;
	flex-wrap: nowrap;
	justify-content: space-between;
	margin: var(--ck-spacing-large) 0 0;
	width: unset;

	& .ck.ck-labeled-field-view {
		padding-top: unset;
	}

	& .ck.ck-input-text {
		width: unset;
	}

	& .ck-color-picker__hash-view {
		padding-top: var(--ck-spacing-tiny);
		padding-right: var(--ck-spacing-medium);
	}
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            6309: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__color-picker,.ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__remove-color{align-items:center;display:flex}[dir=rtl] .ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__color-picker,[dir=rtl] .ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__remove-color{justify-content:flex-start}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-selector_action-bar{display:flex;flex-direction:row;justify-content:space-around}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-selector_action-bar .ck-button-cancel,.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-selector_action-bar .ck-button-save{flex:1}.ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__color-picker,.ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__remove-color{width:100%}.ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__color-picker{border-bottom-left-radius:0;border-bottom-right-radius:0;padding:calc(var(--ck-spacing-standard)/2) var(--ck-spacing-standard)}.ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__color-picker:not(:focus){border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__color-picker .ck.ck-icon{margin-right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__color-picker .ck.ck-icon{margin-left:var(--ck-spacing-standard)}.ck.ck-color-selector .ck-color-grids-fragment label.ck.ck-color-grid__label{font-weight:unset}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-picker{padding:8px}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-picker .hex-color-picker{height:100px;min-width:180px}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-picker .hex-color-picker::part(saturation){border-radius:var(--ck-border-radius) var(--ck-border-radius) 0 0}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-picker .hex-color-picker::part(hue){border-radius:0 0 var(--ck-border-radius) var(--ck-border-radius)}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-picker .hex-color-picker::part(hue-pointer),.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-picker .hex-color-picker::part(saturation-pointer){height:15px;width:15px}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-selector_action-bar{padding:0 8px 8px}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/colorselector/colorselector.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/colorselector/colorselector.css"],
                    names: [],
                    mappings: "AAUE,oLAGC,kBAAmB,CADnB,YAMD,CARA,wMAME,0BAEF,CAKA,iFACC,YAAa,CACb,kBAAmB,CACnB,4BAMD,CAJC,oMAEC,MACD,CCrBD,oLAEC,UACD,CAEA,0FAEC,2BAA4B,CAC5B,4BAA6B,CAF7B,qEAiBD,CAbC,sGACC,gDACD,CAEA,gHAEE,uCAMF,CARA,gHAME,sCAEF,CAGD,6EACC,iBACD,CAKA,oEACC,WAoBD,CAlBC,sFACC,YAAa,CACb,eAeD,CAbC,wGACC,iEACD,CAEA,iGACC,iEACD,CAEA,yNAGC,WAAY,CADZ,UAED,CAIF,iFACC,iBACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

.ck.ck-color-selector {
	/* View fragment with color grids. */
	& .ck-color-grids-fragment {
		& .ck-button.ck-color-selector__remove-color,
		& .ck-button.ck-color-selector__color-picker {
			display: flex;
			align-items: center;

			@mixin ck-dir rtl {
				justify-content: flex-start;
			}
		}
	}

	/* View fragment with a color picker. */
	& .ck-color-picker-fragment {
		& .ck.ck-color-selector_action-bar {
			display: flex;
			flex-direction: row;
			justify-content: space-around;

			& .ck-button-save,
			& .ck-button-cancel {
				flex: 1
			}
		}
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

.ck.ck-color-selector {
	/* View fragment with color grids. */
	& .ck-color-grids-fragment {
		& .ck-button.ck-color-selector__remove-color,
		& .ck-button.ck-color-selector__color-picker {
			width: 100%;
		}

		& .ck-button.ck-color-selector__color-picker {
			padding: calc(var(--ck-spacing-standard) / 2) var(--ck-spacing-standard);
			border-bottom-left-radius: 0;
			border-bottom-right-radius: 0;

			&:not(:focus) {
				border-top: 1px solid var(--ck-color-base-border);
			}

			& .ck.ck-icon {
				@mixin ck-dir ltr {
					margin-right: var(--ck-spacing-standard);
				}

				@mixin ck-dir rtl {
					margin-left: var(--ck-spacing-standard);
				}
			}
		}

		& label.ck.ck-color-grid__label {
			font-weight: unset;
		}
	}

	/* View fragment with a color picker. */
	& .ck-color-picker-fragment {
		& .ck.ck-color-picker {
			padding: 8px;

			& .hex-color-picker {
				height: 100px;
				min-width: 180px;

				&::part(saturation) {
					border-radius: var(--ck-border-radius) var(--ck-border-radius) 0 0;
				}

				&::part(hue) {
					border-radius: 0 0 var(--ck-border-radius) var(--ck-border-radius);
				}

				&::part(saturation-pointer),
				&::part(hue-pointer) {
					width: 15px;
					height: 15px;
				}
			}
		}

		& .ck.ck-color-selector_action-bar {
			padding: 0 8px 8px;
		}
	}
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            9819: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck.ck-dialog-overlay{bottom:0;left:0;overscroll-behavior:none;position:fixed;right:0;top:0;user-select:none}.ck.ck-dialog-overlay.ck-dialog-overlay__transparent{animation:none;background:none;pointer-events:none}.ck.ck-dialog{overscroll-behavior:none;position:absolute;width:fit-content}.ck.ck-dialog .ck.ck-form__header{flex-shrink:0}.ck.ck-dialog .ck.ck-form__header .ck-form__header__label{cursor:grab}.ck.ck-dialog-overlay.ck-dialog-overlay__transparent .ck.ck-dialog{pointer-events:all}:root{--ck-dialog-overlay-background-color:rgba(0,0,0,.5);--ck-dialog-drop-shadow:0px 0px 6px 2px rgba(0,0,0,.15);--ck-dialog-max-width:100vw;--ck-dialog-max-height:90vh;--ck-color-dialog-background:var(--ck-color-base-background);--ck-color-dialog-form-header-border:var(--ck-color-base-border)}.ck.ck-dialog-overlay{animation:ck-dialog-fade-in .3s;background:var(--ck-dialog-overlay-background-color);z-index:var(--ck-z-dialog)}.ck.ck-dialog{border-radius:0}.ck-rounded-corners .ck.ck-dialog,.ck.ck-dialog.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-dialog{box-shadow:var(--ck-drop-shadow),0 0;--ck-drop-shadow:var(--ck-dialog-drop-shadow);background:var(--ck-color-dialog-background);border:1px solid var(--ck-color-base-border);max-height:var(--ck-dialog-max-height);max-width:var(--ck-dialog-max-width)}.ck.ck-dialog .ck.ck-form__header{border-bottom:1px solid var(--ck-color-dialog-form-header-border)}@keyframes ck-dialog-fade-in{0%{background:transparent}to{background:var(--ck-dialog-overlay-background-color)}}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/dialog/dialog.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/dialog/dialog.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"],
                    names: [],
                    mappings: "AAKA,sBAKC,QAAS,CACT,MAAO,CAJP,wBAAyB,CAEzB,cAAe,CAGf,OAAQ,CACR,KAAM,CAPN,gBAcD,CALC,qDAEC,cAAe,CACf,eAAgB,CAFhB,mBAGD,CAGD,cACC,wBAAyB,CAEzB,iBAAkB,CADlB,iBAcD,CAXC,kCACC,aAKD,CAHC,0DACC,WACD,CAVF,mEAcE,kBAEF,CC7BA,MACC,mDAA2D,CAC3D,uDAA8D,CAC9D,2BAA4B,CAC5B,2BAA4B,CAC5B,4DAA6D,CAC7D,gEACD,CAEA,sBACC,+BAAgC,CAChC,oDAAqD,CACrD,0BACD,CAEA,cCbC,eD2BD,CAdA,mECTE,qCDuBF,CAdA,cEfC,oCAA8B,CFmB9B,6CAA8C,CAE9C,4CAA6C,CAG7C,4CAA6C,CAF7C,sCAAuC,CACvC,oCAMD,CAHC,kCACC,iEACD,CAGD,6BACC,GACC,sBACD,CAEA,GACC,oDACD,CACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-dialog-overlay {
	user-select: none;
	overscroll-behavior: none;

	position: fixed;
	bottom: 0;
	left: 0;
	right: 0;
	top: 0;

	&.ck-dialog-overlay__transparent {
		pointer-events: none;
		animation: none;
		background: none;
	}
}

.ck.ck-dialog {
	overscroll-behavior: none;
	width: fit-content;
	position: absolute;

	& .ck.ck-form__header  {
		flex-shrink: 0;

		& .ck-form__header__label {
			cursor: grab;
		}
	}

	@nest .ck.ck-dialog-overlay.ck-dialog-overlay__transparent & {
		pointer-events: all;
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";
@import "../../../mixins/_shadow.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";

:root {
	--ck-dialog-overlay-background-color: hsla( 0, 0%, 0%, .5 );
	--ck-dialog-drop-shadow: 0px 0px 6px 2px hsl(0deg 0% 0% / 15%);
	--ck-dialog-max-width: 100vw;
	--ck-dialog-max-height: 90vh;
	--ck-color-dialog-background: var(--ck-color-base-background);
	--ck-color-dialog-form-header-border: var(--ck-color-base-border);
}

.ck.ck-dialog-overlay {
	animation: ck-dialog-fade-in .3s;
	background: var(--ck-dialog-overlay-background-color);
	z-index: var(--ck-z-dialog);
}

.ck.ck-dialog {
	@mixin ck-rounded-corners;
	@mixin ck-drop-shadow;

	--ck-drop-shadow: var(--ck-dialog-drop-shadow);

	background: var(--ck-color-dialog-background);
	max-height: var(--ck-dialog-max-height);
	max-width: var(--ck-dialog-max-width);
	border: 1px solid var(--ck-color-base-border);

	& .ck.ck-form__header {
		border-bottom: 1px solid var(--ck-color-dialog-form-header-border);
	}
}

@keyframes ck-dialog-fade-in {
	0% {
		background: hsla( 0, 0%, 0%, 0 );
	}

	100% {
		background: var(--ck-dialog-overlay-background-color);
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A helper to combine multiple shadows.
 */
@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {
	box-shadow: $shadowA, $shadowB;
}

/**
 * Gives an element a drop shadow so it looks like a floating panel.
 */
@define-mixin ck-drop-shadow {
	@mixin ck-box-shadow var(--ck-drop-shadow);
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            9822: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck.ck-dialog .ck.ck-dialog__actions{display:flex;justify-content:flex-end;padding:var(--ck-spacing-large)}.ck.ck-dialog .ck.ck-dialog__actions>*+*{margin-left:var(--ck-spacing-large)}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/dialog/dialogactions.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/dialog/dialogactions.css"],
                    names: [],
                    mappings: "AAMC,qCACC,YAAa,CACb,wBAAyB,CCDzB,+BDED,CCAC,yCACC,mCACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-dialog {
	& .ck.ck-dialog__actions {
		display: flex;
		justify-content: flex-end;
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-dialog {
	& .ck.ck-dialog__actions {
		padding: var(--ck-spacing-large);

		& > * + * {
			margin-left: var(--ck-spacing-large);
		}
	}
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            8149: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ":root{--ck-dropdown-max-width:75vw}.ck.ck-dropdown{display:inline-block;position:relative}.ck.ck-dropdown .ck-dropdown__arrow{pointer-events:none;z-index:var(--ck-z-default)}.ck.ck-dropdown .ck-button.ck-dropdown__button{width:100%}.ck.ck-dropdown .ck-dropdown__panel{display:none;max-width:var(--ck-dropdown-max-width);position:absolute;z-index:var(--ck-z-panel)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel-visible{display:inline-block}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_n,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nmw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw{bottom:100%}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_s,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_smw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{bottom:auto;top:100%}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se{left:0}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{right:0}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_n,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_s{left:50%;transform:translateX(-50%)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nmw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_smw{left:75%;transform:translateX(-75%)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sme{left:25%;transform:translateX(-25%)}.ck.ck-toolbar .ck-dropdown__panel{z-index:calc(var(--ck-z-panel) + 1)}:root{--ck-dropdown-arrow-size:calc(var(--ck-icon-size)*0.5)}.ck.ck-dropdown{font-size:inherit}.ck.ck-dropdown .ck-dropdown__arrow{width:var(--ck-dropdown-arrow-size)}[dir=ltr] .ck.ck-dropdown .ck-dropdown__arrow{margin-left:var(--ck-spacing-standard);right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-dropdown .ck-dropdown__arrow{left:var(--ck-spacing-standard);margin-right:var(--ck-spacing-small)}.ck.ck-dropdown.ck-disabled .ck-dropdown__arrow{opacity:var(--ck-disabled-opacity)}[dir=ltr] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-left:var(--ck-spacing-small)}[dir=rtl] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-right:var(--ck-spacing-small)}.ck.ck-dropdown .ck-button.ck-dropdown__button .ck-button__label{overflow:hidden;text-overflow:ellipsis;width:7em}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on{border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-dropdown__button_label-width_auto .ck-button__label{width:auto}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-off:active,.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on:active{box-shadow:none}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-off:active:focus,.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on:active:focus{box-shadow:var(--ck-focus-outer-shadow),0 0}.ck.ck-dropdown__panel{border-radius:0}.ck-rounded-corners .ck.ck-dropdown__panel,.ck.ck-dropdown__panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-dropdown__panel{background:var(--ck-color-dropdown-panel-background);border:1px solid var(--ck-color-dropdown-panel-border);bottom:0;box-shadow:var(--ck-drop-shadow),0 0;min-width:100%}.ck.ck-dropdown__panel.ck-dropdown__panel_se{border-top-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_sw{border-top-right-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_ne{border-bottom-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_nw{border-bottom-right-radius:0}.ck.ck-dropdown__panel:focus{outline:none}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/dropdown/dropdown.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/dropdown.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_disabled.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"],
                    names: [],
                    mappings: "AAKA,MACC,4BACD,CAEA,gBACC,oBAAqB,CACrB,iBA2ED,CAzEC,oCACC,mBAAoB,CACpB,2BACD,CAGA,+CACC,UACD,CAEA,oCACC,YAAa,CAEb,sCAAuC,CAEvC,iBAAkB,CAHlB,yBA4DD,CAvDC,+DACC,oBACD,CAEA,mSAKC,WACD,CAEA,mSAUC,WAAY,CADZ,QAED,CAEA,oHAEC,MACD,CAEA,oHAEC,OACD,CAEA,kHAGC,QAAS,CACT,0BACD,CAEA,sHAGC,QAAS,CACT,0BACD,CAEA,sHAGC,QAAS,CACT,0BACD,CAQF,mCACC,mCACD,CCpFA,MACC,sDACD,CAEA,gBAEC,iBA2ED,CAzEC,oCACC,mCACD,CAGC,8CAIC,sCAAuC,CAHvC,gCAID,CAIA,8CACC,+BAAgC,CAGhC,oCACD,CAGD,gDC/BA,kCDiCA,CAIE,mFAEC,oCACD,CAIA,mFAEC,qCACD,CAID,iEAEC,eAAgB,CAChB,sBAAuB,CAFvB,SAGD,CAGA,6EC1DD,kCD4DC,CAGA,qDACC,2BAA4B,CAC5B,4BACD,CAEA,sGACC,UACD,CAGA,yHAEC,eAKD,CAHC,qIE7EF,2CF+EE,CAKH,uBGlFC,eHkHD,CAhCA,qFG9EE,qCH8GF,CAhCA,uBAIC,oDAAqD,CACrD,sDAAuD,CACvD,QAAS,CE1FT,oCAA8B,CF6F9B,cAuBD,CAnBC,6CACC,wBACD,CAEA,6CACC,yBACD,CAEA,6CACC,2BACD,CAEA,6CACC,4BACD,CAEA,6BACC,YACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-dropdown-max-width: 75vw;
}

.ck.ck-dropdown {
	display: inline-block;
	position: relative;

	& .ck-dropdown__arrow {
		pointer-events: none;
		z-index: var(--ck-z-default);
	}

	/* Dropdown button should span horizontally, e.g. in vertical toolbars */
	& .ck-button.ck-dropdown__button {
		width: 100%;
	}

	& .ck-dropdown__panel {
		display: none;
		z-index: var(--ck-z-panel);
		max-width: var(--ck-dropdown-max-width);

		position: absolute;

		&.ck-dropdown__panel-visible {
			display: inline-block;
		}

		&.ck-dropdown__panel_ne,
		&.ck-dropdown__panel_nw,
		&.ck-dropdown__panel_n,
		&.ck-dropdown__panel_nmw,
		&.ck-dropdown__panel_nme {
			bottom: 100%;
		}

		&.ck-dropdown__panel_se,
		&.ck-dropdown__panel_sw,
		&.ck-dropdown__panel_smw,
		&.ck-dropdown__panel_sme,
		&.ck-dropdown__panel_s {
			/*
			 * Using transform: translate3d( 0, 100%, 0 ) causes blurry dropdown on Chrome 67-78+ on non-retina displays.
			 * See https://github.com/ckeditor/ckeditor5/issues/1053.
			 */
			top: 100%;
			bottom: auto;
		}

		&.ck-dropdown__panel_ne,
		&.ck-dropdown__panel_se {
			left: 0px;
		}

		&.ck-dropdown__panel_nw,
		&.ck-dropdown__panel_sw {
			right: 0px;
		}

		&.ck-dropdown__panel_s,
		&.ck-dropdown__panel_n {
			/* Positioning panels relative to the center of the button */
			left: 50%;
			transform: translateX(-50%);
		}

		&.ck-dropdown__panel_nmw,
		&.ck-dropdown__panel_smw {
			/* Positioning panels relative to the middle-west of the button */
			left: 75%;
			transform: translateX(-75%);
		}

		&.ck-dropdown__panel_nme,
		&.ck-dropdown__panel_sme {
			/* Positioning panels relative to the middle-east of the button */
			left: 25%;
			transform: translateX(-25%);
		}
	}
}

/*
 * Toolbar dropdown panels should be always above the UI (eg. other dropdown panels) from the editor's content.
 * See https://github.com/ckeditor/ckeditor5/issues/7874
 */
.ck.ck-toolbar .ck-dropdown__panel {
	z-index: calc( var(--ck-z-panel) + 1 );
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";
@import "../../../mixins/_disabled.css";
@import "../../../mixins/_shadow.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

:root {
	--ck-dropdown-arrow-size: calc(0.5 * var(--ck-icon-size));
}

.ck.ck-dropdown {
	/* Enable font size inheritance, which allows fluid UI scaling. */
	font-size: inherit;

	& .ck-dropdown__arrow {
		width: var(--ck-dropdown-arrow-size);
	}

	@mixin ck-dir ltr {
		& .ck-dropdown__arrow {
			right: var(--ck-spacing-standard);

			/* A space to accommodate the triangle. */
			margin-left: var(--ck-spacing-standard);
		}
	}

	@mixin ck-dir rtl {
		& .ck-dropdown__arrow {
			left: var(--ck-spacing-standard);

			/* A space to accommodate the triangle. */
			margin-right: var(--ck-spacing-small);
		}
	}

	&.ck-disabled .ck-dropdown__arrow {
		@mixin ck-disabled;
	}

	& .ck-button.ck-dropdown__button {
		@mixin ck-dir ltr {
			&:not(.ck-button_with-text) {
				/* Make sure dropdowns with just an icon have the right inner spacing */
				padding-left: var(--ck-spacing-small);
			}
		}

		@mixin ck-dir rtl {
			&:not(.ck-button_with-text) {
				/* Make sure dropdowns with just an icon have the right inner spacing */
				padding-right: var(--ck-spacing-small);
			}
		}

		/* #23 */
		& .ck-button__label {
			width: 7em;
			overflow: hidden;
			text-overflow: ellipsis;
		}

		/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/70 */
		&.ck-disabled .ck-button__label {
			@mixin ck-disabled;
		}

		/* https://github.com/ckeditor/ckeditor5/issues/816 */
		&.ck-on {
			border-bottom-left-radius: 0;
			border-bottom-right-radius: 0;
		}

		&.ck-dropdown__button_label-width_auto .ck-button__label {
			width: auto;
		}

		/* https://github.com/ckeditor/ckeditor5/issues/8699 */
		&.ck-off:active,
		&.ck-on:active {
			box-shadow: none;

			&:focus {
				@mixin ck-box-shadow var(--ck-focus-outer-shadow);
			}
		}
	}
}

.ck.ck-dropdown__panel {
	@mixin ck-rounded-corners;
	@mixin ck-drop-shadow;

	background: var(--ck-color-dropdown-panel-background);
	border: 1px solid var(--ck-color-dropdown-panel-border);
	bottom: 0;

	/* Make sure the panel is at least as wide as the drop-down's button. */
	min-width: 100%;

	/* Disabled corner border radius to be consistent with the .dropdown__button
	https://github.com/ckeditor/ckeditor5/issues/816 */
	&.ck-dropdown__panel_se {
		border-top-left-radius: 0;
	}

	&.ck-dropdown__panel_sw {
		border-top-right-radius: 0;
	}

	&.ck-dropdown__panel_ne {
		border-bottom-left-radius: 0;
	}

	&.ck-dropdown__panel_nw {
		border-bottom-right-radius: 0;
	}

	&:focus {
		outline: none;
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A class which indicates that an element holding it is disabled.
 */
@define-mixin ck-disabled {
	opacity: var(--ck-disabled-opacity);
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A helper to combine multiple shadows.
 */
@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {
	box-shadow: $shadowA, $shadowB;
}

/**
 * Gives an element a drop shadow so it looks like a floating panel.
 */
@define-mixin ck-drop-shadow {
	@mixin ck-box-shadow var(--ck-drop-shadow);
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            3629: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck.ck-dropdown>.ck-dropdown__panel>.ck-list{border-radius:0}.ck-rounded-corners .ck.ck-dropdown>.ck-dropdown__panel>.ck-list,.ck.ck-dropdown>.ck-dropdown__panel>.ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0}.ck.ck-dropdown>.ck-dropdown__panel>.ck-list .ck-list__item:first-child>.ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown>.ck-dropdown__panel>.ck-list .ck-list__item:first-child>.ck-button,.ck.ck-dropdown>.ck-dropdown__panel>.ck-list .ck-list__item:first-child>.ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-bottom-left-radius:0;border-bottom-right-radius:0;border-top-left-radius:0}.ck.ck-dropdown>.ck-dropdown__panel>.ck-list .ck-list__item:last-child>.ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown>.ck-dropdown__panel>.ck-list .ck-list__item:last-child>.ck-button,.ck.ck-dropdown>.ck-dropdown__panel>.ck-list .ck-list__item:last-child>.ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/listdropdown.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"],
                    names: [],
                    mappings: "AAOA,6CCIC,eDqBD,CAzBA,iICQE,qCAAsC,CDJtC,wBAqBF,CAfE,mFCND,eDYC,CANA,6MCFA,qCAAsC,CDKpC,2BAA4B,CAC5B,4BAA6B,CAF7B,wBAIF,CAEA,kFCdD,eDmBC,CALA,2MCVA,qCAAsC,CDYpC,wBAAyB,CACzB,yBAEF",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";

.ck.ck-dropdown > .ck-dropdown__panel > .ck-list {
	/* Disabled radius of top-left border to be consistent with .dropdown__button
	https://github.com/ckeditor/ckeditor5/issues/816 */
	@mixin ck-rounded-corners {
		border-top-left-radius: 0;
	}

	/* Make sure the button belonging to the first/last child of the list goes well with the
	border radius of the entire panel. */
	& .ck-list__item {
		&:first-child > .ck-button {
			@mixin ck-rounded-corners {
				border-top-left-radius: 0;
				border-bottom-left-radius: 0;
				border-bottom-right-radius: 0;
			}
		}

		&:last-child > .ck-button {
			@mixin ck-rounded-corners {
				border-top-left-radius: 0;
				border-top-right-radius: 0;
			}
		}
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            1792: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, '.ck.ck-splitbutton{font-size:inherit}.ck.ck-splitbutton .ck-splitbutton__action:focus{z-index:calc(var(--ck-z-default) + 1)}:root{--ck-color-split-button-hover-background:#ebebeb;--ck-color-split-button-hover-border:#b3b3b3}[dir=ltr] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,[dir=ltr] .ck.ck-splitbutton:hover>.ck-splitbutton__action{border-bottom-right-radius:unset;border-top-right-radius:unset}[dir=rtl] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,[dir=rtl] .ck.ck-splitbutton:hover>.ck-splitbutton__action{border-bottom-left-radius:unset;border-top-left-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow{min-width:unset}[dir=ltr] .ck.ck-splitbutton>.ck-splitbutton__arrow{border-bottom-left-radius:unset;border-top-left-radius:unset}[dir=rtl] .ck.ck-splitbutton>.ck-splitbutton__arrow{border-bottom-right-radius:unset;border-top-right-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow svg{width:var(--ck-dropdown-arrow-size)}.ck.ck-splitbutton>.ck-splitbutton__arrow:not(:focus){border-bottom-width:0;border-top-width:0}.ck.ck-splitbutton.ck-splitbutton_open>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover),.ck.ck-splitbutton:hover>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover){background:var(--ck-color-split-button-hover-background)}.ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{background-color:var(--ck-color-split-button-hover-border);content:"";height:100%;position:absolute;width:1px}.ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:focus:after,.ck.ck-splitbutton:hover>.ck-splitbutton__arrow:focus:after{--ck-color-split-button-hover-border:var(--ck-color-focus-border)}[dir=ltr] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,[dir=ltr] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{left:-1px}[dir=rtl] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,[dir=rtl] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{right:-1px}.ck.ck-splitbutton.ck-splitbutton_open{border-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__action{border-bottom-left-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__arrow{border-bottom-right-radius:0}', "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/dropdown/splitbutton.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/splitbutton.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"],
                    names: [],
                    mappings: "AAKA,mBAEC,iBAKD,CAHC,iDACC,qCACD,CCJD,MACC,gDAAyD,CACzD,4CACD,CAMC,oIAKE,gCAAiC,CADjC,6BASF,CAbA,oIAWE,+BAAgC,CADhC,4BAGF,CAEA,0CAGC,eAiBD,CApBA,oDAQE,+BAAgC,CADhC,4BAaF,CApBA,oDAcE,gCAAiC,CADjC,6BAOF,CAHC,8CACC,mCACD,CAKD,sDAEC,qBAAwB,CADxB,kBAED,CAQC,0KACC,wDACD,CAIA,8JAKC,0DAA2D,CAJ3D,UAAW,CAGX,WAAY,CAFZ,iBAAkB,CAClB,SAGD,CAGA,sIACC,iEACD,CAGC,kLACC,SACD,CAIA,kLACC,UACD,CAMF,uCCzFA,eDmGA,CAVA,qHCrFC,qCD+FD,CARE,qKACC,2BACD,CAEA,mKACC,4BACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-splitbutton {
	/* Enable font size inheritance, which allows fluid UI scaling. */
	font-size: inherit;

	& .ck-splitbutton__action:focus {
		z-index: calc(var(--ck-z-default) + 1);
	}
}

`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";

:root {
	--ck-color-split-button-hover-background: hsl(0, 0%, 92%);
	--ck-color-split-button-hover-border: hsl(0, 0%, 70%);
}

.ck.ck-splitbutton {
	/*
	 * Note: ck-rounded and ck-dir mixins don't go together (because they both use @nest).
	 */
	&:hover > .ck-splitbutton__action,
	&.ck-splitbutton_open > .ck-splitbutton__action {
		@nest [dir="ltr"] & {
			/* Don't round the action button on the right side */
			border-top-right-radius: unset;
			border-bottom-right-radius: unset;
		}

		@nest [dir="rtl"] & {
			/* Don't round the action button on the left side */
			border-top-left-radius: unset;
			border-bottom-left-radius: unset;
		}
	}

	& > .ck-splitbutton__arrow {
		/* It's a text-less button and since the icon is positioned absolutely in such situation,
		it must get some arbitrary min-width. */
		min-width: unset;

		@nest [dir="ltr"] & {
			/* Don't round the arrow button on the left side */
			border-top-left-radius: unset;
			border-bottom-left-radius: unset;
		}

		@nest [dir="rtl"] & {
			/* Don't round the arrow button on the right side */
			border-top-right-radius: unset;
			border-bottom-right-radius: unset;
		}

		& svg {
			width: var(--ck-dropdown-arrow-size);
		}
	}

	/* Make sure the divider stretches 100% height of the button
	https://github.com/ckeditor/ckeditor5/issues/10936 */
	& > .ck-splitbutton__arrow:not(:focus) {
		border-top-width: 0px;
		border-bottom-width: 0px;
	}

	/* When the split button is "open" (the arrow is on) or being hovered, it should get some styling
	as a whole. The background of both buttons should stand out and there should be a visual
	separation between both buttons. */
	&.ck-splitbutton_open,
	&:hover {
		/* When the split button hovered as a whole, not as individual buttons. */
		& > .ck-button:not(.ck-on):not(.ck-disabled):not(:hover) {
			background: var(--ck-color-split-button-hover-background);
		}

		/* Splitbutton separator needs to be set with the ::after pseudoselector
		to display properly the borders on focus */
		& > .ck-splitbutton__arrow:not(.ck-disabled)::after {
			content: '';
			position: absolute;
			width: 1px;
			height: 100%;
			background-color: var(--ck-color-split-button-hover-border);
		}

		/* Make sure the divider between the buttons looks fine when the button is focused */
		& > .ck-splitbutton__arrow:focus::after {
			--ck-color-split-button-hover-border: var(--ck-color-focus-border);
		}

		@nest [dir="ltr"] & {
			& > .ck-splitbutton__arrow:not(.ck-disabled)::after {
				left: -1px;
			}
		}

		@nest [dir="rtl"] & {
			& > .ck-splitbutton__arrow:not(.ck-disabled)::after {
				right: -1px;
			}
		}
	}

	/* Don't round the bottom left and right corners of the buttons when "open"
	https://github.com/ckeditor/ckeditor5/issues/816 */
	&.ck-splitbutton_open {
		@mixin ck-rounded-corners {
			& > .ck-splitbutton__action {
				border-bottom-left-radius: 0;
			}

			& > .ck-splitbutton__arrow {
				border-bottom-right-radius: 0;
			}
		}
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            1666: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ":root{--ck-toolbar-dropdown-max-width:60vw}.ck.ck-toolbar-dropdown>.ck-dropdown__panel{max-width:var(--ck-toolbar-dropdown-max-width);width:max-content}.ck.ck-toolbar-dropdown>.ck-dropdown__panel .ck-button:focus{z-index:calc(var(--ck-z-default) + 1)}.ck.ck-toolbar-dropdown .ck-toolbar{border:0}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/dropdown/toolbardropdown.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/toolbardropdown.css"],
                    names: [],
                    mappings: "AAKA,MACC,oCACD,CAEA,4CAGC,8CAA+C,CAD/C,iBAQD,CAJE,6DACC,qCACD,CCZF,oCACC,QACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-toolbar-dropdown-max-width: 60vw;
}

.ck.ck-toolbar-dropdown > .ck-dropdown__panel {
	/* https://github.com/ckeditor/ckeditor5/issues/5586 */
	width: max-content;
	max-width: var(--ck-toolbar-dropdown-max-width);

	& .ck-button {
		&:focus {
			z-index: calc(var(--ck-z-default) + 1);
		}
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-toolbar-dropdown .ck-toolbar {
	border: 0;
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            8527: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ":root{--ck-accessibility-help-dialog-max-width:600px;--ck-accessibility-help-dialog-max-height:400px;--ck-accessibility-help-dialog-border-color:#ccced1;--ck-accessibility-help-dialog-code-background-color:#ededed;--ck-accessibility-help-dialog-kbd-shadow-color:#9c9c9c}.ck.ck-accessibility-help-dialog .ck-accessibility-help-dialog__content{border:1px solid transparent;max-height:var(--ck-accessibility-help-dialog-max-height);max-width:var(--ck-accessibility-help-dialog-max-width);overflow:auto;padding:var(--ck-spacing-large);user-select:text}.ck.ck-accessibility-help-dialog .ck-accessibility-help-dialog__content:focus{border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0;outline:none}.ck.ck-accessibility-help-dialog .ck-accessibility-help-dialog__content{*{white-space:normal}}.ck.ck-accessibility-help-dialog .ck-accessibility-help-dialog__content .ck-label{display:none}.ck.ck-accessibility-help-dialog .ck-accessibility-help-dialog__content h3{font-size:1.2em;font-weight:700}.ck.ck-accessibility-help-dialog .ck-accessibility-help-dialog__content h4{font-size:1em;font-weight:700}.ck.ck-accessibility-help-dialog .ck-accessibility-help-dialog__content h3,.ck.ck-accessibility-help-dialog .ck-accessibility-help-dialog__content h4,.ck.ck-accessibility-help-dialog .ck-accessibility-help-dialog__content p,.ck.ck-accessibility-help-dialog .ck-accessibility-help-dialog__content table{margin:1em 0}.ck.ck-accessibility-help-dialog .ck-accessibility-help-dialog__content dl{border-bottom:none;border-top:1px solid var(--ck-accessibility-help-dialog-border-color);display:grid;grid-template-columns:2fr 1fr}.ck.ck-accessibility-help-dialog .ck-accessibility-help-dialog__content dl dd,.ck.ck-accessibility-help-dialog .ck-accessibility-help-dialog__content dl dt{border-bottom:1px solid var(--ck-accessibility-help-dialog-border-color);padding:.4em 0}.ck.ck-accessibility-help-dialog .ck-accessibility-help-dialog__content dl dt{grid-column-start:1}.ck.ck-accessibility-help-dialog .ck-accessibility-help-dialog__content dl dd{grid-column-start:2;text-align:right}.ck.ck-accessibility-help-dialog .ck-accessibility-help-dialog__content code,.ck.ck-accessibility-help-dialog .ck-accessibility-help-dialog__content kbd{background:var(--ck-accessibility-help-dialog-code-background-color);border-radius:2px;display:inline-block;font-size:.9em;line-height:1;padding:.4em;text-align:center;vertical-align:middle}.ck.ck-accessibility-help-dialog .ck-accessibility-help-dialog__content code{font-family:monospace}.ck.ck-accessibility-help-dialog .ck-accessibility-help-dialog__content kbd{box-shadow:0 1px 1px var(--ck-accessibility-help-dialog-kbd-shadow-color);margin:0 1px;min-width:1.8em}.ck.ck-accessibility-help-dialog .ck-accessibility-help-dialog__content kbd+kbd{margin-left:2px}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/editorui/accessibilityhelp.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"],
                    names: [],
                    mappings: "AAQA,MACC,8CAA+C,CAC/C,+CAAgD,CAChD,mDAA8D,CAC9D,4DAAyE,CACzE,uDACD,CAEA,wEAOC,4BAA6B,CAJ7B,yDAA0D,CAD1D,uDAAwD,CAExD,aAAc,CAHd,+BAAgC,CAIhC,gBAgFD,CA5EC,8ECdA,2BAA2B,CCF3B,2CAA8B,CDC9B,YDkBA,CAZD,wEAcC,EACC,kBACD,CAqED,CAlEC,kFACC,YACD,CAEA,2EAEC,eAAgB,CADhB,eAED,CAEA,2EAEC,aAAc,CADd,eAED,CAEA,8SAIC,YACD,CAEA,2EAIC,kBAAmB,CADnB,qEAAsE,CAFtE,YAAa,CACb,6BAiBD,CAbC,4JACC,wEAAyE,CACzE,cACD,CAEA,8EACC,mBACD,CAEA,8EACC,mBAAoB,CACpB,gBACD,CAGD,yJAEC,oEAAqE,CAIrE,iBAAkB,CALlB,oBAAqB,CAOrB,cAAe,CAHf,aAAc,CAFd,YAAa,CAIb,iBAAkB,CAHlB,qBAKD,CAEA,6EACC,qBACD,CAEA,4EAEC,yEAA4E,CAC5E,YAAa,CAFb,eAOD,CAHC,gFACC,eACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_focus.css";
@import "../../../mixins/_shadow.css";

:root {
	--ck-accessibility-help-dialog-max-width: 600px;
	--ck-accessibility-help-dialog-max-height: 400px;
	--ck-accessibility-help-dialog-border-color: hsl(220, 6%, 81%);
	--ck-accessibility-help-dialog-code-background-color: hsl(0deg 0% 92.94%);
	--ck-accessibility-help-dialog-kbd-shadow-color: hsl(0deg 0% 61%);
}

.ck.ck-accessibility-help-dialog .ck-accessibility-help-dialog__content {
	padding: var(--ck-spacing-large);
	max-width: var(--ck-accessibility-help-dialog-max-width);
	max-height: var(--ck-accessibility-help-dialog-max-height);
	overflow: auto;
	user-select: text;

	border: 1px solid transparent;

	&:focus {
		@mixin ck-focus-ring;
		@mixin ck-box-shadow var(--ck-focus-outer-shadow);
	}

	* {
		white-space: normal;
	}

	/* Hide the main label of the content container. */
	& .ck-label {
		display: none;
	}

	& h3 {
		font-weight: bold;
		font-size: 1.2em;
	}

	& h4 {
		font-weight: bold;
		font-size: 1em;
	}

	& p,
	& h3,
	& h4,
	& table {
		margin: 1em 0;
	}

	& dl {
		display: grid;
		grid-template-columns: 2fr 1fr;
		border-top: 1px solid var(--ck-accessibility-help-dialog-border-color);
		border-bottom: none;

		& dt, & dd {
			border-bottom: 1px solid var(--ck-accessibility-help-dialog-border-color);
			padding: .4em 0;
		}

		& dt {
			grid-column-start: 1;
		}

		& dd {
			grid-column-start: 2;
			text-align: right;
		}
	}

	& kbd, & code {
		display: inline-block;
		background: var(--ck-accessibility-help-dialog-code-background-color);
		padding: .4em;
		vertical-align: middle;
		line-height: 1;
		border-radius: 2px;
		text-align: center;
		font-size: .9em;
	}

	& code {
		font-family: monospace;
	}

	& kbd {
		min-width: 1.8em;
		box-shadow: 0px 1px 1px var(--ck-accessibility-help-dialog-kbd-shadow-color);
		margin: 0 1px;

		& + kbd {
			margin-left: 2px;
		}
	}
}

`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A visual style of focused element's border.
 */
@define-mixin ck-focus-ring {
	/* Disable native outline. */
	outline: none;
	border: var(--ck-focus-ring)
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A helper to combine multiple shadows.
 */
@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {
	box-shadow: $shadowA, $shadowB;
}

/**
 * Gives an element a drop shadow so it looks like a floating panel.
 */
@define-mixin ck-drop-shadow {
	@mixin ck-box-shadow var(--ck-drop-shadow);
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            1185: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ":root{--ck-color-editable-blur-selection:#d9d9d9}.ck.ck-editor__editable:not(.ck-editor__nested-editable){border-radius:0}.ck-rounded-corners .ck.ck-editor__editable:not(.ck-editor__nested-editable),.ck.ck-editor__editable.ck-rounded-corners:not(.ck-editor__nested-editable){border-radius:var(--ck-border-radius)}.ck.ck-editor__editable.ck-focused:not(.ck-editor__nested-editable){border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;outline:none}.ck.ck-editor__editable_inline{border:1px solid transparent;overflow:auto;padding:0 var(--ck-spacing-standard)}.ck.ck-editor__editable_inline[dir=ltr]{text-align:left}.ck.ck-editor__editable_inline[dir=rtl]{text-align:right}.ck.ck-editor__editable_inline>:first-child{margin-top:var(--ck-spacing-large)}.ck.ck-editor__editable_inline>:last-child{margin-bottom:var(--ck-spacing-large)}.ck.ck-editor__editable_inline.ck-blurred ::selection{background:var(--ck-color-editable-blur-selection)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_n]:after{border-bottom-color:var(--ck-color-panel-background)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_s]:after{border-top-color:var(--ck-color-panel-background)}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/editorui/editorui.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"],
                    names: [],
                    mappings: "AAWA,MACC,0CACD,CAEA,yDCJC,eDWD,CAPA,yJCAE,qCDOF,CAJC,oEEPA,2BAA2B,CCF3B,qCAA8B,CDC9B,YFWA,CAGD,+BAGC,4BAA6B,CAF7B,aAAc,CACd,oCA6BD,CA1BC,wCACC,eACD,CAEA,wCACC,gBACD,CAGA,4CACC,kCACD,CAGA,2CAKC,qCACD,CAGA,sDACC,kDACD,CAKA,gEACC,oDACD,CAIA,gEACC,iDACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";
@import "../../../mixins/_disabled.css";
@import "../../../mixins/_shadow.css";
@import "../../../mixins/_focus.css";
@import "../../mixins/_button.css";

:root {
	--ck-color-editable-blur-selection: hsl(0, 0%, 85%);
}

.ck.ck-editor__editable:not(.ck-editor__nested-editable) {
	@mixin ck-rounded-corners;

	&.ck-focused {
		@mixin ck-focus-ring;
		@mixin ck-box-shadow var(--ck-inner-shadow);
	}
}

.ck.ck-editor__editable_inline {
	overflow: auto;
	padding: 0 var(--ck-spacing-standard);
	border: 1px solid transparent;

	&[dir="ltr"] {
		text-align: left;
	}

	&[dir="rtl"] {
		text-align: right;
	}

	/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/116 */
	& > *:first-child {
		margin-top: var(--ck-spacing-large);
	}

	/* https://github.com/ckeditor/ckeditor5/issues/847 */
	& > *:last-child {
		/*
		 * This value should match with the default margins of the block elements (like .media or .image)
		 * to avoid a content jumping when the fake selection container shows up (See https://github.com/ckeditor/ckeditor5/issues/9825).
		 */
		margin-bottom: var(--ck-spacing-large);
	}

	/* https://github.com/ckeditor/ckeditor5/issues/6517 */
	&.ck-blurred ::selection {
		background: var(--ck-color-editable-blur-selection);
	}
}

/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/111 */
.ck.ck-balloon-panel.ck-toolbar-container[class*="arrow_n"] {
	&::after {
		border-bottom-color: var(--ck-color-panel-background);
	}
}

.ck.ck-balloon-panel.ck-toolbar-container[class*="arrow_s"] {
	&::after {
		border-top-color: var(--ck-color-panel-background);
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A visual style of focused element's border.
 */
@define-mixin ck-focus-ring {
	/* Disable native outline. */
	outline: none;
	border: var(--ck-focus-ring)
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A helper to combine multiple shadows.
 */
@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {
	box-shadow: $shadowA, $shadowB;
}

/**
 * Gives an element a drop shadow so it looks like a floating panel.
 */
@define-mixin ck-drop-shadow {
	@mixin ck-box-shadow var(--ck-drop-shadow);
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            7913: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck.ck-form__header{align-items:center;display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between}.ck.ck-form__header h2.ck-form__header__label{flex-grow:1}:root{--ck-form-header-height:44px}.ck.ck-form__header{border-bottom:1px solid var(--ck-color-base-border);height:var(--ck-form-header-height);line-height:var(--ck-form-header-height);padding:var(--ck-spacing-small) var(--ck-spacing-large)}[dir=ltr] .ck.ck-form__header>.ck-icon{margin-right:var(--ck-spacing-medium)}[dir=rtl] .ck.ck-form__header>.ck-icon{margin-left:var(--ck-spacing-medium)}.ck.ck-form__header .ck-form__header__label{--ck-font-size-base:15px;font-weight:700}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/formheader/formheader.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/formheader/formheader.css"],
                    names: [],
                    mappings: "AAKA,oBAIC,kBAAmB,CAHnB,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CAEjB,6BAKD,CAHC,8CACC,WACD,CCPD,MACC,4BACD,CAEA,oBAIC,mDAAoD,CAFpD,mCAAoC,CACpC,wCAAyC,CAFzC,uDAmBD,CAdC,uCAEE,qCAMF,CARA,uCAME,oCAEF,CAEA,4CACC,wBAAyB,CACzB,eACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-form__header {
	display: flex;
	flex-direction: row;
	flex-wrap: nowrap;
	align-items: center;
	justify-content: space-between;

	& h2.ck-form__header__label {
		flex-grow: 1;
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

:root {
	--ck-form-header-height: 44px;
}

.ck.ck-form__header {
	padding: var(--ck-spacing-small) var(--ck-spacing-large);
	height: var(--ck-form-header-height);
	line-height: var(--ck-form-header-height);
	border-bottom: 1px solid var(--ck-color-base-border);

	& > .ck-icon {
		@mixin ck-dir ltr {
			margin-right: var(--ck-spacing-medium);
		}

		@mixin ck-dir rtl {
			margin-left: var(--ck-spacing-medium);
		}
	}

	& .ck-form__header__label {
		--ck-font-size-base: 15px;
		font-weight: bold;
	}
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            9529: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck.ck-highlighted-text mark{background:var(--ck-color-highlight-background);font-size:inherit;font-weight:inherit;line-height:inherit;vertical-align:initial}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/highlightedtext/highlightedtext.css"],
                    names: [],
                    mappings: "AAKA,6BACC,+CAAgD,CAIhD,iBAAkB,CAFlB,mBAAoB,CACpB,mBAAoB,CAFpB,sBAID",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-highlighted-text mark {
	background: var(--ck-color-highlight-background);
	vertical-align: initial;
	font-weight: inherit;
	line-height: inherit;
	font-size: inherit;
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            7621: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck.ck-icon{vertical-align:middle}:root{--ck-icon-size:calc(var(--ck-line-height-base)*var(--ck-font-size-normal))}.ck.ck-icon{font-size:.8333350694em;height:var(--ck-icon-size);width:var(--ck-icon-size);will-change:transform}.ck.ck-icon,.ck.ck-icon *{cursor:inherit}.ck.ck-icon.ck-icon_inherit-color,.ck.ck-icon.ck-icon_inherit-color *{color:inherit}.ck.ck-icon.ck-icon_inherit-color :not([fill]){fill:currentColor}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/icon/icon.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/icon/icon.css"],
                    names: [],
                    mappings: "AAKA,YACC,qBACD,CCFA,MACC,0EACD,CAEA,YAKC,uBAAwB,CAHxB,0BAA2B,CAD3B,yBAA0B,CAU1B,qBAoBD,CAlBC,0BALA,cAQA,CAMC,sEACC,aAMD,CAJC,+CAEC,iBACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-icon {
	vertical-align: middle;
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-icon-size: calc(var(--ck-line-height-base) * var(--ck-font-size-normal));
}

.ck.ck-icon {
	width: var(--ck-icon-size);
	height: var(--ck-icon-size);

	/* Multiplied by the height of the line in "px" should give SVG "viewport" dimensions */
	font-size: .8333350694em;

	/* Inherit cursor style (#5). */
	cursor: inherit;

	/* This will prevent blurry icons on Firefox. See #340. */
	will-change: transform;

	& * {
		/* Inherit cursor style (#5). */
		cursor: inherit;
	}

	/* Allows dynamic coloring of an icon by inheriting its color from the parent. */
	&.ck-icon_inherit-color {
		color: inherit;

		& * {
			color: inherit;

			&:not([fill]) {
				/* Needed by FF. */
				fill: currentColor;
			}
		}
	}
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            253: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ":root{--ck-input-width:18em;--ck-input-text-width:var(--ck-input-width)}.ck.ck-input{border-radius:0}.ck-rounded-corners .ck.ck-input,.ck.ck-input.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-input{background:var(--ck-color-input-background);border:1px solid var(--ck-color-input-border);min-height:var(--ck-ui-component-min-height);min-width:var(--ck-input-width);padding:var(--ck-spacing-extra-tiny) var(--ck-spacing-medium);transition:box-shadow .1s ease-in-out,border .1s ease-in-out}@media (prefers-reduced-motion:reduce){.ck.ck-input{transition:none}}.ck.ck-input:focus{border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0;outline:none}.ck.ck-input[readonly]{background:var(--ck-color-input-disabled-background);border:1px solid var(--ck-color-input-disabled-border);color:var(--ck-color-input-disabled-text)}.ck.ck-input[readonly]:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),0 0}.ck.ck-input.ck-error{animation:ck-input-shake .3s ease both;border-color:var(--ck-color-input-error-border)}@media (prefers-reduced-motion:reduce){.ck.ck-input.ck-error{animation:none}}.ck.ck-input.ck-error:focus{box-shadow:var(--ck-focus-error-outer-shadow),0 0}@keyframes ck-input-shake{20%{transform:translateX(-2px)}40%{transform:translateX(2px)}60%{transform:translateX(-1px)}80%{transform:translateX(1px)}}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/input/input.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"],
                    names: [],
                    mappings: "AASA,MACC,qBAAsB,CAGtB,2CACD,CAEA,aCLC,eDmDD,CA9CA,iECDE,qCD+CF,CA9CA,aAGC,2CAA4C,CAC5C,6CAA8C,CAK9C,4CAA6C,CAH7C,+BAAgC,CADhC,6DAA8D,CAO9D,4DAkCD,CAhCC,uCAdD,aAeE,eA+BF,CA9BC,CAEA,mBEvBA,2BAA2B,CCF3B,2CAA8B,CDC9B,YF2BA,CAEA,uBAEC,oDAAqD,CADrD,sDAAuD,CAEvD,yCAMD,CAJC,6BGnCD,oDHsCC,CAGD,sBAEC,sCAAuC,CADvC,+CAUD,CAPC,uCAJD,sBAKE,cAMF,CALC,CAEA,4BGjDD,iDHmDC,CAIF,0BACC,IACC,0BACD,CAEA,IACC,yBACD,CAEA,IACC,0BACD,CAEA,IACC,yBACD,CACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";
@import "../../../mixins/_focus.css";
@import "../../../mixins/_shadow.css";

:root {
	--ck-input-width: 18em;

	/* Backward compatibility. */
	--ck-input-text-width: var(--ck-input-width);
}

.ck.ck-input {
	@mixin ck-rounded-corners;

	background: var(--ck-color-input-background);
	border: 1px solid var(--ck-color-input-border);
	padding: var(--ck-spacing-extra-tiny) var(--ck-spacing-medium);
	min-width: var(--ck-input-width);

	/* This is important to stay of the same height as surrounding buttons */
	min-height: var(--ck-ui-component-min-height);

	/* Apply some smooth transition to the box-shadow and border. */
	transition: box-shadow .1s ease-in-out, border .1s ease-in-out;

	@media (prefers-reduced-motion: reduce) {
		transition: none;
	}

	&:focus {
		@mixin ck-focus-ring;
		@mixin ck-box-shadow var(--ck-focus-outer-shadow);
	}

	&[readonly] {
		border: 1px solid var(--ck-color-input-disabled-border);
		background: var(--ck-color-input-disabled-background);
		color: var(--ck-color-input-disabled-text);

		&:focus {
			/* The read-only input should have a slightly less visible shadow when focused. */
			@mixin ck-box-shadow var(--ck-focus-disabled-outer-shadow);
		}
	}

	&.ck-error {
		border-color: var(--ck-color-input-error-border);
		animation: ck-input-shake .3s ease both;

		@media (prefers-reduced-motion: reduce) {
			animation: none;
		}

		&:focus {
			@mixin ck-box-shadow var(--ck-focus-error-outer-shadow);
		}
	}
}

@keyframes ck-input-shake {
	20% {
		transform: translateX(-2px);
	}

	40% {
		transform: translateX(2px);
	}

	60% {
		transform: translateX(-1px);
	}

	80% {
		transform: translateX(1px);
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A visual style of focused element's border.
 */
@define-mixin ck-focus-ring {
	/* Disable native outline. */
	outline: none;
	border: var(--ck-focus-ring)
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A helper to combine multiple shadows.
 */
@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {
	box-shadow: $shadowA, $shadowB;
}

/**
 * Gives an element a drop shadow so it looks like a floating panel.
 */
@define-mixin ck-drop-shadow {
	@mixin ck-box-shadow var(--ck-drop-shadow);
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            7801: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck.ck-label{display:block}.ck.ck-voice-label{display:none}.ck.ck-label{font-weight:700}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/label/label.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/label/label.css"],
                    names: [],
                    mappings: "AAKA,aACC,aACD,CAEA,mBACC,YACD,CCNA,aACC,eACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-label {
	display: block;
}

.ck.ck-voice-label {
	display: none;
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-label {
	font-weight: bold;
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            4962: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper{display:flex;position:relative}.ck.ck-labeled-field-view .ck.ck-label{display:block;position:absolute}:root{--ck-labeled-field-view-transition:.1s cubic-bezier(0,0,0.24,0.95);--ck-labeled-field-empty-unfocused-max-width:100% - 2 * var(--ck-spacing-medium);--ck-labeled-field-label-default-position-x:var(--ck-spacing-medium);--ck-labeled-field-label-default-position-y:calc(var(--ck-font-size-base)*0.6);--ck-color-labeled-field-label-background:var(--ck-color-base-background)}.ck.ck-labeled-field-view{border-radius:0}.ck-rounded-corners .ck.ck-labeled-field-view,.ck.ck-labeled-field-view.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper{width:100%}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{top:0}[dir=ltr] .ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{left:0;transform:translate(var(--ck-spacing-medium),-6px) scale(.75);transform-origin:0 0}[dir=rtl] .ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{right:0;transform:translate(calc(var(--ck-spacing-medium)*-1),-6px) scale(.75);transform-origin:100% 0}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{background:var(--ck-color-labeled-field-label-background);font-weight:400;line-height:normal;max-width:100%;overflow:hidden;padding:0 calc(var(--ck-font-size-tiny)*.5);pointer-events:none;text-overflow:ellipsis;transition:transform var(--ck-labeled-field-view-transition),padding var(--ck-labeled-field-view-transition),background var(--ck-labeled-field-view-transition)}@media (prefers-reduced-motion:reduce){.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{transition:none}}.ck.ck-labeled-field-view.ck-error .ck-input:not([readonly])+.ck.ck-label,.ck.ck-labeled-field-view.ck-error>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{color:var(--ck-color-base-error)}.ck.ck-labeled-field-view .ck-labeled-field-view__status{font-size:var(--ck-font-size-small);margin-top:var(--ck-spacing-small);white-space:normal}.ck.ck-labeled-field-view .ck-labeled-field-view__status.ck-labeled-field-view__status_error{color:var(--ck-color-base-error)}.ck.ck-labeled-field-view.ck-disabled>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{color:var(--ck-color-input-disabled-text)}[dir=ltr] .ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty:not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,[dir=ltr] .ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder):not(.ck-error)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{transform:translate(var(--ck-labeled-field-label-default-position-x),var(--ck-labeled-field-label-default-position-y)) scale(1)}[dir=rtl] .ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty:not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,[dir=rtl] .ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder):not(.ck-error)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{transform:translate(calc(var(--ck-labeled-field-label-default-position-x)*-1),var(--ck-labeled-field-label-default-position-y)) scale(1)}.ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty:not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder):not(.ck-error)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{background:transparent;max-width:calc(var(--ck-labeled-field-empty-unfocused-max-width));padding:0}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown>.ck.ck-button{background:transparent}.ck.ck-labeled-field-view.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown>.ck-button>.ck-button__label{opacity:0}.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown+.ck-label{max-width:calc(var(--ck-labeled-field-empty-unfocused-max-width) - var(--ck-dropdown-arrow-size) - var(--ck-spacing-standard))}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/labeledfield/labeledfieldview.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/labeledfield/labeledfieldview.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"],
                    names: [],
                    mappings: "AAMC,mEACC,YAAa,CACb,iBACD,CAEA,uCACC,aAAc,CACd,iBACD,CCND,MACC,kEAAsE,CACtE,gFAAiF,CACjF,oEAAqE,CACrE,8EAAiF,CACjF,yEACD,CAEA,0BCLC,eDmHD,CA9GA,2FCDE,qCD+GF,CA3GC,mEACC,UAwCD,CAtCC,gFACC,KAoCD,CArCA,0FAIE,MAAS,CAGT,6DAA+D,CAF/D,oBAgCF,CArCA,0FAWE,OAAU,CAEV,sEAA0E,CAD1E,uBAyBF,CArCA,gFAkBC,yDAA0D,CAG1D,eAAmB,CADnB,kBAAoB,CAOpB,cAAe,CAFf,eAAgB,CANhB,2CAA8C,CAH9C,mBAAoB,CAQpB,sBAAuB,CAKvB,+JAQD,CAHC,uCAlCD,gFAmCE,eAEF,CADC,CASD,mKACC,gCACD,CAGD,yDACC,mCAAoC,CACpC,kCAAmC,CAInC,kBAKD,CAHC,6FACC,gCACD,CAID,4OAEC,yCACD,CAIA,2XAGE,+HAYF,CAfA,2XAOE,wIAQF,CAfA,uWAaC,sBAAuB,CAFvB,iEAAkE,CAGlE,SACD,CAKA,8FACC,sBACD,CAGA,yIACC,SACD,CAGA,kMACC,8HACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-labeled-field-view {
	& > .ck.ck-labeled-field-view__input-wrapper {
		display: flex;
		position: relative;
	}

	& .ck.ck-label {
		display: block;
		position: absolute;
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";
@import "../../../mixins/_rounded.css";

:root {
	--ck-labeled-field-view-transition: .1s cubic-bezier(0, 0, 0.24, 0.95);
	--ck-labeled-field-empty-unfocused-max-width: 100% - 2 * var(--ck-spacing-medium);
	--ck-labeled-field-label-default-position-x: var(--ck-spacing-medium);
	--ck-labeled-field-label-default-position-y: calc(0.6 * var(--ck-font-size-base));
	--ck-color-labeled-field-label-background: var(--ck-color-base-background);
}

.ck.ck-labeled-field-view {
	@mixin ck-rounded-corners;

	& > .ck.ck-labeled-field-view__input-wrapper {
		width: 100%;

		& > .ck.ck-label {
			top: 0px;

			@mixin ck-dir ltr {
				left: 0px;
				transform-origin: 0 0;
				/* By default, display the label scaled down above the field. */
				transform: translate(var(--ck-spacing-medium), -6px) scale(.75);
			}

			@mixin ck-dir rtl {
				right: 0px;
				transform-origin: 100% 0;
				transform: translate(calc(-1 * var(--ck-spacing-medium)), -6px) scale(.75);
			}

			pointer-events: none;

			background: var(--ck-color-labeled-field-label-background);
			padding: 0 calc(.5 * var(--ck-font-size-tiny));
			line-height: initial;
			font-weight: normal;

			/* Prevent overflow when the label is longer than the input */
			text-overflow: ellipsis;
			overflow: hidden;

			max-width: 100%;

			transition:
				transform var(--ck-labeled-field-view-transition),
				padding var(--ck-labeled-field-view-transition),
				background var(--ck-labeled-field-view-transition);

			@media (prefers-reduced-motion: reduce) {
				transition: none;
			}
		}
	}

	&.ck-error {
		& > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {
			color: var(--ck-color-base-error);
		}

		& .ck-input:not([readonly]) + .ck.ck-label {
			color: var(--ck-color-base-error);
		}
	}

	& .ck-labeled-field-view__status {
		font-size: var(--ck-font-size-small);
		margin-top: var(--ck-spacing-small);

		/* Let the info wrap to the next line to avoid stretching the layout horizontally.
		The status could be very long. */
		white-space: normal;

		&.ck-labeled-field-view__status_error {
			color: var(--ck-color-base-error);
		}
	}

	/* Disabled fields and fields that have no focus should fade out. */
	&.ck-disabled > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label,
	&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused) > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {
		color: var(--ck-color-input-disabled-text);
	}

	/* Fields that are disabled or not focused and without a placeholder should have full-sized labels. */
	/* stylelint-disable-next-line no-descending-specificity */
	&.ck-disabled.ck-labeled-field-view_empty:not(.ck-labeled-field-view_placeholder) > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label,
	&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder):not(.ck-error) > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {
		@mixin ck-dir ltr {
			transform: translate(var(--ck-labeled-field-label-default-position-x), var(--ck-labeled-field-label-default-position-y)) scale(1);
		}

		@mixin ck-dir rtl {
			transform: translate(calc(-1 * var(--ck-labeled-field-label-default-position-x)), var(--ck-labeled-field-label-default-position-y)) scale(1);
		}

		/* Compensate for the default translate position. */
		max-width: calc(var(--ck-labeled-field-empty-unfocused-max-width));

		background: transparent;
		padding: 0;
	}

	/*------ DropdownView integration ----------------------------------------------------------------------------------- */

	/* Make sure dropdown' background color in any of dropdown's state does not collide with labeled field. */
	& > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown > .ck.ck-button {
		background: transparent;
	}

	/* When the dropdown is "empty", the labeled field label replaces its label. */
	&.ck-labeled-field-view_empty > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown > .ck-button > .ck-button__label {
		opacity: 0;
	}

	/* Make sure the label of the empty, unfocused input does not cover the dropdown arrow. */
	&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder) > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown + .ck-label {
		max-width: calc(var(--ck-labeled-field-empty-unfocused-max-width) - var(--ck-dropdown-arrow-size) - var(--ck-spacing-standard));
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            5199: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck.ck-list{display:flex;flex-direction:column;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-list .ck-list__item,.ck.ck-list .ck-list__separator{display:block}.ck.ck-list .ck-list__item>:focus{position:relative;z-index:var(--ck-z-default)}:root{--ck-list-button-padding:calc(var(--ck-line-height-base)*0.11*var(--ck-font-size-base)) calc(var(--ck-line-height-base)*0.4*var(--ck-font-size-base))}.ck.ck-list{border-radius:0}.ck-rounded-corners .ck.ck-list,.ck.ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-list{background:var(--ck-color-list-background);list-style-type:none}.ck.ck-list__item{cursor:default;min-width:12em}.ck.ck-list__item>.ck-button{border-radius:0;min-height:unset;width:100%}[dir=ltr] .ck.ck-list__item>.ck-button{text-align:left}[dir=rtl] .ck.ck-list__item>.ck-button{text-align:right}.ck.ck-list__item>.ck-button{padding:var(--ck-list-button-padding)}.ck.ck-list__item>.ck-button:active{box-shadow:none}.ck.ck-list__item>.ck-button.ck-on{background:var(--ck-color-list-button-on-background);color:var(--ck-color-list-button-on-text)}.ck.ck-list__item>.ck-button.ck-on:active{box-shadow:none}.ck.ck-list__item>.ck-button.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-on-background-focus)}.ck.ck-list__item>.ck-button.ck-on:focus:not(.ck-switchbutton):not(.ck-disabled){border-color:var(--ck-color-base-background)}.ck.ck-list__item>.ck-button:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background)}.ck.ck-list__item>.ck-switchbutton.ck-on{background:var(--ck-color-list-background);color:inherit}.ck.ck-list__item>.ck-switchbutton.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background);color:inherit}.ck-list .ck-list__group{padding-top:var(--ck-spacing-medium);:not(.ck-hidden)~&{border-top:1px solid var(--ck-color-base-border)}}.ck-list .ck-list__group>.ck-label{font-size:11px;font-weight:700;padding:var(--ck-spacing-medium) var(--ck-spacing-medium) 0 var(--ck-spacing-medium)}.ck.ck-list__separator{background:var(--ck-color-base-border);height:1px;width:100%}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/list/list.css", "webpack://./../ckeditor5-ui/theme/mixins/_unselectable.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/list/list.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"],
                    names: [],
                    mappings: "AAOA,YAGC,YAAa,CACb,qBAAsB,CCFtB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBDaD,CAZC,2DAEC,aACD,CAKA,kCACC,iBAAkB,CAClB,2BACD,CEdD,MACC,qJAGD,CAEA,YCLC,eDUD,CALA,+DCDE,qCDMF,CALA,YAIC,0CAA2C,CAD3C,oBAED,CAEA,kBACC,cAAe,CACf,cA2DD,CAzDC,6BAGC,eAAgB,CAFhB,gBAAiB,CACjB,UAwCD,CA1CA,uCAME,eAoCF,CA1CA,uCAUE,gBAgCF,CA1CA,6BAgBC,qCA0BD,CAxBC,oCACC,eACD,CAEA,mCACC,oDAAqD,CACrD,yCAaD,CAXC,0CACC,eACD,CAEA,2DACC,0DACD,CAEA,iFACC,4CACD,CAGD,qDACC,uDACD,CAMA,yCACC,0CAA2C,CAC3C,aAMD,CAJC,iEACC,uDAAwD,CACxD,aACD,CAKH,yBACC,oCAAqC,CAGrC,mBACC,gDACD,CAOD,CALC,mCACC,cAAe,CACf,eAAiB,CACjB,oFACD,CAGD,uBAGC,sCAAuC,CAFvC,UAAW,CACX,UAED",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../mixins/_unselectable.css";

.ck.ck-list {
	@mixin ck-unselectable;

	display: flex;
	flex-direction: column;

	& .ck-list__item,
	& .ck-list__separator {
		display: block;
	}

	/* Make sure that whatever child of the list item gets focus, it remains on the
	top. Thanks to that, styles like box-shadow, outline, etc. are not masked by
	adjacent list items. */
	& .ck-list__item > *:focus {
		position: relative;
		z-index: var(--ck-z-default);
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Makes element unselectable.
 */
@define-mixin ck-unselectable {
	-moz-user-select: none;
	-webkit-user-select: none;
	-ms-user-select: none;
	user-select: none
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_disabled.css";
@import "../../../mixins/_rounded.css";
@import "../../../mixins/_shadow.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

:root {
	--ck-list-button-padding:
		calc(.11 * var(--ck-line-height-base) * var(--ck-font-size-base))
		calc(.4 * var(--ck-line-height-base) * var(--ck-font-size-base));
}

.ck.ck-list {
	@mixin ck-rounded-corners;

	list-style-type: none;
	background: var(--ck-color-list-background);
}

.ck.ck-list__item {
	cursor: default;
	min-width: 12em;

	& > .ck-button {
		min-height: unset;
		width: 100%;
		border-radius: 0;

		@mixin ck-dir ltr {
			text-align: left;
		}

		@mixin ck-dir rtl {
			text-align: right;
		}

		/* List items should have the same height. Use absolute units to make sure it is so
		   because e.g. different heading styles may have different height
		   https://github.com/ckeditor/ckeditor5-heading/issues/63 */
		padding: var(--ck-list-button-padding);

		&:active {
			box-shadow: none;
		}

		&.ck-on {
			background: var(--ck-color-list-button-on-background);
			color: var(--ck-color-list-button-on-text);

			&:active {
				box-shadow: none;
			}

			&:hover:not(.ck-disabled) {
				background: var(--ck-color-list-button-on-background-focus);
			}

			&:focus:not(.ck-switchbutton):not(.ck-disabled) {
				border-color: var(--ck-color-base-background);
			}
		}

		&:hover:not(.ck-disabled) {
			background: var(--ck-color-list-button-hover-background);
		}
	}

	/* It's unnecessary to change the background/text of a switch toggle; it has different ways
	of conveying its state (like the switcher) */
	& > .ck-switchbutton {
		&.ck-on {
			background: var(--ck-color-list-background);
			color: inherit;

			&:hover:not(.ck-disabled) {
				background: var(--ck-color-list-button-hover-background);
				color: inherit;
			}
		}
	}
}

.ck-list .ck-list__group {
	padding-top: var(--ck-spacing-medium);

	/* The group should have a border when it's not the first item. */
	*:not(.ck-hidden) ~ & {
		border-top: 1px solid var(--ck-color-base-border);
	}

	& > .ck-label {
		font-size: 11px;
		font-weight: bold;
		padding: var(--ck-spacing-medium) var(--ck-spacing-medium) 0 var(--ck-spacing-medium);
	}
}

.ck.ck-list__separator {
	height: 1px;
	width: 100%;
	background: var(--ck-color-base-border);
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            497: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck.ck-menu-bar{background:var(--ck-color-base-background);border:1px solid var(--ck-color-toolbar-border);display:flex;flex-wrap:wrap;gap:var(--ck-spacing-small);justify-content:flex-start;padding:var(--ck-spacing-small);width:100%}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/menubar/menubar.css"],
                    names: [],
                    mappings: "AAKA,gBAIC,0CAA2C,CAG3C,+CAAgD,CANhD,YAAa,CACb,cAAe,CAIf,2BAA4B,CAH5B,0BAA2B,CAE3B,+BAAgC,CAGhC,UACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-menu-bar {
	display: flex;
	flex-wrap: wrap;
	justify-content: flex-start;
	background: var(--ck-color-base-background);
	padding: var(--ck-spacing-small);
	gap: var(--ck-spacing-small);
	border: 1px solid var(--ck-color-toolbar-border);
	width: 100%;
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            4: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck.ck-menu-bar__menu{display:block;font-size:inherit;position:relative}.ck.ck-menu-bar__menu.ck-menu-bar__menu_top-level{max-width:100%}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/menubar/menubarmenu.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/menubar/menubarmenu.css"],
                    names: [],
                    mappings: "AAKA,sBACC,aAAc,CCCd,iBAAkB,CDAlB,iBACD,CCCC,kDACC,cACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-menu-bar__menu {
	display: block;
	position: relative;
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-menu-bar__menu {
	/* Enable font size inheritance, which allows fluid UI scaling. */
	font-size: inherit;

	&.ck-menu-bar__menu_top-level {
		max-width: 100%;
	}
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            3344: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck.ck-menu-bar__menu>.ck-menu-bar__menu__button>.ck-menu-bar__menu__button__arrow{pointer-events:none;z-index:var(--ck-z-default)}.ck.ck-menu-bar__menu>.ck-menu-bar__menu__button{padding:var(--ck-list-button-padding);width:100%}.ck.ck-menu-bar__menu>.ck-menu-bar__menu__button>.ck-button__label{flex-grow:1;overflow:hidden;text-overflow:ellipsis}.ck.ck-menu-bar__menu>.ck-menu-bar__menu__button.ck-disabled>.ck-button__label{opacity:var(--ck-disabled-opacity)}[dir=ltr] .ck.ck-menu-bar__menu>.ck-menu-bar__menu__button:not(.ck-button_with-text){padding-left:var(--ck-spacing-small)}[dir=rtl] .ck.ck-menu-bar__menu>.ck-menu-bar__menu__button:not(.ck-button_with-text){padding-right:var(--ck-spacing-small)}.ck.ck-menu-bar__menu.ck-menu-bar__menu_top-level>.ck-menu-bar__menu__button{min-height:unset;padding:var(--ck-spacing-small) var(--ck-spacing-medium)}.ck.ck-menu-bar__menu.ck-menu-bar__menu_top-level>.ck-menu-bar__menu__button .ck-button__label{line-height:unset;width:unset}.ck.ck-menu-bar__menu.ck-menu-bar__menu_top-level>.ck-menu-bar__menu__button.ck-on{border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-menu-bar__menu.ck-menu-bar__menu_top-level>.ck-menu-bar__menu__button .ck-icon{display:none}.ck.ck-menu-bar__menu:not(.ck-menu-bar__menu_top-level) .ck-menu-bar__menu__button{border-radius:0}.ck.ck-menu-bar__menu:not(.ck-menu-bar__menu_top-level) .ck-menu-bar__menu__button:focus{border-color:transparent;box-shadow:none}.ck.ck-menu-bar__menu:not(.ck-menu-bar__menu_top-level) .ck-menu-bar__menu__button:focus:not(.ck-on){background:var(--ck-color-button-default-hover-background)}.ck.ck-menu-bar__menu:not(.ck-menu-bar__menu_top-level) .ck-menu-bar__menu__button:not(:has(.ck-button__icon))>.ck-button__label{margin-left:calc(var(--ck-icon-size) - var(--ck-spacing-small))}.ck.ck-menu-bar__menu:not(.ck-menu-bar__menu_top-level) .ck-menu-bar__menu__button>.ck-menu-bar__menu__button__arrow{width:var(--ck-dropdown-arrow-size)}[dir=ltr] .ck.ck-menu-bar__menu:not(.ck-menu-bar__menu_top-level) .ck-menu-bar__menu__button>.ck-menu-bar__menu__button__arrow{transform:rotate(-90deg)}[dir=rtl] .ck.ck-menu-bar__menu:not(.ck-menu-bar__menu_top-level) .ck-menu-bar__menu__button>.ck-menu-bar__menu__button__arrow{transform:rotate(90deg)}.ck.ck-menu-bar__menu:not(.ck-menu-bar__menu_top-level) .ck-menu-bar__menu__button.ck-disabled>.ck-menu-bar__menu__button__arrow{opacity:var(--ck-disabled-opacity)}[dir=ltr] .ck.ck-menu-bar__menu:not(.ck-menu-bar__menu_top-level) .ck-menu-bar__menu__button>.ck-menu-bar__menu__button__arrow{margin-left:var(--ck-spacing-standard);right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-menu-bar__menu:not(.ck-menu-bar__menu_top-level) .ck-menu-bar__menu__button>.ck-menu-bar__menu__button__arrow{left:var(--ck-spacing-standard);margin-right:var(--ck-spacing-small)}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/menubar/menubarmenubutton.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/menubar/menubarmenubutton.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_disabled.css"],
                    names: [],
                    mappings: "AAMC,mFACC,mBAAoB,CACpB,2BACD,CCIA,iDACC,qCAAsC,CACtC,UAuBD,CArBC,mEACC,WAAY,CACZ,eAAgB,CAChB,sBACD,CAEA,+ECdD,kCDgBC,CAGC,qFACC,oCACD,CAIA,qFACC,qCACD,CAOF,6EAEC,gBAAiB,CADjB,wDAgBD,CAbC,+FAEC,iBAAkB,CADlB,WAED,CAEA,mFACC,2BAA4B,CAC5B,4BACD,CAEA,sFACC,YACD,CAMD,mFACC,eAiDD,CA/CC,yFACC,wBAAyB,CACzB,eAKD,CAHC,qGACC,0DACD,CAID,iIACC,+DACD,CAEA,qHACC,mCASD,CAVA,+HAIE,wBAMF,CAVA,+HAQE,uBAEF,CAEA,iICrFD,kCDuFC,CAGC,+HAIC,sCAAuC,CAHvC,gCAID,CAIA,+HACC,+BAAgC,CAGhC,oCACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-menu-bar__menu  {
	& > .ck-menu-bar__menu__button > .ck-menu-bar__menu__button__arrow {
		pointer-events: none;
		z-index: var(--ck-z-default);
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_disabled.css";
@import "../../mixins/_button.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

.ck.ck-menu-bar__menu {
	/*
	 * All menu buttons.
	 */
	& > .ck-menu-bar__menu__button {
		padding: var(--ck-list-button-padding);
		width: 100%;

		& > .ck-button__label {
			flex-grow: 1;
			overflow: hidden;
			text-overflow: ellipsis;
		}

		&.ck-disabled > .ck-button__label {
			@mixin ck-disabled;
		}

		@mixin ck-dir ltr {
			&:not(.ck-button_with-text) {
				padding-left: var(--ck-spacing-small);
			}
		}

		@mixin ck-dir rtl {
			&:not(.ck-button_with-text) {
				padding-right: var(--ck-spacing-small);
			}
		}
	}

	/*
	 * Top-level menu buttons only.
	 */
	&.ck-menu-bar__menu_top-level > .ck-menu-bar__menu__button {
		padding: var(--ck-spacing-small) var(--ck-spacing-medium);
		min-height: unset;

		& .ck-button__label {
			width: unset;
			line-height: unset;
		}

		&.ck-on {
			border-bottom-left-radius: 0;
			border-bottom-right-radius: 0;
		}

		& .ck-icon {
			display: none;
		}
	}

	/*
	 * Sub-menu buttons.
	 */
	&:not(.ck-menu-bar__menu_top-level) .ck-menu-bar__menu__button {
		border-radius: 0;

		&:focus {
			border-color: transparent;
			box-shadow: none;

			&:not(.ck-on) {
				background: var(--ck-color-button-default-hover-background);
			}
		}

		/* Spacing in buttons that miss the icon. */
		&:not(:has(.ck-button__icon)) > .ck-button__label {
			margin-left: calc(var(--ck-icon-size) - var(--ck-spacing-small));
		}

		& > .ck-menu-bar__menu__button__arrow {
			width: var(--ck-dropdown-arrow-size);

			@mixin ck-dir ltr {
				transform: rotate(-90deg);
			}

			@mixin ck-dir rtl {
				transform: rotate(90deg);
			}
		}

		&.ck-disabled > .ck-menu-bar__menu__button__arrow {
			@mixin ck-disabled;
		}

		@mixin ck-dir ltr {
			& > .ck-menu-bar__menu__button__arrow {
				right: var(--ck-spacing-standard);

				/* A space to accommodate the triangle. */
				margin-left: var(--ck-spacing-standard);
			}
		}

		@mixin ck-dir rtl {
			& > .ck-menu-bar__menu__button__arrow {
				left: var(--ck-spacing-standard);

				/* A space to accommodate the triangle. */
				margin-right: var(--ck-spacing-small);
			}
		}
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A class which indicates that an element holding it is disabled.
 */
@define-mixin ck-disabled {
	opacity: var(--ck-disabled-opacity);
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            9481: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ":root{--ck-menu-bar-menu-item-min-width:18em}.ck.ck-menu-bar__menu .ck.ck-menu-bar__menu__item{min-width:var(--ck-menu-bar-menu-item-min-width)}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/menubar/menubarmenulistitem.css"],
                    names: [],
                    mappings: "AAKA,MACC,sCACD,CAEA,kDACC,gDACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-menu-bar-menu-item-min-width: 18em;
}

.ck.ck-menu-bar__menu .ck.ck-menu-bar__menu__item {
	min-width: var(--ck-menu-bar-menu-item-min-width);
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            977: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck.ck-menu-bar__menu .ck-button.ck-menu-bar__menu__item__button{border-radius:0}.ck.ck-menu-bar__menu .ck-button.ck-menu-bar__menu__item__button>.ck-spinner-container,.ck.ck-menu-bar__menu .ck-button.ck-menu-bar__menu__item__button>.ck-spinner-container .ck-spinner{--ck-toolbar-spinner-size:20px}.ck.ck-menu-bar__menu .ck-button.ck-menu-bar__menu__item__button>.ck-spinner-container{margin-left:calc(var(--ck-spacing-small)*-1);margin-right:var(--ck-spacing-small)}.ck.ck-menu-bar__menu .ck-button.ck-menu-bar__menu__item__button:focus{border-color:transparent;box-shadow:none}.ck.ck-menu-bar__menu .ck-button.ck-menu-bar__menu__item__button:focus:not(.ck-on){background:var(--ck-color-button-default-hover-background)}.ck.ck-menu-bar__menu.ck-menu-bar__menu_top-level>.ck-menu-bar__menu__panel>ul>.ck-menu-bar__menu__item>.ck-menu-bar__menu__item__button:not(:has(.ck-button__icon))>.ck-button__label{margin-left:calc(var(--ck-icon-size) - var(--ck-spacing-small))}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/menubar/menubarmenulistitembutton.css"],
                    names: [],
                    mappings: "AASC,iEACC,eA0BD,CAxBC,0LAGC,8BACD,CAEA,uFAEC,4CAA+C,CAC/C,oCACD,CAMA,uEACC,wBAAyB,CACzB,eAKD,CAHC,mFACC,0DACD,CASD,uLACC,+DACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-menu-bar__menu {
	/*
	 * List item buttons.
	 */
	& .ck-button.ck-menu-bar__menu__item__button {
		border-radius: 0;

		& > .ck-spinner-container,
		& > .ck-spinner-container .ck-spinner {
			/* These styles correspond to .ck-icon so that the spinner seamlessly replaces the icon. */
			--ck-toolbar-spinner-size: 20px;
		}

		& > .ck-spinner-container {
			/* These margins are the same as for .ck-icon. */
			margin-left: calc(-1 * var(--ck-spacing-small));
			margin-right: var(--ck-spacing-small);
		}

		/*
		 * Hovered items automatically get focused. Default focus styles look odd
		 * while moving across a huge list of items so let's get rid of them
		 */
		&:focus {
			border-color: transparent;
			box-shadow: none;

			&:not(.ck-on) {
				background: var(--ck-color-button-default-hover-background);
			}
		}
	}

	/*
	 * First-level sub-menu item buttons.
	 */
	&.ck-menu-bar__menu_top-level > .ck-menu-bar__menu__panel > ul > .ck-menu-bar__menu__item > .ck-menu-bar__menu__item__button {
		/* Spacing in buttons that miss the icon. */
		&:not(:has(.ck-button__icon)) > .ck-button__label {
			margin-left: calc(var(--ck-icon-size) - var(--ck-spacing-small));
		}
	}
}


`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            9108: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ":root{--ck-menu-bar-menu-max-width:75vw;--ck-menu-bar-nested-menu-horizontal-offset:5px}.ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel{max-width:var(--ck-menu-bar-menu-max-width);position:absolute;z-index:var(--ck-z-panel)}.ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel.ck-menu-bar__menu__panel_position_ne,.ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel.ck-menu-bar__menu__panel_position_nw{bottom:100%}.ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel.ck-menu-bar__menu__panel_position_se,.ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel.ck-menu-bar__menu__panel_position_sw{bottom:auto;top:100%}.ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel.ck-menu-bar__menu__panel_position_ne,.ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel.ck-menu-bar__menu__panel_position_se{left:0}.ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel.ck-menu-bar__menu__panel_position_nw,.ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel.ck-menu-bar__menu__panel_position_sw{right:0}.ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel.ck-menu-bar__menu__panel_position_en,.ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel.ck-menu-bar__menu__panel_position_es{left:calc(100% - var(--ck-menu-bar-nested-menu-horizontal-offset))}.ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel.ck-menu-bar__menu__panel_position_es{top:0}.ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel.ck-menu-bar__menu__panel_position_en{bottom:0}.ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel.ck-menu-bar__menu__panel_position_wn,.ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel.ck-menu-bar__menu__panel_position_ws{right:calc(100% - var(--ck-menu-bar-nested-menu-horizontal-offset))}.ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel.ck-menu-bar__menu__panel_position_ws{top:0}.ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel.ck-menu-bar__menu__panel_position_wn{bottom:0}:root{--ck-menu-bar-menu-panel-max-width:75vw}.ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel{border-radius:0}.ck-rounded-corners .ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel,.ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel{background:var(--ck-color-dropdown-panel-background);border:1px solid var(--ck-color-dropdown-panel-border);bottom:0;box-shadow:var(--ck-drop-shadow),0 0;height:fit-content;max-width:var(--ck-menu-bar-menu-panel-max-width)}.ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel.ck-menu-bar__menu__panel_position_es,.ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel.ck-menu-bar__menu__panel_position_se{border-top-left-radius:0}.ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel.ck-menu-bar__menu__panel_position_sw,.ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel.ck-menu-bar__menu__panel_position_ws{border-top-right-radius:0}.ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel.ck-menu-bar__menu__panel_position_en,.ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel.ck-menu-bar__menu__panel_position_ne{border-bottom-left-radius:0}.ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel.ck-menu-bar__menu__panel_position_nw,.ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel.ck-menu-bar__menu__panel_position_wn{border-bottom-right-radius:0}.ck.ck-menu-bar__menu>.ck.ck-menu-bar__menu__panel:focus{outline:none}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/menubar/menubarmenupanel.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/menubar/menubarmenupanel.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"],
                    names: [],
                    mappings: "AAKA,MACC,iCAAkC,CAClC,+CACD,CAEA,mDAEC,2CAA4C,CAC5C,iBAAkB,CAFlB,yBAkDD,CA9CC,gLAEC,WACD,CAEA,gLAGC,WAAY,CADZ,QAED,CAEA,gLAEC,MACD,CAEA,gLAEC,OACD,CAEA,gLAEC,kEACD,CAEA,wFACC,KACD,CAEA,wFACC,QACD,CAEA,gLAEC,mEACD,CAEA,wFACC,KACD,CAEA,wFACC,QACD,CCpDD,MACC,uCACD,CAEA,mDCDC,eDmCD,CAlCA,6ICGE,qCD+BF,CAlCA,mDAIC,oDAAqD,CACrD,sDAAuD,CACvD,QAAS,CETT,oCAA8B,CFU9B,kBAAmB,CACnB,iDA0BD,CAvBC,gLAEC,wBACD,CAEA,gLAEC,yBACD,CAEA,gLAEC,2BACD,CAEA,gLAEC,4BACD,CAEA,yDACC,YACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-menu-bar-menu-max-width: 75vw;
	--ck-menu-bar-nested-menu-horizontal-offset: 5px;
}

.ck.ck-menu-bar__menu > .ck.ck-menu-bar__menu__panel {
	z-index: var(--ck-z-panel);
	max-width: var(--ck-menu-bar-menu-max-width);
	position: absolute;

	&.ck-menu-bar__menu__panel_position_ne,
	&.ck-menu-bar__menu__panel_position_nw {
		bottom: 100%;
	}

	&.ck-menu-bar__menu__panel_position_se,
	&.ck-menu-bar__menu__panel_position_sw {
		top: 100%;
		bottom: auto;
	}

	&.ck-menu-bar__menu__panel_position_ne,
	&.ck-menu-bar__menu__panel_position_se {
		left: 0px;
	}

	&.ck-menu-bar__menu__panel_position_nw,
	&.ck-menu-bar__menu__panel_position_sw {
		right: 0px;
	}

	&.ck-menu-bar__menu__panel_position_es,
	&.ck-menu-bar__menu__panel_position_en {
		left: calc( 100% - var(--ck-menu-bar-nested-menu-horizontal-offset) );
	}

	&.ck-menu-bar__menu__panel_position_es {
		top: 0px;
	}

	&.ck-menu-bar__menu__panel_position_en {
		bottom: 0px;
	}

	&.ck-menu-bar__menu__panel_position_ws,
	&.ck-menu-bar__menu__panel_position_wn {
		right: calc( 100% - var(--ck-menu-bar-nested-menu-horizontal-offset) );
	}

	&.ck-menu-bar__menu__panel_position_ws {
		top: 0px;
	}

	&.ck-menu-bar__menu__panel_position_wn {
		bottom: 0px;
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";
@import "../../../mixins/_shadow.css";

:root {
	--ck-menu-bar-menu-panel-max-width: 75vw;
}

.ck.ck-menu-bar__menu > .ck.ck-menu-bar__menu__panel {
	@mixin ck-rounded-corners;
	@mixin ck-drop-shadow;

	background: var(--ck-color-dropdown-panel-background);
	border: 1px solid var(--ck-color-dropdown-panel-border);
	bottom: 0;
	height: fit-content;
	max-width: var(--ck-menu-bar-menu-panel-max-width);

	/* Corner border radius consistent with the button. */
	&.ck-menu-bar__menu__panel_position_es,
	&.ck-menu-bar__menu__panel_position_se {
		border-top-left-radius: 0;
	}

	&.ck-menu-bar__menu__panel_position_ws,
	&.ck-menu-bar__menu__panel_position_sw {
		border-top-right-radius: 0;
	}

	&.ck-menu-bar__menu__panel_position_en,
	&.ck-menu-bar__menu__panel_position_ne {
		border-bottom-left-radius: 0;
	}

	&.ck-menu-bar__menu__panel_position_wn,
	&.ck-menu-bar__menu__panel_position_nw {
		border-bottom-right-radius: 0;
	}

	&:focus {
		outline: none;
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A helper to combine multiple shadows.
 */
@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {
	box-shadow: $shadowA, $shadowB;
}

/**
 * Gives an element a drop shadow so it looks like a floating panel.
 */
@define-mixin ck-drop-shadow {
	@mixin ck-box-shadow var(--ck-drop-shadow);
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            3710: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ':root{--ck-balloon-panel-arrow-z-index:calc(var(--ck-z-default) - 3)}.ck.ck-balloon-panel{display:none;position:absolute;z-index:var(--ck-z-panel)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{content:"";position:absolute}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_n]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_n]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_s]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_s]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel.ck-balloon-panel_visible{display:block}:root{--ck-balloon-border-width:1px;--ck-balloon-arrow-offset:2px;--ck-balloon-arrow-height:10px;--ck-balloon-arrow-half-width:8px;--ck-balloon-arrow-drop-shadow:0 2px 2px var(--ck-color-shadow-drop)}.ck.ck-balloon-panel{border-radius:0}.ck-rounded-corners .ck.ck-balloon-panel,.ck.ck-balloon-panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-balloon-panel{background:var(--ck-color-panel-background);border:var(--ck-balloon-border-width) solid var(--ck-color-panel-border);box-shadow:var(--ck-drop-shadow),0 0;min-height:15px}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{border-style:solid;height:0;width:0}.ck.ck-balloon-panel[class*=arrow_n]:after,.ck.ck-balloon-panel[class*=arrow_n]:before{border-width:0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width)}.ck.ck-balloon-panel[class*=arrow_n]:before{border-color:transparent transparent var(--ck-color-panel-border) transparent;margin-top:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_n]:after{border-color:transparent transparent var(--ck-color-panel-background) transparent;margin-top:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_s]:after,.ck.ck-balloon-panel[class*=arrow_s]:before{border-width:var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width)}.ck.ck-balloon-panel[class*=arrow_s]:before{border-color:var(--ck-color-panel-border) transparent transparent;filter:drop-shadow(var(--ck-balloon-arrow-drop-shadow));margin-bottom:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_s]:after{border-color:var(--ck-color-panel-background) transparent transparent transparent;margin-bottom:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_e]:after,.ck.ck-balloon-panel[class*=arrow_e]:before{border-width:var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height)}.ck.ck-balloon-panel[class*=arrow_e]:before{border-color:transparent transparent transparent var(--ck-color-panel-border);margin-right:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_e]:after{border-color:transparent transparent transparent var(--ck-color-panel-background);margin-right:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_w]:after,.ck.ck-balloon-panel[class*=arrow_w]:before{border-width:var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0}.ck.ck-balloon-panel[class*=arrow_w]:before{border-color:transparent var(--ck-color-panel-border) transparent transparent;margin-left:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_w]:after{border-color:transparent var(--ck-color-panel-background) transparent transparent;margin-left:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:before{left:50%;margin-left:calc(var(--ck-balloon-arrow-half-width)*-1);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:before{left:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:before{right:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:50%;margin-left:calc(var(--ck-balloon-arrow-half-width)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);right:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);margin-right:calc(var(--ck-balloon-arrow-half-width)*2);right:25%}.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:25%;margin-left:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:before{margin-right:calc(var(--ck-balloon-arrow-half-width)*2);right:25%;top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:before{left:25%;margin-left:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_e:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_e:before{margin-top:calc(var(--ck-balloon-arrow-half-width)*-1);right:calc(var(--ck-balloon-arrow-height)*-1);top:50%}.ck.ck-balloon-panel.ck-balloon-panel_arrow_w:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_w:before{left:calc(var(--ck-balloon-arrow-height)*-1);margin-top:calc(var(--ck-balloon-arrow-half-width)*-1);top:50%}', "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/panel/balloonpanel.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/balloonpanel.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"],
                    names: [],
                    mappings: "AAKA,MAEC,8DACD,CAEA,qBACC,YAAa,CACb,iBAAkB,CAElB,yBAyCD,CAtCE,+GAEC,UAAW,CACX,iBACD,CAEA,wDACC,6CACD,CAEA,uDACC,uDACD,CAIA,4CACC,6CACD,CAEA,2CACC,uDACD,CAIA,4CACC,6CACD,CAEA,2CACC,uDACD,CAGD,8CACC,aACD,CC9CD,MACC,6BAA8B,CAC9B,6BAA8B,CAC9B,8BAA+B,CAC/B,iCAAkC,CAClC,oEACD,CAEA,qBCLC,eDmMD,CA9LA,iFCDE,qCD+LF,CA9LA,qBAMC,2CAA4C,CAC5C,wEAAyE,CEdzE,oCAA8B,CFW9B,eA0LD,CApLE,+GAIC,kBAAmB,CADnB,QAAS,CADT,OAGD,CAIA,uFAEC,mHACD,CAEA,4CACC,6EAA8E,CAC9E,kDACD,CAEA,2CACC,iFAAkF,CAClF,gFACD,CAIA,uFAEC,mHACD,CAEA,4CACC,iEAAkE,CAClE,uDAAwD,CACxD,qDACD,CAEA,2CACC,iFAAkF,CAClF,mFACD,CAIA,uFAEC,mHACD,CAEA,4CACC,6EAA8E,CAC9E,oDACD,CAEA,2CACC,iFAAkF,CAClF,kFACD,CAIA,uFAEC,mHACD,CAEA,4CACC,6EAA8E,CAC9E,mDACD,CAEA,2CACC,iFAAkF,CAClF,iFACD,CAIA,yGAEC,QAAS,CACT,uDAA0D,CAC1D,2CACD,CAIA,2GAEC,+CAAkD,CAClD,2CACD,CAIA,2GAEC,gDAAmD,CACnD,2CACD,CAIA,yGAIC,8CAAiD,CAFjD,QAAS,CACT,uDAED,CAIA,2GAGC,8CAAiD,CADjD,+CAED,CAIA,2GAGC,8CAAiD,CADjD,gDAED,CAIA,6GAIC,8CAAiD,CADjD,uDAA0D,CAD1D,SAGD,CAIA,6GAIC,8CAAiD,CAFjD,QAAS,CACT,sDAED,CAIA,6GAGC,uDAA0D,CAD1D,SAAU,CAEV,2CACD,CAIA,6GAEC,QAAS,CACT,sDAAyD,CACzD,2CACD,CAIA,yGAGC,sDAAyD,CADzD,6CAAgD,CAEhD,OACD,CAIA,yGAEC,4CAA+C,CAC/C,sDAAyD,CACzD,OACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	/* Make sure the balloon arrow does not float over its children. */
	--ck-balloon-panel-arrow-z-index: calc(var(--ck-z-default) - 3);
}

.ck.ck-balloon-panel {
	display: none;
	position: absolute;

	z-index: var(--ck-z-panel);

	&.ck-balloon-panel_with-arrow {
		&::before,
		&::after {
			content: "";
			position: absolute;
		}

		&::before {
			z-index: var(--ck-balloon-panel-arrow-z-index);
		}

		&::after {
			z-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);
		}
	}

	&[class*="arrow_n"] {
		&::before {
			z-index: var(--ck-balloon-panel-arrow-z-index);
		}

		&::after {
			z-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);
		}
	}

	&[class*="arrow_s"] {
		&::before {
			z-index: var(--ck-balloon-panel-arrow-z-index);
		}

		&::after {
			z-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);
		}
	}

	&.ck-balloon-panel_visible {
		display: block;
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";
@import "../../../mixins/_shadow.css";

:root {
	--ck-balloon-border-width: 1px;
	--ck-balloon-arrow-offset: 2px;
	--ck-balloon-arrow-height: 10px;
	--ck-balloon-arrow-half-width: 8px;
	--ck-balloon-arrow-drop-shadow: 0 2px 2px var(--ck-color-shadow-drop);
}

.ck.ck-balloon-panel {
	@mixin ck-rounded-corners;
	@mixin ck-drop-shadow;

	min-height: 15px;

	background: var(--ck-color-panel-background);
	border: var(--ck-balloon-border-width) solid var(--ck-color-panel-border);

	&.ck-balloon-panel_with-arrow {
		&::before,
		&::after {
			width: 0;
			height: 0;
			border-style: solid;
		}
	}

	&[class*="arrow_n"] {
		&::before,
		&::after {
			border-width: 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width);
		}

		&::before {
			border-color: transparent transparent var(--ck-color-panel-border) transparent;
			margin-top: calc( -1 * var(--ck-balloon-border-width) );
		}

		&::after {
			border-color: transparent transparent var(--ck-color-panel-background) transparent;
			margin-top: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );
		}
	}

	&[class*="arrow_s"] {
		&::before,
		&::after {
			border-width: var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width);
		}

		&::before {
			border-color: var(--ck-color-panel-border) transparent transparent;
			filter: drop-shadow(var(--ck-balloon-arrow-drop-shadow));
			margin-bottom: calc( -1 * var(--ck-balloon-border-width) );
		}

		&::after {
			border-color: var(--ck-color-panel-background) transparent transparent transparent;
			margin-bottom: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );
		}
	}

	&[class*="arrow_e"] {
		&::before,
		&::after {
			border-width: var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height);
		}

		&::before {
			border-color: transparent transparent transparent var(--ck-color-panel-border);
			margin-right: calc( -1 * var(--ck-balloon-border-width) );
		}

		&::after {
			border-color: transparent transparent transparent var(--ck-color-panel-background);
			margin-right: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );
		}
	}

	&[class*="arrow_w"] {
		&::before,
		&::after {
			border-width: var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0;
		}

		&::before {
			border-color: transparent var(--ck-color-panel-border) transparent transparent;
			margin-left: calc( -1 * var(--ck-balloon-border-width) );
		}

		&::after {
			border-color: transparent var(--ck-color-panel-background) transparent transparent;
			margin-left: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );
		}
	}

	&.ck-balloon-panel_arrow_n {
		&::before,
		&::after {
			left: 50%;
			margin-left: calc(-1 * var(--ck-balloon-arrow-half-width));
			top: calc(-1 * var(--ck-balloon-arrow-height));
		}
	}

	&.ck-balloon-panel_arrow_nw {
		&::before,
		&::after {
			left: calc(2 * var(--ck-balloon-arrow-half-width));
			top: calc(-1 * var(--ck-balloon-arrow-height));
		}
	}

	&.ck-balloon-panel_arrow_ne {
		&::before,
		&::after {
			right: calc(2 * var(--ck-balloon-arrow-half-width));
			top: calc(-1 * var(--ck-balloon-arrow-height));
		}
	}

	&.ck-balloon-panel_arrow_s {
		&::before,
		&::after {
			left: 50%;
			margin-left: calc(-1 * var(--ck-balloon-arrow-half-width));
			bottom: calc(-1 * var(--ck-balloon-arrow-height));
		}
	}

	&.ck-balloon-panel_arrow_sw {
		&::before,
		&::after {
			left: calc(2 * var(--ck-balloon-arrow-half-width));
			bottom: calc(-1 * var(--ck-balloon-arrow-height));
		}
	}

	&.ck-balloon-panel_arrow_se {
		&::before,
		&::after {
			right: calc(2 * var(--ck-balloon-arrow-half-width));
			bottom: calc(-1 * var(--ck-balloon-arrow-height));
		}
	}

	&.ck-balloon-panel_arrow_sme {
		&::before,
		&::after {
			right: 25%;
			margin-right: calc(2 * var(--ck-balloon-arrow-half-width));
			bottom: calc(-1 * var(--ck-balloon-arrow-height));
		}
	}

	&.ck-balloon-panel_arrow_smw {
		&::before,
		&::after {
			left: 25%;
			margin-left: calc(2 * var(--ck-balloon-arrow-half-width));
			bottom: calc(-1 * var(--ck-balloon-arrow-height));
		}
	}

	&.ck-balloon-panel_arrow_nme {
		&::before,
		&::after {
			right: 25%;
			margin-right: calc(2 * var(--ck-balloon-arrow-half-width));
			top: calc(-1 * var(--ck-balloon-arrow-height));
		}
	}

	&.ck-balloon-panel_arrow_nmw {
		&::before,
		&::after {
			left: 25%;
			margin-left: calc(2 * var(--ck-balloon-arrow-half-width));
			top: calc(-1 * var(--ck-balloon-arrow-height));
		}
	}

	&.ck-balloon-panel_arrow_e {
		&::before,
		&::after {
			right: calc(-1 * var(--ck-balloon-arrow-height));
			margin-top: calc(-1 * var(--ck-balloon-arrow-half-width));
			top: 50%;
		}
	}

	&.ck-balloon-panel_arrow_w {
		&::before,
		&::after {
			left: calc(-1 * var(--ck-balloon-arrow-height));
			margin-top: calc(-1 * var(--ck-balloon-arrow-half-width));
			top: 50%;
		}
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A helper to combine multiple shadows.
 */
@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {
	box-shadow: $shadowA, $shadowB;
}

/**
 * Gives an element a drop shadow so it looks like a floating panel.
 */
@define-mixin ck-drop-shadow {
	@mixin ck-box-shadow var(--ck-drop-shadow);
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            991: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck .ck-balloon-rotator__navigation{align-items:center;display:flex;justify-content:center}.ck .ck-balloon-rotator__content .ck-toolbar{justify-content:center}.ck .ck-balloon-rotator__navigation{background:var(--ck-color-toolbar-background);border-bottom:1px solid var(--ck-color-toolbar-border);padding:0 var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation>*{margin-bottom:var(--ck-spacing-small);margin-right:var(--ck-spacing-small);margin-top:var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation .ck-balloon-rotator__counter{margin-left:var(--ck-spacing-small);margin-right:var(--ck-spacing-standard)}.ck .ck-balloon-rotator__content .ck.ck-annotation-wrapper{box-shadow:none}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/panel/balloonrotator.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/balloonrotator.css"],
                    names: [],
                    mappings: "AAKA,oCAEC,kBAAmB,CADnB,YAAa,CAEb,sBACD,CAKA,6CACC,sBACD,CCXA,oCACC,6CAA8C,CAC9C,sDAAuD,CACvD,iCAgBD,CAbC,sCAGC,qCAAsC,CAFtC,oCAAqC,CACrC,kCAED,CAGA,iEAIC,mCAAoC,CAHpC,uCAID,CAMA,2DACC,eACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck .ck-balloon-rotator__navigation {
	display: flex;
	align-items: center;
	justify-content: center;
}

/* Buttons inside a toolbar should be centered when rotator bar is wider.
 * See: https://github.com/ckeditor/ckeditor5-ui/issues/495
 */
.ck .ck-balloon-rotator__content .ck-toolbar {
	justify-content: center;
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck .ck-balloon-rotator__navigation {
	background: var(--ck-color-toolbar-background);
	border-bottom: 1px solid var(--ck-color-toolbar-border);
	padding: 0 var(--ck-spacing-small);

	/* Let's keep similar appearance to \`ck-toolbar\`. */
	& > * {
		margin-right: var(--ck-spacing-small);
		margin-top: var(--ck-spacing-small);
		margin-bottom: var(--ck-spacing-small);
	}

	/* Gives counter more breath than buttons. */
	& .ck-balloon-rotator__counter {
		margin-right: var(--ck-spacing-standard);

		/* We need to use smaller margin because of previous button's right margin. */
		margin-left: var(--ck-spacing-small);
	}
}

.ck .ck-balloon-rotator__content {

	/* Disable default annotation shadow inside rotator with fake panels. */
	& .ck.ck-annotation-wrapper {
		box-shadow: none;
	}
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            5380: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck .ck-fake-panel{position:absolute;z-index:calc(var(--ck-z-panel) - 1)}.ck .ck-fake-panel div{position:absolute}.ck .ck-fake-panel div:first-child{z-index:2}.ck .ck-fake-panel div:nth-child(2){z-index:1}:root{--ck-balloon-fake-panel-offset-horizontal:6px;--ck-balloon-fake-panel-offset-vertical:6px}.ck .ck-fake-panel div{background:var(--ck-color-panel-background);border:1px solid var(--ck-color-panel-border);border-radius:var(--ck-border-radius);box-shadow:var(--ck-drop-shadow),0 0;height:100%;min-height:15px;width:100%}.ck .ck-fake-panel div:first-child{margin-left:var(--ck-balloon-fake-panel-offset-horizontal);margin-top:var(--ck-balloon-fake-panel-offset-vertical)}.ck .ck-fake-panel div:nth-child(2){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*2);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*2)}.ck .ck-fake-panel div:nth-child(3){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*3);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*3)}.ck .ck-balloon-panel_arrow_s+.ck-fake-panel,.ck .ck-balloon-panel_arrow_se+.ck-fake-panel,.ck .ck-balloon-panel_arrow_sw+.ck-fake-panel{--ck-balloon-fake-panel-offset-vertical:-6px}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/panel/fakepanel.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/fakepanel.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"],
                    names: [],
                    mappings: "AAKA,mBACC,iBAAkB,CAGlB,mCACD,CAEA,uBACC,iBACD,CAEA,mCACC,SACD,CAEA,oCACC,SACD,CCfA,MACC,6CAA8C,CAC9C,2CACD,CAGA,uBAKC,2CAA4C,CAC5C,6CAA8C,CAC9C,qCAAsC,CCXtC,oCAA8B,CDc9B,WAAY,CAPZ,eAAgB,CAMhB,UAED,CAEA,mCACC,0DAA2D,CAC3D,uDACD,CAEA,oCACC,kEAAqE,CACrE,+DACD,CACA,oCACC,kEAAqE,CACrE,+DACD,CAGA,yIAGC,4CACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck .ck-fake-panel {
	position: absolute;

	/* Fake panels should be placed under main balloon content. */
	z-index: calc(var(--ck-z-panel) - 1);
}

.ck .ck-fake-panel div {
	position: absolute;
}

.ck .ck-fake-panel div:nth-child( 1 ) {
	z-index: 2;
}

.ck .ck-fake-panel div:nth-child( 2 ) {
	z-index: 1;
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_shadow.css";

:root {
	--ck-balloon-fake-panel-offset-horizontal: 6px;
	--ck-balloon-fake-panel-offset-vertical: 6px;
}

/* Let's use \`.ck-balloon-panel\` appearance. See: balloonpanel.css. */
.ck .ck-fake-panel div {
	@mixin ck-drop-shadow;

	min-height: 15px;

	background: var(--ck-color-panel-background);
	border: 1px solid var(--ck-color-panel-border);
	border-radius: var(--ck-border-radius);

	width: 100%;
	height: 100%;
}

.ck .ck-fake-panel div:nth-child( 1 ) {
	margin-left: var(--ck-balloon-fake-panel-offset-horizontal);
	margin-top: var(--ck-balloon-fake-panel-offset-vertical);
}

.ck .ck-fake-panel div:nth-child( 2 ) {
	margin-left: calc(var(--ck-balloon-fake-panel-offset-horizontal) * 2);
	margin-top: calc(var(--ck-balloon-fake-panel-offset-vertical) * 2);
}
.ck .ck-fake-panel div:nth-child( 3 ) {
	margin-left: calc(var(--ck-balloon-fake-panel-offset-horizontal) * 3);
	margin-top: calc(var(--ck-balloon-fake-panel-offset-vertical) * 3);
}

/* If balloon is positioned above element, we need to move fake panel to the top. */
.ck .ck-balloon-panel_arrow_s + .ck-fake-panel,
.ck .ck-balloon-panel_arrow_se + .ck-fake-panel,
.ck .ck-balloon-panel_arrow_sw + .ck-fake-panel {
	--ck-balloon-fake-panel-offset-vertical: -6px;
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A helper to combine multiple shadows.
 */
@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {
	box-shadow: $shadowA, $shadowB;
}

/**
 * Gives an element a drop shadow so it looks like a floating panel.
 */
@define-mixin ck-drop-shadow {
	@mixin ck-box-shadow var(--ck-drop-shadow);
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            8298: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck.ck-sticky-panel .ck-sticky-panel__content_sticky{position:fixed;top:0;z-index:var(--ck-z-panel)}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky_bottom-limit{position:absolute;top:auto}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky{border-top-left-radius:0;border-top-right-radius:0;border-width:0 1px 1px;box-shadow:var(--ck-drop-shadow),0 0}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/panel/stickypanel.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/stickypanel.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"],
                    names: [],
                    mappings: "AAMC,qDAEC,cAAe,CACf,KAAM,CAFN,yBAGD,CAEA,kEAEC,iBAAkB,CADlB,QAED,CCPA,qDAIC,wBAAyB,CACzB,yBAA0B,CAF1B,sBAAuB,CCFxB,oCDKA",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-sticky-panel {
	& .ck-sticky-panel__content_sticky {
		z-index: var(--ck-z-panel); /* #315 */
		position: fixed;
		top: 0;
	}

	& .ck-sticky-panel__content_sticky_bottom-limit {
		top: auto;
		position: absolute;
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_shadow.css";

.ck.ck-sticky-panel {
	& .ck-sticky-panel__content_sticky {
		@mixin ck-drop-shadow;

		border-width: 0 1px 1px;
		border-top-left-radius: 0;
		border-top-right-radius: 0;
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A helper to combine multiple shadows.
 */
@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {
	box-shadow: $shadowA, $shadowB;
}

/**
 * Gives an element a drop shadow so it looks like a floating panel.
 */
@define-mixin ck-drop-shadow {
	@mixin ck-box-shadow var(--ck-drop-shadow);
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            2722: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, '.ck-vertical-form .ck-button:after{bottom:-1px;content:"";position:absolute;right:-1px;top:-1px;width:0;z-index:1}.ck-vertical-form .ck-button:focus:after{display:none}@media screen and (max-width:600px){.ck.ck-responsive-form .ck-button:after{bottom:-1px;content:"";position:absolute;right:-1px;top:-1px;width:0;z-index:1}.ck.ck-responsive-form .ck-button:focus:after{display:none}}.ck-vertical-form>.ck-button:nth-last-child(2):after{border-right:1px solid var(--ck-color-base-border)}.ck.ck-responsive-form{padding:var(--ck-spacing-large)}.ck.ck-responsive-form:focus{outline:none}[dir=ltr] .ck.ck-responsive-form>:not(:first-child),[dir=rtl] .ck.ck-responsive-form>:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-responsive-form{padding:0;width:calc(var(--ck-input-width)*.8)}.ck.ck-responsive-form .ck-labeled-field-view{margin:var(--ck-spacing-large) var(--ck-spacing-large) 0}.ck.ck-responsive-form .ck-labeled-field-view .ck-input-number,.ck.ck-responsive-form .ck-labeled-field-view .ck-input-text{min-width:0;width:100%}.ck.ck-responsive-form .ck-labeled-field-view .ck-labeled-field-view__error{white-space:normal}.ck.ck-responsive-form>.ck-button:nth-last-child(2):after{border-right:1px solid var(--ck-color-base-border)}.ck.ck-responsive-form>.ck-button:last-child,.ck.ck-responsive-form>.ck-button:nth-last-child(2){border-radius:0;margin-top:var(--ck-spacing-large);padding:var(--ck-spacing-standard)}.ck.ck-responsive-form>.ck-button:last-child:not(:focus),.ck.ck-responsive-form>.ck-button:nth-last-child(2):not(:focus){border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-responsive-form>.ck-button:last-child,[dir=ltr] .ck.ck-responsive-form>.ck-button:nth-last-child(2),[dir=rtl] .ck.ck-responsive-form>.ck-button:last-child,[dir=rtl] .ck.ck-responsive-form>.ck-button:nth-last-child(2){margin-left:0}[dir=rtl] .ck.ck-responsive-form>.ck-button:last-child:last-of-type,[dir=rtl] .ck.ck-responsive-form>.ck-button:nth-last-child(2):last-of-type{border-right:1px solid var(--ck-color-base-border)}}', "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/responsive-form/responsiveform.css", "webpack://./../ckeditor5-ui/theme/mixins/_rwd.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/responsive-form/responsiveform.css"],
                    names: [],
                    mappings: "AAQC,mCAMC,WAAY,CALZ,UAAW,CAEX,iBAAkB,CAClB,UAAW,CACX,QAAS,CAHT,OAAQ,CAKR,SACD,CAEA,yCACC,YACD,CCdA,oCDoBE,wCAMC,WAAY,CALZ,UAAW,CAEX,iBAAkB,CAClB,UAAW,CACX,QAAS,CAHT,OAAQ,CAKR,SACD,CAEA,8CACC,YACD,CC9BF,CCAD,qDACC,kDACD,CAEA,uBACC,+BAoED,CAlEC,6BAEC,YACD,CASC,uGACC,sCACD,CDvBD,oCCMD,uBAqBE,SAAU,CACV,oCA+CF,CA7CE,8CACC,wDAYD,CAVC,4HAEC,WAAY,CACZ,UACD,CAGA,4EACC,kBACD,CAKA,0DACC,kDACD,CAGD,iGAIC,eAAgB,CADhB,kCAAmC,CADnC,kCAmBD,CAfC,yHACC,gDACD,CARD,0OAeE,aAMF,CAJE,+IACC,kDACD,CDrEH",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";

.ck-vertical-form .ck-button {
	&::after {
		content: "";
		width: 0;
		position: absolute;
		right: -1px;
		top: -1px;
		bottom: -1px;
		z-index: 1;
	}

	&:focus::after {
		display: none;
	}
}

.ck.ck-responsive-form {
	@mixin ck-media-phone {
		& .ck-button {
			&::after {
				content: "";
				width: 0;
				position: absolute;
				right: -1px;
				top: -1px;
				bottom: -1px;
				z-index: 1;
			}

			&:focus::after {
				display: none;
			}
		}
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@define-mixin ck-media-phone {
	@media screen and (max-width: 600px) {
		@mixin-content;
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

.ck-vertical-form > .ck-button:nth-last-child(2)::after {
	border-right: 1px solid var(--ck-color-base-border);
}

.ck.ck-responsive-form {
	padding: var(--ck-spacing-large);

	&:focus {
		/* See: https://github.com/ckeditor/ckeditor5/issues/4773 */
		outline: none;
	}

	@mixin ck-dir ltr {
		& > :not(:first-child) {
			margin-left: var(--ck-spacing-standard);
		}
	}

	@mixin ck-dir rtl {
		& > :not(:last-child) {
			margin-left: var(--ck-spacing-standard);
		}
	}

	@mixin ck-media-phone {
		padding: 0;
		width: calc(.8 * var(--ck-input-width));

		& .ck-labeled-field-view {
			margin: var(--ck-spacing-large) var(--ck-spacing-large) 0;

			& .ck-input-text,
			& .ck-input-number {
				min-width: 0;
				width: 100%;
			}

			/* Let the long error messages wrap in the narrow form. */
			& .ck-labeled-field-view__error {
				white-space: normal;
			}
		}

		/* Styles for two last buttons in the form (save&cancel, edit&unlink, etc.). */
		& > .ck-button:nth-last-child(2) {
			&::after {
				border-right: 1px solid var(--ck-color-base-border);
			}
		}

		& > .ck-button:nth-last-child(1),
		& > .ck-button:nth-last-child(2) {
			padding: var(--ck-spacing-standard);
			margin-top: var(--ck-spacing-large);
			border-radius: 0;

			&:not(:focus) {
				border-top: 1px solid var(--ck-color-base-border);
			}

			@mixin ck-dir ltr {
				margin-left: 0;
			}

			@mixin ck-dir rtl {
				margin-left: 0;

				&:last-of-type {
					border-right: 1px solid var(--ck-color-base-border);
				}
			}
		}
	}
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            8107: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck.ck-search>.ck-labeled-field-view>.ck-labeled-field-view__input-wrapper>.ck-icon{position:absolute;top:50%;transform:translateY(-50%)}[dir=ltr] .ck.ck-search>.ck-labeled-field-view>.ck-labeled-field-view__input-wrapper>.ck-icon{left:var(--ck-spacing-medium)}[dir=rtl] .ck.ck-search>.ck-labeled-field-view>.ck-labeled-field-view__input-wrapper>.ck-icon{right:var(--ck-spacing-medium)}.ck.ck-search>.ck-labeled-field-view .ck-search__reset{position:absolute;top:50%;transform:translateY(-50%)}.ck.ck-search>.ck-search__results>.ck-search__info>span:first-child{display:block}.ck.ck-search>.ck-search__results>.ck-search__info:not(.ck-hidden)~*{display:none}:root{--ck-search-field-view-horizontal-spacing:calc(var(--ck-icon-size) + var(--ck-spacing-medium))}.ck.ck-search>.ck-labeled-field-view .ck-input{width:100%}.ck.ck-search>.ck-labeled-field-view.ck-search__query_with-icon{--ck-labeled-field-label-default-position-x:var(--ck-search-field-view-horizontal-spacing)}.ck.ck-search>.ck-labeled-field-view.ck-search__query_with-icon>.ck-labeled-field-view__input-wrapper>.ck-icon{opacity:.5;pointer-events:none}.ck.ck-search>.ck-labeled-field-view.ck-search__query_with-icon .ck-input{width:100%}[dir=ltr] .ck.ck-search>.ck-labeled-field-view.ck-search__query_with-icon .ck-input,[dir=rtl] .ck.ck-search>.ck-labeled-field-view.ck-search__query_with-icon .ck-input:not(.ck-input-text_empty){padding-left:var(--ck-search-field-view-horizontal-spacing)}.ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset{--ck-labeled-field-empty-unfocused-max-width:100% - 2 * var(--ck-search-field-view-horizontal-spacing)}.ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset.ck-labeled-field-view_empty{--ck-labeled-field-empty-unfocused-max-width:100% - var(--ck-search-field-view-horizontal-spacing) - var(--ck-spacing-medium)}.ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset .ck-search__reset{background:none;min-height:auto;min-width:auto;opacity:.5;padding:0}[dir=ltr] .ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset .ck-search__reset{right:var(--ck-spacing-medium)}[dir=rtl] .ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset .ck-search__reset{left:var(--ck-spacing-medium)}.ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset .ck-search__reset:hover{opacity:1}.ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset .ck-input{width:100%}[dir=ltr] .ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset .ck-input:not(.ck-input-text_empty),[dir=rtl] .ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset .ck-input{padding-right:var(--ck-search-field-view-horizontal-spacing)}.ck.ck-search>.ck-search__results{min-width:100%}.ck.ck-search>.ck-search__results>.ck-search__info{padding:var(--ck-spacing-medium) var(--ck-spacing-large);width:100%}.ck.ck-search>.ck-search__results>.ck-search__info *{white-space:normal}.ck.ck-search>.ck-search__results>.ck-search__info>span:first-child{font-weight:700}.ck.ck-search>.ck-search__results>.ck-search__info>span:last-child{margin-top:var(--ck-spacing-medium)}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/search/search.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/search/search.css"],
                    names: [],
                    mappings: "AASE,oFACC,iBAAkB,CAClB,OAAQ,CACR,0BASD,CAZA,8FAME,6BAMF,CAZA,8FAUE,8BAEF,CAEA,uDACC,iBAAkB,CAClB,OAAQ,CACR,0BACD,CAKC,oEACC,aACD,CAGA,qEACC,YACD,CChCH,MACC,8FACD,CAIE,+CACC,UACD,CAEA,gEACC,0FAoBD,CAlBC,+GACC,UAAW,CACX,mBACD,CAEA,0EACC,UAWD,CAJE,kMACC,2DACD,CAKH,iEACC,sGAwCD,CAtCC,6FACC,6HACD,CAEA,mFAIC,eAAgB,CAFhB,eAAgB,CADhB,cAAe,CAIf,UAAW,CACX,SAaD,CAnBA,6FASE,8BAUF,CAnBA,6FAaE,6BAMF,CAHC,yFACC,SACD,CAGD,2EACC,UAWD,CAZA,oMAUE,4DAEF,CAIF,kCACC,cAkBD,CAhBC,mDAEC,wDAAyD,CADzD,UAcD,CAXC,qDACC,kBACD,CAEA,oEACC,eACD,CAEA,mEACC,mCACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

.ck.ck-search {
	& > .ck-labeled-field-view {
		& > .ck-labeled-field-view__input-wrapper > .ck-icon {
			position: absolute;
			top: 50%;
			transform: translateY(-50%);

			@mixin ck-dir ltr {
				left: var(--ck-spacing-medium);
			}

			@mixin ck-dir rtl {
				right: var(--ck-spacing-medium);
			}
		}

		& .ck-search__reset {
			position: absolute;
			top: 50%;
			transform: translateY(-50%);
		}
	}

	& > .ck-search__results {
		& > .ck-search__info {
			& > span:first-child {
				display: block;
			}

			/* Hide the filtered view when nothing was found */
			&:not(.ck-hidden) ~ * {
				display: none;
			}
		}
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

:root {
	--ck-search-field-view-horizontal-spacing: calc(var(--ck-icon-size) + var(--ck-spacing-medium));
}

.ck.ck-search {
	& > .ck-labeled-field-view {
		& .ck-input {
			width: 100%;
		}

		&.ck-search__query_with-icon {
			--ck-labeled-field-label-default-position-x: var(--ck-search-field-view-horizontal-spacing);

			& > .ck-labeled-field-view__input-wrapper > .ck-icon {
				opacity: .5;
				pointer-events: none;
			}

			& .ck-input {
				width: 100%;

				@mixin ck-dir ltr {
					padding-left: var(--ck-search-field-view-horizontal-spacing);
				}

				@mixin ck-dir rtl {
					&:not(.ck-input-text_empty) {
						padding-left: var(--ck-search-field-view-horizontal-spacing);
					}
				}
			}
		}

		&.ck-search__query_with-reset {
			--ck-labeled-field-empty-unfocused-max-width: 100% - 2 * var(--ck-search-field-view-horizontal-spacing);

			&.ck-labeled-field-view_empty {
				--ck-labeled-field-empty-unfocused-max-width: 100% - var(--ck-search-field-view-horizontal-spacing) - var(--ck-spacing-medium);
			}

			& .ck-search__reset {
				min-width: auto;
				min-height: auto;

				background: none;
				opacity: .5;
				padding: 0;

				@mixin ck-dir ltr {
					right: var(--ck-spacing-medium);
				}

				@mixin ck-dir rtl {
					left: var(--ck-spacing-medium);
				}

				&:hover {
					opacity: 1;
				}
			}

			& .ck-input {
				width: 100%;

				@mixin ck-dir ltr {
					&:not(.ck-input-text_empty) {
						padding-right: var(--ck-search-field-view-horizontal-spacing);
					}
				}

				@mixin ck-dir rtl {
					padding-right: var(--ck-search-field-view-horizontal-spacing);
				}
			}
		}
	}

	& > .ck-search__results {
		min-width: 100%;

		& > .ck-search__info {
			width: 100%;
			padding: var(--ck-spacing-medium) var(--ck-spacing-large);

			& * {
				white-space: normal;
			}

			& > span:first-child {
				font-weight: bold;
			}

			& > span:last-child {
				margin-top: var(--ck-spacing-medium);
			}
		}
	}
}

`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            109: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck.ck-spinner-container{display:block;position:relative}.ck.ck-spinner{left:0;margin:0 auto;position:absolute;right:0;top:50%;transform:translateY(-50%);z-index:1}:root{--ck-toolbar-spinner-size:18px}.ck.ck-spinner-container{animation:ck-spinner-rotate 1.5s linear infinite;height:var(--ck-toolbar-spinner-size);width:var(--ck-toolbar-spinner-size)}@media (prefers-reduced-motion:reduce){.ck.ck-spinner-container{animation-duration:3s}}.ck.ck-spinner{border:2px solid var(--ck-color-text);border-radius:50%;border-top:2px solid transparent;height:var(--ck-toolbar-spinner-size);width:var(--ck-toolbar-spinner-size)}@keyframes ck-spinner-rotate{to{transform:rotate(1turn)}}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/spinner/spinner.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/spinner/spinner.css"],
                    names: [],
                    mappings: "AASA,yBACC,aAAc,CACd,iBACD,CAEA,eAGC,MAAO,CAEP,aAAc,CAJd,iBAAkB,CAGlB,OAAQ,CAFR,OAAQ,CAIR,0BAA2B,CAC3B,SACD,CCjBA,MACC,8BACD,CAEA,yBAGC,gDAAiD,CADjD,qCAAsC,CADtC,oCAOD,CAHC,uCALD,yBAME,qBAEF,CADC,CAGD,eAKC,qCAA6B,CAF7B,iBAAkB,CAElB,gCAA6B,CAH7B,qCAAsC,CADtC,oCAKD,CAEA,6BACC,GACC,uBACD,CACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-toolbar-spinner-size: 18px;
}

.ck.ck-spinner-container {
	display: block;
	position: relative;
}

.ck.ck-spinner {
	position: absolute;
	top: 50%;
	left: 0;
	right: 0;
	margin: 0 auto;
	transform: translateY(-50%);
	z-index: 1;
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-toolbar-spinner-size: 18px;
}

.ck.ck-spinner-container {
	width: var(--ck-toolbar-spinner-size);
	height: var(--ck-toolbar-spinner-size);
	animation: 1.5s infinite ck-spinner-rotate linear;

	@media (prefers-reduced-motion: reduce) {
		animation-duration: 3s;
	}
}

.ck.ck-spinner {
	width: var(--ck-toolbar-spinner-size);
	height: var(--ck-toolbar-spinner-size);
	border-radius: 50%;
	border: 2px solid var(--ck-color-text);
	border-top-color: transparent;
}

@keyframes ck-spinner-rotate {
	to {
		transform: rotate(360deg)
	}
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            1671: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck-textarea{overflow-x:hidden}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/textarea/textarea.css"],
                    names: [],
                    mappings: "AASA,aACC,iBACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/*
 * This fixes a problem in Firefox when the initial height of the complement does not match the number of rows.
 * This bug is especially visible when rows=1.
 */
.ck-textarea {
	overflow-x: hidden
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            2710: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck.ck-block-toolbar-button{position:absolute;z-index:var(--ck-z-default)}:root{--ck-color-block-toolbar-button:var(--ck-color-text);--ck-block-toolbar-button-size:var(--ck-font-size-normal)}.ck.ck-block-toolbar-button{color:var(--ck-color-block-toolbar-button);font-size:var(--ck-block-toolbar-size)}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/toolbar/blocktoolbar.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/toolbar/blocktoolbar.css"],
                    names: [],
                    mappings: "AAKA,4BACC,iBAAkB,CAClB,2BACD,CCHA,MACC,oDAAqD,CACrD,yDACD,CAEA,4BACC,0CAA2C,CAC3C,sCACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-block-toolbar-button {
	position: absolute;
	z-index: var(--ck-z-default);
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-color-block-toolbar-button: var(--ck-color-text);
	--ck-block-toolbar-button-size: var(--ck-font-size-normal);
}

.ck.ck-block-toolbar-button {
	color: var(--ck-color-block-toolbar-button);
	font-size: var(--ck-block-toolbar-size);
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            9677: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck.ck-toolbar{align-items:center;display:flex;flex-flow:row nowrap;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-toolbar>.ck-toolbar__items{align-items:center;display:flex;flex-flow:row wrap;flex-grow:1}.ck.ck-toolbar .ck.ck-toolbar__separator{display:inline-block}.ck.ck-toolbar .ck.ck-toolbar__separator:first-child,.ck.ck-toolbar .ck.ck-toolbar__separator:last-child{display:none}.ck.ck-toolbar .ck-toolbar__line-break{flex-basis:100%}.ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items{flex-direction:column}.ck.ck-toolbar.ck-toolbar_floating>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck-dropdown__button .ck-dropdown__arrow{display:none}.ck.ck-toolbar{border-radius:0}.ck-rounded-corners .ck.ck-toolbar,.ck.ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-toolbar{background:var(--ck-color-toolbar-background);border:1px solid var(--ck-color-toolbar-border);padding:0 var(--ck-spacing-small)}.ck.ck-toolbar .ck.ck-toolbar__separator{background:var(--ck-color-toolbar-border);height:var(--ck-icon-size);margin-bottom:var(--ck-spacing-small);margin-top:var(--ck-spacing-small);min-width:1px;width:1px}.ck.ck-toolbar .ck-toolbar__line-break{height:0}.ck.ck-toolbar>.ck-toolbar__items>:not(.ck-toolbar__line-break){margin-right:var(--ck-spacing-small)}.ck.ck-toolbar>.ck-toolbar__items:empty+.ck.ck-toolbar__separator{display:none}.ck.ck-toolbar>.ck-toolbar__items>:not(.ck-toolbar__line-break),.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown{margin-bottom:var(--ck-spacing-small);margin-top:var(--ck-spacing-small)}.ck.ck-toolbar.ck-toolbar_vertical{padding:0}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items>.ck{border-radius:0;margin:0;width:100%}.ck.ck-toolbar.ck-toolbar_compact{padding:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>*{margin:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>:not(:first-child):not(:last-child){border-radius:0}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck.ck-button.ck-dropdown__button{padding-left:var(--ck-spacing-tiny)}.ck.ck-toolbar .ck-toolbar__nested-toolbar-dropdown>.ck-dropdown__panel{min-width:auto}.ck.ck-toolbar .ck-toolbar__nested-toolbar-dropdown>.ck-button>.ck-button__label{max-width:7em;width:auto}.ck.ck-toolbar:focus{outline:none}.ck-toolbar-container .ck.ck-toolbar{border:0}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck{margin-right:0}.ck.ck-toolbar[dir=rtl]:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-left:0}.ck.ck-toolbar.ck-toolbar_compact[dir=rtl]>.ck-toolbar__items>.ck:first-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-bottom-left-radius:0;border-top-left-radius:0}.ck.ck-toolbar.ck-toolbar_compact[dir=rtl]>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-bottom-right-radius:0;border-top-right-radius:0}.ck.ck-toolbar.ck-toolbar_grouping[dir=rtl]>.ck-toolbar__items:not(:empty):not(:only-child),.ck.ck-toolbar[dir=rtl]>.ck.ck-toolbar__separator,[dir=rtl] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=rtl] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=ltr]>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-right:0}.ck.ck-toolbar.ck-toolbar_compact[dir=ltr]>.ck-toolbar__items>.ck:first-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-bottom-right-radius:0;border-top-right-radius:0}.ck.ck-toolbar.ck-toolbar_compact[dir=ltr]>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-bottom-left-radius:0;border-top-left-radius:0}.ck.ck-toolbar.ck-toolbar_grouping[dir=ltr]>.ck-toolbar__items:not(:empty):not(:only-child),.ck.ck-toolbar[dir=ltr]>.ck.ck-toolbar__separator,[dir=ltr] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=ltr] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-right:var(--ck-spacing-small)}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/toolbar/toolbar.css", "webpack://./../ckeditor5-ui/theme/mixins/_unselectable.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/toolbar/toolbar.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"],
                    names: [],
                    mappings: "AAOA,eAKC,kBAAmB,CAFnB,YAAa,CACb,oBAAqB,CCFrB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBD6CD,CA3CC,kCAGC,kBAAmB,CAFnB,YAAa,CACb,kBAAmB,CAEnB,WAED,CAEA,yCACC,oBAWD,CAJC,yGAEC,YACD,CAGD,uCACC,eACD,CAEA,sDACC,gBACD,CAEA,sDACC,qBACD,CAEA,sDACC,gBACD,CAGC,yFACC,YACD,CE/CF,eCGC,eDwGD,CA3GA,qECOE,qCDoGF,CA3GA,eAGC,6CAA8C,CAE9C,+CAAgD,CADhD,iCAuGD,CApGC,yCAIC,yCAA0C,CAH1C,0BAA2B,CAU3B,qCAAsC,CADtC,kCAAmC,CAPnC,aAAc,CADd,SAUD,CAEA,uCACC,QACD,CAGC,gEAEC,oCACD,CAIA,kEACC,YACD,CAGD,gHAIC,qCAAsC,CADtC,kCAED,CAEA,mCAEC,SAaD,CAVC,0DAQC,eAAgB,CAHhB,QAAS,CAHT,UAOD,CAGD,kCAEC,SAWD,CATC,uDAEC,QAMD,CAHC,yFACC,eACD,CASD,kFACC,mCACD,CAMA,wEACC,cACD,CAEA,iFACC,aAAc,CACd,UACD,CAGD,qBACC,YACD,CAtGD,qCAyGE,QAEF,CAYC,+FACC,cACD,CAEA,iJAEC,mCACD,CAEA,qHACC,aACD,CAIC,6JAEC,2BAA4B,CAD5B,wBAED,CAGA,2JAEC,4BAA6B,CAD7B,yBAED,CASD,8RACC,mCACD,CAWA,qHACC,cACD,CAIC,6JAEC,4BAA6B,CAD7B,yBAED,CAGA,2JAEC,2BAA4B,CAD5B,wBAED,CASD,8RACC,oCACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../mixins/_unselectable.css";

.ck.ck-toolbar {
	@mixin ck-unselectable;

	display: flex;
	flex-flow: row nowrap;
	align-items: center;

	& > .ck-toolbar__items {
		display: flex;
		flex-flow: row wrap;
		align-items: center;
		flex-grow: 1;

	}

	& .ck.ck-toolbar__separator {
		display: inline-block;

		/*
		 * A leading or trailing separator makes no sense (separates from nothing on one side).
		 * For instance, it can happen when toolbar items (also separators) are getting grouped one by one and
		 * moved to another toolbar in the dropdown.
		 */
		&:first-child,
		&:last-child {
			display: none;
		}
	}

	& .ck-toolbar__line-break {
		flex-basis: 100%;
	}

	&.ck-toolbar_grouping > .ck-toolbar__items {
		flex-wrap: nowrap;
	}

	&.ck-toolbar_vertical > .ck-toolbar__items {
		flex-direction: column;
	}

	&.ck-toolbar_floating > .ck-toolbar__items {
		flex-wrap: nowrap;
	}

	& > .ck.ck-toolbar__grouped-dropdown {
		& > .ck-dropdown__button .ck-dropdown__arrow {
			display: none;
		}
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Makes element unselectable.
 */
@define-mixin ck-unselectable {
	-moz-user-select: none;
	-webkit-user-select: none;
	-ms-user-select: none;
	user-select: none
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

.ck.ck-toolbar {
	@mixin ck-rounded-corners;

	background: var(--ck-color-toolbar-background);
	padding: 0 var(--ck-spacing-small);
	border: 1px solid var(--ck-color-toolbar-border);

	& .ck.ck-toolbar__separator {
		height: var(--ck-icon-size);
		width: 1px;
		min-width: 1px;
		background: var(--ck-color-toolbar-border);

		/*
		 * These margins make the separators look better in balloon toolbars (when aligned with the "tip").
		 * See https://github.com/ckeditor/ckeditor5/issues/7493.
		 */
		margin-top: var(--ck-spacing-small);
		margin-bottom: var(--ck-spacing-small);
	}

	& .ck-toolbar__line-break {
		height: 0;
	}

	& > .ck-toolbar__items {
		& > *:not(.ck-toolbar__line-break) {
			/* (#11) Separate toolbar items. */
			margin-right: var(--ck-spacing-small);
		}

		/* Don't display a separator after an empty items container, for instance,
		when all items were grouped */
		&:empty + .ck.ck-toolbar__separator {
			display: none;
		}
	}

	& > .ck-toolbar__items > *:not(.ck-toolbar__line-break),
	& > .ck.ck-toolbar__grouped-dropdown {
		/* Make sure items wrapped to the next line have v-spacing */
		margin-top: var(--ck-spacing-small);
		margin-bottom: var(--ck-spacing-small);
	}

	&.ck-toolbar_vertical {
		/* Items in a vertical toolbar span the entire width. */
		padding: 0;

		/* Specificity matters here. See https://github.com/ckeditor/ckeditor5-theme-lark/issues/168. */
		& > .ck-toolbar__items > .ck {
			/* Items in a vertical toolbar should span the horizontal space. */
			width: 100%;

			/* Items in a vertical toolbar should have no margin. */
			margin: 0;

			/* Items in a vertical toolbar span the entire width so rounded corners are pointless. */
			border-radius: 0;
		}
	}

	&.ck-toolbar_compact {
		/* No spacing around items. */
		padding: 0;

		& > .ck-toolbar__items > * {
			/* Compact toolbar items have no spacing between them. */
			margin: 0;

			/* "Middle" children should have no rounded corners. */
			&:not(:first-child):not(:last-child) {
				border-radius: 0;
			}
		}
	}

	& > .ck.ck-toolbar__grouped-dropdown {
		/*
		 * Dropdown button has asymmetric padding to fit the arrow.
		 * This button has no arrow so let's revert that padding back to normal.
		 */
		& > .ck.ck-button.ck-dropdown__button {
			padding-left: var(--ck-spacing-tiny);
		}
	}

	/* A drop-down containing the nested toolbar with configured items. */
	& .ck-toolbar__nested-toolbar-dropdown {
		/* Prevent empty space in the panel when the dropdown label is visible and long but the toolbar has few items. */
		& > .ck-dropdown__panel {
			min-width: auto;
		}

		& > .ck-button > .ck-button__label {
			max-width: 7em;
			width: auto;
		}
	}

	&:focus {
		outline: none;
	}

	@nest .ck-toolbar-container & {
		border: 0;
	}
}

/* stylelint-disable */

/*
 * Styles for RTL toolbars.
 *
 * Note: In some cases (e.g. a decoupled editor), the toolbar has its own "dir"
 * because its parent is not controlled by the editor framework.
 */
[dir="rtl"] .ck.ck-toolbar,
.ck.ck-toolbar[dir="rtl"] {
	& > .ck-toolbar__items > .ck {
		margin-right: 0;
	}

	&:not(.ck-toolbar_compact) > .ck-toolbar__items > .ck {
		/* (#11) Separate toolbar items. */
		margin-left: var(--ck-spacing-small);
	}

	& > .ck-toolbar__items > .ck:last-child {
		margin-left: 0;
	}

	&.ck-toolbar_compact > .ck-toolbar__items > .ck {
		/* No rounded corners on the right side of the first child. */
		&:first-child {
			border-top-left-radius: 0;
			border-bottom-left-radius: 0;
		}

		/* No rounded corners on the left side of the last child. */
		&:last-child {
			border-top-right-radius: 0;
			border-bottom-right-radius: 0;
		}
	}

	/* Separate the the separator form the grouping dropdown when some items are grouped. */
	& > .ck.ck-toolbar__separator {
		margin-left: var(--ck-spacing-small);
	}

	/* Some spacing between the items and the separator before the grouped items dropdown. */
	&.ck-toolbar_grouping > .ck-toolbar__items:not(:empty):not(:only-child) {
		margin-left: var(--ck-spacing-small);
	}
}

/*
 * Styles for LTR toolbars.
 *
 * Note: In some cases (e.g. a decoupled editor), the toolbar has its own "dir"
 * because its parent is not controlled by the editor framework.
 */
[dir="ltr"] .ck.ck-toolbar,
.ck.ck-toolbar[dir="ltr"] {
	& > .ck-toolbar__items > .ck:last-child {
		margin-right: 0;
	}

	&.ck-toolbar_compact > .ck-toolbar__items > .ck {
		/* No rounded corners on the right side of the first child. */
		&:first-child {
			border-top-right-radius: 0;
			border-bottom-right-radius: 0;
		}

		/* No rounded corners on the left side of the last child. */
		&:last-child {
			border-top-left-radius: 0;
			border-bottom-left-radius: 0;
		}
	}

	/* Separate the the separator form the grouping dropdown when some items are grouped. */
	& > .ck.ck-toolbar__separator {
		margin-right: var(--ck-spacing-small);
	}

	/* Some spacing between the items and the separator before the grouped items dropdown. */
	&.ck-toolbar_grouping > .ck-toolbar__items:not(:empty):not(:only-child) {
		margin-right: var(--ck-spacing-small);
	}
}

/* stylelint-enable */
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Implements rounded corner interface for .ck-rounded-corners class.
 *
 * @see $ck-border-radius
 */
@define-mixin ck-rounded-corners {
	border-radius: 0;

	@nest .ck-rounded-corners &,
	&.ck-rounded-corners {
		border-radius: var(--ck-border-radius);
		@mixin-content;
	}
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            9205: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck.ck-balloon-panel.ck-tooltip{-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none;z-index:calc(var(--ck-z-dialog) + 100);--ck-balloon-border-width:0px;--ck-balloon-arrow-offset:0px;--ck-balloon-arrow-half-width:4px;--ck-balloon-arrow-height:4px;--ck-tooltip-text-padding:4px;--ck-color-panel-background:var(--ck-color-tooltip-background);padding:0 var(--ck-spacing-medium)}.ck.ck-balloon-panel.ck-tooltip .ck-tooltip__text{color:var(--ck-color-tooltip-text);font-size:.9em;line-height:1.5}.ck.ck-balloon-panel.ck-tooltip.ck-tooltip_multi-line .ck-tooltip__text{display:inline-block;max-width:200px;padding:var(--ck-tooltip-text-padding) 0;white-space:break-spaces}.ck.ck-balloon-panel.ck-tooltip{box-shadow:none}.ck.ck-balloon-panel.ck-tooltip:before{display:none}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/components/tooltip/tooltip.css", "webpack://./../ckeditor5-ui/theme/mixins/_unselectable.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/tooltip/tooltip.css"],
                    names: [],
                    mappings: "AAOA,gCCEC,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBAAgB,CDFhB,sCAAyC,CEFzC,6BAA8B,CAC9B,6BAA8B,CAC9B,iCAAkC,CAClC,6BAA8B,CAC9B,6BAA8B,CAC9B,8DAA+D,CAE/D,kCFJD,CEMC,kDAGC,kCAAmC,CAFnC,cAAe,CACf,eAED,CAEA,wEAEC,oBAAqB,CAErB,eAAgB,CADhB,wCAAyC,CAFzC,wBAID,CArBD,gCAwBC,eAMD,CAHC,uCACC,YACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../mixins/_unselectable.css";

.ck.ck-balloon-panel.ck-tooltip {
	@mixin ck-unselectable;

	z-index: calc( var(--ck-z-dialog) + 100 );
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Makes element unselectable.
 */
@define-mixin ck-unselectable {
	-moz-user-select: none;
	-webkit-user-select: none;
	-ms-user-select: none;
	user-select: none
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";

.ck.ck-balloon-panel.ck-tooltip {
	--ck-balloon-border-width: 0px;
	--ck-balloon-arrow-offset: 0px;
	--ck-balloon-arrow-half-width: 4px;
	--ck-balloon-arrow-height: 4px;
	--ck-tooltip-text-padding: 4px;
	--ck-color-panel-background: var(--ck-color-tooltip-background);

	padding: 0 var(--ck-spacing-medium);

	& .ck-tooltip__text {
		font-size: .9em;
		line-height: 1.5;
		color: var(--ck-color-tooltip-text);
	}

	&.ck-tooltip_multi-line .ck-tooltip__text {
		white-space: break-spaces;
		display: inline-block;
		padding: var(--ck-tooltip-text-padding) 0;
		max-width: 200px;
	}

	/* Reset balloon panel styles */
	box-shadow: none;

	/* Hide the default shadow of the .ck-balloon-panel tip */
	&::before {
		display: none;
	}
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            7676: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck-hidden{display:none!important}:root{--ck-z-default:1;--ck-z-panel:calc(var(--ck-z-default) + 999);--ck-z-dialog:9999}.ck-transitions-disabled,.ck-transitions-disabled *{transition:none!important}:root{--ck-powered-by-line-height:10px;--ck-powered-by-padding-vertical:2px;--ck-powered-by-padding-horizontal:4px;--ck-powered-by-text-color:#4f4f4f;--ck-powered-by-border-radius:var(--ck-border-radius);--ck-powered-by-background:#fff;--ck-powered-by-border-color:var(--ck-color-focus-border)}.ck.ck-balloon-panel.ck-powered-by-balloon{--ck-border-radius:var(--ck-powered-by-border-radius);background:var(--ck-powered-by-background);box-shadow:none;min-height:unset;z-index:calc(var(--ck-z-panel) - 1)}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by{line-height:var(--ck-powered-by-line-height)}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by a{align-items:center;cursor:pointer;display:flex;filter:grayscale(80%);line-height:var(--ck-powered-by-line-height);opacity:.66;padding:var(--ck-powered-by-padding-vertical) var(--ck-powered-by-padding-horizontal)}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by .ck-powered-by__label{color:var(--ck-powered-by-text-color);cursor:pointer;font-size:7.5px;font-weight:700;letter-spacing:-.2px;line-height:normal;margin-right:4px;padding-left:2px;text-transform:uppercase}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by .ck-icon{cursor:pointer;display:block}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by:hover a{filter:grayscale(0);opacity:1}.ck.ck-balloon-panel.ck-powered-by-balloon[class*=position_inside]{border-color:transparent}.ck.ck-balloon-panel.ck-powered-by-balloon[class*=position_border]{border:var(--ck-focus-ring);border-color:var(--ck-powered-by-border-color)}:root{--ck-color-base-foreground:#fafafa;--ck-color-base-background:#fff;--ck-color-base-border:#ccced1;--ck-color-base-action:#53a336;--ck-color-base-focus:#6cb5f9;--ck-color-base-text:#333;--ck-color-base-active:#2977ff;--ck-color-base-active-focus:#0d65ff;--ck-color-base-error:#db3700;--ck-color-focus-border-coordinates:218,81.8%,56.9%;--ck-color-focus-border:hsl(var(--ck-color-focus-border-coordinates));--ck-color-focus-outer-shadow:#cae1fc;--ck-color-focus-disabled-shadow:rgba(119,186,248,.3);--ck-color-focus-error-shadow:rgba(255,64,31,.3);--ck-color-text:var(--ck-color-base-text);--ck-color-shadow-drop:rgba(0,0,0,.15);--ck-color-shadow-drop-active:rgba(0,0,0,.2);--ck-color-shadow-inner:rgba(0,0,0,.1);--ck-color-button-default-background:transparent;--ck-color-button-default-hover-background:#f0f0f0;--ck-color-button-default-active-background:#f0f0f0;--ck-color-button-default-disabled-background:transparent;--ck-color-button-on-background:#f0f7ff;--ck-color-button-on-hover-background:#dbecff;--ck-color-button-on-active-background:#dbecff;--ck-color-button-on-disabled-background:#f0f2f4;--ck-color-button-on-color:#2977ff;--ck-color-button-action-background:var(--ck-color-base-action);--ck-color-button-action-hover-background:#4d9d30;--ck-color-button-action-active-background:#4d9d30;--ck-color-button-action-disabled-background:#7ec365;--ck-color-button-action-text:var(--ck-color-base-background);--ck-color-button-save:#008a00;--ck-color-button-cancel:#db3700;--ck-color-switch-button-off-background:#939393;--ck-color-switch-button-off-hover-background:#7d7d7d;--ck-color-switch-button-on-background:var(--ck-color-button-action-background);--ck-color-switch-button-on-hover-background:#4d9d30;--ck-color-switch-button-inner-background:var(--ck-color-base-background);--ck-color-switch-button-inner-shadow:rgba(0,0,0,.1);--ck-color-dropdown-panel-background:var(--ck-color-base-background);--ck-color-dropdown-panel-border:var(--ck-color-base-border);--ck-color-dialog-background:var(--ck-custom-background);--ck-color-dialog-form-header-border:var(--ck-custom-border);--ck-color-input-background:var(--ck-color-base-background);--ck-color-input-border:var(--ck-color-base-border);--ck-color-input-error-border:var(--ck-color-base-error);--ck-color-input-text:var(--ck-color-base-text);--ck-color-input-disabled-background:#f2f2f2;--ck-color-input-disabled-border:var(--ck-color-base-border);--ck-color-input-disabled-text:#757575;--ck-color-list-background:var(--ck-color-base-background);--ck-color-list-button-hover-background:var(--ck-color-button-default-hover-background);--ck-color-list-button-on-background:var(--ck-color-button-on-color);--ck-color-list-button-on-background-focus:var(--ck-color-button-on-color);--ck-color-list-button-on-text:var(--ck-color-base-background);--ck-color-panel-background:var(--ck-color-base-background);--ck-color-panel-border:var(--ck-color-base-border);--ck-color-toolbar-background:var(--ck-color-base-background);--ck-color-toolbar-border:var(--ck-color-base-border);--ck-color-tooltip-background:var(--ck-color-base-text);--ck-color-tooltip-text:var(--ck-color-base-background);--ck-color-engine-placeholder-text:#707070;--ck-color-upload-bar-background:#6cb5f9;--ck-color-link-default:#0000f0;--ck-color-link-selected-background:rgba(31,176,255,.1);--ck-color-link-fake-selection:rgba(31,176,255,.3);--ck-color-highlight-background:#ff0;--ck-color-light-red:#fcc;--ck-disabled-opacity:.5;--ck-focus-outer-shadow-geometry:0 0 0 3px;--ck-focus-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-outer-shadow);--ck-focus-disabled-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-disabled-shadow);--ck-focus-error-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-error-shadow);--ck-focus-ring:1px solid var(--ck-color-focus-border);--ck-font-size-base:13px;--ck-line-height-base:1.84615;--ck-font-face:Helvetica,Arial,Tahoma,Verdana,Sans-Serif;--ck-font-size-tiny:0.7em;--ck-font-size-small:0.75em;--ck-font-size-normal:1em;--ck-font-size-big:1.4em;--ck-font-size-large:1.8em;--ck-ui-component-min-height:2.3em}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset,.ck.ck-reset_all{background:transparent;border:0;box-sizing:border-box;height:auto;margin:0;padding:0;position:static;text-decoration:none;transition:none;vertical-align:middle;width:auto;word-wrap:break-word}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset_all{border-collapse:collapse;color:var(--ck-color-text);cursor:auto;float:none;font:normal normal normal var(--ck-font-size-base)/var(--ck-line-height-base) var(--ck-font-face);text-align:left;white-space:nowrap}.ck-reset_all .ck-rtl :not(.ck-reset_all-excluded *){text-align:right}.ck-reset_all iframe:not(.ck-reset_all-excluded *){vertical-align:inherit}.ck-reset_all textarea:not(.ck-reset_all-excluded *){white-space:pre-wrap}.ck-reset_all input[type=password]:not(.ck-reset_all-excluded *),.ck-reset_all input[type=text]:not(.ck-reset_all-excluded *),.ck-reset_all textarea:not(.ck-reset_all-excluded *){cursor:text}.ck-reset_all input[type=password][disabled]:not(.ck-reset_all-excluded *),.ck-reset_all input[type=text][disabled]:not(.ck-reset_all-excluded *),.ck-reset_all textarea[disabled]:not(.ck-reset_all-excluded *){cursor:default}.ck-reset_all fieldset:not(.ck-reset_all-excluded *){border:2px groove #dfdee3;padding:10px}.ck-reset_all button:not(.ck-reset_all-excluded *)::-moz-focus-inner{border:0;padding:0}.ck[dir=rtl],.ck[dir=rtl] .ck{text-align:right}:root{--ck-border-radius:2px;--ck-inner-shadow:2px 2px 3px var(--ck-color-shadow-inner) inset;--ck-drop-shadow:0 1px 2px 1px var(--ck-color-shadow-drop);--ck-drop-shadow-active:0 3px 6px 1px var(--ck-color-shadow-drop-active);--ck-spacing-unit:0.6em;--ck-spacing-large:calc(var(--ck-spacing-unit)*1.5);--ck-spacing-standard:var(--ck-spacing-unit);--ck-spacing-medium:calc(var(--ck-spacing-unit)*0.8);--ck-spacing-small:calc(var(--ck-spacing-unit)*0.5);--ck-spacing-tiny:calc(var(--ck-spacing-unit)*0.3);--ck-spacing-extra-tiny:calc(var(--ck-spacing-unit)*0.16)}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-ui/theme/globals/_hidden.css", "webpack://./../ckeditor5-ui/theme/globals/_zindex.css", "webpack://./../ckeditor5-ui/theme/globals/_transition.css", "webpack://./../ckeditor5-ui/theme/globals/_poweredby.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_colors.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_disabled.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_focus.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_fonts.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_reset.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_shadow.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_spacing.css"],
                    names: [],
                    mappings: "AAQA,WAGC,sBACD,CCPA,MACC,gBAAiB,CACjB,4CAA+C,CAC/C,kBACD,CCDA,oDAEC,yBACD,CCNA,MACC,gCAAiC,CACjC,oCAAqC,CACrC,sCAAuC,CACvC,kCAA2C,CAC3C,qDAAsD,CACtD,+BAA4C,CAC5C,yDACD,CAEA,2CACC,qDAAsD,CAGtD,0CAA2C,CAD3C,eAAgB,CAEhB,gBAAiB,CACjB,mCAiDD,CA/CC,6DACC,4CAoCD,CAlCC,+DAGC,kBAAmB,CAFnB,cAAe,CACf,YAAa,CAGb,qBAAsB,CACtB,4CAA6C,CAF7C,WAAY,CAGZ,qFACD,CAEA,mFASC,qCAAsC,CAFtC,cAAe,CANf,eAAgB,CAIhB,eAAiB,CAHjB,oBAAqB,CAMrB,kBAAmB,CAFnB,gBAAiB,CAHjB,gBAAiB,CACjB,wBAOD,CAEA,sEAEC,cAAe,CADf,aAED,CAGC,qEACC,mBAAqB,CACrB,SACD,CAIF,mEACC,wBACD,CAEA,mEACC,2BAA4B,CAC5B,8CACD,CChED,MACC,kCAAmD,CACnD,+BAAoD,CACpD,8BAAkD,CAClD,8BAAuD,CACvD,6BAAmD,CACnD,yBAA+C,CAC/C,8BAAsD,CACtD,oCAA4D,CAC5D,6BAAkD,CAIlD,mDAA4D,CAC5D,qEAA+E,CAC/E,qCAA4D,CAC5D,qDAA8D,CAC9D,gDAAyD,CACzD,yCAAqD,CACrD,sCAAsD,CACtD,4CAA0D,CAC1D,sCAAsD,CAItD,gDAAuD,CACvD,kDAAiE,CACjE,mDAAkE,CAClE,yDAA8D,CAE9D,uCAA6D,CAC7D,6CAAoE,CACpE,8CAAoE,CACpE,gDAAiE,CACjE,kCAAyD,CAGzD,+DAAsE,CACtE,iDAAsE,CACtE,kDAAsE,CACtE,oDAAoE,CACpE,6DAAsE,CAEtE,8BAAoD,CACpD,gCAAqD,CAErD,+CAA8D,CAC9D,qDAAiE,CACjE,+EAAqF,CACrF,oDAAuE,CACvE,yEAA8E,CAC9E,oDAAgE,CAIhE,oEAA2E,CAC3E,4DAAoE,CAIpE,wDAAiE,CACjE,4DAAmE,CAInE,2DAAoE,CACpE,mDAA6D,CAC7D,wDAAgE,CAChE,+CAA0D,CAC1D,4CAA2D,CAC3D,4DAAoE,CACpE,sCAAsD,CAItD,0DAAmE,CACnE,uFAA6F,CAC7F,oEAA2E,CAC3E,0EAA+E,CAC/E,8DAAsE,CAItE,2DAAoE,CACpE,mDAA6D,CAI7D,6DAAsE,CACtE,qDAA+D,CAI/D,uDAAgE,CAChE,uDAAiE,CAIjE,0CAAyD,CAIzD,wCAA2D,CAI3D,+BAAoD,CACpD,uDAAmE,CACnE,kDAAgE,CAIhE,oCAAyD,CAIzD,yBAAgD,CChHhD,wBAAyB,CCAzB,0CAA2C,CAK3C,gGAAiG,CAKjG,4GAA6G,CAK7G,sGAAuG,CAKvG,sDAAuD,CCvBvD,wBAAyB,CACzB,6BAA8B,CAC9B,wDAA6D,CAE7D,yBAA0B,CAC1B,2BAA4B,CAC5B,yBAA0B,CAC1B,wBAAyB,CACzB,0BAA2B,CCJ3B,kCJgHD,CI1GA,2EAYC,sBAAuB,CADvB,QAAS,CART,qBAAsB,CAEtB,WAAY,CAIZ,QAAS,CACT,SAAU,CAJV,eAAgB,CAOhB,oBAAqB,CAErB,eAAgB,CADhB,qBAAsB,CAVtB,UAAW,CAcX,oBACD,CAKA,8DAGC,wBAAyB,CAEzB,0BAA2B,CAG3B,WAAY,CACZ,UAAW,CALX,iGAAkG,CAElG,eAAgB,CAChB,kBAGD,CAGC,qDACC,gBACD,CAEA,mDAEC,sBACD,CAEA,qDACC,oBACD,CAEA,mLAGC,WACD,CAEA,iNAGC,cACD,CAEA,qDAEC,yBAAoC,CADpC,YAED,CAEA,qEAGC,QAAQ,CADR,SAED,CAMD,8BAEC,gBACD,CCxFA,MACC,sBAAuB,CCAvB,gEAAiE,CAKjE,0DAA2D,CAK3D,wEAAyE,CCbzE,uBAA8B,CAC9B,mDAA2D,CAC3D,4CAAkD,CAClD,oDAA4D,CAC5D,mDAA2D,CAC3D,kDAA2D,CAC3D,yDFFD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A class which hides an element in DOM.
 */
.ck-hidden {
	/* Override selector specificity. Otherwise, all elements with some display
	style defined will override this one, which is not a desired result. */
	display: none !important;
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-z-default: 1;
	--ck-z-panel: calc( var(--ck-z-default) + 999 );
	--ck-z-dialog: 9999;
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A class that disables all transitions of the element and its children.
 */
.ck-transitions-disabled,
.ck-transitions-disabled * {
	transition: none !important;
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-powered-by-line-height: 10px;
	--ck-powered-by-padding-vertical: 2px;
	--ck-powered-by-padding-horizontal: 4px;
	--ck-powered-by-text-color: hsl(0, 0%, 31%);
	--ck-powered-by-border-radius: var(--ck-border-radius);
	--ck-powered-by-background: hsl(0, 0%, 100%);
	--ck-powered-by-border-color: var(--ck-color-focus-border);
}

.ck.ck-balloon-panel.ck-powered-by-balloon {
	--ck-border-radius: var(--ck-powered-by-border-radius);

	box-shadow: none;
	background: var(--ck-powered-by-background);
	min-height: unset;
	z-index: calc( var(--ck-z-panel) - 1 );

	& .ck.ck-powered-by {
		line-height: var(--ck-powered-by-line-height);

		& a {
			cursor: pointer;
			display: flex;
			align-items: center;
			opacity: .66;
			filter: grayscale(80%);
			line-height: var(--ck-powered-by-line-height);
			padding: var(--ck-powered-by-padding-vertical) var(--ck-powered-by-padding-horizontal);
		}

		& .ck-powered-by__label {
			font-size: 7.5px;
			letter-spacing: -.2px;
			padding-left: 2px;
			text-transform: uppercase;
			font-weight: bold;
			margin-right: 4px;
			cursor: pointer;
			line-height: normal;
			color: var(--ck-powered-by-text-color);

		}

		& .ck-icon {
			display: block;
			cursor: pointer;
		}

		&:hover {
			& a {
				filter: grayscale(0%);
				opacity: 1;
			}
		}
	}

	&[class*="position_inside"] {
		border-color: transparent;
	}

	&[class*="position_border"] {
		border: var(--ck-focus-ring);
		border-color: var(--ck-powered-by-border-color);
	}
}

`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-color-base-foreground: 								hsl(0, 0%, 98%);
	--ck-color-base-background: 								hsl(0, 0%, 100%);
	--ck-color-base-border: 									hsl(220, 6%, 81%);
	--ck-color-base-action: 									hsl(104, 50.2%, 42.5%);
	--ck-color-base-focus: 										hsl(209, 92%, 70%);
	--ck-color-base-text: 										hsl(0, 0%, 20%);
	--ck-color-base-active: 									hsl(218.1, 100%, 58%);
	--ck-color-base-active-focus:								hsl(218.2, 100%, 52.5%);
	--ck-color-base-error:										hsl(15, 100%, 43%);

	/* -- Generic colors ------------------------------------------------------------------------ */

	--ck-color-focus-border-coordinates: 						218, 81.8%, 56.9%;
	--ck-color-focus-border: 									hsl(var(--ck-color-focus-border-coordinates));
	--ck-color-focus-outer-shadow:								hsl(212.4, 89.3%, 89%);
	--ck-color-focus-disabled-shadow:							hsla(209, 90%, 72%,.3);
	--ck-color-focus-error-shadow:								hsla(9,100%,56%,.3);
	--ck-color-text: 											var(--ck-color-base-text);
	--ck-color-shadow-drop: 									hsla(0, 0%, 0%, 0.15);
	--ck-color-shadow-drop-active:								hsla(0, 0%, 0%, 0.2);
	--ck-color-shadow-inner: 									hsla(0, 0%, 0%, 0.1);

	/* -- Buttons ------------------------------------------------------------------------------- */

	--ck-color-button-default-background: 						transparent;
	--ck-color-button-default-hover-background: 				hsl(0, 0%, 94.1%);
	--ck-color-button-default-active-background: 				hsl(0, 0%, 94.1%);
	--ck-color-button-default-disabled-background: 				transparent;

	--ck-color-button-on-background: 							hsl(212, 100%, 97.1%);
	--ck-color-button-on-hover-background: 						hsl(211.7, 100%, 92.9%);
	--ck-color-button-on-active-background: 					hsl(211.7, 100%, 92.9%);
	--ck-color-button-on-disabled-background: 					hsl(211, 15%, 95%);
	--ck-color-button-on-color:									hsl(218.1, 100%, 58%);


	--ck-color-button-action-background: 						var(--ck-color-base-action);
	--ck-color-button-action-hover-background: 					hsl(104, 53.2%, 40.2%);
	--ck-color-button-action-active-background: 				hsl(104, 53.2%, 40.2%);
	--ck-color-button-action-disabled-background: 				hsl(104, 44%, 58%);
	--ck-color-button-action-text: 								var(--ck-color-base-background);

	--ck-color-button-save: 									hsl(120, 100%, 27%);
	--ck-color-button-cancel: 									hsl(15, 100%, 43%);

	--ck-color-switch-button-off-background:					hsl(0, 0%, 57.6%);
	--ck-color-switch-button-off-hover-background:				hsl(0, 0%, 49%);
	--ck-color-switch-button-on-background:						var(--ck-color-button-action-background);
	--ck-color-switch-button-on-hover-background:				hsl(104, 53.2%, 40.2%);
	--ck-color-switch-button-inner-background:					var(--ck-color-base-background);
	--ck-color-switch-button-inner-shadow:						hsla(0, 0%, 0%, 0.1);

	/* -- Dropdown ------------------------------------------------------------------------------ */

	--ck-color-dropdown-panel-background: 						var(--ck-color-base-background);
	--ck-color-dropdown-panel-border: 							var(--ck-color-base-border);

	/* -- Dialog -------------------------------------------------------------------------------- */

	--ck-color-dialog-background: 								var(--ck-custom-background);
	--ck-color-dialog-form-header-border: 						var(--ck-custom-border);

	/* -- Input --------------------------------------------------------------------------------- */

	--ck-color-input-background: 								var(--ck-color-base-background);
	--ck-color-input-border: 									var(--ck-color-base-border);
	--ck-color-input-error-border:								var(--ck-color-base-error);
	--ck-color-input-text: 										var(--ck-color-base-text);
	--ck-color-input-disabled-background: 						hsl(0, 0%, 95%);
	--ck-color-input-disabled-border: 							var(--ck-color-base-border);
	--ck-color-input-disabled-text: 							hsl(0, 0%, 46%);

	/* -- List ---------------------------------------------------------------------------------- */

	--ck-color-list-background: 								var(--ck-color-base-background);
	--ck-color-list-button-hover-background: 					var(--ck-color-button-default-hover-background);
	--ck-color-list-button-on-background: 						var(--ck-color-button-on-color);
	--ck-color-list-button-on-background-focus: 				var(--ck-color-button-on-color);
	--ck-color-list-button-on-text:								var(--ck-color-base-background);

	/* -- Panel --------------------------------------------------------------------------------- */

	--ck-color-panel-background: 								var(--ck-color-base-background);
	--ck-color-panel-border: 									var(--ck-color-base-border);

	/* -- Toolbar ------------------------------------------------------------------------------- */

	--ck-color-toolbar-background: 								var(--ck-color-base-background);
	--ck-color-toolbar-border: 									var(--ck-color-base-border);

	/* -- Tooltip ------------------------------------------------------------------------------- */

	--ck-color-tooltip-background: 								var(--ck-color-base-text);
	--ck-color-tooltip-text: 									var(--ck-color-base-background);

	/* -- Engine -------------------------------------------------------------------------------- */

	--ck-color-engine-placeholder-text: 						hsl(0, 0%, 44%);

	/* -- Upload -------------------------------------------------------------------------------- */

	--ck-color-upload-bar-background:		 					hsl(209, 92%, 70%);

	/* -- Link -------------------------------------------------------------------------------- */

	--ck-color-link-default:									hsl(240, 100%, 47%);
	--ck-color-link-selected-background:						hsla(201, 100%, 56%, 0.1);
	--ck-color-link-fake-selection:								hsla(201, 100%, 56%, 0.3);

	/* -- Search result highlight ---------------------------------------------------------------- */

	--ck-color-highlight-background:							hsl(60, 100%, 50%);

	/* -- Generic colors ------------------------------------------------------------------------- */

	--ck-color-light-red:										hsl(0, 100%, 90%);
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	/**
	 * An opacity value of disabled UI item.
	 */
	--ck-disabled-opacity: .5;
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	/**
	 * The geometry of the of focused element's outer shadow.
	 */
	--ck-focus-outer-shadow-geometry: 0 0 0 3px;

	/**
	 * A visual style of focused element's outer shadow.
	 */
	--ck-focus-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-outer-shadow);

	/**
	 * A visual style of focused element's outer shadow (when disabled).
	 */
	--ck-focus-disabled-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-disabled-shadow);

	/**
	 * A visual style of focused element's outer shadow (when has errors).
	 */
	--ck-focus-error-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-error-shadow);

	/**
	 * A visual style of focused element's border or outline.
	 */
	--ck-focus-ring: 1px solid var(--ck-color-focus-border);
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-font-size-base: 13px;
	--ck-line-height-base: 1.84615;
	--ck-font-face: Helvetica, Arial, Tahoma, Verdana, Sans-Serif;

	--ck-font-size-tiny: 0.7em;
	--ck-font-size-small: 0.75em;
	--ck-font-size-normal: 1em;
	--ck-font-size-big: 1.4em;
	--ck-font-size-large: 1.8em;
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	/* This is super-important. This is **manually** adjusted so a button without an icon
	is never smaller than a button with icon, additionally making sure that text-less buttons
	are perfect squares. The value is also shared by other components which should stay "in-line"
	with buttons. */
	--ck-ui-component-min-height: 2.3em;
}

/**
 * Resets an element, ignoring its children.
 */
.ck.ck-reset,
.ck.ck-reset_all,
.ck-reset_all *:not(.ck-reset_all-excluded *) {
	box-sizing: border-box;
	width: auto;
	height: auto;
	position: static;

	/* Do not include inheritable rules here. */
	margin: 0;
	padding: 0;
	border: 0;
	background: transparent;
	text-decoration: none;
	vertical-align: middle;
	transition: none;

	/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/105 */
	word-wrap: break-word;
}

/**
 * Resets an element AND its children.
 */
.ck.ck-reset_all,
.ck-reset_all *:not(.ck-reset_all-excluded *) {
	/* These are rule inherited by all children elements. */
	border-collapse: collapse;
	font: normal normal normal var(--ck-font-size-base)/var(--ck-line-height-base) var(--ck-font-face);
	color: var(--ck-color-text);
	text-align: left;
	white-space: nowrap;
	cursor: auto;
	float: none;
}

.ck-reset_all {
	& .ck-rtl *:not(.ck-reset_all-excluded *) {
		text-align: right;
	}

	& iframe:not(.ck-reset_all-excluded *) {
		/* For IE */
		vertical-align: inherit;
	}

	& textarea:not(.ck-reset_all-excluded *) {
		white-space: pre-wrap;
	}

	& textarea:not(.ck-reset_all-excluded *),
	& input[type="text"]:not(.ck-reset_all-excluded *),
	& input[type="password"]:not(.ck-reset_all-excluded *) {
		cursor: text;
	}

	& textarea[disabled]:not(.ck-reset_all-excluded *),
	& input[type="text"][disabled]:not(.ck-reset_all-excluded *),
	& input[type="password"][disabled]:not(.ck-reset_all-excluded *) {
		cursor: default;
	}

	& fieldset:not(.ck-reset_all-excluded *) {
		padding: 10px;
		border: 2px groove hsl(255, 7%, 88%);
	}

	& button:not(.ck-reset_all-excluded *)::-moz-focus-inner {
		/* See http://stackoverflow.com/questions/5517744/remove-extra-button-spacing-padding-in-firefox */
		padding: 0;
		border: 0
	}
}

/**
 * Default UI rules for RTL languages.
 */
.ck[dir="rtl"],
.ck[dir="rtl"] .ck {
	text-align: right;
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Default border-radius value.
 */
:root{
	--ck-border-radius: 2px;
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	/**
	 * A visual style of element's inner shadow (i.e. input).
	 */
	--ck-inner-shadow: 2px 2px 3px var(--ck-color-shadow-inner) inset;

	/**
	 * A visual style of element's drop shadow (i.e. panel).
	 */
	--ck-drop-shadow: 0 1px 2px 1px var(--ck-color-shadow-drop);

	/**
	 * A visual style of element's active shadow (i.e. comment or suggestion).
	 */
	--ck-drop-shadow-active: 0 3px 6px 1px var(--ck-color-shadow-drop-active);
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-spacing-unit: 						0.6em;
	--ck-spacing-large: 					calc(var(--ck-spacing-unit) * 1.5);
	--ck-spacing-standard: 					var(--ck-spacing-unit);
	--ck-spacing-medium: 					calc(var(--ck-spacing-unit) * 0.8);
	--ck-spacing-small: 					calc(var(--ck-spacing-unit) * 0.5);
	--ck-spacing-tiny: 						calc(var(--ck-spacing-unit) * 0.3);
	--ck-spacing-extra-tiny: 				calc(var(--ck-spacing-unit) * 0.16);
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            695: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ":root{--ck-color-resizer:var(--ck-color-focus-border);--ck-color-resizer-tooltip-background:#262626;--ck-color-resizer-tooltip-text:#f2f2f2;--ck-resizer-border-radius:var(--ck-border-radius);--ck-resizer-tooltip-offset:10px;--ck-resizer-tooltip-height:calc(var(--ck-spacing-small)*2 + 10px)}.ck .ck-widget,.ck .ck-widget.ck-widget_with-selection-handle{position:relative}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{position:absolute}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{display:block}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle{visibility:visible}.ck .ck-size-view{background:var(--ck-color-resizer-tooltip-background);border:1px solid var(--ck-color-resizer-tooltip-text);border-radius:var(--ck-resizer-border-radius);color:var(--ck-color-resizer-tooltip-text);display:block;font-size:var(--ck-font-size-tiny);height:var(--ck-resizer-tooltip-height);line-height:var(--ck-resizer-tooltip-height);padding:0 var(--ck-spacing-small)}.ck .ck-size-view.ck-orientation-above-center,.ck .ck-size-view.ck-orientation-bottom-left,.ck .ck-size-view.ck-orientation-bottom-right,.ck .ck-size-view.ck-orientation-top-left,.ck .ck-size-view.ck-orientation-top-right{position:absolute}.ck .ck-size-view.ck-orientation-top-left{left:var(--ck-resizer-tooltip-offset);top:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-top-right{right:var(--ck-resizer-tooltip-offset);top:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-right{bottom:var(--ck-resizer-tooltip-offset);right:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-left{bottom:var(--ck-resizer-tooltip-offset);left:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-above-center{left:50%;top:calc(var(--ck-resizer-tooltip-height)*-1);transform:translate(-50%)}:root{--ck-widget-outline-thickness:3px;--ck-widget-handler-icon-size:16px;--ck-widget-handler-animation-duration:200ms;--ck-widget-handler-animation-curve:ease;--ck-color-widget-blurred-border:#dedede;--ck-color-widget-hover-border:#ffc83d;--ck-color-widget-editable-focus-background:var(--ck-color-base-background);--ck-color-widget-drag-handler-icon-color:var(--ck-color-base-background)}.ck .ck-widget{outline-color:transparent;outline-style:solid;outline-width:var(--ck-widget-outline-thickness);transition:outline-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}@media (prefers-reduced-motion:reduce){.ck .ck-widget{transition:none}}.ck .ck-widget.ck-widget_selected,.ck .ck-widget.ck-widget_selected:hover{outline:var(--ck-widget-outline-thickness) solid var(--ck-color-focus-border)}.ck .ck-widget:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-editor__nested-editable{border:1px solid transparent}.ck .ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck .ck-editor__nested-editable:focus{border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;outline:none}@media (forced-colors:none){.ck .ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck .ck-editor__nested-editable:focus{background-color:var(--ck-color-widget-editable-focus-background)}}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{background-color:transparent;border-radius:var(--ck-border-radius) var(--ck-border-radius) 0 0;box-sizing:border-box;left:calc(0px - var(--ck-widget-outline-thickness));opacity:0;padding:4px;top:0;transform:translateY(-100%);transition:background-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),visibility var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}@media (prefers-reduced-motion:reduce){.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{transition:none}}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{color:var(--ck-color-widget-drag-handler-icon-color);height:var(--ck-widget-handler-icon-size);width:var(--ck-widget-handler-icon-size)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:0;transition:opacity .3s var(--ck-widget-handler-animation-curve)}@media (prefers-reduced-motion:reduce){.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{transition:none}}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover .ck-icon .ck-icon__selected-indicator{opacity:1}.ck .ck-widget.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle{background-color:var(--ck-color-widget-hover-border);opacity:1}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle{background-color:var(--ck-color-focus-border);opacity:1}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:1}.ck[dir=rtl] .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{left:auto;right:calc(0px - var(--ck-widget-outline-thickness))}.ck.ck-editor__editable.ck-read-only .ck-widget{transition:none}.ck.ck-editor__editable.ck-read-only .ck-widget:not(.ck-widget_selected){--ck-widget-outline-thickness:0px}.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle,.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected:hover{outline-color:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle:hover,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle>.ck-widget__selection-handle,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle>.ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable blockquote>.ck-widget.ck-widget_with-selection-handle:first-child,.ck.ck-editor__editable>.ck-widget.ck-widget_with-selection-handle:first-child{margin-top:calc(1em + var(--ck-widget-handler-icon-size))}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-widget/theme/widget.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-widget/widget.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css", "webpack://./../ckeditor5-ui/theme/mixins/_mediacolors.css"],
                    names: [],
                    mappings: "AAKA,MACC,+CAAgD,CAChD,6CAAsD,CACtD,uCAAgD,CAEhD,kDAAmD,CACnD,gCAAiC,CACjC,kEACD,CAOA,8DAEC,iBAqBD,CAnBC,4EACC,iBAOD,CALC,qFAGC,aACD,CASD,iLACC,kBACD,CAGD,kBACC,qDAAsD,CAEtD,qDAAsD,CACtD,6CAA8C,CAF9C,0CAA2C,CAI3C,aAAc,CADd,kCAAmC,CAGnC,uCAAwC,CACxC,4CAA6C,CAF7C,iCAsCD,CAlCC,8NAKC,iBACD,CAEA,0CAEC,qCAAsC,CADtC,oCAED,CAEA,2CAEC,sCAAuC,CADvC,oCAED,CAEA,8CACC,uCAAwC,CACxC,sCACD,CAEA,6CACC,uCAAwC,CACxC,qCACD,CAGA,8CAEC,QAAS,CADT,6CAAgD,CAEhD,yBACD,CChFD,MACC,iCAAkC,CAClC,kCAAmC,CACnC,4CAA6C,CAC7C,wCAAyC,CAEzC,wCAAiD,CACjD,sCAAkD,CAClD,2EAA4E,CAC5E,yEACD,CAEA,eAGC,yBAA0B,CAD1B,mBAAoB,CADpB,gDAAiD,CAGjD,6GAcD,CAZC,uCAND,eAOE,eAWF,CAVC,CAEA,0EAEC,6EACD,CAEA,qBACC,iDACD,CAGD,gCACC,4BAYD,CARC,yGCnCA,2BAA2B,CCF3B,qCAA8B,CDC9B,YD2CA,CGvCA,4BACC,yGHoCC,iEGlCD,CACD,CHuCA,4EAKC,4BAA6B,CAa7B,iEAAkE,CAhBlE,qBAAsB,CAoBtB,mDAAoD,CAhBpD,SAAU,CALV,WAAY,CAsBZ,KAAM,CAFN,2BAA4B,CAT5B,6SAwCD,CA3BC,uCAzBD,4EA0BE,eA0BF,CAzBC,CAEA,qFAIC,oDAAqD,CADrD,yCAA0C,CAD1C,wCAeD,CAVC,kHACC,SAAU,CAGV,+DAKD,CAHC,uCAND,kHAOE,eAEF,CADC,CAKF,wHACC,SACD,CAID,kFAEC,oDAAqD,CADrD,SAED,CAKC,oMAEC,6CAA8C,CAD9C,SAOD,CAHC,gRACC,SACD,CAOH,qFACC,SAAU,CACV,oDACD,CAGA,gDAEC,eAkBD,CAhBC,yEAOC,iCACD,CAGC,gOAEC,gDACD,CAOD,wIAEC,mDAQD,CALE,ghBAEC,gDACD,CAKH,yKAOC,yDACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-color-resizer: var(--ck-color-focus-border);
	--ck-color-resizer-tooltip-background: hsl(0, 0%, 15%);
	--ck-color-resizer-tooltip-text: hsl(0, 0%, 95%);

	--ck-resizer-border-radius: var(--ck-border-radius);
	--ck-resizer-tooltip-offset: 10px;
	--ck-resizer-tooltip-height: calc(var(--ck-spacing-small) * 2 + 10px);
}

.ck .ck-widget {
	/* This is neccessary for type around UI to be positioned properly. */
	position: relative;
}

.ck .ck-widget.ck-widget_with-selection-handle {
	/* Make the widget wrapper a relative positioning container for the drag handle. */
	position: relative;

	& .ck-widget__selection-handle {
		position: absolute;

		& .ck-icon {
			/* Make sure the icon in not a subject to font-size or line-height to avoid
			unnecessary spacing around it. */
			display: block;
		}
	}

	/* Show the selection handle on mouse hover over the widget, but not for nested widgets. */
	&:hover > .ck-widget__selection-handle {
		visibility: visible;
	}

	/* Show the selection handle when the widget is selected, but not for nested widgets. */
	&.ck-widget_selected > .ck-widget__selection-handle {
		visibility: visible;
	}
}

.ck .ck-size-view {
	background: var(--ck-color-resizer-tooltip-background);
	color: var(--ck-color-resizer-tooltip-text);
	border: 1px solid var(--ck-color-resizer-tooltip-text);
	border-radius: var(--ck-resizer-border-radius);
	font-size: var(--ck-font-size-tiny);
	display: block;
	padding: 0 var(--ck-spacing-small);
	height: var(--ck-resizer-tooltip-height);
	line-height: var(--ck-resizer-tooltip-height);

	&.ck-orientation-top-left,
	&.ck-orientation-top-right,
	&.ck-orientation-bottom-right,
	&.ck-orientation-bottom-left,
	&.ck-orientation-above-center {
		position: absolute;
	}

	&.ck-orientation-top-left {
		top: var(--ck-resizer-tooltip-offset);
		left: var(--ck-resizer-tooltip-offset);
	}

	&.ck-orientation-top-right {
		top: var(--ck-resizer-tooltip-offset);
		right: var(--ck-resizer-tooltip-offset);
	}

	&.ck-orientation-bottom-right {
		bottom: var(--ck-resizer-tooltip-offset);
		right: var(--ck-resizer-tooltip-offset);
	}

	&.ck-orientation-bottom-left {
		bottom: var(--ck-resizer-tooltip-offset);
		left: var(--ck-resizer-tooltip-offset);
	}

	/* Class applied if the widget is too small to contain the size label */
	&.ck-orientation-above-center {
		top: calc(var(--ck-resizer-tooltip-height) * -1);
		left: 50%;
		transform: translate(-50%);
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../mixins/_focus.css";
@import "../mixins/_shadow.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_mediacolors.css";

:root {
	--ck-widget-outline-thickness: 3px;
	--ck-widget-handler-icon-size: 16px;
	--ck-widget-handler-animation-duration: 200ms;
	--ck-widget-handler-animation-curve: ease;

	--ck-color-widget-blurred-border: hsl(0, 0%, 87%);
	--ck-color-widget-hover-border: hsl(43, 100%, 62%);
	--ck-color-widget-editable-focus-background: var(--ck-color-base-background);
	--ck-color-widget-drag-handler-icon-color: var(--ck-color-base-background);
}

.ck .ck-widget {
	outline-width: var(--ck-widget-outline-thickness);
	outline-style: solid;
	outline-color: transparent;
	transition: outline-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);

	@media (prefers-reduced-motion: reduce) {
		transition: none;
	}

	&.ck-widget_selected,
	&.ck-widget_selected:hover {
		outline: var(--ck-widget-outline-thickness) solid var(--ck-color-focus-border);
	}

	&:hover {
		outline-color: var(--ck-color-widget-hover-border);
	}
}

.ck .ck-editor__nested-editable {
	border: 1px solid transparent;

	/* The :focus style is applied before .ck-editor__nested-editable_focused class is rendered in the view.
	These styles show a different border for a blink of an eye, so \`:focus\` need to have same styles applied. */
	&.ck-editor__nested-editable_focused,
	&:focus {
		@mixin ck-focus-ring;
		@mixin ck-box-shadow var(--ck-inner-shadow);
		@mixin ck-media-default-colors {
			background-color: var(--ck-color-widget-editable-focus-background);
		}
	}
}

.ck .ck-widget.ck-widget_with-selection-handle {
	& .ck-widget__selection-handle {
		padding: 4px;
		box-sizing: border-box;

		/* Background and opacity will be animated as the handler shows up or the widget gets selected. */
		background-color: transparent;
		opacity: 0;

		/* Transition:
		   * background-color for the .ck-widget_selected state change,
		   * visibility for hiding the handler,
		   * opacity for the proper look of the icon when the handler disappears. */
		transition:
			background-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),
			visibility var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),
			opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);

		/* Make only top corners round. */
		border-radius: var(--ck-border-radius) var(--ck-border-radius) 0 0;

		/* Place the drag handler outside the widget wrapper. */
		transform: translateY(-100%);
		left: calc(0px - var(--ck-widget-outline-thickness));
		top: 0;

		@media (prefers-reduced-motion: reduce) {
			transition: none;
		}

		& .ck-icon {
			/* Make sure the dimensions of the icon are independent of the fon-size of the content. */
			width: var(--ck-widget-handler-icon-size);
			height: var(--ck-widget-handler-icon-size);
			color: var(--ck-color-widget-drag-handler-icon-color);

			/* The "selected" part of the icon is invisible by default */
			& .ck-icon__selected-indicator {
				opacity: 0;

				/* Note: The animation is longer on purpose. Simply feels better. */
				transition: opacity 300ms var(--ck-widget-handler-animation-curve);

				@media (prefers-reduced-motion: reduce) {
					transition: none;
				}
			}
		}

		/* Advertise using the look of the icon that once clicked the handler, the widget will be selected. */
		&:hover .ck-icon .ck-icon__selected-indicator {
			opacity: 1;
		}
	}

	/* Show the selection handler on mouse hover over the widget, but not for nested widgets. */
	&:hover > .ck-widget__selection-handle {
		opacity: 1;
		background-color: var(--ck-color-widget-hover-border);
	}

	/* Show the selection handler when the widget is selected, but not for nested widgets. */
	&.ck-widget_selected,
	&.ck-widget_selected:hover {
		& > .ck-widget__selection-handle {
			opacity: 1;
			background-color: var(--ck-color-focus-border);

			/* When the widget is selected, notify the user using the proper look of the icon. */
			& .ck-icon .ck-icon__selected-indicator {
				opacity: 1;
			}
		}
	}
}

/* In a RTL environment, align the selection handler to the right side of the widget */
/* stylelint-disable-next-line no-descending-specificity */
.ck[dir="rtl"] .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle {
	left: auto;
	right: calc(0px - var(--ck-widget-outline-thickness));
}

/* https://github.com/ckeditor/ckeditor5/issues/6415 */
.ck.ck-editor__editable.ck-read-only .ck-widget {
	/* Prevent the :hover outline from showing up because of the used outline-color transition. */
	transition: none;

	&:not(.ck-widget_selected) {
		/* Disable visual effects of hover/active widget when CKEditor is in readOnly mode.
		 * See: https://github.com/ckeditor/ckeditor5/issues/1261
		 *
		 * Leave the unit because this custom property is used in calc() by other features.
		 * See: https://github.com/ckeditor/ckeditor5/issues/6775
		 */
		--ck-widget-outline-thickness: 0px;
	}

	&.ck-widget_with-selection-handle {
		& .ck-widget__selection-handle,
		& .ck-widget__selection-handle:hover {
			background: var(--ck-color-widget-blurred-border);
		}
	}
}

/* Style the widget when it's selected but the editable it belongs to lost focus. */
/* stylelint-disable-next-line no-descending-specificity */
.ck.ck-editor__editable.ck-blurred .ck-widget {
	&.ck-widget_selected,
	&.ck-widget_selected:hover {
		outline-color: var(--ck-color-widget-blurred-border);

		&.ck-widget_with-selection-handle {
			& > .ck-widget__selection-handle,
			& > .ck-widget__selection-handle:hover {
				background: var(--ck-color-widget-blurred-border);
			}
		}
	}
}

.ck.ck-editor__editable > .ck-widget.ck-widget_with-selection-handle:first-child,
.ck.ck-editor__editable blockquote > .ck-widget.ck-widget_with-selection-handle:first-child {
	/* Do not crop selection handler if a widget is a first-child in the blockquote or in the root editable.
	In fact, anything with overflow: hidden.
	https://github.com/ckeditor/ckeditor5-block-quote/issues/28
	https://github.com/ckeditor/ckeditor5-widget/issues/44
	https://github.com/ckeditor/ckeditor5-widget/issues/66 */
	margin-top: calc(1em + var(--ck-widget-handler-icon-size));
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A visual style of focused element's border.
 */
@define-mixin ck-focus-ring {
	/* Disable native outline. */
	outline: none;
	border: var(--ck-focus-ring)
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * A helper to combine multiple shadows.
 */
@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {
	box-shadow: $shadowA, $shadowB;
}

/**
 * Gives an element a drop shadow so it looks like a floating panel.
 */
@define-mixin ck-drop-shadow {
	@mixin ck-box-shadow var(--ck-drop-shadow);
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@define-mixin ck-media-forced-colors {
	@media (forced-colors: active) {
		& {
			@mixin-content;
		}
	}
}

@define-mixin ck-media-default-colors {
	@media (forced-colors: none) {
		& {
			@mixin-content;
		}
	}
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            4095: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, ".ck .ck-widget_with-resizer{position:relative}.ck .ck-widget__resizer{display:none;left:0;pointer-events:none;position:absolute;top:0}.ck-focused .ck-widget_with-resizer.ck-widget_selected>.ck-widget__resizer{display:block}.ck .ck-widget__resizer__handle{pointer-events:all;position:absolute}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-right,.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-left{cursor:nwse-resize}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-left,.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-right{cursor:nesw-resize}:root{--ck-resizer-size:10px;--ck-resizer-offset:calc(var(--ck-resizer-size)/-2 - 2px);--ck-resizer-border-width:1px}.ck .ck-widget__resizer{outline:1px solid var(--ck-color-resizer)}.ck .ck-widget__resizer__handle{background:var(--ck-color-focus-border);border:var(--ck-resizer-border-width) solid #fff;border-radius:var(--ck-resizer-border-radius);height:var(--ck-resizer-size);width:var(--ck-resizer-size)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-left{left:var(--ck-resizer-offset);top:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-right{right:var(--ck-resizer-offset);top:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-right{bottom:var(--ck-resizer-offset);right:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-left{bottom:var(--ck-resizer-offset);left:var(--ck-resizer-offset)}", "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-widget/theme/widgetresize.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-widget/widgetresize.css"],
                    names: [],
                    mappings: "AAKA,4BAEC,iBACD,CAEA,wBACC,YAAa,CAMb,MAAO,CAFP,mBAAoB,CAHpB,iBAAkB,CAMlB,KACD,CAGC,2EACC,aACD,CAGD,gCAIC,kBAAmB,CAHnB,iBAcD,CATC,4IAEC,kBACD,CAEA,4IAEC,kBACD,CCpCD,MACC,sBAAuB,CAGvB,yDAAiE,CACjE,6BACD,CAEA,wBACC,yCACD,CAEA,gCAGC,uCAAwC,CACxC,gDAA6D,CAC7D,6CAA8C,CAH9C,6BAA8B,CAD9B,4BAyBD,CAnBC,oEAEC,6BAA8B,CAD9B,4BAED,CAEA,qEAEC,8BAA+B,CAD/B,4BAED,CAEA,wEACC,+BAAgC,CAChC,8BACD,CAEA,uEACC,+BAAgC,CAChC,6BACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck .ck-widget_with-resizer {
	/* Make the widget wrapper a relative positioning container for the drag handle. */
	position: relative;
}

.ck .ck-widget__resizer {
	display: none;
	position: absolute;

	/* The wrapper itself should not interfere with the pointer device, only the handles should. */
	pointer-events: none;

	left: 0;
	top: 0;
}

.ck-focused .ck-widget_with-resizer.ck-widget_selected {
	& > .ck-widget__resizer {
		display: block;
	}
}

.ck .ck-widget__resizer__handle {
	position: absolute;

	/* Resizers are the only UI elements that should interfere with a pointer device. */
	pointer-events: all;

	&.ck-widget__resizer__handle-top-left,
	&.ck-widget__resizer__handle-bottom-right {
		cursor: nwse-resize;
	}

	&.ck-widget__resizer__handle-top-right,
	&.ck-widget__resizer__handle-bottom-left {
		cursor: nesw-resize;
	}
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-resizer-size: 10px;

	/* Set the resizer with a 50% offset. */
	--ck-resizer-offset: calc( ( var(--ck-resizer-size) / -2 ) - 2px);
	--ck-resizer-border-width: 1px;
}

.ck .ck-widget__resizer {
	outline: 1px solid var(--ck-color-resizer);
}

.ck .ck-widget__resizer__handle {
	width: var(--ck-resizer-size);
	height: var(--ck-resizer-size);
	background: var(--ck-color-focus-border);
	border: var(--ck-resizer-border-width) solid hsl(0, 0%, 100%);
	border-radius: var(--ck-resizer-border-radius);

	&.ck-widget__resizer__handle-top-left {
		top: var(--ck-resizer-offset);
		left: var(--ck-resizer-offset);
	}

	&.ck-widget__resizer__handle-top-right {
		top: var(--ck-resizer-offset);
		right: var(--ck-resizer-offset);
	}

	&.ck-widget__resizer__handle-bottom-right {
		bottom: var(--ck-resizer-offset);
		right: var(--ck-resizer-offset);
	}

	&.ck-widget__resizer__handle-bottom-left {
		bottom: var(--ck-resizer-offset);
		left: var(--ck-resizer-offset);
	}
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            8508: (f, w, k) => {
                k.d(w, {
                    A: () => D
                });
                var y = k(9372)
                  , E = k.n(y)
                  , S = k(935)
                  , A = k.n(S)()(E());
                A.push([f.id, '.ck .ck-widget .ck-widget__type-around__button{display:block;overflow:hidden;position:absolute;z-index:var(--ck-z-default)}.ck .ck-widget .ck-widget__type-around__button svg{left:50%;position:absolute;top:50%;z-index:calc(var(--ck-z-default) + 2)}.ck .ck-widget .ck-widget__type-around__button.ck-widget__type-around__button_before{left:min(10%,30px);top:calc(var(--ck-widget-outline-thickness)*-.5);transform:translateY(-50%)}.ck .ck-widget .ck-widget__type-around__button.ck-widget__type-around__button_after{bottom:calc(var(--ck-widget-outline-thickness)*-.5);right:min(10%,30px);transform:translateY(50%)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:after,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover:after{content:"";display:block;left:1px;position:absolute;top:1px;z-index:calc(var(--ck-z-default) + 1)}.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__fake-caret{display:none;left:0;position:absolute;right:0}.ck .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__fake-caret{left:calc(var(--ck-widget-outline-thickness)*-1);right:calc(var(--ck-widget-outline-thickness)*-1)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_before>.ck-widget__type-around>.ck-widget__type-around__fake-caret{display:block;top:calc(var(--ck-widget-outline-thickness)*-1 - 1px)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after>.ck-widget__type-around>.ck-widget__type-around__fake-caret{bottom:calc(var(--ck-widget-outline-thickness)*-1 - 1px);display:block}.ck.ck-editor__editable.ck-read-only .ck-widget__type-around,.ck.ck-editor__editable.ck-restricted-editing_mode_restricted .ck-widget__type-around,.ck.ck-editor__editable.ck-widget__type-around_disabled .ck-widget__type-around{display:none}:root{--ck-widget-type-around-button-size:20px;--ck-color-widget-type-around-button-active:var(--ck-color-focus-border);--ck-color-widget-type-around-button-hover:var(--ck-color-widget-hover-border);--ck-color-widget-type-around-button-blurred-editable:var(--ck-color-widget-blurred-border);--ck-color-widget-type-around-button-radar-start-alpha:0;--ck-color-widget-type-around-button-radar-end-alpha:.3;--ck-color-widget-type-around-button-icon:var(--ck-color-base-background)}.ck .ck-widget .ck-widget__type-around__button{background:var(--ck-color-widget-type-around-button);border-radius:100px;height:var(--ck-widget-type-around-button-size);opacity:0;pointer-events:none;transition:opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);width:var(--ck-widget-type-around-button-size)}@media (prefers-reduced-motion:reduce){.ck .ck-widget .ck-widget__type-around__button{transition:none}}.ck .ck-widget .ck-widget__type-around__button svg{height:8px;margin-top:1px;transform:translate(-50%,-50%);transition:transform .5s ease;width:10px}@media (prefers-reduced-motion:reduce){.ck .ck-widget .ck-widget__type-around__button svg{transition:none}}.ck .ck-widget .ck-widget__type-around__button svg *{stroke-dasharray:10;stroke-dashoffset:0;fill:none;stroke:var(--ck-color-widget-type-around-button-icon);stroke-width:1.5px;stroke-linecap:round;stroke-linejoin:round}.ck .ck-widget .ck-widget__type-around__button svg line{stroke-dasharray:7}.ck .ck-widget .ck-widget__type-around__button:hover{animation:ck-widget-type-around-button-sonar 1s ease infinite}.ck .ck-widget .ck-widget__type-around__button:hover svg polyline{animation:ck-widget-type-around-arrow-dash 2s linear}.ck .ck-widget .ck-widget__type-around__button:hover svg line{animation:ck-widget-type-around-arrow-tip-dash 2s linear}@media (prefers-reduced-motion:reduce){.ck .ck-widget .ck-widget__type-around__button:hover,.ck .ck-widget .ck-widget__type-around__button:hover svg line,.ck .ck-widget .ck-widget__type-around__button:hover svg polyline{animation:none}}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__button{opacity:1;pointer-events:auto}.ck .ck-widget:not(.ck-widget_selected)>.ck-widget__type-around>.ck-widget__type-around__button{background:var(--ck-color-widget-type-around-button-hover)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover{background:var(--ck-color-widget-type-around-button-active)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:after,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover:after{background:linear-gradient(135deg,hsla(0,0%,100%,0),hsla(0,0%,100%,.3));border-radius:100px;height:calc(var(--ck-widget-type-around-button-size) - 2px);width:calc(var(--ck-widget-type-around-button-size) - 2px)}.ck .ck-widget.ck-widget_with-selection-handle>.ck-widget__type-around>.ck-widget__type-around__button_before{margin-left:20px}.ck .ck-widget .ck-widget__type-around__fake-caret{animation:ck-widget-type-around-fake-caret-pulse 1s linear infinite normal forwards;background:var(--ck-color-base-text);height:1px;outline:1px solid hsla(0,0%,100%,.5);pointer-events:none}.ck .ck-widget.ck-widget_selected.ck-widget_type-around_show-fake-caret_after,.ck .ck-widget.ck-widget_selected.ck-widget_type-around_show-fake-caret_before{outline-color:transparent}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_selected:hover,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_selected:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before>.ck-widget__type-around>.ck-widget__type-around__button{opacity:0;pointer-events:none}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_selected.ck-widget_with-resizer>.ck-widget__resizer,.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_selected.ck-widget_with-resizer>.ck-widget__resizer,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle{opacity:0}.ck[dir=rtl] .ck-widget.ck-widget_with-selection-handle .ck-widget__type-around>.ck-widget__type-around__button_before{margin-left:0;margin-right:20px}.ck-editor__nested-editable.ck-editor__editable_selected .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck-editor__nested-editable.ck-editor__editable_selected .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__button{opacity:0;pointer-events:none}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:not(:hover){background:var(--ck-color-widget-type-around-button-blurred-editable)}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:not(:hover) svg *{stroke:#999}@keyframes ck-widget-type-around-arrow-dash{0%{stroke-dashoffset:10}20%,to{stroke-dashoffset:0}}@keyframes ck-widget-type-around-arrow-tip-dash{0%,20%{stroke-dashoffset:7}40%,to{stroke-dashoffset:0}}@keyframes ck-widget-type-around-button-sonar{0%{box-shadow:0 0 0 0 hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-start-alpha))}50%{box-shadow:0 0 0 5px hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-end-alpha))}to{box-shadow:0 0 0 5px hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-start-alpha))}}@keyframes ck-widget-type-around-fake-caret-pulse{0%{opacity:1}49%{opacity:1}50%{opacity:0}99%{opacity:0}to{opacity:1}}', "", {
                    version: 3,
                    sources: ["webpack://./../ckeditor5-widget/theme/widgettypearound.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-widget/widgettypearound.css"],
                    names: [],
                    mappings: "AASC,+CACC,aAAc,CAEd,eAAgB,CADhB,iBAAkB,CAElB,2BAwBD,CAtBC,mDAGC,QAAS,CAFT,iBAAkB,CAClB,OAAQ,CAER,qCACD,CAEA,qFAGC,kBAAoB,CADpB,gDAAoD,CAGpD,0BACD,CAEA,oFAEC,mDAAuD,CACvD,mBAAqB,CAErB,yBACD,CAUA,mLACC,UAAW,CACX,aAAc,CAGd,QAAS,CAFT,iBAAkB,CAClB,OAAQ,CAER,qCACD,CAMD,2EACC,YAAa,CAEb,MAAO,CADP,iBAAkB,CAElB,OACD,CAOA,iFACC,gDAAqD,CACrD,iDACD,CAKA,wHAEC,aAAc,CADd,qDAED,CAKA,uHACC,wDAA6D,CAC7D,aACD,CAoBD,mOACC,YACD,CC3GA,MACC,wCAAyC,CACzC,wEAAyE,CACzE,8EAA+E,CAC/E,2FAA4F,CAC5F,wDAAyD,CACzD,uDAAwD,CACxD,yEACD,CAgBC,+CAGC,oDAAqD,CACrD,mBAAoB,CAFpB,+CAAgD,CAVjD,SAAU,CACV,mBAAoB,CAYnB,uMAAyM,CAJzM,8CAwED,CAhEC,uCATD,+CAUE,eA+DF,CA9DC,CAEA,mDAEC,UAAW,CAGX,cAAe,CAFf,8BAA+B,CAC/B,6BAA8B,CAH9B,UAwBD,CAlBC,uCAPD,mDAQE,eAiBF,CAhBC,CAEA,qDACC,mBAAoB,CACpB,mBAAoB,CAEpB,SAAU,CACV,qDAAsD,CACtD,kBAAmB,CACnB,oBAAqB,CACrB,qBACD,CAEA,wDACC,kBACD,CAGD,qDAIC,6DA4BD,CAtBE,kEACC,oDACD,CAEA,8DACC,wDACD,CAGD,uCAQE,qLACC,cACD,CAEF,CASD,uKA7FD,SAAU,CACV,mBA8FC,CAOD,gGACC,0DACD,CAOA,uKAEC,2DAQD,CANC,mLAIC,uEAAkF,CADlF,mBAAoB,CADpB,2DAA4D,CAD5D,0DAID,CAOD,8GACC,gBACD,CAKA,mDAGC,mFAAoF,CAOpF,oCAAqC,CARrC,UAAW,CAOX,oCAAwC,CARxC,mBAUD,CAOC,6JAEC,yBACD,CAUA,yKACC,iDACD,CAMA,uOAxKD,SAAU,CACV,mBAyKC,CAoBA,6yBACC,SACD,CASF,uHACC,aAAc,CACd,iBACD,CAYG,iRAxNF,SAAU,CACV,mBAyNE,CAQH,kIACC,qEAKD,CAHC,wIACC,WACD,CAGD,4CACC,GACC,oBACD,CACA,OACC,mBACD,CACD,CAEA,gDACC,OACC,mBACD,CACA,OACC,mBACD,CACD,CAEA,8CACC,GACC,6HACD,CACA,IACC,6HACD,CACA,GACC,+HACD,CACD,CAEA,kDACC,GACC,SACD,CACA,IACC,SACD,CACA,IACC,SACD,CACA,IACC,SACD,CACA,GACC,SACD,CACD",
                    sourcesContent: [`/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck .ck-widget {
	/*
	 * Styles of the type around buttons
	 */
	& .ck-widget__type-around__button {
		display: block;
		position: absolute;
		overflow: hidden;
		z-index: var(--ck-z-default);

		& svg {
			position: absolute;
			top: 50%;
			left: 50%;
			z-index: calc(var(--ck-z-default) + 2);
		}

		&.ck-widget__type-around__button_before {
			/* Place it in the middle of the outline */
			top: calc(-0.5 * var(--ck-widget-outline-thickness));
			left: min(10%, 30px);

			transform: translateY(-50%);
		}

		&.ck-widget__type-around__button_after {
			/* Place it in the middle of the outline */
			bottom: calc(-0.5 * var(--ck-widget-outline-thickness));
			right: min(10%, 30px);

			transform: translateY(50%);
		}
	}

	/*
	 * Styles for the buttons when:
	 * - the widget is selected,
	 * - or the button is being hovered (regardless of the widget state).
	 */
	&.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button,
	& > .ck-widget__type-around > .ck-widget__type-around__button:hover {
		&::after {
			content: "";
			display: block;
			position: absolute;
			top: 1px;
			left: 1px;
			z-index: calc(var(--ck-z-default) + 1);
		}
	}

	/*
	 * Styles for the horizontal "fake caret" which is displayed when the user navigates using the keyboard.
	 */
	& > .ck-widget__type-around > .ck-widget__type-around__fake-caret {
		display: none;
		position: absolute;
		left: 0;
		right: 0;
	}

	/*
	 * When the widget is hovered the "fake caret" would normally be narrower than the
	 * extra outline displayed around the widget. Let's extend the "fake caret" to match
	 * the full width of the widget.
	 */
	&:hover > .ck-widget__type-around > .ck-widget__type-around__fake-caret {
		left: calc( -1 * var(--ck-widget-outline-thickness) );
		right: calc( -1 * var(--ck-widget-outline-thickness) );
	}

	/*
	 * Styles for the horizontal "fake caret" when it should be displayed before the widget (backward keyboard navigation).
	 */
	&.ck-widget_type-around_show-fake-caret_before > .ck-widget__type-around > .ck-widget__type-around__fake-caret {
		top: calc( -1 * var(--ck-widget-outline-thickness) - 1px );
		display: block;
	}

	/*
	 * Styles for the horizontal "fake caret" when it should be displayed after the widget (forward keyboard navigation).
	 */
	&.ck-widget_type-around_show-fake-caret_after > .ck-widget__type-around > .ck-widget__type-around__fake-caret {
		bottom: calc( -1 * var(--ck-widget-outline-thickness) - 1px );
		display: block;
	}
}

/*
 * Integration with the read-only mode of the editor.
 */
.ck.ck-editor__editable.ck-read-only .ck-widget__type-around {
	display: none;
}

/*
 * Integration with the restricted editing mode (feature) of the editor.
 */
.ck.ck-editor__editable.ck-restricted-editing_mode_restricted .ck-widget__type-around {
	display: none;
}

/*
 * Integration with the #isEnabled property of the WidgetTypeAround plugin.
 */
.ck.ck-editor__editable.ck-widget__type-around_disabled .ck-widget__type-around {
	display: none;
}
`, `/*
 * Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-widget-type-around-button-size: 20px;
	--ck-color-widget-type-around-button-active: var(--ck-color-focus-border);
	--ck-color-widget-type-around-button-hover: var(--ck-color-widget-hover-border);
	--ck-color-widget-type-around-button-blurred-editable: var(--ck-color-widget-blurred-border);
	--ck-color-widget-type-around-button-radar-start-alpha: 0;
	--ck-color-widget-type-around-button-radar-end-alpha: .3;
	--ck-color-widget-type-around-button-icon: var(--ck-color-base-background);
}

@define-mixin ck-widget-type-around-button-visible {
	opacity: 1;
	pointer-events: auto;
}

@define-mixin ck-widget-type-around-button-hidden {
	opacity: 0;
	pointer-events: none;
}

.ck .ck-widget {
	/*
	 * Styles of the type around buttons
	 */
	& .ck-widget__type-around__button {
		width: var(--ck-widget-type-around-button-size);
		height: var(--ck-widget-type-around-button-size);
		background: var(--ck-color-widget-type-around-button);
		border-radius: 100px;
		transition: opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve), background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);

		@mixin ck-widget-type-around-button-hidden;

		@media (prefers-reduced-motion: reduce) {
			transition: none;
		}

		& svg {
			width: 10px;
			height: 8px;
			transform: translate(-50%,-50%);
			transition: transform .5s ease;
			margin-top: 1px;

			@media (prefers-reduced-motion: reduce) {
				transition: none;
			}

			& * {
				stroke-dasharray: 10;
				stroke-dashoffset: 0;

				fill: none;
				stroke: var(--ck-color-widget-type-around-button-icon);
				stroke-width: 1.5px;
				stroke-linecap: round;
				stroke-linejoin: round;
			}

			& line {
				stroke-dasharray: 7;
			}
		}

		&:hover {
			/*
			 * Display the "sonar" around the button when hovered.
			 */
			animation: ck-widget-type-around-button-sonar 1s ease infinite;

			/*
			 * Animate active button's icon.
			 */
			& svg {
				& polyline {
					animation: ck-widget-type-around-arrow-dash 2s linear;
				}

				& line {
					animation: ck-widget-type-around-arrow-tip-dash 2s linear;
				}
			}

			@media (prefers-reduced-motion: reduce) {
				animation: none;

				& svg {
					& polyline {
						animation: none;
					}

					& line {
						animation: none;
					}
				}
			}
		}
	}

	/*
	 * Show type around buttons when the widget gets selected or being hovered.
	 */
	&.ck-widget_selected,
	&:hover {
		& > .ck-widget__type-around > .ck-widget__type-around__button {
			@mixin ck-widget-type-around-button-visible;
		}
	}

	/*
	 * Styles for the buttons when the widget is NOT selected (but the buttons are visible
	 * and still can be hovered).
	 */
	&:not(.ck-widget_selected) > .ck-widget__type-around > .ck-widget__type-around__button {
		background: var(--ck-color-widget-type-around-button-hover);
	}

	/*
	 * Styles for the buttons when:
	 * - the widget is selected,
	 * - or the button is being hovered (regardless of the widget state).
	 */
	&.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button,
	& > .ck-widget__type-around > .ck-widget__type-around__button:hover {
		background: var(--ck-color-widget-type-around-button-active);

		&::after {
			width: calc(var(--ck-widget-type-around-button-size) - 2px);
			height: calc(var(--ck-widget-type-around-button-size) - 2px);
			border-radius: 100px;
			background: linear-gradient(135deg, hsla(0,0%,100%,0) 0%, hsla(0,0%,100%,.3) 100%);
		}
	}

	/*
	 * Styles for the "before" button when the widget has a selection handle. Because some space
	 * is consumed by the handle, the button must be moved slightly to the right to let it breathe.
	 */
	&.ck-widget_with-selection-handle > .ck-widget__type-around > .ck-widget__type-around__button_before {
		margin-left: 20px;
	}

	/*
	 * Styles for the horizontal "fake caret" which is displayed when the user navigates using the keyboard.
	 */
	& .ck-widget__type-around__fake-caret {
		pointer-events: none;
		height: 1px;
		animation: ck-widget-type-around-fake-caret-pulse linear 1s infinite normal forwards;

		/*
		 * The semi-transparent-outline+background combo improves the contrast
		 * when the background underneath the fake caret is dark.
		 */
		outline: solid 1px hsla(0, 0%, 100%, .5);
		background: var(--ck-color-base-text);
	}

	/*
	 * Styles of the widget when the "fake caret" is blinking (e.g. upon keyboard navigation).
	 * Despite the widget being physically selected in the model, its outline should disappear.
	 */
	&.ck-widget_selected {
		&.ck-widget_type-around_show-fake-caret_before,
		&.ck-widget_type-around_show-fake-caret_after {
			outline-color: transparent;
		}
	}

	&.ck-widget_type-around_show-fake-caret_before,
	&.ck-widget_type-around_show-fake-caret_after {
		/*
		 * When the "fake caret" is visible we simulate that the widget is not selected
		 * (despite being physically selected), so the outline color should be for the
		 * unselected widget.
		 */
		&.ck-widget_selected:hover {
			outline-color: var(--ck-color-widget-hover-border);
		}

		/*
		 * Styles of the type around buttons when the "fake caret" is blinking (e.g. upon keyboard navigation).
		 * In this state, the type around buttons would collide with the fake carets so they should disappear.
		 */
		& > .ck-widget__type-around > .ck-widget__type-around__button {
			@mixin ck-widget-type-around-button-hidden;
		}

		/*
		 * Fake horizontal caret integration with the selection handle. When the caret is visible, simply
		 * hide the handle because it intersects with the caret (and does not make much sense anyway).
		 */
		&.ck-widget_with-selection-handle {
			&.ck-widget_selected,
			&.ck-widget_selected:hover {
				& > .ck-widget__selection-handle {
					opacity: 0
				}
			}
		}

		/*
		 * Fake horizontal caret integration with the resize UI. When the caret is visible, simply
		 * hide the resize UI because it creates too much noise. It can be visible when the user
		 * hovers the widget, though.
		 */
		&.ck-widget_selected.ck-widget_with-resizer > .ck-widget__resizer {
			opacity: 0
		}
	}
}

/*
 * Styles for the "before" button when the widget has a selection handle in an RTL environment.
 * The selection handler is aligned to the right side of the widget so there is no need to create
 * additional space for it next to the "before" button.
 */
.ck[dir="rtl"] .ck-widget.ck-widget_with-selection-handle .ck-widget__type-around > .ck-widget__type-around__button_before {
	margin-left: 0;
	margin-right: 20px;
}

/*
 * Hide type around buttons when the widget is selected as a child of a selected
 * nested editable (e.g. mulit-cell table selection).
 *
 * See https://github.com/ckeditor/ckeditor5/issues/7263.
 */
.ck-editor__nested-editable.ck-editor__editable_selected {
	& .ck-widget {
		&.ck-widget_selected,
		&:hover {
			& > .ck-widget__type-around > .ck-widget__type-around__button {
				@mixin ck-widget-type-around-button-hidden;
			}
		}
	}
}

/*
 * Styles for the buttons when the widget is selected but the user clicked outside of the editor (blurred the editor).
 */
.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button:not(:hover) {
	background: var(--ck-color-widget-type-around-button-blurred-editable);

	& svg * {
		stroke: hsl(0,0%,60%);
	}
}

@keyframes ck-widget-type-around-arrow-dash {
	0% {
		stroke-dashoffset: 10;
	}
	20%, 100% {
		stroke-dashoffset: 0;
	}
}

@keyframes ck-widget-type-around-arrow-tip-dash {
	0%, 20% {
		stroke-dashoffset: 7;
	}
	40%, 100% {
		stroke-dashoffset: 0;
	}
}

@keyframes ck-widget-type-around-button-sonar {
	0% {
		box-shadow: 0 0 0 0 hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-start-alpha));
	}
	50% {
		box-shadow: 0 0 0 5px hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-end-alpha));
	}
	100% {
		box-shadow: 0 0 0 5px hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-start-alpha));
	}
}

@keyframes ck-widget-type-around-fake-caret-pulse {
	0% {
		opacity: 1;
	}
	49% {
		opacity: 1;
	}
	50% {
		opacity: 0;
	}
	99% {
		opacity: 0;
	}
	100% {
		opacity: 1;
	}
}
`],
                    sourceRoot: ""
                }]);
                const D = A
            }
            ,
            935: f => {
                f.exports = function(w) {
                    var k = [];
                    return k.toString = function() {
                        return this.map(function(y) {
                            var E = w(y);
                            return y[2] ? "@media ".concat(y[2], " {").concat(E, "}") : E
                        }).join("")
                    }
                    ,
                    k.i = function(y, E, S) {
                        typeof y == "string" && (y = [[null, y, ""]]);
                        var A = {};
                        if (S)
                            for (var D = 0; D < this.length; D++) {
                                var N = this[D][0];
                                N != null && (A[N] = !0)
                            }
                        for (var L = 0; L < y.length; L++) {
                            var z = [].concat(y[L]);
                            S && A[z[0]] || (E && (z[2] ? z[2] = "".concat(E, " and ").concat(z[2]) : z[2] = E),
                            k.push(z))
                        }
                    }
                    ,
                    k
                }
            }
            ,
            9372: f => {
                function w(y, E) {
                    return function(S) {
                        if (Array.isArray(S))
                            return S
                    }(y) || function(S, A) {
                        var D = S && (typeof Symbol < "u" && S[Symbol.iterator] || S["@@iterator"]);
                        if (D != null) {
                            var N, L, z = [], B = !0, M = !1;
                            try {
                                for (D = D.call(S); !(B = (N = D.next()).done) && (z.push(N.value),
                                !A || z.length !== A); B = !0)
                                    ;
                            } catch (j) {
                                M = !0,
                                L = j
                            } finally {
                                try {
                                    B || D.return == null || D.return()
                                } finally {
                                    if (M)
                                        throw L
                                }
                            }
                            return z
                        }
                    }(y, E) || function(S, A) {
                        if (S) {
                            if (typeof S == "string")
                                return k(S, A);
                            var D = Object.prototype.toString.call(S).slice(8, -1);
                            if (D === "Object" && S.constructor && (D = S.constructor.name),
                            D === "Map" || D === "Set")
                                return Array.from(S);
                            if (D === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(D))
                                return k(S, A)
                        }
                    }(y, E) || function() {
                        throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
                    }()
                }
                function k(y, E) {
                    (E == null || E > y.length) && (E = y.length);
                    for (var S = 0, A = new Array(E); S < E; S++)
                        A[S] = y[S];
                    return A
                }
                f.exports = function(y) {
                    var E = w(y, 4)
                      , S = E[1]
                      , A = E[3];
                    if (!A)
                        return S;
                    if (typeof btoa == "function") {
                        var D = btoa(unescape(encodeURIComponent(JSON.stringify(A))))
                          , N = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(D)
                          , L = "/*# ".concat(N, " */")
                          , z = A.sources.map(function(B) {
                            return "/*# sourceURL=".concat(A.sourceRoot || "").concat(B, " */")
                        });
                        return [S].concat(z).concat([L]).join(`
`)
                    }
                    return [S].join(`
`)
                }
            }
            ,
            2591: (f, w, k) => {
                var y, E = function() {
                    return y === void 0 && (y = !!(window && document && document.all && !window.atob)),
                    y
                }, S = function() {
                    var $ = {};
                    return function(K) {
                        if ($[K] === void 0) {
                            var Z = document.querySelector(K);
                            if (window.HTMLIFrameElement && Z instanceof window.HTMLIFrameElement)
                                try {
                                    Z = Z.contentDocument.head
                                } catch {
                                    Z = null
                                }
                            $[K] = Z
                        }
                        return $[K]
                    }
                }(), A = [];
                function D($) {
                    for (var K = -1, Z = 0; Z < A.length; Z++)
                        if (A[Z].identifier === $) {
                            K = Z;
                            break
                        }
                    return K
                }
                function N($, K) {
                    for (var Z = {}, H = [], W = 0; W < $.length; W++) {
                        var ee = $[W]
                          , re = K.base ? ee[0] + K.base : ee[0]
                          , U = Z[re] || 0
                          , de = "".concat(re, " ").concat(U);
                        Z[re] = U + 1;
                        var te = D(de)
                          , ue = {
                            css: ee[1],
                            media: ee[2],
                            sourceMap: ee[3]
                        };
                        te !== -1 ? (A[te].references++,
                        A[te].updater(ue)) : A.push({
                            identifier: de,
                            updater: Y(ue, K),
                            references: 1
                        }),
                        H.push(de)
                    }
                    return H
                }
                function L($) {
                    var K = document.createElement("style")
                      , Z = $.attributes || {};
                    if (Z.nonce === void 0) {
                        var H = k.nc;
                        H && (Z.nonce = H)
                    }
                    if (Object.keys(Z).forEach(function(ee) {
                        K.setAttribute(ee, Z[ee])
                    }),
                    typeof $.insert == "function")
                        $.insert(K);
                    else {
                        var W = S($.insert || "head");
                        if (!W)
                            throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
                        W.appendChild(K)
                    }
                    return K
                }
                var z, B = (z = [],
                function($, K) {
                    return z[$] = K,
                    z.filter(Boolean).join(`
`)
                }
                );
                function M($, K, Z, H) {
                    var W = Z ? "" : H.media ? "@media ".concat(H.media, " {").concat(H.css, "}") : H.css;
                    if ($.styleSheet)
                        $.styleSheet.cssText = B(K, W);
                    else {
                        var ee = document.createTextNode(W)
                          , re = $.childNodes;
                        re[K] && $.removeChild(re[K]),
                        re.length ? $.insertBefore(ee, re[K]) : $.appendChild(ee)
                    }
                }
                function j($, K, Z) {
                    var H = Z.css
                      , W = Z.media
                      , ee = Z.sourceMap;
                    if (W ? $.setAttribute("media", W) : $.removeAttribute("media"),
                    ee && typeof btoa < "u" && (H += `
/*# sourceMappingURL=data:application/json;base64,`.concat(btoa(unescape(encodeURIComponent(JSON.stringify(ee)))), " */")),
                    $.styleSheet)
                        $.styleSheet.cssText = H;
                    else {
                        for (; $.firstChild; )
                            $.removeChild($.firstChild);
                        $.appendChild(document.createTextNode(H))
                    }
                }
                var V = null
                  , G = 0;
                function Y($, K) {
                    var Z, H, W;
                    if (K.singleton) {
                        var ee = G++;
                        Z = V || (V = L(K)),
                        H = M.bind(null, Z, ee, !1),
                        W = M.bind(null, Z, ee, !0)
                    } else
                        Z = L(K),
                        H = j.bind(null, Z, K),
                        W = function() {
                            (function(re) {
                                if (re.parentNode === null)
                                    return !1;
                                re.parentNode.removeChild(re)
                            }
                            )(Z)
                        }
                        ;
                    return H($),
                    function(re) {
                        if (re) {
                            if (re.css === $.css && re.media === $.media && re.sourceMap === $.sourceMap)
                                return;
                            H($ = re)
                        } else
                            W()
                    }
                }
                f.exports = function($, K) {
                    (K = K || {}).singleton || typeof K.singleton == "boolean" || (K.singleton = E());
                    var Z = N($ = $ || [], K);
                    return function(H) {
                        if (H = H || [],
                        Object.prototype.toString.call(H) === "[object Array]") {
                            for (var W = 0; W < Z.length; W++) {
                                var ee = D(Z[W]);
                                A[ee].references--
                            }
                            for (var re = N(H, K), U = 0; U < Z.length; U++) {
                                var de = D(Z[U]);
                                A[de].references === 0 && (A[de].updater(),
                                A.splice(de, 1))
                            }
                            Z = re
                        }
                    }
                }
            }
        }
          , c = {};
        function u(f) {
            var w = c[f];
            if (w !== void 0)
                return w.exports;
            var k = c[f] = {
                id: f,
                exports: {}
            };
            return a[f](k, k.exports, u),
            k.exports
        }
        u.n = f => {
            var w = f && f.__esModule ? () => f.default : () => f;
            return u.d(w, {
                a: w
            }),
            w
        }
        ,
        u.d = (f, w) => {
            for (var k in w)
                u.o(w, k) && !u.o(f, k) && Object.defineProperty(f, k, {
                    enumerable: !0,
                    get: w[k]
                })
        }
        ,
        u.o = (f, w) => Object.prototype.hasOwnProperty.call(f, w),
        u.nc = void 0;
        var p = {};
        return ( () => {
            let f;
            u.d(p, {
                default: () => Ng
            });
            try {
                f = {
                    window,
                    document
                }
            } catch {
                f = {
                    window: {},
                    document: {}
                }
            }
            const w = f;
            function k() {
                try {
                    return navigator.userAgent.toLowerCase()
                } catch {
                    return ""
                }
            }
            const y = k()
              , E = {
                isMac: S(y),
                isWindows: A(y),
                isGecko: D(y),
                isSafari: N(y),
                isiOS: L(y),
                isAndroid: z(y),
                isBlink: B(y),
                features: {
                    isRegExpUnicodePropertySupported: M()
                }
            };
            function S(s) {
                return s.indexOf("macintosh") > -1
            }
            function A(s) {
                return s.indexOf("windows") > -1
            }
            function D(s) {
                return !!s.match(/gecko\/\d+/)
            }
            function N(s) {
                return s.indexOf(" applewebkit/") > -1 && s.indexOf("chrome") === -1
            }
            function L(s) {
                return !!s.match(/iphone|ipad/i) || S(s) && navigator.maxTouchPoints > 0
            }
            function z(s) {
                return s.indexOf("android") > -1
            }
            function B(s) {
                return s.indexOf("chrome/") > -1 && s.indexOf("edge/") < 0
            }
            function M() {
                let s = !1;
                try {
                    s = "ć".search(new RegExp("[\\p{L}]","u")) === 0
                } catch {}
                return s
            }
            function j(s, e, t, r) {
                t = t || function(h, m) {
                    return h === m
                }
                ;
                const i = Array.isArray(s) ? s : Array.prototype.slice.call(s)
                  , l = Array.isArray(e) ? e : Array.prototype.slice.call(e)
                  , d = function(h, m, g) {
                    const b = V(h, m, g);
                    if (b === -1)
                        return {
                            firstIndex: -1,
                            lastIndexOld: -1,
                            lastIndexNew: -1
                        };
                    const v = G(h, b)
                      , x = G(m, b)
                      , T = V(v, x, g)
                      , I = h.length - T
                      , P = m.length - T;
                    return {
                        firstIndex: b,
                        lastIndexOld: I,
                        lastIndexNew: P
                    }
                }(i, l, t);
                return r ? function(h, m) {
                    const {firstIndex: g, lastIndexOld: b, lastIndexNew: v} = h;
                    if (g === -1)
                        return Array(m).fill("equal");
                    let x = [];
                    return g > 0 && (x = x.concat(Array(g).fill("equal"))),
                    v - g > 0 && (x = x.concat(Array(v - g).fill("insert"))),
                    b - g > 0 && (x = x.concat(Array(b - g).fill("delete"))),
                    v < m && (x = x.concat(Array(m - v).fill("equal"))),
                    x
                }(d, l.length) : function(h, m) {
                    const g = []
                      , {firstIndex: b, lastIndexOld: v, lastIndexNew: x} = m;
                    return x - b > 0 && g.push({
                        index: b,
                        type: "insert",
                        values: h.slice(b, x)
                    }),
                    v - b > 0 && g.push({
                        index: b + (x - b),
                        type: "delete",
                        howMany: v - b
                    }),
                    g
                }(l, d)
            }
            function V(s, e, t) {
                for (let r = 0; r < Math.max(s.length, e.length); r++)
                    if (s[r] === void 0 || e[r] === void 0 || !t(s[r], e[r]))
                        return r;
                return -1
            }
            function G(s, e) {
                return s.slice(e).reverse()
            }
            function Y(s, e, t) {
                t = t || function(P, O) {
                    return P === O
                }
                ;
                const r = s.length
                  , i = e.length;
                if (r > 200 || i > 200 || r + i > 300)
                    return Y.fastDiff(s, e, t, !0);
                let l, d;
                if (i < r) {
                    const P = s;
                    s = e,
                    e = P,
                    l = "delete",
                    d = "insert"
                } else
                    l = "insert",
                    d = "delete";
                const h = s.length
                  , m = e.length
                  , g = m - h
                  , b = {}
                  , v = {};
                function x(P) {
                    const O = (v[P - 1] !== void 0 ? v[P - 1] : -1) + 1
                      , F = v[P + 1] !== void 0 ? v[P + 1] : -1
                      , q = O > F ? -1 : 1;
                    b[P + q] && (b[P] = b[P + q].slice(0)),
                    b[P] || (b[P] = []),
                    b[P].push(O > F ? l : d);
                    let Q = Math.max(O, F)
                      , X = Q - P;
                    for (; X < h && Q < m && t(s[X], e[Q]); )
                        X++,
                        Q++,
                        b[P].push("equal");
                    return Q
                }
                let T, I = 0;
                do {
                    for (T = -I; T < g; T++)
                        v[T] = x(T);
                    for (T = g + I; T > g; T--)
                        v[T] = x(T);
                    v[g] = x(g),
                    I++
                } while (v[g] !== m);
                return b[g].slice(1)
            }
            Y.fastDiff = j;
            const $ = function() {
                return function s() {
                    s.called = !0
                }
            };
            class K {
                constructor(e, t) {
                    C(this, "source"),
                    C(this, "name"),
                    C(this, "path"),
                    C(this, "stop"),
                    C(this, "off"),
                    C(this, "return"),
                    this.source = e,
                    this.name = t,
                    this.path = [],
                    this.stop = $(),
                    this.off = $()
                }
            }
            const Z = new Array(256).fill("").map( (s, e) => ("0" + e.toString(16)).slice(-2));
            function H() {
                const s = 4294967296 * Math.random() >>> 0
                  , e = 4294967296 * Math.random() >>> 0
                  , t = 4294967296 * Math.random() >>> 0
                  , r = 4294967296 * Math.random() >>> 0;
                return "e" + Z[255 & s] + Z[s >> 8 & 255] + Z[s >> 16 & 255] + Z[s >> 24 & 255] + Z[255 & e] + Z[e >> 8 & 255] + Z[e >> 16 & 255] + Z[e >> 24 & 255] + Z[255 & t] + Z[t >> 8 & 255] + Z[t >> 16 & 255] + Z[t >> 24 & 255] + Z[255 & r] + Z[r >> 8 & 255] + Z[r >> 16 & 255] + Z[r >> 24 & 255]
            }
            const W = {
                get(s="normal") {
                    return typeof s != "number" ? this[s] || this.normal : s
                },
                highest: 1e5,
                high: 1e3,
                normal: 0,
                low: -1e3,
                lowest: -1e5
            };
            function ee(s, e) {
                const t = W.get(e.priority);
                for (let r = 0; r < s.length; r++)
                    if (W.get(s[r].priority) < t)
                        return void s.splice(r, 0, e);
                s.push(e)
            }
            const re = "https://ckeditor.com/docs/ckeditor5/latest/support/error-codes.html";
            class U extends Error {
                constructor(e, t, r) {
                    super(function(i, l) {
                        const d = new WeakSet
                          , h = (b, v) => {
                            if (typeof v == "object" && v !== null) {
                                if (d.has(v))
                                    return `[object ${v.constructor.name}]`;
                                d.add(v)
                            }
                            return v
                        }
                          , m = l ? ` ${JSON.stringify(l, h)}` : ""
                          , g = ue(i);
                        return i + m + g
                    }(e, r)),
                    C(this, "context"),
                    C(this, "data"),
                    this.name = "CKEditorError",
                    this.context = t,
                    this.data = r
                }
                is(e) {
                    return e === "CKEditorError"
                }
                static rethrowUnexpectedError(e, t) {
                    if (e.is && e.is("CKEditorError"))
                        throw e;
                    const r = new U(e.message,t);
                    throw r.stack = e.stack,
                    r
                }
            }
            function de(s, e) {
                console.warn(...me(s, e))
            }
            function te(s, e) {
                console.error(...me(s, e))
            }
            function ue(s) {
                return `
Read more: ${re}#error-${s}`
            }
            function me(s, e) {
                const t = ue(s);
                return e ? [s, e, t] : [s, t]
            }
            const Ce = "42.0.2"
              , Ye = new Date(2024,6,25);
            if (globalThis.CKEDITOR_VERSION)
                throw new U("ckeditor-duplicated-modules",null);
            globalThis.CKEDITOR_VERSION = Ce;
            const Co = Symbol("listeningTo")
              , Dr = Symbol("emitterId")
              , oo = Symbol("delegations")
              , Uo = Se(Object);
            function Se(s) {
                return s ? class extends s {
                    on(e, t, r) {
                        this.listenTo(this, e, t, r)
                    }
                    once(e, t, r) {
                        let i = !1;
                        this.listenTo(this, e, (l, ...d) => {
                            i || (i = !0,
                            l.off(),
                            t.call(this, l, ...d))
                        }
                        , r)
                    }
                    off(e, t) {
                        this.stopListening(this, e, t)
                    }
                    listenTo(e, t, r, i={}) {
                        let l, d;
                        this[Co] || (this[Co] = {});
                        const h = this[Co];
                        Qa(e) || dd(e);
                        const m = Qa(e);
                        (l = h[m]) || (l = h[m] = {
                            emitter: e,
                            callbacks: {}
                        }),
                        (d = l.callbacks[t]) || (d = l.callbacks[t] = []),
                        d.push(r),
                        function(g, b, v, x, T) {
                            b._addEventListener ? b._addEventListener(v, x, T) : g._addEventListener.call(b, v, x, T)
                        }(this, e, t, r, i)
                    }
                    stopListening(e, t, r) {
                        const i = this[Co];
                        let l = e && Qa(e);
                        const d = i && l ? i[l] : void 0
                          , h = d && t ? d.callbacks[t] : void 0;
                        if (!(!i || e && !d || t && !h))
                            if (r)
                                Xa(this, e, t, r),
                                h.indexOf(r) !== -1 && (h.length === 1 ? delete d.callbacks[t] : Xa(this, e, t, r));
                            else if (h) {
                                for (; r = h.pop(); )
                                    Xa(this, e, t, r);
                                delete d.callbacks[t]
                            } else if (d) {
                                for (t in d.callbacks)
                                    this.stopListening(e, t);
                                delete i[l]
                            } else {
                                for (l in i)
                                    this.stopListening(i[l].emitter);
                                delete this[Co]
                            }
                    }
                    fire(e, ...t) {
                        try {
                            const r = e instanceof K ? e : new K(this,e)
                              , i = r.name;
                            let l = Ja(this, i);
                            if (r.path.push(this),
                            l) {
                                const h = [r, ...t];
                                l = Array.from(l);
                                for (let m = 0; m < l.length && (l[m].callback.apply(this, h),
                                r.off.called && (delete r.off.called,
                                this._removeEventListener(i, l[m].callback)),
                                !r.stop.called); m++)
                                    ;
                            }
                            const d = this[oo];
                            if (d) {
                                const h = d.get(i)
                                  , m = d.get("*");
                                h && ud(h, r, t),
                                m && ud(m, r, t)
                            }
                            return r.return
                        } catch (r) {
                            U.rethrowUnexpectedError(r, this)
                        }
                    }
                    delegate(...e) {
                        return {
                            to: (t, r) => {
                                this[oo] || (this[oo] = new Map),
                                e.forEach(i => {
                                    const l = this[oo].get(i);
                                    l ? l.set(t, r) : this[oo].set(i, new Map([[t, r]]))
                                }
                                )
                            }
                        }
                    }
                    stopDelegating(e, t) {
                        if (this[oo])
                            if (e)
                                if (t) {
                                    const r = this[oo].get(e);
                                    r && r.delete(t)
                                } else
                                    this[oo].delete(e);
                            else
                                this[oo].clear()
                    }
                    _addEventListener(e, t, r) {
                        (function(d, h) {
                            const m = ki(d);
                            if (m[h])
                                return;
                            let g = h
                              , b = null;
                            const v = [];
                            for (; g !== "" && !m[g]; )
                                m[g] = {
                                    callbacks: [],
                                    childEvents: []
                                },
                                v.push(m[g]),
                                b && m[g].childEvents.push(b),
                                b = g,
                                g = g.substr(0, g.lastIndexOf(":"));
                            if (g !== "") {
                                for (const x of v)
                                    x.callbacks = m[g].callbacks.slice();
                                m[g].childEvents.push(b)
                            }
                        }
                        )(this, e);
                        const i = Za(this, e)
                          , l = {
                            callback: t,
                            priority: W.get(r.priority)
                        };
                        for (const d of i)
                            ee(d, l)
                    }
                    _removeEventListener(e, t) {
                        const r = Za(this, e);
                        for (const i of r)
                            for (let l = 0; l < i.length; l++)
                                i[l].callback == t && (i.splice(l, 1),
                                l--)
                    }
                }
                : Uo
            }
            function dd(s, e) {
                s[Dr] || (s[Dr] = e || H())
            }
            function Qa(s) {
                return s[Dr]
            }
            function ki(s) {
                return s._events || Object.defineProperty(s, "_events", {
                    value: {}
                }),
                s._events
            }
            function Za(s, e) {
                const t = ki(s)[e];
                if (!t)
                    return [];
                let r = [t.callbacks];
                for (let i = 0; i < t.childEvents.length; i++) {
                    const l = Za(s, t.childEvents[i]);
                    r = r.concat(l)
                }
                return r
            }
            function Ja(s, e) {
                let t;
                return s._events && (t = s._events[e]) && t.callbacks.length ? t.callbacks : e.indexOf(":") > -1 ? Ja(s, e.substr(0, e.lastIndexOf(":"))) : null
            }
            function ud(s, e, t) {
                for (let[r,i] of s) {
                    i ? typeof i == "function" && (i = i(e.name)) : i = e.name;
                    const l = new K(e.source,i);
                    l.path = [...e.path],
                    r.fire(l, ...t)
                }
            }
            function Xa(s, e, t, r) {
                e._removeEventListener ? e._removeEventListener(t, r) : s._removeEventListener.call(e, t, r)
            }
            ["on", "once", "off", "listenTo", "stopListening", "fire", "delegate", "stopDelegating", "_addEventListener", "_removeEventListener"].forEach(s => {
                Se[s] = Uo.prototype[s]
            }
            );
            const Le = function(s) {
                var e = typeof s;
                return s != null && (e == "object" || e == "function")
            }
              , bi = Symbol("observableProperties")
              , ce = Symbol("boundObservables")
              , Re = Symbol("boundProperties")
              , Qe = Symbol("decoratedMethods")
              , Gr = Symbol("decoratedOriginal")
              , Sn = ye(Se());
            function ye(s) {
                var e, t, r, i, l;
                return s ? class extends (l = s,
                i = bi,
                r = Qe,
                t = Re,
                e = ce,
                l) {
                    constructor() {
                        super(...arguments),
                        C(this, i),
                        C(this, r),
                        C(this, t),
                        C(this, e)
                    }
                    set(d, h) {
                        if (Le(d))
                            return void Object.keys(d).forEach(g => {
                                this.set(g, d[g])
                            }
                            , this);
                        el(this);
                        const m = this[bi];
                        if (d in this && !m.has(d))
                            throw new U("observable-set-cannot-override",this);
                        Object.defineProperty(this, d, {
                            enumerable: !0,
                            configurable: !0,
                            get: () => m.get(d),
                            set(g) {
                                const b = m.get(d);
                                let v = this.fire(`set:${d}`, d, g, b);
                                v === void 0 && (v = g),
                                b === v && m.has(d) || (m.set(d, v),
                                this.fire(`change:${d}`, d, v, b))
                            }
                        }),
                        this[d] = h
                    }
                    bind(...d) {
                        if (!d.length || !$w(d))
                            throw new U("observable-bind-wrong-properties",this);
                        if (new Set(d).size !== d.length)
                            throw new U("observable-bind-duplicate-properties",this);
                        el(this);
                        const h = this[Re];
                        d.forEach(g => {
                            if (h.has(g))
                                throw new U("observable-bind-rebind",this)
                        }
                        );
                        const m = new Map;
                        return d.forEach(g => {
                            const b = {
                                property: g,
                                to: []
                            };
                            h.set(g, b),
                            m.set(g, b)
                        }
                        ),
                        {
                            to: Ho,
                            toMany: EB,
                            _observable: this,
                            _bindProperties: d,
                            _to: [],
                            _bindings: m
                        }
                    }
                    unbind(...d) {
                        if (!this[bi])
                            return;
                        const h = this[Re]
                          , m = this[ce];
                        if (d.length) {
                            if (!$w(d))
                                throw new U("observable-unbind-wrong-properties",this);
                            d.forEach(g => {
                                const b = h.get(g);
                                b && (b.to.forEach( ([v,x]) => {
                                    const T = m.get(v)
                                      , I = T[x];
                                    I.delete(b),
                                    I.size || delete T[x],
                                    Object.keys(T).length || (m.delete(v),
                                    this.stopListening(v, "change"))
                                }
                                ),
                                h.delete(g))
                            }
                            )
                        } else
                            m.forEach( (g, b) => {
                                this.stopListening(b, "change")
                            }
                            ),
                            m.clear(),
                            h.clear()
                    }
                    decorate(d) {
                        el(this);
                        const h = this[d];
                        if (!h)
                            throw new U("observablemixin-cannot-decorate-undefined",this,{
                                object: this,
                                methodName: d
                            });
                        this.on(d, (m, g) => {
                            m.return = h.apply(this, g)
                        }
                        ),
                        this[d] = function(...m) {
                            return this.fire(d, m)
                        }
                        ,
                        this[d][Gr] = h,
                        this[Qe] || (this[Qe] = []),
                        this[Qe].push(d)
                    }
                    stopListening(d, h, m) {
                        if (!d && this[Qe]) {
                            for (const g of this[Qe])
                                this[g] = this[g][Gr];
                            delete this[Qe]
                        }
                        super.stopListening(d, h, m)
                    }
                }
                : Sn
            }
            function el(s) {
                s[bi] || (Object.defineProperty(s, bi, {
                    value: new Map
                }),
                Object.defineProperty(s, ce, {
                    value: new Map
                }),
                Object.defineProperty(s, Re, {
                    value: new Map
                }))
            }
            function Ho(...s) {
                const e = function(...l) {
                    if (!l.length)
                        throw new U("observable-bind-to-parse-error",null);
                    const d = {
                        to: []
                    };
                    let h;
                    return typeof l[l.length - 1] == "function" && (d.callback = l.pop()),
                    l.forEach(m => {
                        if (typeof m == "string")
                            h.properties.push(m);
                        else {
                            if (typeof m != "object")
                                throw new U("observable-bind-to-parse-error",null);
                            h = {
                                observable: m,
                                properties: []
                            },
                            d.to.push(h)
                        }
                    }
                    ),
                    d
                }(...s)
                  , t = Array.from(this._bindings.keys())
                  , r = t.length;
                if (!e.callback && e.to.length > 1)
                    throw new U("observable-bind-to-no-callback",this);
                if (r > 1 && e.callback)
                    throw new U("observable-bind-to-extra-callback",this);
                var i;
                e.to.forEach(l => {
                    if (l.properties.length && l.properties.length !== r)
                        throw new U("observable-bind-to-properties-length",this);
                    l.properties.length || (l.properties = this._bindProperties)
                }
                ),
                this._to = e.to,
                e.callback && (this._bindings.get(t[0]).callback = e.callback),
                i = this._observable,
                this._to.forEach(l => {
                    const d = i[ce];
                    let h;
                    d.get(l.observable) || i.listenTo(l.observable, "change", (m, g) => {
                        h = d.get(l.observable)[g],
                        h && h.forEach(b => {
                            qw(i, b.property)
                        }
                        )
                    }
                    )
                }
                ),
                function(l) {
                    let d;
                    l._bindings.forEach( (h, m) => {
                        l._to.forEach(g => {
                            d = g.properties[h.callback ? 0 : l._bindProperties.indexOf(m)],
                            h.to.push([g.observable, d]),
                            function(b, v, x, T) {
                                const I = b[ce]
                                  , P = I.get(x)
                                  , O = P || {};
                                O[T] || (O[T] = new Set),
                                O[T].add(v),
                                P || I.set(x, O)
                            }(l._observable, h, g.observable, d)
                        }
                        )
                    }
                    )
                }(this),
                this._bindProperties.forEach(l => {
                    qw(this._observable, l)
                }
                )
            }
            function EB(s, e, t) {
                if (this._bindings.size > 1)
                    throw new U("observable-bind-to-many-not-one-binding",this);
                this.to(...function(r, i) {
                    const l = r.map(d => [d, i]);
                    return Array.prototype.concat.apply([], l)
                }(s, e), t)
            }
            function $w(s) {
                return s.every(e => typeof e == "string")
            }
            function qw(s, e) {
                const t = s[Re].get(e);
                let r;
                t.callback ? r = t.callback.apply(s, t.to.map(i => i[0][i[1]])) : (r = t.to[0],
                r = r[0][r[1]]),
                Object.prototype.hasOwnProperty.call(s, e) ? s[e] = r : s.set(e, r)
            }
            ["set", "bind", "unbind", "decorate", "on", "once", "off", "listenTo", "stopListening", "fire", "delegate", "stopDelegating", "_addEventListener", "_removeEventListener"].forEach(s => {
                ye[s] = Sn.prototype[s]
            }
            );
            class SB {
                constructor() {
                    C(this, "_replacedElements"),
                    this._replacedElements = []
                }
                replace(e, t) {
                    this._replacedElements.push({
                        element: e,
                        newElement: t
                    }),
                    e.style.display = "none",
                    t && e.parentNode.insertBefore(t, e.nextSibling)
                }
                restore() {
                    this._replacedElements.forEach( ({element: e, newElement: t}) => {
                        e.style.display = "",
                        t && t.remove()
                    }
                    ),
                    this._replacedElements = []
                }
            }
            function Sm(s) {
                let e = 0;
                for (const t of s)
                    e++;
                return e
            }
            function ro(s, e) {
                const t = Math.min(s.length, e.length);
                for (let r = 0; r < t; r++)
                    if (s[r] != e[r])
                        return r;
                return s.length == e.length ? "same" : s.length < e.length ? "prefix" : "extension"
            }
            function yo(s) {
                return !(!s || !s[Symbol.iterator])
            }
            const Gw = typeof Tu == "object" && Tu && Tu.Object === Object && Tu;
            var DB = typeof self == "object" && self && self.Object === Object && self;
            const cr = Gw || DB || Function("return this")()
              , Tr = cr.Symbol;
            var Kw = Object.prototype
              , TB = Kw.hasOwnProperty
              , IB = Kw.toString
              , tl = Tr ? Tr.toStringTag : void 0;
            const MB = function(s) {
                var e = TB.call(s, tl)
                  , t = s[tl];
                try {
                    s[tl] = void 0;
                    var r = !0
                } catch {}
                var i = IB.call(s);
                return r && (e ? s[tl] = t : delete s[tl]),
                i
            };
            var BB = Object.prototype.toString;
            const NB = function(s) {
                return BB.call(s)
            };
            var Yw = Tr ? Tr.toStringTag : void 0;
            const Dn = function(s) {
                return s == null ? s === void 0 ? "[object Undefined]" : "[object Null]" : Yw && Yw in Object(s) ? MB(s) : NB(s)
            }
              , xo = Array.isArray
              , Wo = function(s) {
                return s != null && typeof s == "object"
            }
              , Qw = function(s) {
                return typeof s == "string" || !xo(s) && Wo(s) && Dn(s) == "[object String]"
            };
            function $o(s, e, t={}, r=[]) {
                const i = t && t.xmlns
                  , l = i ? s.createElementNS(i, e) : s.createElement(e);
                for (const d in t)
                    l.setAttribute(d, t[d]);
                !Qw(r) && yo(r) || (r = [r]);
                for (let d of r)
                    Qw(d) && (d = s.createTextNode(d)),
                    l.appendChild(d);
                return l
            }
            const Zw = function(s, e) {
                return function(t) {
                    return s(e(t))
                }
            }
              , Dm = Zw(Object.getPrototypeOf, Object);
            var PB = Function.prototype
              , jB = Object.prototype
              , Jw = PB.toString
              , LB = jB.hasOwnProperty
              , zB = Jw.call(Object);
            const Eo = function(s) {
                if (!Wo(s) || Dn(s) != "[object Object]")
                    return !1;
                var e = Dm(s);
                if (e === null)
                    return !0;
                var t = LB.call(e, "constructor") && e.constructor;
                return typeof t == "function" && t instanceof t && Jw.call(t) == zB
            }
              , OB = function() {
                this.__data__ = [],
                this.size = 0
            }
              , ol = function(s, e) {
                return s === e || s != s && e != e
            }
              , hd = function(s, e) {
                for (var t = s.length; t--; )
                    if (ol(s[t][0], e))
                        return t;
                return -1
            };
            var RB = Array.prototype.splice;
            const FB = function(s) {
                var e = this.__data__
                  , t = hd(e, s);
                return !(t < 0) && (t == e.length - 1 ? e.pop() : RB.call(e, t, 1),
                --this.size,
                !0)
            }
              , VB = function(s) {
                var e = this.__data__
                  , t = hd(e, s);
                return t < 0 ? void 0 : e[t][1]
            }
              , UB = function(s) {
                return hd(this.__data__, s) > -1
            }
              , HB = function(s, e) {
                var t = this.__data__
                  , r = hd(t, s);
                return r < 0 ? (++this.size,
                t.push([s, e])) : t[r][1] = e,
                this
            };
            function ps(s) {
                var e = -1
                  , t = s == null ? 0 : s.length;
                for (this.clear(); ++e < t; ) {
                    var r = s[e];
                    this.set(r[0], r[1])
                }
            }
            ps.prototype.clear = OB,
            ps.prototype.delete = FB,
            ps.prototype.get = VB,
            ps.prototype.has = UB,
            ps.prototype.set = HB;
            const md = ps
              , WB = function() {
                this.__data__ = new md,
                this.size = 0
            }
              , $B = function(s) {
                var e = this.__data__
                  , t = e.delete(s);
                return this.size = e.size,
                t
            }
              , qB = function(s) {
                return this.__data__.get(s)
            }
              , GB = function(s) {
                return this.__data__.has(s)
            }
              , wi = function(s) {
                if (!Le(s))
                    return !1;
                var e = Dn(s);
                return e == "[object Function]" || e == "[object GeneratorFunction]" || e == "[object AsyncFunction]" || e == "[object Proxy]"
            }
              , Tm = cr["__core-js_shared__"];
            var Xw = function() {
                var s = /[^.]+$/.exec(Tm && Tm.keys && Tm.keys.IE_PROTO || "");
                return s ? "Symbol(src)_1." + s : ""
            }();
            const KB = function(s) {
                return !!Xw && Xw in s
            };
            var YB = Function.prototype.toString;
            const Ai = function(s) {
                if (s != null) {
                    try {
                        return YB.call(s)
                    } catch {}
                    try {
                        return s + ""
                    } catch {}
                }
                return ""
            };
            var QB = /^\[object .+?Constructor\]$/
              , ZB = Function.prototype
              , JB = Object.prototype
              , XB = ZB.toString
              , eN = JB.hasOwnProperty
              , tN = RegExp("^" + XB.call(eN).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
            const oN = function(s) {
                return !(!Le(s) || KB(s)) && (wi(s) ? tN : QB).test(Ai(s))
            }
              , rN = function(s, e) {
                return s == null ? void 0 : s[e]
            }
              , vi = function(s, e) {
                var t = rN(s, e);
                return oN(t) ? t : void 0
            }
              , rl = vi(cr, "Map")
              , nl = vi(Object, "create")
              , nN = function() {
                this.__data__ = nl ? nl(null) : {},
                this.size = 0
            }
              , iN = function(s) {
                var e = this.has(s) && delete this.__data__[s];
                return this.size -= e ? 1 : 0,
                e
            };
            var sN = Object.prototype.hasOwnProperty;
            const aN = function(s) {
                var e = this.__data__;
                if (nl) {
                    var t = e[s];
                    return t === "__lodash_hash_undefined__" ? void 0 : t
                }
                return sN.call(e, s) ? e[s] : void 0
            };
            var lN = Object.prototype.hasOwnProperty;
            const cN = function(s) {
                var e = this.__data__;
                return nl ? e[s] !== void 0 : lN.call(e, s)
            }
              , dN = function(s, e) {
                var t = this.__data__;
                return this.size += this.has(s) ? 0 : 1,
                t[s] = nl && e === void 0 ? "__lodash_hash_undefined__" : e,
                this
            };
            function gs(s) {
                var e = -1
                  , t = s == null ? 0 : s.length;
                for (this.clear(); ++e < t; ) {
                    var r = s[e];
                    this.set(r[0], r[1])
                }
            }
            gs.prototype.clear = nN,
            gs.prototype.delete = iN,
            gs.prototype.get = aN,
            gs.prototype.has = cN,
            gs.prototype.set = dN;
            const eA = gs
              , uN = function() {
                this.size = 0,
                this.__data__ = {
                    hash: new eA,
                    map: new (rl || md),
                    string: new eA
                }
            }
              , hN = function(s) {
                var e = typeof s;
                return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? s !== "__proto__" : s === null
            }
              , pd = function(s, e) {
                var t = s.__data__;
                return hN(e) ? t[typeof e == "string" ? "string" : "hash"] : t.map
            }
              , mN = function(s) {
                var e = pd(this, s).delete(s);
                return this.size -= e ? 1 : 0,
                e
            }
              , pN = function(s) {
                return pd(this, s).get(s)
            }
              , gN = function(s) {
                return pd(this, s).has(s)
            }
              , fN = function(s, e) {
                var t = pd(this, s)
                  , r = t.size;
                return t.set(s, e),
                this.size += t.size == r ? 0 : 1,
                this
            };
            function fs(s) {
                var e = -1
                  , t = s == null ? 0 : s.length;
                for (this.clear(); ++e < t; ) {
                    var r = s[e];
                    this.set(r[0], r[1])
                }
            }
            fs.prototype.clear = uN,
            fs.prototype.delete = mN,
            fs.prototype.get = pN,
            fs.prototype.has = gN,
            fs.prototype.set = fN;
            const gd = fs
              , kN = function(s, e) {
                var t = this.__data__;
                if (t instanceof md) {
                    var r = t.__data__;
                    if (!rl || r.length < 199)
                        return r.push([s, e]),
                        this.size = ++t.size,
                        this;
                    t = this.__data__ = new gd(r)
                }
                return t.set(s, e),
                this.size = t.size,
                this
            };
            function ks(s) {
                var e = this.__data__ = new md(s);
                this.size = e.size
            }
            ks.prototype.clear = WB,
            ks.prototype.delete = $B,
            ks.prototype.get = qB,
            ks.prototype.has = GB,
            ks.prototype.set = kN;
            const bs = ks
              , bN = function(s, e) {
                for (var t = -1, r = s == null ? 0 : s.length; ++t < r && e(s[t], t, s) !== !1; )
                    ;
                return s
            }
              , fd = function() {
                try {
                    var s = vi(Object, "defineProperty");
                    return s({}, "", {}),
                    s
                } catch {}
            }()
              , kd = function(s, e, t) {
                e == "__proto__" && fd ? fd(s, e, {
                    configurable: !0,
                    enumerable: !0,
                    value: t,
                    writable: !0
                }) : s[e] = t
            };
            var wN = Object.prototype.hasOwnProperty;
            const Im = function(s, e, t) {
                var r = s[e];
                wN.call(s, e) && ol(r, t) && (t !== void 0 || e in s) || kd(s, e, t)
            }
              , ws = function(s, e, t, r) {
                var i = !t;
                t || (t = {});
                for (var l = -1, d = e.length; ++l < d; ) {
                    var h = e[l]
                      , m = void 0;
                    m === void 0 && (m = s[h]),
                    i ? kd(t, h, m) : Im(t, h, m)
                }
                return t
            }
              , AN = function(s, e) {
                for (var t = -1, r = Array(s); ++t < s; )
                    r[t] = e(t);
                return r
            }
              , tA = function(s) {
                return Wo(s) && Dn(s) == "[object Arguments]"
            };
            var oA = Object.prototype
              , vN = oA.hasOwnProperty
              , _N = oA.propertyIsEnumerable;
            const bd = tA(function() {
                return arguments
            }()) ? tA : function(s) {
                return Wo(s) && vN.call(s, "callee") && !_N.call(s, "callee")
            }
              , CN = function() {
                return !1
            };
            var rA = n && !n.nodeType && n
              , nA = rA && !0 && o && !o.nodeType && o
              , iA = nA && nA.exports === rA ? cr.Buffer : void 0;
            const il = (iA ? iA.isBuffer : void 0) || CN;
            var yN = /^(?:0|[1-9]\d*)$/;
            const wd = function(s, e) {
                var t = typeof s;
                return !!(e = e ?? 9007199254740991) && (t == "number" || t != "symbol" && yN.test(s)) && s > -1 && s % 1 == 0 && s < e
            }
              , Mm = function(s) {
                return typeof s == "number" && s > -1 && s % 1 == 0 && s <= 9007199254740991
            };
            var ot = {};
            ot["[object Float32Array]"] = ot["[object Float64Array]"] = ot["[object Int8Array]"] = ot["[object Int16Array]"] = ot["[object Int32Array]"] = ot["[object Uint8Array]"] = ot["[object Uint8ClampedArray]"] = ot["[object Uint16Array]"] = ot["[object Uint32Array]"] = !0,
            ot["[object Arguments]"] = ot["[object Array]"] = ot["[object ArrayBuffer]"] = ot["[object Boolean]"] = ot["[object DataView]"] = ot["[object Date]"] = ot["[object Error]"] = ot["[object Function]"] = ot["[object Map]"] = ot["[object Number]"] = ot["[object Object]"] = ot["[object RegExp]"] = ot["[object Set]"] = ot["[object String]"] = ot["[object WeakMap]"] = !1;
            const xN = function(s) {
                return Wo(s) && Mm(s.length) && !!ot[Dn(s)]
            }
              , Bm = function(s) {
                return function(e) {
                    return s(e)
                }
            };
            var sA = n && !n.nodeType && n
              , sl = sA && !0 && o && !o.nodeType && o
              , Nm = sl && sl.exports === sA && Gw.process;
            const As = function() {
                try {
                    var s = sl && sl.require && sl.require("util").types;
                    return s || Nm && Nm.binding && Nm.binding("util")
                } catch {}
            }();
            var aA = As && As.isTypedArray;
            const Pm = aA ? Bm(aA) : xN;
            var EN = Object.prototype.hasOwnProperty;
            const lA = function(s, e) {
                var t = xo(s)
                  , r = !t && bd(s)
                  , i = !t && !r && il(s)
                  , l = !t && !r && !i && Pm(s)
                  , d = t || r || i || l
                  , h = d ? AN(s.length, String) : []
                  , m = h.length;
                for (var g in s)
                    !e && !EN.call(s, g) || d && (g == "length" || i && (g == "offset" || g == "parent") || l && (g == "buffer" || g == "byteLength" || g == "byteOffset") || wd(g, m)) || h.push(g);
                return h
            };
            var SN = Object.prototype;
            const jm = function(s) {
                var e = s && s.constructor;
                return s === (typeof e == "function" && e.prototype || SN)
            }
              , DN = Zw(Object.keys, Object);
            var TN = Object.prototype.hasOwnProperty;
            const IN = function(s) {
                if (!jm(s))
                    return DN(s);
                var e = [];
                for (var t in Object(s))
                    TN.call(s, t) && t != "constructor" && e.push(t);
                return e
            }
              , Ad = function(s) {
                return s != null && Mm(s.length) && !wi(s)
            }
              , al = function(s) {
                return Ad(s) ? lA(s) : IN(s)
            }
              , MN = function(s, e) {
                return s && ws(e, al(e), s)
            }
              , BN = function(s) {
                var e = [];
                if (s != null)
                    for (var t in Object(s))
                        e.push(t);
                return e
            };
            var NN = Object.prototype.hasOwnProperty;
            const PN = function(s) {
                if (!Le(s))
                    return BN(s);
                var e = jm(s)
                  , t = [];
                for (var r in s)
                    (r != "constructor" || !e && NN.call(s, r)) && t.push(r);
                return t
            }
              , vs = function(s) {
                return Ad(s) ? lA(s, !0) : PN(s)
            }
              , jN = function(s, e) {
                return s && ws(e, vs(e), s)
            };
            var cA = n && !n.nodeType && n
              , dA = cA && !0 && o && !o.nodeType && o
              , uA = dA && dA.exports === cA ? cr.Buffer : void 0
              , hA = uA ? uA.allocUnsafe : void 0;
            const mA = function(s, e) {
                if (e)
                    return s.slice();
                var t = s.length
                  , r = hA ? hA(t) : new s.constructor(t);
                return s.copy(r),
                r
            }
              , pA = function(s, e) {
                var t = -1
                  , r = s.length;
                for (e || (e = Array(r)); ++t < r; )
                    e[t] = s[t];
                return e
            }
              , LN = function(s, e) {
                for (var t = -1, r = s == null ? 0 : s.length, i = 0, l = []; ++t < r; ) {
                    var d = s[t];
                    e(d, t, s) && (l[i++] = d)
                }
                return l
            }
              , gA = function() {
                return []
            };
            var zN = Object.prototype.propertyIsEnumerable
              , fA = Object.getOwnPropertySymbols;
            const Lm = fA ? function(s) {
                return s == null ? [] : (s = Object(s),
                LN(fA(s), function(e) {
                    return zN.call(s, e)
                }))
            }
            : gA
              , ON = function(s, e) {
                return ws(s, Lm(s), e)
            }
              , kA = function(s, e) {
                for (var t = -1, r = e.length, i = s.length; ++t < r; )
                    s[i + t] = e[t];
                return s
            }
              , bA = Object.getOwnPropertySymbols ? function(s) {
                for (var e = []; s; )
                    kA(e, Lm(s)),
                    s = Dm(s);
                return e
            }
            : gA
              , RN = function(s, e) {
                return ws(s, bA(s), e)
            }
              , wA = function(s, e, t) {
                var r = e(s);
                return xo(s) ? r : kA(r, t(s))
            }
              , zm = function(s) {
                return wA(s, al, Lm)
            }
              , FN = function(s) {
                return wA(s, vs, bA)
            }
              , Om = vi(cr, "DataView")
              , Rm = vi(cr, "Promise")
              , Fm = vi(cr, "Set")
              , Vm = vi(cr, "WeakMap");
            var AA = "[object Map]"
              , vA = "[object Promise]"
              , _A = "[object Set]"
              , CA = "[object WeakMap]"
              , yA = "[object DataView]"
              , VN = Ai(Om)
              , UN = Ai(rl)
              , HN = Ai(Rm)
              , WN = Ai(Fm)
              , $N = Ai(Vm)
              , _i = Dn;
            (Om && _i(new Om(new ArrayBuffer(1))) != yA || rl && _i(new rl) != AA || Rm && _i(Rm.resolve()) != vA || Fm && _i(new Fm) != _A || Vm && _i(new Vm) != CA) && (_i = function(s) {
                var e = Dn(s)
                  , t = e == "[object Object]" ? s.constructor : void 0
                  , r = t ? Ai(t) : "";
                if (r)
                    switch (r) {
                    case VN:
                        return yA;
                    case UN:
                        return AA;
                    case HN:
                        return vA;
                    case WN:
                        return _A;
                    case $N:
                        return CA
                    }
                return e
            }
            );
            const ll = _i;
            var qN = Object.prototype.hasOwnProperty;
            const GN = function(s) {
                var e = s.length
                  , t = new s.constructor(e);
                return e && typeof s[0] == "string" && qN.call(s, "index") && (t.index = s.index,
                t.input = s.input),
                t
            }
              , vd = cr.Uint8Array
              , Um = function(s) {
                var e = new s.constructor(s.byteLength);
                return new vd(e).set(new vd(s)),
                e
            }
              , KN = function(s, e) {
                var t = e ? Um(s.buffer) : s.buffer;
                return new s.constructor(t,s.byteOffset,s.byteLength)
            };
            var YN = /\w*$/;
            const QN = function(s) {
                var e = new s.constructor(s.source,YN.exec(s));
                return e.lastIndex = s.lastIndex,
                e
            };
            var xA = Tr ? Tr.prototype : void 0
              , EA = xA ? xA.valueOf : void 0;
            const ZN = function(s) {
                return EA ? Object(EA.call(s)) : {}
            }
              , SA = function(s, e) {
                var t = e ? Um(s.buffer) : s.buffer;
                return new s.constructor(t,s.byteOffset,s.length)
            }
              , JN = function(s, e, t) {
                var r = s.constructor;
                switch (e) {
                case "[object ArrayBuffer]":
                    return Um(s);
                case "[object Boolean]":
                case "[object Date]":
                    return new r(+s);
                case "[object DataView]":
                    return KN(s, t);
                case "[object Float32Array]":
                case "[object Float64Array]":
                case "[object Int8Array]":
                case "[object Int16Array]":
                case "[object Int32Array]":
                case "[object Uint8Array]":
                case "[object Uint8ClampedArray]":
                case "[object Uint16Array]":
                case "[object Uint32Array]":
                    return SA(s, t);
                case "[object Map]":
                case "[object Set]":
                    return new r;
                case "[object Number]":
                case "[object String]":
                    return new r(s);
                case "[object RegExp]":
                    return QN(s);
                case "[object Symbol]":
                    return ZN(s)
                }
            };
            var DA = Object.create;
            const XN = function() {
                function s() {}
                return function(e) {
                    if (!Le(e))
                        return {};
                    if (DA)
                        return DA(e);
                    s.prototype = e;
                    var t = new s;
                    return s.prototype = void 0,
                    t
                }
            }()
              , TA = function(s) {
                return typeof s.constructor != "function" || jm(s) ? {} : XN(Dm(s))
            }
              , e4 = function(s) {
                return Wo(s) && ll(s) == "[object Map]"
            };
            var IA = As && As.isMap;
            const t4 = IA ? Bm(IA) : e4
              , o4 = function(s) {
                return Wo(s) && ll(s) == "[object Set]"
            };
            var MA = As && As.isSet;
            const r4 = MA ? Bm(MA) : o4;
            var BA = "[object Arguments]"
              , NA = "[object Function]"
              , PA = "[object Object]"
              , et = {};
            et[BA] = et["[object Array]"] = et["[object ArrayBuffer]"] = et["[object DataView]"] = et["[object Boolean]"] = et["[object Date]"] = et["[object Float32Array]"] = et["[object Float64Array]"] = et["[object Int8Array]"] = et["[object Int16Array]"] = et["[object Int32Array]"] = et["[object Map]"] = et["[object Number]"] = et[PA] = et["[object RegExp]"] = et["[object Set]"] = et["[object String]"] = et["[object Symbol]"] = et["[object Uint8Array]"] = et["[object Uint8ClampedArray]"] = et["[object Uint16Array]"] = et["[object Uint32Array]"] = !0,
            et["[object Error]"] = et[NA] = et["[object WeakMap]"] = !1;
            const Hm = function s(e, t, r, i, l, d) {
                var h, m = 1 & t, g = 2 & t, b = 4 & t;
                if (r && (h = l ? r(e, i, l, d) : r(e)),
                h !== void 0)
                    return h;
                if (!Le(e))
                    return e;
                var v = xo(e);
                if (v) {
                    if (h = GN(e),
                    !m)
                        return pA(e, h)
                } else {
                    var x = ll(e)
                      , T = x == NA || x == "[object GeneratorFunction]";
                    if (il(e))
                        return mA(e, m);
                    if (x == PA || x == BA || T && !l) {
                        if (h = g || T ? {} : TA(e),
                        !m)
                            return g ? RN(e, jN(h, e)) : ON(e, MN(h, e))
                    } else {
                        if (!et[x])
                            return l ? e : {};
                        h = JN(e, x, m)
                    }
                }
                d || (d = new bs);
                var I = d.get(e);
                if (I)
                    return I;
                d.set(e, h),
                r4(e) ? e.forEach(function(O) {
                    h.add(s(O, t, r, O, e, d))
                }) : t4(e) && e.forEach(function(O, F) {
                    h.set(F, s(O, t, r, F, e, d))
                });
                var P = v ? void 0 : (b ? g ? FN : zm : g ? vs : al)(e);
                return bN(P || e, function(O, F) {
                    P && (O = e[F = O]),
                    Im(h, F, s(O, t, r, F, e, d))
                }),
                h
            }
              , Wm = function(s, e) {
                return Hm(s, 5, e = typeof e == "function" ? e : void 0)
            }
              , Ci = function(s) {
                return Wo(s) && s.nodeType === 1 && !Eo(s)
            };
            class jA {
                constructor(e, t) {
                    C(this, "_config"),
                    this._config = {},
                    t && this.define(LA(t)),
                    e && this._setObjectToTarget(this._config, e)
                }
                set(e, t) {
                    this._setToTarget(this._config, e, t)
                }
                define(e, t) {
                    this._setToTarget(this._config, e, t, !0)
                }
                get(e) {
                    return this._getFromSource(this._config, e)
                }
                *names() {
                    for (const e of Object.keys(this._config))
                        yield e
                }
                _setToTarget(e, t, r, i=!1) {
                    if (Eo(t))
                        return void this._setObjectToTarget(e, t, i);
                    const l = t.split(".");
                    t = l.pop();
                    for (const d of l)
                        Eo(e[d]) || (e[d] = {}),
                        e = e[d];
                    if (Eo(r))
                        return Eo(e[t]) || (e[t] = {}),
                        e = e[t],
                        void this._setObjectToTarget(e, r, i);
                    i && e[t] !== void 0 || (e[t] = r)
                }
                _getFromSource(e, t) {
                    const r = t.split(".");
                    t = r.pop();
                    for (const i of r) {
                        if (!Eo(e[i])) {
                            e = null;
                            break
                        }
                        e = e[i]
                    }
                    return e ? LA(e[t]) : void 0
                }
                _setObjectToTarget(e, t, r) {
                    Object.keys(t).forEach(i => {
                        this._setToTarget(e, i, t[i], r)
                    }
                    )
                }
            }
            function LA(s) {
                return Wm(s, n4)
            }
            function n4(s) {
                return Ci(s) || typeof s == "function" ? s : void 0
            }
            function Tn(s) {
                if (s) {
                    if (s.defaultView)
                        return s instanceof s.defaultView.Document;
                    if (s.ownerDocument && s.ownerDocument.defaultView)
                        return s instanceof s.ownerDocument.defaultView.Node
                }
                return !1
            }
            function _d(s) {
                const e = Object.prototype.toString.apply(s);
                return e == "[object Window]" || e == "[object global]"
            }
            const zA = qo(Se());
            function qo(s) {
                return s ? class extends s {
                    listenTo(e, t, r, i={}) {
                        if (Tn(e) || _d(e)) {
                            const l = {
                                capture: !!i.useCapture,
                                passive: !!i.usePassive
                            }
                              , d = this._getProxyEmitter(e, l) || new i4(e,l);
                            this.listenTo(d, t, r, i)
                        } else
                            super.listenTo(e, t, r, i)
                    }
                    stopListening(e, t, r) {
                        if (Tn(e) || _d(e)) {
                            const i = this._getAllProxyEmitters(e);
                            for (const l of i)
                                this.stopListening(l, t, r)
                        } else
                            super.stopListening(e, t, r)
                    }
                    _getProxyEmitter(e, t) {
                        return function(r, i) {
                            const l = r[Co];
                            return l && l[i] ? l[i].emitter : null
                        }(this, OA(e, t))
                    }
                    _getAllProxyEmitters(e) {
                        return [{
                            capture: !1,
                            passive: !1
                        }, {
                            capture: !1,
                            passive: !0
                        }, {
                            capture: !0,
                            passive: !1
                        }, {
                            capture: !0,
                            passive: !0
                        }].map(t => this._getProxyEmitter(e, t)).filter(t => !!t)
                    }
                }
                : zA
            }
            ["_getProxyEmitter", "_getAllProxyEmitters", "on", "once", "off", "listenTo", "stopListening", "fire", "delegate", "stopDelegating", "_addEventListener", "_removeEventListener"].forEach(s => {
                qo[s] = zA.prototype[s]
            }
            );
            class i4 extends Se() {
                constructor(e, t) {
                    super(),
                    C(this, "_domNode"),
                    C(this, "_options"),
                    C(this, "_domListeners"),
                    dd(this, OA(e, t)),
                    this._domNode = e,
                    this._options = t
                }
                attach(e) {
                    if (this._domListeners && this._domListeners[e])
                        return;
                    const t = this._createDomListener(e);
                    this._domNode.addEventListener(e, t, this._options),
                    this._domListeners || (this._domListeners = {}),
                    this._domListeners[e] = t
                }
                detach(e) {
                    let t;
                    !this._domListeners[e] || (t = this._events[e]) && t.callbacks.length || this._domListeners[e].removeListener()
                }
                _addEventListener(e, t, r) {
                    this.attach(e),
                    Se().prototype._addEventListener.call(this, e, t, r)
                }
                _removeEventListener(e, t) {
                    Se().prototype._removeEventListener.call(this, e, t),
                    this.detach(e)
                }
                _createDomListener(e) {
                    const t = r => {
                        this.fire(e, r)
                    }
                    ;
                    return t.removeListener = () => {
                        this._domNode.removeEventListener(e, t, this._options),
                        delete this._domListeners[e]
                    }
                    ,
                    t
                }
            }
            function OA(s, e) {
                let t = function(r) {
                    return r["data-ck-expando"] || (r["data-ck-expando"] = H())
                }(s);
                for (const r of Object.keys(e).sort())
                    e[r] && (t += "-" + r);
                return t
            }
            function RA(s) {
                const e = s.ownerDocument.defaultView.getComputedStyle(s);
                return {
                    top: parseInt(e.borderTopWidth, 10),
                    right: parseInt(e.borderRightWidth, 10),
                    bottom: parseInt(e.borderBottomWidth, 10),
                    left: parseInt(e.borderLeftWidth, 10)
                }
            }
            function bt(s) {
                return Object.prototype.toString.call(s) == "[object Text]"
            }
            function Cd(s) {
                return Object.prototype.toString.apply(s) == "[object Range]"
            }
            function FA(s) {
                return s && s.parentNode ? s.offsetParent === w.document.body ? null : s.offsetParent : null
            }
            const VA = ["top", "right", "bottom", "left", "width", "height"];
            class De {
                constructor(e) {
                    C(this, "top"),
                    C(this, "right"),
                    C(this, "bottom"),
                    C(this, "left"),
                    C(this, "width"),
                    C(this, "height"),
                    C(this, "_source");
                    const t = Cd(e);
                    if (Object.defineProperty(this, "_source", {
                        value: e._source || e,
                        writable: !0,
                        enumerable: !1
                    }),
                    $m(e) || t)
                        if (t) {
                            const r = De.getDomRangeRects(e);
                            yd(this, De.getBoundingRect(r))
                        } else
                            yd(this, e.getBoundingClientRect());
                    else if (_d(e)) {
                        const {innerWidth: r, innerHeight: i} = e;
                        yd(this, {
                            top: 0,
                            right: r,
                            bottom: i,
                            left: 0,
                            width: r,
                            height: i
                        })
                    } else
                        yd(this, e)
                }
                clone() {
                    return new De(this)
                }
                moveTo(e, t) {
                    return this.top = t,
                    this.right = e + this.width,
                    this.bottom = t + this.height,
                    this.left = e,
                    this
                }
                moveBy(e, t) {
                    return this.top += t,
                    this.right += e,
                    this.left += e,
                    this.bottom += t,
                    this
                }
                getIntersection(e) {
                    const t = {
                        top: Math.max(this.top, e.top),
                        right: Math.min(this.right, e.right),
                        bottom: Math.min(this.bottom, e.bottom),
                        left: Math.max(this.left, e.left),
                        width: 0,
                        height: 0
                    };
                    if (t.width = t.right - t.left,
                    t.height = t.bottom - t.top,
                    t.width < 0 || t.height < 0)
                        return null;
                    {
                        const r = new De(t);
                        return r._source = this._source,
                        r
                    }
                }
                getIntersectionArea(e) {
                    const t = this.getIntersection(e);
                    return t ? t.getArea() : 0
                }
                getArea() {
                    return this.width * this.height
                }
                getVisible() {
                    const e = this._source;
                    let t = this.clone();
                    if (UA(e))
                        return t;
                    let r, i = e, l = e.parentNode || e.commonAncestorContainer;
                    for (; l && !UA(l); ) {
                        const h = ((d = l)instanceof HTMLElement ? d.ownerDocument.defaultView.getComputedStyle(d).overflow : "visible") === "visible";
                        i instanceof HTMLElement && HA(i) === "absolute" && (r = i);
                        const m = HA(l);
                        if (h || r && (m === "relative" && h || m !== "relative")) {
                            i = l,
                            l = l.parentNode;
                            continue
                        }
                        const g = new De(l)
                          , b = t.getIntersection(g);
                        if (!b)
                            return null;
                        b.getArea() < t.getArea() && (t = b),
                        i = l,
                        l = l.parentNode
                    }
                    var d;
                    return t
                }
                isEqual(e) {
                    for (const t of VA)
                        if (this[t] !== e[t])
                            return !1;
                    return !0
                }
                contains(e) {
                    const t = this.getIntersection(e);
                    return !(!t || !t.isEqual(e))
                }
                toAbsoluteRect() {
                    const {scrollX: e, scrollY: t} = w.window
                      , r = this.clone().moveBy(e, t);
                    if ($m(r._source)) {
                        const i = FA(r._source);
                        i && function(l, d) {
                            const h = new De(d)
                              , m = RA(d);
                            let g = 0
                              , b = 0;
                            g -= h.left,
                            b -= h.top,
                            g += d.scrollLeft,
                            b += d.scrollTop,
                            g -= m.left,
                            b -= m.top,
                            l.moveBy(g, b)
                        }(r, i)
                    }
                    return r
                }
                excludeScrollbarsAndBorders() {
                    const e = this._source;
                    let t, r, i;
                    if (_d(e))
                        t = e.innerWidth - e.document.documentElement.clientWidth,
                        r = e.innerHeight - e.document.documentElement.clientHeight,
                        i = e.getComputedStyle(e.document.documentElement).direction;
                    else {
                        const l = RA(e);
                        t = e.offsetWidth - e.clientWidth - l.left - l.right,
                        r = e.offsetHeight - e.clientHeight - l.top - l.bottom,
                        i = e.ownerDocument.defaultView.getComputedStyle(e).direction,
                        this.left += l.left,
                        this.top += l.top,
                        this.right -= l.right,
                        this.bottom -= l.bottom,
                        this.width = this.right - this.left,
                        this.height = this.bottom - this.top
                    }
                    return this.width -= t,
                    i === "ltr" ? this.right -= t : this.left += t,
                    this.height -= r,
                    this.bottom -= r,
                    this
                }
                static getDomRangeRects(e) {
                    const t = []
                      , r = Array.from(e.getClientRects());
                    if (r.length)
                        for (const i of r)
                            t.push(new De(i));
                    else {
                        let i = e.startContainer;
                        bt(i) && (i = i.parentNode);
                        const l = new De(i.getBoundingClientRect());
                        l.right = l.left,
                        l.width = 0,
                        t.push(l)
                    }
                    return t
                }
                static getBoundingRect(e) {
                    const t = {
                        left: Number.POSITIVE_INFINITY,
                        top: Number.POSITIVE_INFINITY,
                        right: Number.NEGATIVE_INFINITY,
                        bottom: Number.NEGATIVE_INFINITY,
                        width: 0,
                        height: 0
                    };
                    let r = 0;
                    for (const i of e)
                        r++,
                        t.left = Math.min(t.left, i.left),
                        t.top = Math.min(t.top, i.top),
                        t.right = Math.max(t.right, i.right),
                        t.bottom = Math.max(t.bottom, i.bottom);
                    return r == 0 ? null : (t.width = t.right - t.left,
                    t.height = t.bottom - t.top,
                    new De(t))
                }
            }
            function yd(s, e) {
                for (const t of VA)
                    s[t] = e[t]
            }
            function UA(s) {
                return !!$m(s) && s === s.ownerDocument.body
            }
            function $m(s) {
                return s !== null && typeof s == "object" && s.nodeType === 1 && typeof s.getBoundingClientRect == "function"
            }
            function HA(s) {
                return s instanceof HTMLElement ? s.ownerDocument.defaultView.getComputedStyle(s).position : "static"
            }
            const qm = class _t {
                constructor(e, t) {
                    C(this, "_element"),
                    C(this, "_callback"),
                    _t._observerInstance || _t._createObserver(),
                    this._element = e,
                    this._callback = t,
                    _t._addElementCallback(e, t),
                    _t._observerInstance.observe(e)
                }
                get element() {
                    return this._element
                }
                destroy() {
                    _t._deleteElementCallback(this._element, this._callback)
                }
                static _addElementCallback(e, t) {
                    _t._elementCallbacks || (_t._elementCallbacks = new Map);
                    let r = _t._elementCallbacks.get(e);
                    r || (r = new Set,
                    _t._elementCallbacks.set(e, r)),
                    r.add(t)
                }
                static _deleteElementCallback(e, t) {
                    const r = _t._getElementCallbacks(e);
                    r && (r.delete(t),
                    r.size || (_t._elementCallbacks.delete(e),
                    _t._observerInstance.unobserve(e))),
                    _t._elementCallbacks && !_t._elementCallbacks.size && (_t._observerInstance = null,
                    _t._elementCallbacks = null)
                }
                static _getElementCallbacks(e) {
                    return _t._elementCallbacks ? _t._elementCallbacks.get(e) : null
                }
                static _createObserver() {
                    _t._observerInstance = new w.window.ResizeObserver(e => {
                        for (const t of e) {
                            const r = _t._getElementCallbacks(t.target);
                            if (r)
                                for (const i of r)
                                    i(t)
                        }
                    }
                    )
                }
            }
            ;
            C(qm, "_observerInstance", null),
            C(qm, "_elementCallbacks", null);
            let Gm = qm;
            function WA(s, e) {
                s instanceof HTMLTextAreaElement && (s.value = e),
                s.innerHTML = e
            }
            function cl(s) {
                return e => e + s
            }
            function dl(s) {
                let e = 0;
                for (; s.previousSibling; )
                    s = s.previousSibling,
                    e++;
                return e
            }
            function $A(s, e, t) {
                s.insertBefore(t, s.childNodes[e] || null)
            }
            function ul(s) {
                return s && s.nodeType === Node.COMMENT_NODE
            }
            function yi(s) {
                return !!(s && s.getClientRects && s.getClientRects().length)
            }
            function Km({element: s, target: e, positions: t, limiter: r, fitInViewport: i, viewportOffsetConfig: l}) {
                wi(e) && (e = e()),
                wi(r) && (r = r());
                const d = FA(s)
                  , h = function(x) {
                    x = Object.assign({
                        top: 0,
                        bottom: 0,
                        left: 0,
                        right: 0
                    }, x);
                    const T = new De(w.window);
                    return T.top += x.top,
                    T.height -= x.top,
                    T.bottom -= x.bottom,
                    T.height -= x.bottom,
                    T
                }(l)
                  , m = new De(s)
                  , g = qA(e, h);
                let b;
                if (!g || !h.getIntersection(g))
                    return null;
                const v = {
                    targetRect: g,
                    elementRect: m,
                    positionedElementAncestor: d,
                    viewportRect: h
                };
                if (r || i) {
                    if (r) {
                        const x = qA(r, h);
                        x && (v.limiterRect = x)
                    }
                    b = function(x, T) {
                        const {elementRect: I} = T
                          , P = I.getArea()
                          , O = x.map(Q => new GA(Q,T)).filter(Q => !!Q.name);
                        let F = 0
                          , q = null;
                        for (const Q of O) {
                            const {limiterIntersectionArea: X, viewportIntersectionArea: le} = Q;
                            if (X === P)
                                return Q;
                            const ge = le ** 2 + X ** 2;
                            ge > F && (F = ge,
                            q = Q)
                        }
                        return q
                    }(t, v)
                } else
                    b = new GA(t[0],v);
                return b
            }
            function qA(s, e) {
                const t = new De(s).getVisible();
                return t ? t.getIntersection(e) : null
            }
            class GA {
                constructor(e, t) {
                    C(this, "name"),
                    C(this, "config"),
                    C(this, "_positioningFunctionCoordinates"),
                    C(this, "_options"),
                    C(this, "_cachedRect"),
                    C(this, "_cachedAbsoluteRect");
                    const r = e(t.targetRect, t.elementRect, t.viewportRect, t.limiterRect);
                    if (!r)
                        return;
                    const {left: i, top: l, name: d, config: h} = r;
                    this.name = d,
                    this.config = h,
                    this._positioningFunctionCoordinates = {
                        left: i,
                        top: l
                    },
                    this._options = t
                }
                get left() {
                    return this._absoluteRect.left
                }
                get top() {
                    return this._absoluteRect.top
                }
                get limiterIntersectionArea() {
                    const e = this._options.limiterRect;
                    return e ? e.getIntersectionArea(this._rect) : 0
                }
                get viewportIntersectionArea() {
                    return this._options.viewportRect.getIntersectionArea(this._rect)
                }
                get _rect() {
                    return this._cachedRect || (this._cachedRect = this._options.elementRect.clone().moveTo(this._positioningFunctionCoordinates.left, this._positioningFunctionCoordinates.top)),
                    this._cachedRect
                }
                get _absoluteRect() {
                    return this._cachedAbsoluteRect || (this._cachedAbsoluteRect = this._rect.toAbsoluteRect()),
                    this._cachedAbsoluteRect
                }
            }
            function KA(s) {
                const e = s.parentNode;
                e && e.removeChild(s)
            }
            function s4({window: s, rect: e, alignToTop: t, forceScroll: r, viewportOffset: i}) {
                const l = e.clone().moveBy(0, i.bottom)
                  , d = e.clone().moveBy(0, -i.top)
                  , h = new De(s).excludeScrollbarsAndBorders()
                  , m = t && r
                  , g = [d, l].every(I => h.contains(I));
                let {scrollX: b, scrollY: v} = s;
                const x = b
                  , T = v;
                m ? v -= h.top - e.top + i.top : g || (QA(d, h) ? v -= h.top - e.top + i.top : YA(l, h) && (v += t ? e.top - h.top - i.top : e.bottom - h.bottom + i.bottom)),
                g || (ZA(e, h) ? b -= h.left - e.left + i.left : JA(e, h) && (b += e.right - h.right + i.right)),
                b == x && v === T || s.scrollTo(b, v)
            }
            function a4({parent: s, getRect: e, alignToTop: t, forceScroll: r, ancestorOffset: i=0, limiterElement: l}) {
                const d = Ym(s)
                  , h = t && r;
                let m, g, b;
                const v = l || d.document.body;
                for (; s != v; )
                    g = e(),
                    m = new De(s).excludeScrollbarsAndBorders(),
                    b = m.contains(g),
                    h ? s.scrollTop -= m.top - g.top + i : b || (QA(g, m) ? s.scrollTop -= m.top - g.top + i : YA(g, m) && (s.scrollTop += t ? g.top - m.top - i : g.bottom - m.bottom + i)),
                    b || (ZA(g, m) ? s.scrollLeft -= m.left - g.left + i : JA(g, m) && (s.scrollLeft += g.right - m.right + i)),
                    s = s.parentNode
            }
            function YA(s, e) {
                return s.bottom > e.bottom
            }
            function QA(s, e) {
                return s.top < e.top
            }
            function ZA(s, e) {
                return s.left < e.left
            }
            function JA(s, e) {
                return s.right > e.right
            }
            function Ym(s) {
                return Cd(s) ? s.startContainer.ownerDocument.defaultView : s.ownerDocument.defaultView
            }
            function l4(s) {
                if (Cd(s)) {
                    let e = s.commonAncestorContainer;
                    return bt(e) && (e = e.parentNode),
                    e
                }
                return s.parentNode
            }
            function XA(s, e) {
                const t = Ym(s)
                  , r = new De(s);
                if (t === e)
                    return r;
                {
                    let i = t;
                    for (; i != e; ) {
                        const l = i.frameElement
                          , d = new De(l).excludeScrollbarsAndBorders();
                        r.moveBy(d.left, d.top),
                        i = i.parent
                    }
                }
                return r
            }
            const c4 = {
                ctrl: "⌃",
                cmd: "⌘",
                alt: "⌥",
                shift: "⇧"
            }
              , d4 = {
                ctrl: "Ctrl+",
                alt: "Alt+",
                shift: "Shift+"
            }
              , ev = {
                37: "←",
                38: "↑",
                39: "→",
                40: "↓",
                9: "⇥",
                33: "Page Up",
                34: "Page Down"
            }
              , Me = h4()
              , u4 = Object.fromEntries(Object.entries(Me).map( ([s,e]) => {
                let t;
                return t = e in ev ? ev[e] : s.charAt(0).toUpperCase() + s.slice(1),
                [e, t]
            }
            ));
            function _s(s) {
                let e;
                if (typeof s == "string") {
                    if (e = Me[s.toLowerCase()],
                    !e)
                        throw new U("keyboard-unknown-key",null,{
                            key: s
                        })
                } else
                    e = s.keyCode + (s.altKey ? Me.alt : 0) + (s.ctrlKey ? Me.ctrl : 0) + (s.shiftKey ? Me.shift : 0) + (s.metaKey ? Me.cmd : 0);
                return e
            }
            function Qm(s) {
                return typeof s == "string" && (s = function(e) {
                    return e.split("+").map(t => t.trim())
                }(s)),
                s.map(e => typeof e == "string" ? function(t) {
                    if (t.endsWith("!"))
                        return _s(t.slice(0, -1));
                    const r = _s(t);
                    return (E.isMac || E.isiOS) && r == Me.ctrl ? Me.cmd : r
                }(e) : e).reduce( (e, t) => t + e, 0)
            }
            function xd(s) {
                let e = Qm(s);
                return Object.entries(E.isMac || E.isiOS ? c4 : d4).reduce( (t, [r,i]) => (e & Me[r] && (e &= ~Me[r],
                t += i),
                t), "") + (e ? u4[e] : "")
            }
            function Zm(s, e) {
                const t = e === "ltr";
                switch (s) {
                case Me.arrowleft:
                    return t ? "left" : "right";
                case Me.arrowright:
                    return t ? "right" : "left";
                case Me.arrowup:
                    return "up";
                case Me.arrowdown:
                    return "down"
                }
            }
            function h4() {
                const s = {
                    pageup: 33,
                    pagedown: 34,
                    arrowleft: 37,
                    arrowup: 38,
                    arrowright: 39,
                    arrowdown: 40,
                    backspace: 8,
                    delete: 46,
                    enter: 13,
                    space: 32,
                    esc: 27,
                    tab: 9,
                    ctrl: 1114112,
                    shift: 2228224,
                    alt: 4456448,
                    cmd: 8912896
                };
                for (let e = 65; e <= 90; e++)
                    s[String.fromCharCode(e).toLowerCase()] = e;
                for (let e = 48; e <= 57; e++)
                    s[e - 48] = e;
                for (let e = 112; e <= 123; e++)
                    s["f" + (e - 111)] = e;
                return Object.assign(s, {
                    "'": 222,
                    ",": 108,
                    "-": 109,
                    ".": 110,
                    "/": 111,
                    ";": 186,
                    "=": 187,
                    "[": 219,
                    "\\": 220,
                    "]": 221,
                    "`": 223
                }),
                s
            }
            function Ze(s) {
                return Array.isArray(s) ? s : [s]
            }
            const Jm = function(s, e, t) {
                (t !== void 0 && !ol(s[e], t) || t === void 0 && !(e in s)) && kd(s, e, t)
            }
              , tv = function(s) {
                return function(e, t, r) {
                    for (var i = -1, l = Object(e), d = r(e), h = d.length; h--; ) {
                        var m = d[++i];
                        if (t(l[m], m, l) === !1)
                            break
                    }
                    return e
                }
            }()
              , m4 = function(s) {
                return Wo(s) && Ad(s)
            }
              , ov = function(s, e) {
                if ((e !== "constructor" || typeof s[e] != "function") && e != "__proto__")
                    return s[e]
            }
              , p4 = function(s) {
                return ws(s, vs(s))
            }
              , g4 = function(s, e, t, r, i, l, d) {
                var h = ov(s, t)
                  , m = ov(e, t)
                  , g = d.get(m);
                if (g)
                    Jm(s, t, g);
                else {
                    var b = void 0
                      , v = b === void 0;
                    if (v) {
                        var x = xo(m)
                          , T = !x && il(m)
                          , I = !x && !T && Pm(m);
                        b = m,
                        x || T || I ? xo(h) ? b = h : m4(h) ? b = pA(h) : T ? (v = !1,
                        b = mA(m, !0)) : I ? (v = !1,
                        b = SA(m, !0)) : b = [] : Eo(m) || bd(m) ? (b = h,
                        bd(h) ? b = p4(h) : Le(h) && !wi(h) || (b = TA(m))) : v = !1
                    }
                    v && (d.set(m, b),
                    i(b, m, r, l, d),
                    d.delete(m)),
                    Jm(s, t, b)
                }
            }
              , f4 = function s(e, t, r, i, l) {
                e !== t && tv(t, function(d, h) {
                    if (l || (l = new bs),
                    Le(d))
                        g4(e, t, h, r, s, i, l);
                    else {
                        var m = void 0;
                        m === void 0 && (m = d),
                        Jm(e, h, m)
                    }
                }, vs)
            }
              , In = function(s) {
                return s
            }
              , k4 = function(s, e, t) {
                switch (t.length) {
                case 0:
                    return s.call(e);
                case 1:
                    return s.call(e, t[0]);
                case 2:
                    return s.call(e, t[0], t[1]);
                case 3:
                    return s.call(e, t[0], t[1], t[2])
                }
                return s.apply(e, t)
            };
            var rv = Math.max;
            const b4 = function(s, e, t) {
                return e = rv(e === void 0 ? s.length - 1 : e, 0),
                function() {
                    for (var r = arguments, i = -1, l = rv(r.length - e, 0), d = Array(l); ++i < l; )
                        d[i] = r[e + i];
                    i = -1;
                    for (var h = Array(e + 1); ++i < e; )
                        h[i] = r[i];
                    return h[e] = t(d),
                    k4(s, this, h)
                }
            }
              , w4 = function(s) {
                return function() {
                    return s
                }
            }
              , A4 = fd ? function(s, e) {
                return fd(s, "toString", {
                    configurable: !0,
                    enumerable: !1,
                    value: w4(e),
                    writable: !0
                })
            }
            : In;
            var v4 = Date.now;
            const _4 = function(s) {
                var e = 0
                  , t = 0;
                return function() {
                    var r = v4()
                      , i = 16 - (r - t);
                    if (t = r,
                    i > 0) {
                        if (++e >= 800)
                            return arguments[0]
                    } else
                        e = 0;
                    return s.apply(void 0, arguments)
                }
            }(A4)
              , C4 = function(s, e) {
                return _4(b4(s, e, In), s + "")
            }
              , y4 = function(s, e, t) {
                if (!Le(t))
                    return !1;
                var r = typeof e;
                return !!(r == "number" ? Ad(t) && wd(e, t.length) : r == "string" && e in t) && ol(t[e], s)
            }
              , nv = function(s) {
                return C4(function(e, t) {
                    var r = -1
                      , i = t.length
                      , l = i > 1 ? t[i - 1] : void 0
                      , d = i > 2 ? t[2] : void 0;
                    for (l = s.length > 3 && typeof l == "function" ? (i--,
                    l) : void 0,
                    d && y4(t[0], t[1], d) && (l = i < 3 ? void 0 : l,
                    i = 1),
                    e = Object(e); ++r < i; ) {
                        var h = t[r];
                        h && s(e, h, r, l)
                    }
                    return e
                })
            }
              , Xm = nv(function(s, e, t) {
                f4(s, e, t)
            });
            function x4(s, e, t=1, r) {
                if (typeof t != "number")
                    throw new U("translation-service-quantity-not-a-number",null,{
                        quantity: t
                    });
                const i = r || w.window.CKEDITOR_TRANSLATIONS
                  , l = function(b) {
                    return Object.keys(b).length
                }(i);
                l === 1 && (s = Object.keys(i)[0]);
                const d = e.id || e.string;
                if (l === 0 || !function(b, v, x) {
                    return !!x[b] && !!x[b].dictionary[v]
                }(s, d, i))
                    return t !== 1 ? e.plural : e.string;
                const h = i[s].dictionary
                  , m = i[s].getPluralForm || (b => b === 1 ? 0 : 1)
                  , g = h[d];
                return typeof g == "string" ? g : g[Number(m(t))]
            }
            w.window.CKEDITOR_TRANSLATIONS || (w.window.CKEDITOR_TRANSLATIONS = {});
            const E4 = ["ar", "ara", "dv", "div", "fa", "per", "fas", "he", "heb", "ku", "kur", "ug", "uig"];
            function iv(s) {
                return E4.includes(s) ? "rtl" : "ltr"
            }
            class S4 {
                constructor({uiLanguage: e="en", contentLanguage: t, translations: r}={}) {
                    C(this, "uiLanguage"),
                    C(this, "uiLanguageDirection"),
                    C(this, "contentLanguage"),
                    C(this, "contentLanguageDirection"),
                    C(this, "t"),
                    C(this, "translations"),
                    this.uiLanguage = e,
                    this.contentLanguage = t || this.uiLanguage,
                    this.uiLanguageDirection = iv(this.uiLanguage),
                    this.contentLanguageDirection = iv(this.contentLanguage),
                    this.translations = function(i) {
                        return Array.isArray(i) ? i.reduce( (l, d) => Xm(l, d)) : i
                    }(r),
                    this.t = (i, l) => this._t(i, l)
                }
                get language() {
                    return console.warn("locale-deprecated-language-property: The Locale#language property has been deprecated and will be removed in the near future. Please use #uiLanguage and #contentLanguage properties instead."),
                    this.uiLanguage
                }
                _t(e, t=[]) {
                    t = Ze(t),
                    typeof e == "string" && (e = {
                        string: e
                    });
                    const r = e.plural ? t[0] : 1;
                    return function(i, l) {
                        return i.replace(/%(\d+)/g, (d, h) => h < l.length ? l[h] : d)
                    }(x4(this.uiLanguage, e, r, this.translations), t)
                }
            }
            class dr extends Se() {
                constructor(e={}, t={}) {
                    super(),
                    C(this, "_items"),
                    C(this, "_itemMap"),
                    C(this, "_idProperty"),
                    C(this, "_bindToCollection"),
                    C(this, "_bindToExternalToInternalMap"),
                    C(this, "_bindToInternalToExternalMap"),
                    C(this, "_skippedIndexesFromExternal");
                    const r = yo(e);
                    if (r || (t = e),
                    this._items = [],
                    this._itemMap = new Map,
                    this._idProperty = t.idProperty || "id",
                    this._bindToExternalToInternalMap = new WeakMap,
                    this._bindToInternalToExternalMap = new WeakMap,
                    this._skippedIndexesFromExternal = [],
                    r)
                        for (const i of e)
                            this._items.push(i),
                            this._itemMap.set(this._getItemIdBeforeAdding(i), i)
                }
                get length() {
                    return this._items.length
                }
                get first() {
                    return this._items[0] || null
                }
                get last() {
                    return this._items[this.length - 1] || null
                }
                add(e, t) {
                    return this.addMany([e], t)
                }
                addMany(e, t) {
                    if (t === void 0)
                        t = this._items.length;
                    else if (t > this._items.length || t < 0)
                        throw new U("collection-add-item-invalid-index",this);
                    let r = 0;
                    for (const i of e) {
                        const l = this._getItemIdBeforeAdding(i)
                          , d = t + r;
                        this._items.splice(d, 0, i),
                        this._itemMap.set(l, i),
                        this.fire("add", i, d),
                        r++
                    }
                    return this.fire("change", {
                        added: e,
                        removed: [],
                        index: t
                    }),
                    this
                }
                get(e) {
                    let t;
                    if (typeof e == "string")
                        t = this._itemMap.get(e);
                    else {
                        if (typeof e != "number")
                            throw new U("collection-get-invalid-arg",this);
                        t = this._items[e]
                    }
                    return t || null
                }
                has(e) {
                    if (typeof e == "string")
                        return this._itemMap.has(e);
                    {
                        const t = e[this._idProperty];
                        return t && this._itemMap.has(t)
                    }
                }
                getIndex(e) {
                    let t;
                    return t = typeof e == "string" ? this._itemMap.get(e) : e,
                    t ? this._items.indexOf(t) : -1
                }
                remove(e) {
                    const [t,r] = this._remove(e);
                    return this.fire("change", {
                        added: [],
                        removed: [t],
                        index: r
                    }),
                    t
                }
                map(e, t) {
                    return this._items.map(e, t)
                }
                forEach(e, t) {
                    this._items.forEach(e, t)
                }
                find(e, t) {
                    return this._items.find(e, t)
                }
                filter(e, t) {
                    return this._items.filter(e, t)
                }
                clear() {
                    this._bindToCollection && (this.stopListening(this._bindToCollection),
                    this._bindToCollection = null);
                    const e = Array.from(this._items);
                    for (; this.length; )
                        this._remove(0);
                    this.fire("change", {
                        added: [],
                        removed: e,
                        index: 0
                    })
                }
                bindTo(e) {
                    if (this._bindToCollection)
                        throw new U("collection-bind-to-rebind",this);
                    return this._bindToCollection = e,
                    {
                        as: t => {
                            this._setUpBindToBinding(r => new t(r))
                        }
                        ,
                        using: t => {
                            typeof t == "function" ? this._setUpBindToBinding(t) : this._setUpBindToBinding(r => r[t])
                        }
                    }
                }
                _setUpBindToBinding(e) {
                    const t = this._bindToCollection
                      , r = (i, l, d) => {
                        const h = t._bindToCollection == this
                          , m = t._bindToInternalToExternalMap.get(l);
                        if (h && m)
                            this._bindToExternalToInternalMap.set(l, m),
                            this._bindToInternalToExternalMap.set(m, l);
                        else {
                            const g = e(l);
                            if (!g)
                                return void this._skippedIndexesFromExternal.push(d);
                            let b = d;
                            for (const v of this._skippedIndexesFromExternal)
                                d > v && b--;
                            for (const v of t._skippedIndexesFromExternal)
                                b >= v && b++;
                            this._bindToExternalToInternalMap.set(l, g),
                            this._bindToInternalToExternalMap.set(g, l),
                            this.add(g, b);
                            for (let v = 0; v < t._skippedIndexesFromExternal.length; v++)
                                b <= t._skippedIndexesFromExternal[v] && t._skippedIndexesFromExternal[v]++
                        }
                    }
                    ;
                    for (const i of t)
                        r(0, i, t.getIndex(i));
                    this.listenTo(t, "add", r),
                    this.listenTo(t, "remove", (i, l, d) => {
                        const h = this._bindToExternalToInternalMap.get(l);
                        h && this.remove(h),
                        this._skippedIndexesFromExternal = this._skippedIndexesFromExternal.reduce( (m, g) => (d < g && m.push(g - 1),
                        d > g && m.push(g),
                        m), [])
                    }
                    )
                }
                _getItemIdBeforeAdding(e) {
                    const t = this._idProperty;
                    let r;
                    if (t in e) {
                        if (r = e[t],
                        typeof r != "string")
                            throw new U("collection-add-invalid-id",this);
                        if (this.get(r))
                            throw new U("collection-add-item-already-exists",this)
                    } else
                        e[t] = r = H();
                    return r
                }
                _remove(e) {
                    let t, r, i, l = !1;
                    const d = this._idProperty;
                    if (typeof e == "string" ? (r = e,
                    i = this._itemMap.get(r),
                    l = !i,
                    i && (t = this._items.indexOf(i))) : typeof e == "number" ? (t = e,
                    i = this._items[t],
                    l = !i,
                    i && (r = i[d])) : (i = e,
                    r = i[d],
                    t = this._items.indexOf(i),
                    l = t == -1 || !this._itemMap.get(r)),
                    l)
                        throw new U("collection-remove-404",this);
                    this._items.splice(t, 1),
                    this._itemMap.delete(r);
                    const h = this._bindToInternalToExternalMap.get(i);
                    return this._bindToInternalToExternalMap.delete(i),
                    this._bindToExternalToInternalMap.delete(h),
                    this.fire("remove", i, t),
                    [i, t]
                }
                [Symbol.iterator]() {
                    return this._items[Symbol.iterator]()
                }
            }
            function zt(s) {
                const e = s.next();
                return e.done ? null : e.value
            }
            class Jt extends qo(ye()) {
                constructor() {
                    super(),
                    C(this, "_elements", new Set),
                    C(this, "_nextEventLoopTimeout", null),
                    this.set("isFocused", !1),
                    this.set("focusedElement", null)
                }
                add(e) {
                    if (this._elements.has(e))
                        throw new U("focustracker-add-element-already-exist",this);
                    this.listenTo(e, "focus", () => this._focus(e), {
                        useCapture: !0
                    }),
                    this.listenTo(e, "blur", () => this._blur(), {
                        useCapture: !0
                    }),
                    this._elements.add(e)
                }
                remove(e) {
                    e === this.focusedElement && this._blur(),
                    this._elements.has(e) && (this.stopListening(e),
                    this._elements.delete(e))
                }
                destroy() {
                    this.stopListening()
                }
                _focus(e) {
                    clearTimeout(this._nextEventLoopTimeout),
                    this.focusedElement = e,
                    this.isFocused = !0
                }
                _blur() {
                    clearTimeout(this._nextEventLoopTimeout),
                    this._nextEventLoopTimeout = setTimeout( () => {
                        this.focusedElement = null,
                        this.isFocused = !1
                    }
                    , 0)
                }
            }
            class lo {
                constructor() {
                    C(this, "_listener"),
                    this._listener = new (qo())
                }
                listenTo(e) {
                    this._listener.listenTo(e, "keydown", (t, r) => {
                        this._listener.fire("_keydown:" + _s(r), r)
                    }
                    )
                }
                set(e, t, r={}) {
                    const i = Qm(e)
                      , l = r.priority;
                    this._listener.listenTo(this._listener, "_keydown:" + i, (d, h) => {
                        t(h, () => {
                            h.preventDefault(),
                            h.stopPropagation(),
                            d.stop()
                        }
                        ),
                        d.return = !0
                    }
                    , {
                        priority: l
                    })
                }
                press(e) {
                    return !!this._listener.fire("_keydown:" + _s(e), e)
                }
                stopListening(e) {
                    this._listener.stopListening(e)
                }
                destroy() {
                    this.stopListening()
                }
            }
            function Ir(s) {
                return yo(s) ? new Map(s) : function(e) {
                    const t = new Map;
                    for (const r in e)
                        t.set(r, e[r]);
                    return t
                }(s)
            }
            function ep(s, e) {
                let t;
                function r(...i) {
                    r.cancel(),
                    t = setTimeout( () => s(...i), e)
                }
                return r.cancel = () => {
                    clearTimeout(t)
                }
                ,
                r
            }
            function tp(s, e) {
                return !!(t = s.charAt(e - 1)) && t.length == 1 && /[\ud800-\udbff]/.test(t) && function(r) {
                    return !!r && r.length == 1 && /[\udc00-\udfff]/.test(r)
                }(s.charAt(e));
                var t
            }
            function op(s, e) {
                return !!(t = s.charAt(e)) && t.length == 1 && /[\u0300-\u036f\u1ab0-\u1aff\u1dc0-\u1dff\u20d0-\u20ff\ufe20-\ufe2f]/.test(t);
                var t
            }
            const D4 = T4();
            function sv(s, e) {
                const t = String(s).matchAll(D4);
                return Array.from(t).some(r => r.index < e && e < r.index + r[0].length)
            }
            function T4() {
                const s = new RegExp("\\p{Regional_Indicator}{2}","u").source
                  , e = "(?:" + [new RegExp("\\p{Emoji}[\\u{E0020}-\\u{E007E}]+\\u{E007F}","u"), new RegExp("\\p{Emoji}\\u{FE0F}?\\u{20E3}","u"), new RegExp("\\p{Emoji}\\u{FE0F}","u"), new RegExp("(?=\\p{General_Category=Other_Symbol})\\p{Emoji}\\p{Emoji_Modifier}*","u")].map(t => t.source).join("|") + ")";
                return new RegExp(`${s}|${e}(?:‍${e})*`,"ug")
            }
            class ur extends dr {
                constructor(e=[]) {
                    super(e, {
                        idProperty: "viewUid"
                    }),
                    C(this, "_parentElement"),
                    this.on("add", (t, r, i) => {
                        this._renderViewIntoCollectionParent(r, i)
                    }
                    ),
                    this.on("remove", (t, r) => {
                        r.element && this._parentElement && r.element.remove()
                    }
                    ),
                    this._parentElement = null
                }
                destroy() {
                    this.map(e => e.destroy())
                }
                setParent(e) {
                    this._parentElement = e;
                    for (const t of this)
                        this._renderViewIntoCollectionParent(t)
                }
                delegate(...e) {
                    if (!e.length || !e.every(t => typeof t == "string"))
                        throw new U("ui-viewcollection-delegate-wrong-events",this);
                    return {
                        to: t => {
                            for (const r of this)
                                for (const i of e)
                                    r.delegate(i).to(t);
                            this.on("add", (r, i) => {
                                for (const l of e)
                                    i.delegate(l).to(t)
                            }
                            ),
                            this.on("remove", (r, i) => {
                                for (const l of e)
                                    i.stopDelegating(l, t)
                            }
                            )
                        }
                    }
                }
                _renderViewIntoCollectionParent(e, t) {
                    e.isRendered || e.render(),
                    e.element && this._parentElement && this._parentElement.insertBefore(e.element, this._parentElement.children[t])
                }
                remove(e) {
                    return super.remove(e)
                }
            }
            class hr extends Se() {
                constructor(e) {
                    super(),
                    C(this, "ns"),
                    C(this, "tag"),
                    C(this, "text"),
                    C(this, "attributes"),
                    C(this, "children"),
                    C(this, "eventListeners"),
                    C(this, "_isRendered"),
                    C(this, "_revertData"),
                    Object.assign(this, dv(cv(e))),
                    this._isRendered = !1,
                    this._revertData = null
                }
                render() {
                    const e = this._renderNode({
                        intoFragment: !0
                    });
                    return this._isRendered = !0,
                    e
                }
                apply(e) {
                    return this._revertData = {
                        children: [],
                        bindings: [],
                        attributes: {}
                    },
                    this._renderNode({
                        node: e,
                        intoFragment: !1,
                        isApplying: !0,
                        revertData: this._revertData
                    }),
                    e
                }
                revert(e) {
                    if (!this._revertData)
                        throw new U("ui-template-revert-not-applied",[this, e]);
                    this._revertTemplateFromNode(e, this._revertData)
                }
                *getViews() {
                    yield*function *e(t) {
                        if (t.children)
                            for (const r of t.children)
                                Sd(r) ? yield r : rp(r) && (yield*e(r))
                    }(this)
                }
                static bind(e, t) {
                    return {
                        to: (r, i) => new I4({
                            eventNameOrFunction: r,
                            attribute: r,
                            observable: e,
                            emitter: t,
                            callback: i
                        }),
                        if: (r, i, l) => new av({
                            observable: e,
                            emitter: t,
                            attribute: r,
                            valueIfTrue: i,
                            callback: l
                        })
                    }
                }
                static extend(e, t) {
                    if (e._isRendered)
                        throw new U("template-extend-render",[this, e]);
                    pv(e, dv(cv(t)))
                }
                _renderNode(e) {
                    let t;
                    if (t = e.node ? this.tag && this.text : this.tag ? this.text : !this.text,
                    t)
                        throw new U("ui-template-wrong-syntax",this);
                    return this.text ? this._renderText(e) : this._renderElement(e)
                }
                _renderElement(e) {
                    let t = e.node;
                    return t || (t = e.node = document.createElementNS(this.ns || "http://www.w3.org/1999/xhtml", this.tag)),
                    this._renderAttributes(e),
                    this._renderElementChildren(e),
                    this._setUpListeners(e),
                    t
                }
                _renderText(e) {
                    let t = e.node;
                    return t ? e.revertData.text = t.textContent : t = e.node = document.createTextNode(""),
                    Ed(this.text) ? this._bindToObservable({
                        schema: this.text,
                        updater: M4(t),
                        data: e
                    }) : t.textContent = this.text.join(""),
                    t
                }
                _renderAttributes(e) {
                    if (!this.attributes)
                        return;
                    const t = e.node
                      , r = e.revertData;
                    for (const i in this.attributes) {
                        const l = t.getAttribute(i)
                          , d = this.attributes[i];
                        r && (r.attributes[i] = l);
                        const h = gv(d) ? d[0].ns : null;
                        if (Ed(d)) {
                            const m = gv(d) ? d[0].value : d;
                            r && fv(i) && m.unshift(l),
                            this._bindToObservable({
                                schema: m,
                                updater: B4(t, i, h),
                                data: e
                            })
                        } else if (i == "style" && typeof d[0] != "string")
                            this._renderStyleAttribute(d[0], e);
                        else {
                            r && l && fv(i) && d.unshift(l);
                            const m = d.map(g => g && g.value || g).reduce( (g, b) => g.concat(b), []).reduce(hv, "");
                            Cs(m) || t.setAttributeNS(h, i, m)
                        }
                    }
                }
                _renderStyleAttribute(e, t) {
                    const r = t.node;
                    for (const i in e) {
                        const l = e[i];
                        Ed(l) ? this._bindToObservable({
                            schema: [l],
                            updater: N4(r, i),
                            data: t
                        }) : r.style[i] = l
                    }
                }
                _renderElementChildren(e) {
                    const t = e.node
                      , r = e.intoFragment ? document.createDocumentFragment() : t
                      , i = e.isApplying;
                    let l = 0;
                    for (const d of this.children)
                        if (np(d)) {
                            if (!i) {
                                d.setParent(t);
                                for (const h of d)
                                    r.appendChild(h.element)
                            }
                        } else if (Sd(d))
                            i || (d.isRendered || d.render(),
                            r.appendChild(d.element));
                        else if (Tn(d))
                            r.appendChild(d);
                        else if (i) {
                            const h = {
                                children: [],
                                bindings: [],
                                attributes: {}
                            };
                            e.revertData.children.push(h),
                            d._renderNode({
                                intoFragment: !1,
                                node: r.childNodes[l++],
                                isApplying: !0,
                                revertData: h
                            })
                        } else
                            r.appendChild(d.render());
                    e.intoFragment && t.appendChild(r)
                }
                _setUpListeners(e) {
                    if (this.eventListeners)
                        for (const t in this.eventListeners) {
                            const r = this.eventListeners[t].map(i => {
                                const [l,d] = t.split("@");
                                return i.activateDomEventListener(l, d, e)
                            }
                            );
                            e.revertData && e.revertData.bindings.push(r)
                        }
                }
                _bindToObservable({schema: e, updater: t, data: r}) {
                    const i = r.revertData;
                    lv(e, t, r);
                    const l = e.filter(d => !Cs(d)).filter(d => d.observable).map(d => d.activateAttributeListener(e, t, r));
                    i && i.bindings.push(l)
                }
                _revertTemplateFromNode(e, t) {
                    for (const i of t.bindings)
                        for (const l of i)
                            l();
                    if (t.text)
                        return void (e.textContent = t.text);
                    const r = e;
                    for (const i in t.attributes) {
                        const l = t.attributes[i];
                        l === null ? r.removeAttribute(i) : r.setAttribute(i, l)
                    }
                    for (let i = 0; i < t.children.length; ++i)
                        this._revertTemplateFromNode(r.childNodes[i], t.children[i])
                }
            }
            class hl {
                constructor(e) {
                    C(this, "attribute"),
                    C(this, "observable"),
                    C(this, "emitter"),
                    C(this, "callback"),
                    this.attribute = e.attribute,
                    this.observable = e.observable,
                    this.emitter = e.emitter,
                    this.callback = e.callback
                }
                getValue(e) {
                    const t = this.observable[this.attribute];
                    return this.callback ? this.callback(t, e) : t
                }
                activateAttributeListener(e, t, r) {
                    const i = () => lv(e, t, r);
                    return this.emitter.listenTo(this.observable, `change:${this.attribute}`, i),
                    () => {
                        this.emitter.stopListening(this.observable, `change:${this.attribute}`, i)
                    }
                }
            }
            class I4 extends hl {
                constructor(e) {
                    super(e),
                    C(this, "eventNameOrFunction"),
                    this.eventNameOrFunction = e.eventNameOrFunction
                }
                activateDomEventListener(e, t, r) {
                    const i = (l, d) => {
                        t && !d.target.matches(t) || (typeof this.eventNameOrFunction == "function" ? this.eventNameOrFunction(d) : this.observable.fire(this.eventNameOrFunction, d))
                    }
                    ;
                    return this.emitter.listenTo(r.node, e, i),
                    () => {
                        this.emitter.stopListening(r.node, e, i)
                    }
                }
            }
            class av extends hl {
                constructor(e) {
                    super(e),
                    C(this, "valueIfTrue"),
                    this.valueIfTrue = e.valueIfTrue
                }
                getValue(e) {
                    return !Cs(super.getValue(e)) && (this.valueIfTrue || !0)
                }
            }
            function Ed(s) {
                return !!s && (s.value && (s = s.value),
                Array.isArray(s) ? s.some(Ed) : s instanceof hl)
            }
            function lv(s, e, {node: t}) {
                const r = function(l, d) {
                    return l.map(h => h instanceof hl ? h.getValue(d) : h)
                }(s, t);
                let i;
                i = s.length == 1 && s[0]instanceof av ? r[0] : r.reduce(hv, ""),
                Cs(i) ? e.remove() : e.set(i)
            }
            function M4(s) {
                return {
                    set(e) {
                        s.textContent = e
                    },
                    remove() {
                        s.textContent = ""
                    }
                }
            }
            function B4(s, e, t) {
                return {
                    set(r) {
                        s.setAttributeNS(t, e, r)
                    },
                    remove() {
                        s.removeAttributeNS(t, e)
                    }
                }
            }
            function N4(s, e) {
                return {
                    set(t) {
                        s.style[e] = t
                    },
                    remove() {
                        s.style[e] = null
                    }
                }
            }
            function cv(s) {
                return Wm(s, e => {
                    if (e && (e instanceof hl || rp(e) || Sd(e) || np(e)))
                        return e
                }
                )
            }
            function dv(s) {
                if (typeof s == "string" ? s = function(e) {
                    return {
                        text: [e]
                    }
                }(s) : s.text && function(e) {
                    e.text = Ze(e.text)
                }(s),
                s.on && (s.eventListeners = function(e) {
                    for (const t in e)
                        uv(e, t);
                    return e
                }(s.on),
                delete s.on),
                !s.text) {
                    s.attributes && function(t) {
                        for (const r in t)
                            t[r].value && (t[r].value = Ze(t[r].value)),
                            uv(t, r)
                    }(s.attributes);
                    const e = [];
                    if (s.children)
                        if (np(s.children))
                            e.push(s.children);
                        else
                            for (const t of s.children)
                                rp(t) || Sd(t) || Tn(t) ? e.push(t) : e.push(new hr(t));
                    s.children = e
                }
                return s
            }
            function uv(s, e) {
                s[e] = Ze(s[e])
            }
            function hv(s, e) {
                return Cs(e) ? s : Cs(s) ? e : `${s} ${e}`
            }
            function mv(s, e) {
                for (const t in e)
                    s[t] ? s[t].push(...e[t]) : s[t] = e[t]
            }
            function pv(s, e) {
                if (e.attributes && (s.attributes || (s.attributes = {}),
                mv(s.attributes, e.attributes)),
                e.eventListeners && (s.eventListeners || (s.eventListeners = {}),
                mv(s.eventListeners, e.eventListeners)),
                e.text && s.text.push(...e.text),
                e.children && e.children.length) {
                    if (s.children.length != e.children.length)
                        throw new U("ui-template-extend-children-mismatch",s);
                    let t = 0;
                    for (const r of e.children)
                        pv(s.children[t++], r)
                }
            }
            function Cs(s) {
                return !s && s !== 0
            }
            function Sd(s) {
                return s instanceof pe
            }
            function rp(s) {
                return s instanceof hr
            }
            function np(s) {
                return s instanceof ur
            }
            function gv(s) {
                return Le(s[0]) && s[0].ns
            }
            function fv(s) {
                return s == "class" || s == "style"
            }
            var P4 = u(2591)
              , se = u.n(P4)
              , kv = u(7676)
              , j4 = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(kv.A, j4),
            kv.A.locals;
            class pe extends qo(ye()) {
                constructor(e) {
                    super(),
                    C(this, "element"),
                    C(this, "isRendered"),
                    C(this, "locale"),
                    C(this, "t"),
                    C(this, "template"),
                    C(this, "_viewCollections"),
                    C(this, "_unboundChildren"),
                    C(this, "_bindTemplate"),
                    this.element = null,
                    this.isRendered = !1,
                    this.locale = e,
                    this.t = e && e.t,
                    this._viewCollections = new dr,
                    this._unboundChildren = this.createCollection(),
                    this._viewCollections.on("add", (t, r) => {
                        r.locale = e,
                        r.t = e && e.t
                    }
                    ),
                    this.decorate("render")
                }
                get bindTemplate() {
                    return this._bindTemplate ? this._bindTemplate : this._bindTemplate = hr.bind(this, this)
                }
                createCollection(e) {
                    const t = new ur(e);
                    return this._viewCollections.add(t),
                    t
                }
                registerChild(e) {
                    yo(e) || (e = [e]);
                    for (const t of e)
                        this._unboundChildren.add(t)
                }
                deregisterChild(e) {
                    yo(e) || (e = [e]);
                    for (const t of e)
                        this._unboundChildren.remove(t)
                }
                setTemplate(e) {
                    this.template = new hr(e)
                }
                extendTemplate(e) {
                    hr.extend(this.template, e)
                }
                render() {
                    if (this.isRendered)
                        throw new U("ui-view-render-already-rendered",this);
                    this.template && (this.element = this.template.render(),
                    this.registerChild(this.template.getViews())),
                    this.isRendered = !0
                }
                destroy() {
                    this.stopListening(),
                    this._viewCollections.map(e => e.destroy()),
                    this.template && this.template._revertData && this.template.revert(this.element)
                }
            }
            function Dd({emitter: s, activator: e, callback: t, contextElements: r}) {
                s.listenTo(document, "mousedown", (i, l) => {
                    if (!e())
                        return;
                    const d = typeof l.composedPath == "function" ? l.composedPath() : []
                      , h = typeof r == "function" ? r() : r;
                    for (const m of h)
                        if (m.contains(l.target) || d.includes(m))
                            return;
                    t()
                }
                )
            }
            function ip(s) {
                return class extends s {
                    disableCssTransitions() {
                        this._isCssTransitionsDisabled = !0
                    }
                    enableCssTransitions() {
                        this._isCssTransitionsDisabled = !1
                    }
                    constructor(...e) {
                        super(...e),
                        this.set("_isCssTransitionsDisabled", !1),
                        this.initializeCssTransitionDisablerMixin()
                    }
                    initializeCssTransitionDisablerMixin() {
                        this.extendTemplate({
                            attributes: {
                                class: [this.bindTemplate.if("_isCssTransitionsDisabled", "ck-transitions-disabled")]
                            }
                        })
                    }
                }
            }
            function Td({view: s}) {
                s.listenTo(s.element, "submit", (e, t) => {
                    t.preventDefault(),
                    s.fire("submit")
                }
                , {
                    useCapture: !0
                })
            }
            function L4({keystrokeHandler: s, focusTracker: e, gridItems: t, numberOfColumns: r, uiLanguageDirection: i}) {
                const l = () => r;
                function d(g) {
                    return b => {
                        const v = t.find(I => I.element === e.focusedElement)
                          , x = t.getIndex(v)
                          , T = g(x, t);
                        t.get(T).focus(),
                        b.stopPropagation(),
                        b.preventDefault()
                    }
                }
                function h(g, b) {
                    return g === b - 1 ? 0 : g + 1
                }
                function m(g, b) {
                    return g === 0 ? b - 1 : g - 1
                }
                s.set("arrowright", d( (g, b) => i === "rtl" ? m(g, b.length) : h(g, b.length))),
                s.set("arrowleft", d( (g, b) => i === "rtl" ? h(g, b.length) : m(g, b.length))),
                s.set("arrowup", d( (g, b) => {
                    let v = g - l();
                    return v < 0 && (v = g + l() * Math.floor(b.length / l()),
                    v > b.length - 1 && (v -= l())),
                    v
                }
                )),
                s.set("arrowdown", d( (g, b) => {
                    let v = g + l();
                    return v > b.length - 1 && (v = g % l()),
                    v
                }
                ))
            }
            class ie extends ye() {
                constructor(e) {
                    super(),
                    C(this, "editor"),
                    C(this, "_disableStack", new Set),
                    this.editor = e,
                    this.set("isEnabled", !0)
                }
                forceDisabled(e) {
                    this._disableStack.add(e),
                    this._disableStack.size == 1 && (this.on("set:isEnabled", bv, {
                        priority: "highest"
                    }),
                    this.isEnabled = !1)
                }
                clearForceDisabled(e) {
                    this._disableStack.delete(e),
                    this._disableStack.size == 0 && (this.off("set:isEnabled", bv),
                    this.isEnabled = !0)
                }
                destroy() {
                    this.stopListening()
                }
                static get isContextPlugin() {
                    return !1
                }
            }
            function bv(s) {
                s.return = !1,
                s.stop()
            }
            class _e extends ye() {
                constructor(e) {
                    super(),
                    C(this, "editor"),
                    C(this, "_isEnabledBasedOnSelection"),
                    C(this, "_affectsData"),
                    C(this, "_disableStack"),
                    this.editor = e,
                    this.set("value", void 0),
                    this.set("isEnabled", !1),
                    this._affectsData = !0,
                    this._isEnabledBasedOnSelection = !0,
                    this._disableStack = new Set,
                    this.decorate("execute"),
                    this.listenTo(this.editor.model.document, "change", () => {
                        this.refresh()
                    }
                    ),
                    this.listenTo(e, "change:isReadOnly", () => {
                        this.refresh()
                    }
                    ),
                    this.on("set:isEnabled", t => {
                        if (!this.affectsData)
                            return;
                        const r = e.model.document.selection
                          , i = r.getFirstPosition().root.rootName != "$graveyard" && e.model.canEditAt(r);
                        (e.isReadOnly || this._isEnabledBasedOnSelection && !i) && (t.return = !1,
                        t.stop())
                    }
                    , {
                        priority: "highest"
                    }),
                    this.on("execute", t => {
                        this.isEnabled || t.stop()
                    }
                    , {
                        priority: "high"
                    })
                }
                get affectsData() {
                    return this._affectsData
                }
                set affectsData(e) {
                    this._affectsData = e
                }
                refresh() {
                    this.isEnabled = !0
                }
                forceDisabled(e) {
                    this._disableStack.add(e),
                    this._disableStack.size == 1 && (this.on("set:isEnabled", wv, {
                        priority: "highest"
                    }),
                    this.isEnabled = !1)
                }
                clearForceDisabled(e) {
                    this._disableStack.delete(e),
                    this._disableStack.size == 0 && (this.off("set:isEnabled", wv),
                    this.refresh())
                }
                execute(...e) {}
                destroy() {
                    this.stopListening()
                }
            }
            function wv(s) {
                s.return = !1,
                s.stop()
            }
            class Av extends _e {
                constructor() {
                    super(...arguments),
                    C(this, "_childCommandsDefinitions", [])
                }
                refresh() {}
                execute(...e) {
                    const t = this._getFirstEnabledCommand();
                    return !!t && t.execute(e)
                }
                registerChildCommand(e, t={}) {
                    ee(this._childCommandsDefinitions, {
                        command: e,
                        priority: t.priority || "normal"
                    }),
                    e.on("change:isEnabled", () => this._checkEnabled()),
                    this._checkEnabled()
                }
                _checkEnabled() {
                    this.isEnabled = !!this._getFirstEnabledCommand()
                }
                _getFirstEnabledCommand() {
                    const e = this._childCommandsDefinitions.find( ({command: t}) => t.isEnabled);
                    return e && e.command
                }
            }
            class vv extends Se() {
                constructor(e, t=[], r=[]) {
                    super(),
                    C(this, "_context"),
                    C(this, "_plugins", new Map),
                    C(this, "_availablePlugins"),
                    C(this, "_contextPlugins"),
                    this._context = e,
                    this._availablePlugins = new Map;
                    for (const i of t)
                        i.pluginName && this._availablePlugins.set(i.pluginName, i);
                    this._contextPlugins = new Map;
                    for (const [i,l] of r)
                        this._contextPlugins.set(i, l),
                        this._contextPlugins.set(l, i),
                        i.pluginName && this._availablePlugins.set(i.pluginName, i)
                }
                *[Symbol.iterator]() {
                    for (const e of this._plugins)
                        typeof e[0] == "function" && (yield e)
                }
                get(e) {
                    const t = this._plugins.get(e);
                    if (!t) {
                        let r = e;
                        throw typeof e == "function" && (r = e.pluginName || e.name),
                        new U("plugincollection-plugin-not-loaded",this._context,{
                            plugin: r
                        })
                    }
                    return t
                }
                has(e) {
                    return this._plugins.has(e)
                }
                init(e, t=[], r=[]) {
                    const i = this
                      , l = this._context;
                    (function I(P, O=new Set) {
                        P.forEach(F => {
                            m(F) && (O.has(F) || (O.add(F),
                            F.pluginName && !i._availablePlugins.has(F.pluginName) && i._availablePlugins.set(F.pluginName, F),
                            F.requires && I(F.requires, O)))
                        }
                        )
                    }
                    )(e),
                    x(e);
                    const d = [...function I(P, O=new Set) {
                        return P.map(F => m(F) ? F : i._availablePlugins.get(F)).reduce( (F, q) => O.has(q) ? F : (O.add(q),
                        q.requires && (x(q.requires, q),
                        I(q.requires, O).forEach(Q => F.add(Q))),
                        F.add(q)), new Set)
                    }(e.filter(I => !b(I, t)))];
                    (function(I, P) {
                        for (const O of P) {
                            if (typeof O != "function")
                                throw new U("plugincollection-replace-plugin-invalid-type",null,{
                                    pluginItem: O
                                });
                            const F = O.pluginName;
                            if (!F)
                                throw new U("plugincollection-replace-plugin-missing-name",null,{
                                    pluginItem: O
                                });
                            if (O.requires && O.requires.length)
                                throw new U("plugincollection-plugin-for-replacing-cannot-have-dependencies",null,{
                                    pluginName: F
                                });
                            const q = i._availablePlugins.get(F);
                            if (!q)
                                throw new U("plugincollection-plugin-for-replacing-not-exist",null,{
                                    pluginName: F
                                });
                            const Q = I.indexOf(q);
                            if (Q === -1) {
                                if (i._contextPlugins.has(q))
                                    return;
                                throw new U("plugincollection-plugin-for-replacing-not-loaded",null,{
                                    pluginName: F
                                })
                            }
                            if (q.requires && q.requires.length)
                                throw new U("plugincollection-replaced-plugin-cannot-have-dependencies",null,{
                                    pluginName: F
                                });
                            I.splice(Q, 1, O),
                            i._availablePlugins.set(F, O)
                        }
                    }
                    )(d, r);
                    const h = d.map(I => {
                        let P = i._contextPlugins.get(I);
                        return P = P || new I(l),
                        i._add(I, P),
                        P
                    }
                    );
                    return T(h, "init").then( () => T(h, "afterInit")).then( () => h);
                    function m(I) {
                        return typeof I == "function"
                    }
                    function g(I) {
                        return m(I) && !!I.isContextPlugin
                    }
                    function b(I, P) {
                        return P.some(O => O === I || v(I) === O || v(O) === I)
                    }
                    function v(I) {
                        return m(I) ? I.pluginName || I.name : I
                    }
                    function x(I, P=null) {
                        I.map(O => m(O) ? O : i._availablePlugins.get(O) || O).forEach(O => {
                            (function(F, q) {
                                if (!m(F))
                                    throw q ? new U("plugincollection-soft-required",l,{
                                        missingPlugin: F,
                                        requiredBy: v(q)
                                    }) : new U("plugincollection-plugin-not-found",l,{
                                        plugin: F
                                    })
                            }
                            )(O, P),
                            function(F, q) {
                                if (g(q) && !g(F))
                                    throw new U("plugincollection-context-required",l,{
                                        plugin: v(F),
                                        requiredBy: v(q)
                                    })
                            }(O, P),
                            function(F, q) {
                                if (q && b(F, t))
                                    throw new U("plugincollection-required",l,{
                                        plugin: v(F),
                                        requiredBy: v(q)
                                    })
                            }(O, P)
                        }
                        )
                    }
                    function T(I, P) {
                        return I.reduce( (O, F) => F[P] ? i._contextPlugins.has(F) ? O : O.then(F[P].bind(F)) : O, Promise.resolve())
                    }
                }
                destroy() {
                    const e = [];
                    for (const [,t] of this)
                        typeof t.destroy != "function" || this._contextPlugins.has(t) || e.push(t.destroy());
                    return Promise.all(e)
                }
                _add(e, t) {
                    this._plugins.set(e, t);
                    const r = e.pluginName;
                    if (r) {
                        if (this._plugins.has(r))
                            throw new U("plugincollection-plugin-name-conflict",null,{
                                pluginName: r,
                                plugin1: this._plugins.get(r).constructor,
                                plugin2: e
                            });
                        this._plugins.set(r, t)
                    }
                }
            }
            class Id {
                constructor(e) {
                    C(this, "config"),
                    C(this, "plugins"),
                    C(this, "locale"),
                    C(this, "t"),
                    C(this, "editors"),
                    C(this, "_contextOwner", null);
                    const {translations: t, ...r} = e || {};
                    this.config = new jA(r,this.constructor.defaultConfig);
                    const i = this.constructor.builtinPlugins;
                    this.config.define("plugins", i),
                    this.plugins = new vv(this,i);
                    const l = this.config.get("language") || {};
                    this.locale = new S4({
                        uiLanguage: typeof l == "string" ? l : l.ui,
                        contentLanguage: this.config.get("language.content"),
                        translations: t
                    }),
                    this.t = this.locale.t,
                    this.editors = new dr
                }
                initPlugins() {
                    const e = this.config.get("plugins") || []
                      , t = this.config.get("substitutePlugins") || [];
                    for (const r of e.concat(t)) {
                        if (typeof r != "function")
                            throw new U("context-initplugins-constructor-only",null,{
                                Plugin: r
                            });
                        if (r.isContextPlugin !== !0)
                            throw new U("context-initplugins-invalid-plugin",null,{
                                Plugin: r
                            })
                    }
                    return this.plugins.init(e, [], t)
                }
                destroy() {
                    return Promise.all(Array.from(this.editors, e => e.destroy())).then( () => this.plugins.destroy())
                }
                _addEditor(e, t) {
                    if (this._contextOwner)
                        throw new U("context-addeditor-private-context");
                    this.editors.add(e),
                    t && (this._contextOwner = e)
                }
                _removeEditor(e) {
                    return this.editors.has(e) && this.editors.remove(e),
                    this._contextOwner === e ? this.destroy() : Promise.resolve()
                }
                _getEditorConfig() {
                    const e = {};
                    for (const t of this.config.names())
                        ["plugins", "removePlugins", "extraPlugins"].includes(t) || (e[t] = this.config.get(t));
                    return e
                }
                static create(e) {
                    return new Promise(t => {
                        const r = new this(e);
                        t(r.initPlugins().then( () => r))
                    }
                    )
                }
            }
            C(Id, "defaultConfig"),
            C(Id, "builtinPlugins");
            class Md extends ye() {
                constructor(e) {
                    super(),
                    C(this, "context"),
                    this.context = e
                }
                destroy() {
                    this.stopListening()
                }
                static get isContextPlugin() {
                    return !0
                }
            }
            class z4 extends lo {
                constructor(e) {
                    super(),
                    C(this, "editor"),
                    this.editor = e
                }
                set(e, t, r={}) {
                    if (typeof t == "string") {
                        const i = t;
                        t = (l, d) => {
                            this.editor.execute(i),
                            d()
                        }
                    }
                    super.set(e, t, r)
                }
            }
            var _v = u(4098)
              , O4 = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(_v.A, O4),
            _v.A.locals;
            const Bd = new WeakMap;
            let Cv = !1;
            function yv({view: s, element: e, text: t, isDirectHost: r=!0, keepOnFocus: i=!1}) {
                const l = s.document;
                function d(h) {
                    Bd.get(l).set(e, {
                        text: h,
                        isDirectHost: r,
                        keepOnFocus: i,
                        hostElement: r ? e : null
                    }),
                    s.change(m => sp(l, m))
                }
                Bd.has(l) || (Bd.set(l, new Map),
                l.registerPostFixer(h => sp(l, h)),
                l.on("change:isComposing", () => {
                    s.change(h => sp(l, h))
                }
                , {
                    priority: "high"
                })),
                e.is("editableElement") && e.on("change:placeholder", (h, m, g) => {
                    d(g)
                }
                ),
                e.placeholder ? d(e.placeholder) : t && d(t),
                t && function() {
                    Cv || de("enableplaceholder-deprecated-text-option"),
                    Cv = !0
                }()
            }
            function R4(s, e) {
                return !!e.hasClass("ck-placeholder") && (s.removeClass("ck-placeholder", e),
                !0)
            }
            function sp(s, e) {
                const t = Bd.get(s)
                  , r = [];
                let i = !1;
                for (const [l,d] of t)
                    d.isDirectHost && (r.push(l),
                    xv(e, l, d) && (i = !0));
                for (const [l,d] of t) {
                    if (d.isDirectHost)
                        continue;
                    const h = F4(l);
                    h && (r.includes(h) || (d.hostElement = h,
                    xv(e, l, d) && (i = !0)))
                }
                return i
            }
            function xv(s, e, t) {
                const {text: r, isDirectHost: i, hostElement: l} = t;
                let d = !1;
                return l.getAttribute("data-placeholder") !== r && (s.setAttribute("data-placeholder", r, l),
                d = !0),
                (i || e.childCount == 1) && function(h, m) {
                    if (!h.isAttached() || Array.from(h.getChildren()).some(v => !v.is("uiElement")))
                        return !1;
                    const g = h.document
                      , b = g.selection.anchor;
                    return !(g.isComposing && b && b.parent === h || !m && g.isFocused && (!b || b.parent === h))
                }(l, t.keepOnFocus) ? function(h, m) {
                    return !m.hasClass("ck-placeholder") && (h.addClass("ck-placeholder", m),
                    !0)
                }(s, l) && (d = !0) : R4(s, l) && (d = !0),
                d
            }
            function F4(s) {
                if (s.childCount) {
                    const e = s.getChild(0);
                    if (e.is("element") && !e.is("uiElement") && !e.is("attributeElement"))
                        return e
                }
                return null
            }
            class xi {
                is() {
                    throw new Error("is() method is abstract")
                }
            }
            const Ev = function(s) {
                return Hm(s, 4)
            };
            class Ei extends Se(xi) {
                constructor(e) {
                    super(),
                    C(this, "document"),
                    C(this, "parent"),
                    this.document = e,
                    this.parent = null
                }
                get index() {
                    let e;
                    if (!this.parent)
                        return null;
                    if ((e = this.parent.getChildIndex(this)) == -1)
                        throw new U("view-node-not-found-in-parent",this);
                    return e
                }
                get nextSibling() {
                    const e = this.index;
                    return e !== null && this.parent.getChild(e + 1) || null
                }
                get previousSibling() {
                    const e = this.index;
                    return e !== null && this.parent.getChild(e - 1) || null
                }
                get root() {
                    let e = this;
                    for (; e.parent; )
                        e = e.parent;
                    return e
                }
                isAttached() {
                    return this.root.is("rootElement")
                }
                getPath() {
                    const e = [];
                    let t = this;
                    for (; t.parent; )
                        e.unshift(t.index),
                        t = t.parent;
                    return e
                }
                getAncestors(e={}) {
                    const t = [];
                    let r = e.includeSelf ? this : this.parent;
                    for (; r; )
                        t[e.parentFirst ? "push" : "unshift"](r),
                        r = r.parent;
                    return t
                }
                getCommonAncestor(e, t={}) {
                    const r = this.getAncestors(t)
                      , i = e.getAncestors(t);
                    let l = 0;
                    for (; r[l] == i[l] && r[l]; )
                        l++;
                    return l === 0 ? null : r[l - 1]
                }
                isBefore(e) {
                    if (this == e || this.root !== e.root)
                        return !1;
                    const t = this.getPath()
                      , r = e.getPath()
                      , i = ro(t, r);
                    switch (i) {
                    case "prefix":
                        return !0;
                    case "extension":
                        return !1;
                    default:
                        return t[i] < r[i]
                    }
                }
                isAfter(e) {
                    return this != e && this.root === e.root && !this.isBefore(e)
                }
                _remove() {
                    this.parent._removeChildren(this.index)
                }
                _fireChange(e, t) {
                    this.fire(`change:${e}`, t),
                    this.parent && this.parent._fireChange(e, t)
                }
                toJSON() {
                    const e = Ev(this);
                    return delete e.parent,
                    e
                }
            }
            Ei.prototype.is = function(s) {
                return s === "node" || s === "view:node"
            }
            ;
            class We extends Ei {
                constructor(e, t) {
                    super(e),
                    C(this, "_textData"),
                    this._textData = t
                }
                get data() {
                    return this._textData
                }
                get _data() {
                    return this.data
                }
                set _data(e) {
                    this._fireChange("text", this),
                    this._textData = e
                }
                isSimilar(e) {
                    return e instanceof We && (this === e || this.data === e.data)
                }
                _clone() {
                    return new We(this.document,this.data)
                }
            }
            We.prototype.is = function(s) {
                return s === "$text" || s === "view:$text" || s === "text" || s === "view:text" || s === "node" || s === "view:node"
            }
            ;
            class Mr extends xi {
                constructor(e, t, r) {
                    if (super(),
                    C(this, "textNode"),
                    C(this, "data"),
                    C(this, "offsetInText"),
                    this.textNode = e,
                    t < 0 || t > e.data.length)
                        throw new U("view-textproxy-wrong-offsetintext",this);
                    if (r < 0 || t + r > e.data.length)
                        throw new U("view-textproxy-wrong-length",this);
                    this.data = e.data.substring(t, t + r),
                    this.offsetInText = t
                }
                get offsetSize() {
                    return this.data.length
                }
                get isPartial() {
                    return this.data.length !== this.textNode.data.length
                }
                get parent() {
                    return this.textNode.parent
                }
                get root() {
                    return this.textNode.root
                }
                get document() {
                    return this.textNode.document
                }
                getAncestors(e={}) {
                    const t = [];
                    let r = e.includeSelf ? this.textNode : this.parent;
                    for (; r !== null; )
                        t[e.parentFirst ? "push" : "unshift"](r),
                        r = r.parent;
                    return t
                }
            }
            Mr.prototype.is = function(s) {
                return s === "$textProxy" || s === "view:$textProxy" || s === "textProxy" || s === "view:textProxy"
            }
            ;
            class Br {
                constructor(...e) {
                    C(this, "_patterns", []),
                    this.add(...e)
                }
                add(...e) {
                    for (let t of e)
                        (typeof t == "string" || t instanceof RegExp) && (t = {
                            name: t
                        }),
                        this._patterns.push(t)
                }
                match(...e) {
                    for (const t of e)
                        for (const r of this._patterns) {
                            const i = Sv(t, r);
                            if (i)
                                return {
                                    element: t,
                                    pattern: r,
                                    match: i
                                }
                        }
                    return null
                }
                matchAll(...e) {
                    const t = [];
                    for (const r of e)
                        for (const i of this._patterns) {
                            const l = Sv(r, i);
                            l && t.push({
                                element: r,
                                pattern: i,
                                match: l
                            })
                        }
                    return t.length > 0 ? t : null
                }
                getElementName() {
                    if (this._patterns.length !== 1)
                        return null;
                    const e = this._patterns[0]
                      , t = e.name;
                    return typeof e == "function" || !t || t instanceof RegExp ? null : t
                }
            }
            function Sv(s, e) {
                if (typeof e == "function")
                    return e(s);
                const t = {};
                return e.name && (t.name = function(r, i) {
                    return r instanceof RegExp ? !!i.match(r) : r === i
                }(e.name, s.name),
                !t.name) || e.attributes && (t.attributes = function(r, i) {
                    const l = new Set(i.getAttributeKeys());
                    return Eo(r) ? (r.style !== void 0 && de("matcher-pattern-deprecated-attributes-style-key", r),
                    r.class !== void 0 && de("matcher-pattern-deprecated-attributes-class-key", r)) : (l.delete("style"),
                    l.delete("class")),
                    ap(r, l, d => i.getAttribute(d))
                }(e.attributes, s),
                !t.attributes) || e.classes && (t.classes = function(r, i) {
                    return ap(r, i.getClassNames(), () => {}
                    )
                }(e.classes, s),
                !t.classes) || e.styles && (t.styles = function(r, i) {
                    return ap(r, i.getStyleNames(!0), l => i.getStyle(l))
                }(e.styles, s),
                !t.styles) ? null : t
            }
            function ap(s, e, t) {
                const r = function(d) {
                    return Array.isArray(d) ? d.map(h => Eo(h) ? (h.key !== void 0 && h.value !== void 0 || de("matcher-pattern-missing-key-or-value", h),
                    [h.key, h.value]) : [h, !0]) : Eo(d) ? Object.entries(d) : [[d, !0]]
                }(s)
                  , i = Array.from(e)
                  , l = [];
                if (r.forEach( ([d,h]) => {
                    i.forEach(m => {
                        (function(g, b) {
                            return g === !0 || g === b || g instanceof RegExp && b.match(g)
                        }
                        )(d, m) && function(g, b, v) {
                            if (g === !0)
                                return !0;
                            const x = v(b);
                            return g === x || g instanceof RegExp && !!String(x).match(g)
                        }(h, m, t) && l.push(m)
                    }
                    )
                }
                ),
                r.length && !(l.length < r.length))
                    return l
            }
            const Nd = function(s) {
                return typeof s == "symbol" || Wo(s) && Dn(s) == "[object Symbol]"
            };
            var V4 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/
              , U4 = /^\w*$/;
            const lp = function(s, e) {
                if (xo(s))
                    return !1;
                var t = typeof s;
                return !(t != "number" && t != "symbol" && t != "boolean" && s != null && !Nd(s)) || U4.test(s) || !V4.test(s) || e != null && s in Object(e)
            };
            function cp(s, e) {
                if (typeof s != "function" || e != null && typeof e != "function")
                    throw new TypeError("Expected a function");
                var t = function() {
                    var r = arguments
                      , i = e ? e.apply(this, r) : r[0]
                      , l = t.cache;
                    if (l.has(i))
                        return l.get(i);
                    var d = s.apply(this, r);
                    return t.cache = l.set(i, d) || l,
                    d
                };
                return t.cache = new (cp.Cache || gd),
                t
            }
            cp.Cache = gd;
            const H4 = cp
              , W4 = function(s) {
                var e = H4(s, function(r) {
                    return t.size === 500 && t.clear(),
                    r
                })
                  , t = e.cache;
                return e
            };
            var $4 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g
              , q4 = /\\(\\)?/g
              , G4 = W4(function(s) {
                var e = [];
                return s.charCodeAt(0) === 46 && e.push(""),
                s.replace($4, function(t, r, i, l) {
                    e.push(i ? l.replace(q4, "$1") : r || t)
                }),
                e
            });
            const K4 = G4
              , Y4 = function(s, e) {
                for (var t = -1, r = s == null ? 0 : s.length, i = Array(r); ++t < r; )
                    i[t] = e(s[t], t, s);
                return i
            };
            var Dv = Tr ? Tr.prototype : void 0
              , Tv = Dv ? Dv.toString : void 0;
            const Q4 = function s(e) {
                if (typeof e == "string")
                    return e;
                if (xo(e))
                    return Y4(e, s) + "";
                if (Nd(e))
                    return Tv ? Tv.call(e) : "";
                var t = e + "";
                return t == "0" && 1 / e == -1 / 0 ? "-0" : t
            }
              , dp = function(s) {
                return s == null ? "" : Q4(s)
            }
              , Pd = function(s, e) {
                return xo(s) ? s : lp(s, e) ? [s] : K4(dp(s))
            }
              , Z4 = function(s) {
                var e = s == null ? 0 : s.length;
                return e ? s[e - 1] : void 0
            }
              , ys = function(s) {
                if (typeof s == "string" || Nd(s))
                    return s;
                var e = s + "";
                return e == "0" && 1 / s == -1 / 0 ? "-0" : e
            }
              , up = function(s, e) {
                for (var t = 0, r = (e = Pd(e, s)).length; s != null && t < r; )
                    s = s[ys(e[t++])];
                return t && t == r ? s : void 0
            }
              , Iv = function(s, e, t) {
                var r = -1
                  , i = s.length;
                e < 0 && (e = -e > i ? 0 : i + e),
                (t = t > i ? i : t) < 0 && (t += i),
                i = e > t ? 0 : t - e >>> 0,
                e >>>= 0;
                for (var l = Array(i); ++r < i; )
                    l[r] = s[r + e];
                return l
            }
              , J4 = function(s, e) {
                return e.length < 2 ? s : up(s, Iv(e, 0, -1))
            }
              , X4 = function(s, e) {
                return e = Pd(e, s),
                (s = J4(s, e)) == null || delete s[ys(Z4(e))]
            }
              , eP = function(s, e) {
                return s == null || X4(s, e)
            }
              , ml = function(s, e, t) {
                var r = s == null ? void 0 : up(s, e);
                return r === void 0 ? t : r
            }
              , tP = function(s, e, t, r) {
                if (!Le(s))
                    return s;
                for (var i = -1, l = (e = Pd(e, s)).length, d = l - 1, h = s; h != null && ++i < l; ) {
                    var m = ys(e[i])
                      , g = t;
                    if (m === "__proto__" || m === "constructor" || m === "prototype")
                        return s;
                    if (i != d) {
                        var b = h[m];
                        (g = void 0) == null && (g = Le(b) ? b : wd(e[i + 1]) ? [] : {})
                    }
                    Im(h, m, g),
                    h = h[m]
                }
                return s
            }
              , oP = function(s, e, t) {
                return s == null ? s : tP(s, e, t)
            };
            class hp {
                constructor(e) {
                    C(this, "_styles"),
                    C(this, "_styleProcessor"),
                    this._styles = {},
                    this._styleProcessor = e
                }
                get isEmpty() {
                    return !Object.entries(this._styles).length
                }
                get size() {
                    return this.isEmpty ? 0 : this.getStyleNames().length
                }
                setTo(e) {
                    this.clear();
                    const t = function(r) {
                        let i = null
                          , l = 0
                          , d = 0
                          , h = null;
                        const m = new Map;
                        if (r === "")
                            return m;
                        r.charAt(r.length - 1) != ";" && (r += ";");
                        for (let g = 0; g < r.length; g++) {
                            const b = r.charAt(g);
                            if (i === null)
                                switch (b) {
                                case ":":
                                    h || (h = r.substr(l, g - l),
                                    d = g + 1);
                                    break;
                                case '"':
                                case "'":
                                    i = b;
                                    break;
                                case ";":
                                    {
                                        const v = r.substr(d, g - d);
                                        h && m.set(h.trim(), v.trim()),
                                        h = null,
                                        l = g + 1;
                                        break
                                    }
                                }
                            else
                                b === i && (i = null)
                        }
                        return m
                    }(e);
                    for (const [r,i] of t)
                        this._styleProcessor.toNormalizedForm(r, i, this._styles)
                }
                has(e) {
                    if (this.isEmpty)
                        return !1;
                    const t = this._styleProcessor.getReducedForm(e, this._styles).find( ([r]) => r === e);
                    return Array.isArray(t)
                }
                set(e, t) {
                    if (Le(e))
                        for (const [r,i] of Object.entries(e))
                            this._styleProcessor.toNormalizedForm(r, i, this._styles);
                    else
                        this._styleProcessor.toNormalizedForm(e, t, this._styles)
                }
                remove(e) {
                    const t = mp(e);
                    eP(this._styles, t),
                    delete this._styles[e],
                    this._cleanEmptyObjectsOnPath(t)
                }
                getNormalized(e) {
                    return this._styleProcessor.getNormalized(e, this._styles)
                }
                toString() {
                    return this.isEmpty ? "" : this.getStylesEntries().map(e => e.join(":")).sort().join(";") + ";"
                }
                getAsString(e) {
                    if (this.isEmpty)
                        return;
                    if (this._styles[e] && !Le(this._styles[e]))
                        return this._styles[e];
                    const t = this._styleProcessor.getReducedForm(e, this._styles).find( ([r]) => r === e);
                    return Array.isArray(t) ? t[1] : void 0
                }
                getStyleNames(e=!1) {
                    return this.isEmpty ? [] : e ? this._styleProcessor.getStyleNames(this._styles) : this.getStylesEntries().map( ([t]) => t)
                }
                clear() {
                    this._styles = {}
                }
                getStylesEntries() {
                    const e = []
                      , t = Object.keys(this._styles);
                    for (const r of t)
                        e.push(...this._styleProcessor.getReducedForm(r, this._styles));
                    return e
                }
                _cleanEmptyObjectsOnPath(e) {
                    const t = e.split(".");
                    if (!(t.length > 1))
                        return;
                    const r = t.splice(0, t.length - 1).join(".")
                      , i = ml(this._styles, r);
                    i && !Object.keys(i).length && this.remove(r)
                }
            }
            class rP {
                constructor() {
                    C(this, "_normalizers"),
                    C(this, "_extractors"),
                    C(this, "_reducers"),
                    C(this, "_consumables"),
                    this._normalizers = new Map,
                    this._extractors = new Map,
                    this._reducers = new Map,
                    this._consumables = new Map
                }
                toNormalizedForm(e, t, r) {
                    if (Le(t))
                        pp(r, mp(e), t);
                    else if (this._normalizers.has(e)) {
                        const i = this._normalizers.get(e)
                          , {path: l, value: d} = i(t);
                        pp(r, l, d)
                    } else
                        pp(r, e, t)
                }
                getNormalized(e, t) {
                    if (!e)
                        return Xm({}, t);
                    if (t[e] !== void 0)
                        return t[e];
                    if (this._extractors.has(e)) {
                        const r = this._extractors.get(e);
                        if (typeof r == "string")
                            return ml(t, r);
                        const i = r(e, t);
                        if (i)
                            return i
                    }
                    return ml(t, mp(e))
                }
                getReducedForm(e, t) {
                    const r = this.getNormalized(e, t);
                    return r === void 0 ? [] : this._reducers.has(e) ? this._reducers.get(e)(r) : [[e, r]]
                }
                getStyleNames(e) {
                    const t = Array.from(this._consumables.keys()).filter(i => {
                        const l = this.getNormalized(i, e);
                        return l && typeof l == "object" ? Object.keys(l).length : l
                    }
                    )
                      , r = new Set([...t, ...Object.keys(e)]);
                    return Array.from(r)
                }
                getRelatedStyles(e) {
                    return this._consumables.get(e) || []
                }
                setNormalizer(e, t) {
                    this._normalizers.set(e, t)
                }
                setExtractor(e, t) {
                    this._extractors.set(e, t)
                }
                setReducer(e, t) {
                    this._reducers.set(e, t)
                }
                setStyleRelation(e, t) {
                    this._mapStyleNames(e, t);
                    for (const r of t)
                        this._mapStyleNames(r, [e])
                }
                _mapStyleNames(e, t) {
                    this._consumables.has(e) || this._consumables.set(e, []),
                    this._consumables.get(e).push(...t)
                }
            }
            function mp(s) {
                return s.replace("-", ".")
            }
            function pp(s, e, t) {
                let r = t;
                Le(t) && (r = Xm({}, ml(s, e), t)),
                oP(s, e, r)
            }
            class So extends Ei {
                constructor(e, t, r, i) {
                    if (super(e),
                    C(this, "name"),
                    C(this, "_unsafeAttributesToRender", []),
                    C(this, "_attrs"),
                    C(this, "_children"),
                    C(this, "_classes"),
                    C(this, "_styles"),
                    C(this, "_customProperties", new Map),
                    this.name = t,
                    this._attrs = function(l) {
                        const d = Ir(l);
                        for (const [h,m] of d)
                            m === null ? d.delete(h) : typeof m != "string" && d.set(h, String(m));
                        return d
                    }(r),
                    this._children = [],
                    i && this._insertChild(0, i),
                    this._classes = new Set,
                    this._attrs.has("class")) {
                        const l = this._attrs.get("class");
                        Mv(this._classes, l),
                        this._attrs.delete("class")
                    }
                    this._styles = new hp(this.document.stylesProcessor),
                    this._attrs.has("style") && (this._styles.setTo(this._attrs.get("style")),
                    this._attrs.delete("style"))
                }
                get childCount() {
                    return this._children.length
                }
                get isEmpty() {
                    return this._children.length === 0
                }
                getChild(e) {
                    return this._children[e]
                }
                getChildIndex(e) {
                    return this._children.indexOf(e)
                }
                getChildren() {
                    return this._children[Symbol.iterator]()
                }
                *getAttributeKeys() {
                    this._classes.size > 0 && (yield "class"),
                    this._styles.isEmpty || (yield "style"),
                    yield*this._attrs.keys()
                }
                *getAttributes() {
                    yield*this._attrs.entries(),
                    this._classes.size > 0 && (yield["class", this.getAttribute("class")]),
                    this._styles.isEmpty || (yield["style", this.getAttribute("style")])
                }
                getAttribute(e) {
                    if (e == "class")
                        return this._classes.size > 0 ? [...this._classes].join(" ") : void 0;
                    if (e == "style") {
                        const t = this._styles.toString();
                        return t == "" ? void 0 : t
                    }
                    return this._attrs.get(e)
                }
                hasAttribute(e) {
                    return e == "class" ? this._classes.size > 0 : e == "style" ? !this._styles.isEmpty : this._attrs.has(e)
                }
                isSimilar(e) {
                    if (!(e instanceof So))
                        return !1;
                    if (this === e)
                        return !0;
                    if (this.name != e.name || this._attrs.size !== e._attrs.size || this._classes.size !== e._classes.size || this._styles.size !== e._styles.size)
                        return !1;
                    for (const [t,r] of this._attrs)
                        if (!e._attrs.has(t) || e._attrs.get(t) !== r)
                            return !1;
                    for (const t of this._classes)
                        if (!e._classes.has(t))
                            return !1;
                    for (const t of this._styles.getStyleNames())
                        if (!e._styles.has(t) || e._styles.getAsString(t) !== this._styles.getAsString(t))
                            return !1;
                    return !0
                }
                hasClass(...e) {
                    for (const t of e)
                        if (!this._classes.has(t))
                            return !1;
                    return !0
                }
                getClassNames() {
                    return this._classes.keys()
                }
                getStyle(e) {
                    return this._styles.getAsString(e)
                }
                getNormalizedStyle(e) {
                    return this._styles.getNormalized(e)
                }
                getStyleNames(e) {
                    return this._styles.getStyleNames(e)
                }
                hasStyle(...e) {
                    for (const t of e)
                        if (!this._styles.has(t))
                            return !1;
                    return !0
                }
                findAncestor(...e) {
                    const t = new Br(...e);
                    let r = this.parent;
                    for (; r && !r.is("documentFragment"); ) {
                        if (t.match(r))
                            return r;
                        r = r.parent
                    }
                    return null
                }
                getCustomProperty(e) {
                    return this._customProperties.get(e)
                }
                *getCustomProperties() {
                    yield*this._customProperties.entries()
                }
                getIdentity() {
                    const e = Array.from(this._classes).sort().join(",")
                      , t = this._styles.toString()
                      , r = Array.from(this._attrs).map(i => `${i[0]}="${i[1]}"`).sort().join(" ");
                    return this.name + (e == "" ? "" : ` class="${e}"`) + (t ? ` style="${t}"` : "") + (r == "" ? "" : ` ${r}`)
                }
                shouldRenderUnsafeAttribute(e) {
                    return this._unsafeAttributesToRender.includes(e)
                }
                _clone(e=!1) {
                    const t = [];
                    if (e)
                        for (const i of this.getChildren())
                            t.push(i._clone(e));
                    const r = new this.constructor(this.document,this.name,this._attrs,t);
                    return r._classes = new Set(this._classes),
                    r._styles.set(this._styles.getNormalized()),
                    r._customProperties = new Map(this._customProperties),
                    r.getFillerOffset = this.getFillerOffset,
                    r._unsafeAttributesToRender = this._unsafeAttributesToRender,
                    r
                }
                _appendChild(e) {
                    return this._insertChild(this.childCount, e)
                }
                _insertChild(e, t) {
                    this._fireChange("children", this);
                    let r = 0;
                    const i = function(l, d) {
                        return typeof d == "string" ? [new We(l,d)] : (yo(d) || (d = [d]),
                        Array.from(d).map(h => typeof h == "string" ? new We(l,h) : h instanceof Mr ? new We(l,h.data) : h))
                    }(this.document, t);
                    for (const l of i)
                        l.parent !== null && l._remove(),
                        l.parent = this,
                        l.document = this.document,
                        this._children.splice(e, 0, l),
                        e++,
                        r++;
                    return r
                }
                _removeChildren(e, t=1) {
                    this._fireChange("children", this);
                    for (let r = e; r < e + t; r++)
                        this._children[r].parent = null;
                    return this._children.splice(e, t)
                }
                _setAttribute(e, t) {
                    const r = String(t);
                    this._fireChange("attributes", this),
                    e == "class" ? Mv(this._classes, r) : e == "style" ? this._styles.setTo(r) : this._attrs.set(e, r)
                }
                _removeAttribute(e) {
                    return this._fireChange("attributes", this),
                    e == "class" ? this._classes.size > 0 && (this._classes.clear(),
                    !0) : e == "style" ? !this._styles.isEmpty && (this._styles.clear(),
                    !0) : this._attrs.delete(e)
                }
                _addClass(e) {
                    this._fireChange("attributes", this);
                    for (const t of Ze(e))
                        this._classes.add(t)
                }
                _removeClass(e) {
                    this._fireChange("attributes", this);
                    for (const t of Ze(e))
                        this._classes.delete(t)
                }
                _setStyle(e, t) {
                    this._fireChange("attributes", this),
                    typeof e != "string" ? this._styles.set(e) : this._styles.set(e, t)
                }
                _removeStyle(e) {
                    this._fireChange("attributes", this);
                    for (const t of Ze(e))
                        this._styles.remove(t)
                }
                _setCustomProperty(e, t) {
                    this._customProperties.set(e, t)
                }
                _removeCustomProperty(e) {
                    return this._customProperties.delete(e)
                }
            }
            function Mv(s, e) {
                const t = e.split(/\s+/);
                s.clear(),
                t.forEach(r => s.add(r))
            }
            So.prototype.is = function(s, e) {
                return e ? e === this.name && (s === "element" || s === "view:element") : s === "element" || s === "view:element" || s === "node" || s === "view:node"
            }
            ;
            class pl extends So {
                constructor(e, t, r, i) {
                    super(e, t, r, i),
                    this.getFillerOffset = nP
                }
            }
            function nP() {
                const s = [...this.getChildren()]
                  , e = s[this.childCount - 1];
                if (e && e.is("element", "br"))
                    return this.childCount;
                for (const t of s)
                    if (!t.is("uiElement"))
                        return null;
                return this.childCount
            }
            pl.prototype.is = function(s, e) {
                return e ? e === this.name && (s === "containerElement" || s === "view:containerElement" || s === "element" || s === "view:element") : s === "containerElement" || s === "view:containerElement" || s === "element" || s === "view:element" || s === "node" || s === "view:node"
            }
            ;
            class jd extends ye(pl) {
                constructor(e, t, r, i) {
                    super(e, t, r, i),
                    this.set("isReadOnly", !1),
                    this.set("isFocused", !1),
                    this.set("placeholder", void 0),
                    this.bind("isReadOnly").to(e),
                    this.bind("isFocused").to(e, "isFocused", l => l && e.selection.editableElement == this),
                    this.listenTo(e.selection, "change", () => {
                        this.isFocused = e.isFocused && e.selection.editableElement == this
                    }
                    )
                }
                destroy() {
                    this.stopListening()
                }
            }
            jd.prototype.is = function(s, e) {
                return e ? e === this.name && (s === "editableElement" || s === "view:editableElement" || s === "containerElement" || s === "view:containerElement" || s === "element" || s === "view:element") : s === "editableElement" || s === "view:editableElement" || s === "containerElement" || s === "view:containerElement" || s === "element" || s === "view:element" || s === "node" || s === "view:node"
            }
            ;
            const Bv = Symbol("rootName");
            class Nv extends jd {
                constructor(e, t) {
                    super(e, t),
                    this.rootName = "main"
                }
                get rootName() {
                    return this.getCustomProperty(Bv)
                }
                set rootName(e) {
                    this._setCustomProperty(Bv, e)
                }
                set _name(e) {
                    this.name = e
                }
            }
            Nv.prototype.is = function(s, e) {
                return e ? e === this.name && (s === "rootElement" || s === "view:rootElement" || s === "editableElement" || s === "view:editableElement" || s === "containerElement" || s === "view:containerElement" || s === "element" || s === "view:element") : s === "rootElement" || s === "view:rootElement" || s === "editableElement" || s === "view:editableElement" || s === "containerElement" || s === "view:containerElement" || s === "element" || s === "view:element" || s === "node" || s === "view:node"
            }
            ;
            class Si {
                constructor(e={}) {
                    if (C(this, "direction"),
                    C(this, "boundaries"),
                    C(this, "singleCharacters"),
                    C(this, "shallow"),
                    C(this, "ignoreElementEnd"),
                    C(this, "_position"),
                    C(this, "_boundaryStartParent"),
                    C(this, "_boundaryEndParent"),
                    !e.boundaries && !e.startPosition)
                        throw new U("view-tree-walker-no-start-position",null);
                    if (e.direction && e.direction != "forward" && e.direction != "backward")
                        throw new U("view-tree-walker-unknown-direction",e.startPosition,{
                            direction: e.direction
                        });
                    this.boundaries = e.boundaries || null,
                    e.startPosition ? this._position = ae._createAt(e.startPosition) : this._position = ae._createAt(e.boundaries[e.direction == "backward" ? "end" : "start"]),
                    this.direction = e.direction || "forward",
                    this.singleCharacters = !!e.singleCharacters,
                    this.shallow = !!e.shallow,
                    this.ignoreElementEnd = !!e.ignoreElementEnd,
                    this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null,
                    this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null
                }
                [Symbol.iterator]() {
                    return this
                }
                get position() {
                    return this._position
                }
                skip(e) {
                    let t, r;
                    do
                        r = this.position,
                        t = this.next();
                    while (!t.done && e(t.value));
                    t.done || (this._position = r)
                }
                next() {
                    return this.direction == "forward" ? this._next() : this._previous()
                }
                _next() {
                    let e = this.position.clone();
                    const t = this.position
                      , r = e.parent;
                    if (r.parent === null && e.offset === r.childCount)
                        return {
                            done: !0,
                            value: void 0
                        };
                    if (r === this._boundaryEndParent && e.offset == this.boundaries.end.offset)
                        return {
                            done: !0,
                            value: void 0
                        };
                    let i;
                    if (r instanceof We) {
                        if (e.isAtEnd)
                            return this._position = ae._createAfter(r),
                            this._next();
                        i = r.data[e.offset]
                    } else
                        i = r.getChild(e.offset);
                    if (i instanceof So) {
                        if (this.shallow) {
                            if (this.boundaries && this.boundaries.end.isBefore(e))
                                return {
                                    done: !0,
                                    value: void 0
                                };
                            e.offset++
                        } else
                            e = new ae(i,0);
                        return this._position = e,
                        this._formatReturnValue("elementStart", i, t, e, 1)
                    }
                    if (i instanceof We) {
                        if (this.singleCharacters)
                            return e = new ae(i,0),
                            this._position = e,
                            this._next();
                        let l, d = i.data.length;
                        return i == this._boundaryEndParent ? (d = this.boundaries.end.offset,
                        l = new Mr(i,0,d),
                        e = ae._createAfter(l)) : (l = new Mr(i,0,i.data.length),
                        e.offset++),
                        this._position = e,
                        this._formatReturnValue("text", l, t, e, d)
                    }
                    if (typeof i == "string") {
                        let l;
                        this.singleCharacters ? l = 1 : l = (r === this._boundaryEndParent ? this.boundaries.end.offset : r.data.length) - e.offset;
                        const d = new Mr(r,e.offset,l);
                        return e.offset += l,
                        this._position = e,
                        this._formatReturnValue("text", d, t, e, l)
                    }
                    return e = ae._createAfter(r),
                    this._position = e,
                    this.ignoreElementEnd ? this._next() : this._formatReturnValue("elementEnd", r, t, e)
                }
                _previous() {
                    let e = this.position.clone();
                    const t = this.position
                      , r = e.parent;
                    if (r.parent === null && e.offset === 0)
                        return {
                            done: !0,
                            value: void 0
                        };
                    if (r == this._boundaryStartParent && e.offset == this.boundaries.start.offset)
                        return {
                            done: !0,
                            value: void 0
                        };
                    let i;
                    if (r instanceof We) {
                        if (e.isAtStart)
                            return this._position = ae._createBefore(r),
                            this._previous();
                        i = r.data[e.offset - 1]
                    } else
                        i = r.getChild(e.offset - 1);
                    if (i instanceof So)
                        return this.shallow ? (e.offset--,
                        this._position = e,
                        this._formatReturnValue("elementStart", i, t, e, 1)) : (e = new ae(i,i.childCount),
                        this._position = e,
                        this.ignoreElementEnd ? this._previous() : this._formatReturnValue("elementEnd", i, t, e));
                    if (i instanceof We) {
                        if (this.singleCharacters)
                            return e = new ae(i,i.data.length),
                            this._position = e,
                            this._previous();
                        let l, d = i.data.length;
                        if (i == this._boundaryStartParent) {
                            const h = this.boundaries.start.offset;
                            l = new Mr(i,h,i.data.length - h),
                            d = l.data.length,
                            e = ae._createBefore(l)
                        } else
                            l = new Mr(i,0,i.data.length),
                            e.offset--;
                        return this._position = e,
                        this._formatReturnValue("text", l, t, e, d)
                    }
                    if (typeof i == "string") {
                        let l;
                        if (this.singleCharacters)
                            l = 1;
                        else {
                            const h = r === this._boundaryStartParent ? this.boundaries.start.offset : 0;
                            l = e.offset - h
                        }
                        e.offset -= l;
                        const d = new Mr(r,e.offset,l);
                        return this._position = e,
                        this._formatReturnValue("text", d, t, e, l)
                    }
                    return e = ae._createBefore(r),
                    this._position = e,
                    this._formatReturnValue("elementStart", r, t, e, 1)
                }
                _formatReturnValue(e, t, r, i, l) {
                    return t instanceof Mr && (t.offsetInText + t.data.length == t.textNode.data.length && (this.direction != "forward" || this.boundaries && this.boundaries.end.isEqual(this.position) ? r = ae._createAfter(t.textNode) : (i = ae._createAfter(t.textNode),
                    this._position = i)),
                    t.offsetInText === 0 && (this.direction != "backward" || this.boundaries && this.boundaries.start.isEqual(this.position) ? r = ae._createBefore(t.textNode) : (i = ae._createBefore(t.textNode),
                    this._position = i))),
                    {
                        done: !1,
                        value: {
                            type: e,
                            item: t,
                            previousPosition: r,
                            nextPosition: i,
                            length: l
                        }
                    }
                }
            }
            class ae extends xi {
                constructor(e, t) {
                    super(),
                    C(this, "parent"),
                    C(this, "offset"),
                    this.parent = e,
                    this.offset = t
                }
                get nodeAfter() {
                    return this.parent.is("$text") ? null : this.parent.getChild(this.offset) || null
                }
                get nodeBefore() {
                    return this.parent.is("$text") ? null : this.parent.getChild(this.offset - 1) || null
                }
                get isAtStart() {
                    return this.offset === 0
                }
                get isAtEnd() {
                    const e = this.parent.is("$text") ? this.parent.data.length : this.parent.childCount;
                    return this.offset === e
                }
                get root() {
                    return this.parent.root
                }
                get editableElement() {
                    let e = this.parent;
                    for (; !(e instanceof jd); ) {
                        if (!e.parent)
                            return null;
                        e = e.parent
                    }
                    return e
                }
                getShiftedBy(e) {
                    const t = ae._createAt(this)
                      , r = t.offset + e;
                    return t.offset = r < 0 ? 0 : r,
                    t
                }
                getLastMatchingPosition(e, t={}) {
                    t.startPosition = this;
                    const r = new Si(t);
                    return r.skip(e),
                    r.position
                }
                getAncestors() {
                    return this.parent.is("documentFragment") ? [this.parent] : this.parent.getAncestors({
                        includeSelf: !0
                    })
                }
                getCommonAncestor(e) {
                    const t = this.getAncestors()
                      , r = e.getAncestors();
                    let i = 0;
                    for (; t[i] == r[i] && t[i]; )
                        i++;
                    return i === 0 ? null : t[i - 1]
                }
                isEqual(e) {
                    return this.parent == e.parent && this.offset == e.offset
                }
                isBefore(e) {
                    return this.compareWith(e) == "before"
                }
                isAfter(e) {
                    return this.compareWith(e) == "after"
                }
                compareWith(e) {
                    if (this.root !== e.root)
                        return "different";
                    if (this.isEqual(e))
                        return "same";
                    const t = this.parent.is("node") ? this.parent.getPath() : []
                      , r = e.parent.is("node") ? e.parent.getPath() : [];
                    t.push(this.offset),
                    r.push(e.offset);
                    const i = ro(t, r);
                    switch (i) {
                    case "prefix":
                        return "before";
                    case "extension":
                        return "after";
                    default:
                        return t[i] < r[i] ? "before" : "after"
                    }
                }
                getWalker(e={}) {
                    return e.startPosition = this,
                    new Si(e)
                }
                clone() {
                    return new ae(this.parent,this.offset)
                }
                static _createAt(e, t) {
                    if (e instanceof ae)
                        return new this(e.parent,e.offset);
                    {
                        const r = e;
                        if (t == "end")
                            t = r.is("$text") ? r.data.length : r.childCount;
                        else {
                            if (t == "before")
                                return this._createBefore(r);
                            if (t == "after")
                                return this._createAfter(r);
                            if (t !== 0 && !t)
                                throw new U("view-createpositionat-offset-required",r)
                        }
                        return new ae(r,t)
                    }
                }
                static _createAfter(e) {
                    if (e.is("$textProxy"))
                        return new ae(e.textNode,e.offsetInText + e.data.length);
                    if (!e.parent)
                        throw new U("view-position-after-root",e,{
                            root: e
                        });
                    return new ae(e.parent,e.index + 1)
                }
                static _createBefore(e) {
                    if (e.is("$textProxy"))
                        return new ae(e.textNode,e.offsetInText);
                    if (!e.parent)
                        throw new U("view-position-before-root",e,{
                            root: e
                        });
                    return new ae(e.parent,e.index)
                }
            }
            ae.prototype.is = function(s) {
                return s === "position" || s === "view:position"
            }
            ;
            class fe extends xi {
                constructor(e, t=null) {
                    super(),
                    C(this, "start"),
                    C(this, "end"),
                    this.start = e.clone(),
                    this.end = t ? t.clone() : e.clone()
                }
                *[Symbol.iterator]() {
                    yield*new Si({
                        boundaries: this,
                        ignoreElementEnd: !0
                    })
                }
                get isCollapsed() {
                    return this.start.isEqual(this.end)
                }
                get isFlat() {
                    return this.start.parent === this.end.parent
                }
                get root() {
                    return this.start.root
                }
                getEnlarged() {
                    let e = this.start.getLastMatchingPosition(Ld, {
                        direction: "backward"
                    })
                      , t = this.end.getLastMatchingPosition(Ld);
                    return e.parent.is("$text") && e.isAtStart && (e = ae._createBefore(e.parent)),
                    t.parent.is("$text") && t.isAtEnd && (t = ae._createAfter(t.parent)),
                    new fe(e,t)
                }
                getTrimmed() {
                    let e = this.start.getLastMatchingPosition(Ld);
                    if (e.isAfter(this.end) || e.isEqual(this.end))
                        return new fe(e,e);
                    let t = this.end.getLastMatchingPosition(Ld, {
                        direction: "backward"
                    });
                    const r = e.nodeAfter
                      , i = t.nodeBefore;
                    return r && r.is("$text") && (e = new ae(r,0)),
                    i && i.is("$text") && (t = new ae(i,i.data.length)),
                    new fe(e,t)
                }
                isEqual(e) {
                    return this == e || this.start.isEqual(e.start) && this.end.isEqual(e.end)
                }
                containsPosition(e) {
                    return e.isAfter(this.start) && e.isBefore(this.end)
                }
                containsRange(e, t=!1) {
                    e.isCollapsed && (t = !1);
                    const r = this.containsPosition(e.start) || t && this.start.isEqual(e.start)
                      , i = this.containsPosition(e.end) || t && this.end.isEqual(e.end);
                    return r && i
                }
                getDifference(e) {
                    const t = [];
                    return this.isIntersecting(e) ? (this.containsPosition(e.start) && t.push(new fe(this.start,e.start)),
                    this.containsPosition(e.end) && t.push(new fe(e.end,this.end))) : t.push(this.clone()),
                    t
                }
                getIntersection(e) {
                    if (this.isIntersecting(e)) {
                        let t = this.start
                          , r = this.end;
                        return this.containsPosition(e.start) && (t = e.start),
                        this.containsPosition(e.end) && (r = e.end),
                        new fe(t,r)
                    }
                    return null
                }
                getWalker(e={}) {
                    return e.boundaries = this,
                    new Si(e)
                }
                getCommonAncestor() {
                    return this.start.getCommonAncestor(this.end)
                }
                getContainedElement() {
                    if (this.isCollapsed)
                        return null;
                    let e = this.start.nodeAfter
                      , t = this.end.nodeBefore;
                    return this.start.parent.is("$text") && this.start.isAtEnd && this.start.parent.nextSibling && (e = this.start.parent.nextSibling),
                    this.end.parent.is("$text") && this.end.isAtStart && this.end.parent.previousSibling && (t = this.end.parent.previousSibling),
                    e && e.is("element") && e === t ? e : null
                }
                clone() {
                    return new fe(this.start,this.end)
                }
                *getItems(e={}) {
                    e.boundaries = this,
                    e.ignoreElementEnd = !0;
                    const t = new Si(e);
                    for (const r of t)
                        yield r.item
                }
                *getPositions(e={}) {
                    e.boundaries = this;
                    const t = new Si(e);
                    yield t.position;
                    for (const r of t)
                        yield r.nextPosition
                }
                isIntersecting(e) {
                    return this.start.isBefore(e.end) && this.end.isAfter(e.start)
                }
                static _createFromParentsAndOffsets(e, t, r, i) {
                    return new this(new ae(e,t),new ae(r,i))
                }
                static _createFromPositionAndShift(e, t) {
                    const r = e
                      , i = e.getShiftedBy(t);
                    return t > 0 ? new this(r,i) : new this(i,r)
                }
                static _createIn(e) {
                    return this._createFromParentsAndOffsets(e, 0, e, e.childCount)
                }
                static _createOn(e) {
                    const t = e.is("$textProxy") ? e.offsetSize : 1;
                    return this._createFromPositionAndShift(ae._createBefore(e), t)
                }
            }
            function Ld(s) {
                return !(!s.item.is("attributeElement") && !s.item.is("uiElement"))
            }
            fe.prototype.is = function(s) {
                return s === "range" || s === "view:range"
            }
            ;
            class mr extends Se(xi) {
                constructor(...e) {
                    super(),
                    C(this, "_ranges"),
                    C(this, "_lastRangeBackward"),
                    C(this, "_isFake"),
                    C(this, "_fakeSelectionLabel"),
                    this._ranges = [],
                    this._lastRangeBackward = !1,
                    this._isFake = !1,
                    this._fakeSelectionLabel = "",
                    e.length && this.setTo(...e)
                }
                get isFake() {
                    return this._isFake
                }
                get fakeSelectionLabel() {
                    return this._fakeSelectionLabel
                }
                get anchor() {
                    if (!this._ranges.length)
                        return null;
                    const e = this._ranges[this._ranges.length - 1];
                    return (this._lastRangeBackward ? e.end : e.start).clone()
                }
                get focus() {
                    if (!this._ranges.length)
                        return null;
                    const e = this._ranges[this._ranges.length - 1];
                    return (this._lastRangeBackward ? e.start : e.end).clone()
                }
                get isCollapsed() {
                    return this.rangeCount === 1 && this._ranges[0].isCollapsed
                }
                get rangeCount() {
                    return this._ranges.length
                }
                get isBackward() {
                    return !this.isCollapsed && this._lastRangeBackward
                }
                get editableElement() {
                    return this.anchor ? this.anchor.editableElement : null
                }
                *getRanges() {
                    for (const e of this._ranges)
                        yield e.clone()
                }
                getFirstRange() {
                    let e = null;
                    for (const t of this._ranges)
                        e && !t.start.isBefore(e.start) || (e = t);
                    return e ? e.clone() : null
                }
                getLastRange() {
                    let e = null;
                    for (const t of this._ranges)
                        e && !t.end.isAfter(e.end) || (e = t);
                    return e ? e.clone() : null
                }
                getFirstPosition() {
                    const e = this.getFirstRange();
                    return e ? e.start.clone() : null
                }
                getLastPosition() {
                    const e = this.getLastRange();
                    return e ? e.end.clone() : null
                }
                isEqual(e) {
                    if (this.isFake != e.isFake || this.isFake && this.fakeSelectionLabel != e.fakeSelectionLabel || this.rangeCount != e.rangeCount)
                        return !1;
                    if (this.rangeCount === 0)
                        return !0;
                    if (!this.anchor.isEqual(e.anchor) || !this.focus.isEqual(e.focus))
                        return !1;
                    for (const t of this._ranges) {
                        let r = !1;
                        for (const i of e._ranges)
                            if (t.isEqual(i)) {
                                r = !0;
                                break
                            }
                        if (!r)
                            return !1
                    }
                    return !0
                }
                isSimilar(e) {
                    if (this.isBackward != e.isBackward)
                        return !1;
                    const t = Sm(this.getRanges());
                    if (t != Sm(e.getRanges()))
                        return !1;
                    if (t == 0)
                        return !0;
                    for (let r of this.getRanges()) {
                        r = r.getTrimmed();
                        let i = !1;
                        for (let l of e.getRanges())
                            if (l = l.getTrimmed(),
                            r.start.isEqual(l.start) && r.end.isEqual(l.end)) {
                                i = !0;
                                break
                            }
                        if (!i)
                            return !1
                    }
                    return !0
                }
                getSelectedElement() {
                    return this.rangeCount !== 1 ? null : this.getFirstRange().getContainedElement()
                }
                setTo(...e) {
                    let[t,r,i] = e;
                    if (typeof r == "object" && (i = r,
                    r = void 0),
                    t === null)
                        this._setRanges([]),
                        this._setFakeOptions(i);
                    else if (t instanceof mr || t instanceof gp)
                        this._setRanges(t.getRanges(), t.isBackward),
                        this._setFakeOptions({
                            fake: t.isFake,
                            label: t.fakeSelectionLabel
                        });
                    else if (t instanceof fe)
                        this._setRanges([t], i && i.backward),
                        this._setFakeOptions(i);
                    else if (t instanceof ae)
                        this._setRanges([new fe(t)]),
                        this._setFakeOptions(i);
                    else if (t instanceof Ei) {
                        const l = !!i && !!i.backward;
                        let d;
                        if (r === void 0)
                            throw new U("view-selection-setto-required-second-parameter",this);
                        d = r == "in" ? fe._createIn(t) : r == "on" ? fe._createOn(t) : new fe(ae._createAt(t, r)),
                        this._setRanges([d], l),
                        this._setFakeOptions(i)
                    } else {
                        if (!yo(t))
                            throw new U("view-selection-setto-not-selectable",this);
                        this._setRanges(t, i && i.backward),
                        this._setFakeOptions(i)
                    }
                    this.fire("change")
                }
                setFocus(e, t) {
                    if (this.anchor === null)
                        throw new U("view-selection-setfocus-no-ranges",this);
                    const r = ae._createAt(e, t);
                    if (r.compareWith(this.focus) == "same")
                        return;
                    const i = this.anchor;
                    this._ranges.pop(),
                    r.compareWith(i) == "before" ? this._addRange(new fe(r,i), !0) : this._addRange(new fe(i,r)),
                    this.fire("change")
                }
                _setRanges(e, t=!1) {
                    e = Array.from(e),
                    this._ranges = [];
                    for (const r of e)
                        this._addRange(r);
                    this._lastRangeBackward = !!t
                }
                _setFakeOptions(e={}) {
                    this._isFake = !!e.fake,
                    this._fakeSelectionLabel = e.fake && e.label || ""
                }
                _addRange(e, t=!1) {
                    if (!(e instanceof fe))
                        throw new U("view-selection-add-range-not-range",this);
                    this._pushRange(e),
                    this._lastRangeBackward = !!t
                }
                _pushRange(e) {
                    for (const t of this._ranges)
                        if (e.isIntersecting(t))
                            throw new U("view-selection-range-intersects",this,{
                                addedRange: e,
                                intersectingRange: t
                            });
                    this._ranges.push(new fe(e.start,e.end))
                }
            }
            mr.prototype.is = function(s) {
                return s === "selection" || s === "view:selection"
            }
            ;
            class gp extends Se(xi) {
                constructor(...e) {
                    super(),
                    C(this, "_selection"),
                    this._selection = new mr,
                    this._selection.delegate("change").to(this),
                    e.length && this._selection.setTo(...e)
                }
                get isFake() {
                    return this._selection.isFake
                }
                get fakeSelectionLabel() {
                    return this._selection.fakeSelectionLabel
                }
                get anchor() {
                    return this._selection.anchor
                }
                get focus() {
                    return this._selection.focus
                }
                get isCollapsed() {
                    return this._selection.isCollapsed
                }
                get rangeCount() {
                    return this._selection.rangeCount
                }
                get isBackward() {
                    return this._selection.isBackward
                }
                get editableElement() {
                    return this._selection.editableElement
                }
                get _ranges() {
                    return this._selection._ranges
                }
                *getRanges() {
                    yield*this._selection.getRanges()
                }
                getFirstRange() {
                    return this._selection.getFirstRange()
                }
                getLastRange() {
                    return this._selection.getLastRange()
                }
                getFirstPosition() {
                    return this._selection.getFirstPosition()
                }
                getLastPosition() {
                    return this._selection.getLastPosition()
                }
                getSelectedElement() {
                    return this._selection.getSelectedElement()
                }
                isEqual(e) {
                    return this._selection.isEqual(e)
                }
                isSimilar(e) {
                    return this._selection.isSimilar(e)
                }
                _setTo(...e) {
                    this._selection.setTo(...e)
                }
                _setFocus(e, t) {
                    this._selection.setFocus(e, t)
                }
            }
            gp.prototype.is = function(s) {
                return s === "selection" || s == "documentSelection" || s == "view:selection" || s == "view:documentSelection"
            }
            ;
            class xs extends K {
                constructor(e, t, r) {
                    super(e, t),
                    C(this, "startRange"),
                    C(this, "_eventPhase"),
                    C(this, "_currentTarget"),
                    this.startRange = r,
                    this._eventPhase = "none",
                    this._currentTarget = null
                }
                get eventPhase() {
                    return this._eventPhase
                }
                get currentTarget() {
                    return this._currentTarget
                }
            }
            const fp = Symbol("bubbling contexts");
            function kp(s) {
                return class extends s {
                    fire(e, ...t) {
                        try {
                            const r = e instanceof K ? e : new K(this,e)
                              , i = bp(this);
                            if (!i.size)
                                return;
                            if (gl(r, "capturing", this),
                            Es(i, "$capture", r, ...t))
                                return r.return;
                            const l = r.startRange || this.selection.getFirstRange()
                              , d = l ? l.getContainedElement() : null
                              , h = !!d && !!Pv(i, d);
                            let m = d || function(g) {
                                if (!g)
                                    return null;
                                const b = g.start.parent
                                  , v = g.end.parent
                                  , x = b.getPath()
                                  , T = v.getPath();
                                return x.length > T.length ? b : v
                            }(l);
                            if (gl(r, "atTarget", m),
                            !h) {
                                if (Es(i, "$text", r, ...t))
                                    return r.return;
                                gl(r, "bubbling", m)
                            }
                            for (; m; ) {
                                if (m.is("rootElement")) {
                                    if (Es(i, "$root", r, ...t))
                                        return r.return
                                } else if (m.is("element") && Es(i, m.name, r, ...t))
                                    return r.return;
                                if (Es(i, m, r, ...t))
                                    return r.return;
                                m = m.parent,
                                gl(r, "bubbling", m)
                            }
                            return gl(r, "bubbling", this),
                            Es(i, "$document", r, ...t),
                            r.return
                        } catch (r) {
                            U.rethrowUnexpectedError(r, this)
                        }
                    }
                    _addEventListener(e, t, r) {
                        const i = Ze(r.context || "$document")
                          , l = bp(this);
                        for (const d of i) {
                            let h = l.get(d);
                            h || (h = new (Se()),
                            l.set(d, h)),
                            this.listenTo(h, e, t, r)
                        }
                    }
                    _removeEventListener(e, t) {
                        const r = bp(this);
                        for (const i of r.values())
                            this.stopListening(i, e, t)
                    }
                }
            }
            {
                const s = kp(Object);
                ["fire", "_addEventListener", "_removeEventListener"].forEach(e => {
                    kp[e] = s.prototype[e]
                }
                )
            }
            function gl(s, e, t) {
                s instanceof xs && (s._eventPhase = e,
                s._currentTarget = t)
            }
            function Es(s, e, t, ...r) {
                const i = typeof e == "string" ? s.get(e) : Pv(s, e);
                return !!i && (i.fire(t, ...r),
                t.stop.called)
            }
            function Pv(s, e) {
                for (const [t,r] of s)
                    if (typeof t == "function" && t(e))
                        return r;
                return null
            }
            function bp(s) {
                return s[fp] || (s[fp] = new Map),
                s[fp]
            }
            class zd extends kp(ye()) {
                constructor(e) {
                    super(),
                    C(this, "selection"),
                    C(this, "roots"),
                    C(this, "stylesProcessor"),
                    C(this, "_postFixers", new Set),
                    this.selection = new gp,
                    this.roots = new dr({
                        idProperty: "rootName"
                    }),
                    this.stylesProcessor = e,
                    this.set("isReadOnly", !1),
                    this.set("isFocused", !1),
                    this.set("isSelecting", !1),
                    this.set("isComposing", !1)
                }
                getRoot(e="main") {
                    return this.roots.get(e)
                }
                registerPostFixer(e) {
                    this._postFixers.add(e)
                }
                destroy() {
                    this.roots.forEach(e => e.destroy()),
                    this.stopListening()
                }
                _callPostFixers(e) {
                    let t = !1;
                    do
                        for (const r of this._postFixers)
                            if (t = r(e),
                            t)
                                break;
                    while (t)
                }
            }
            class Di extends So {
                constructor(e, t, r, i) {
                    super(e, t, r, i),
                    C(this, "_priority", 10),
                    C(this, "_id", null),
                    C(this, "_clonesGroup", null),
                    this.getFillerOffset = iP
                }
                get priority() {
                    return this._priority
                }
                get id() {
                    return this._id
                }
                getElementsWithSameId() {
                    if (this.id === null)
                        throw new U("attribute-element-get-elements-with-same-id-no-id",this);
                    return new Set(this._clonesGroup)
                }
                isSimilar(e) {
                    return this.id !== null || e.id !== null ? this.id === e.id : super.isSimilar(e) && this.priority == e.priority
                }
                _clone(e=!1) {
                    const t = super._clone(e);
                    return t._priority = this._priority,
                    t._id = this._id,
                    t
                }
            }
            C(Di, "DEFAULT_PRIORITY", 10);
            function iP() {
                if (wp(this))
                    return null;
                let s = this.parent;
                for (; s && s.is("attributeElement"); ) {
                    if (wp(s) > 1)
                        return null;
                    s = s.parent
                }
                return !s || wp(s) > 1 ? null : this.childCount
            }
            function wp(s) {
                return Array.from(s.getChildren()).filter(e => !e.is("uiElement")).length
            }
            Di.prototype.is = function(s, e) {
                return e ? e === this.name && (s === "attributeElement" || s === "view:attributeElement" || s === "element" || s === "view:element") : s === "attributeElement" || s === "view:attributeElement" || s === "element" || s === "view:element" || s === "node" || s === "view:node"
            }
            ;
            class Ap extends So {
                constructor(e, t, r, i) {
                    super(e, t, r, i),
                    this.getFillerOffset = sP
                }
                _insertChild(e, t) {
                    if (t && (t instanceof Ei || Array.from(t).length > 0))
                        throw new U("view-emptyelement-cannot-add",[this, t]);
                    return 0
                }
            }
            function sP() {
                return null
            }
            Ap.prototype.is = function(s, e) {
                return e ? e === this.name && (s === "emptyElement" || s === "view:emptyElement" || s === "element" || s === "view:element") : s === "emptyElement" || s === "view:emptyElement" || s === "element" || s === "view:element" || s === "node" || s === "view:node"
            }
            ;
            class Od extends So {
                constructor(e, t, r, i) {
                    super(e, t, r, i),
                    this.getFillerOffset = lP
                }
                _insertChild(e, t) {
                    if (t && (t instanceof Ei || Array.from(t).length > 0))
                        throw new U("view-uielement-cannot-add",[this, t]);
                    return 0
                }
                render(e, t) {
                    return this.toDomElement(e)
                }
                toDomElement(e) {
                    const t = e.createElement(this.name);
                    for (const r of this.getAttributeKeys())
                        t.setAttribute(r, this.getAttribute(r));
                    return t
                }
            }
            function aP(s) {
                s.document.on("arrowKey", (e, t) => function(r, i, l) {
                    if (i.keyCode == Me.arrowright) {
                        const d = i.domTarget.ownerDocument.defaultView.getSelection()
                          , h = d.rangeCount == 1 && d.getRangeAt(0).collapsed;
                        if (h || i.shiftKey) {
                            const m = d.focusNode
                              , g = d.focusOffset
                              , b = l.domPositionToView(m, g);
                            if (b === null)
                                return;
                            let v = !1;
                            const x = b.getLastMatchingPosition(T => (T.item.is("uiElement") && (v = !0),
                            !(!T.item.is("uiElement") && !T.item.is("attributeElement"))));
                            if (v) {
                                const T = l.viewPositionToDom(x);
                                h ? d.collapse(T.parent, T.offset) : d.extend(T.parent, T.offset)
                            }
                        }
                    }
                }(0, t, s.domConverter), {
                    priority: "low"
                })
            }
            function lP() {
                return null
            }
            Od.prototype.is = function(s, e) {
                return e ? e === this.name && (s === "uiElement" || s === "view:uiElement" || s === "element" || s === "view:element") : s === "uiElement" || s === "view:uiElement" || s === "element" || s === "view:element" || s === "node" || s === "view:node"
            }
            ;
            class vp extends So {
                constructor(e, t, r, i) {
                    super(e, t, r, i),
                    this.getFillerOffset = cP
                }
                _insertChild(e, t) {
                    if (t && (t instanceof Ei || Array.from(t).length > 0))
                        throw new U("view-rawelement-cannot-add",[this, t]);
                    return 0
                }
                render(e, t) {}
            }
            function cP() {
                return null
            }
            vp.prototype.is = function(s, e) {
                return e ? e === this.name && (s === "rawElement" || s === "view:rawElement" || s === "element" || s === "view:element") : s === "rawElement" || s === "view:rawElement" || s === this.name || s === "view:" + this.name || s === "element" || s === "view:element" || s === "node" || s === "view:node"
            }
            ;
            class Ti extends Se(xi) {
                constructor(e, t) {
                    super(),
                    C(this, "document"),
                    C(this, "_children", []),
                    C(this, "_customProperties", new Map),
                    this.document = e,
                    t && this._insertChild(0, t)
                }
                [Symbol.iterator]() {
                    return this._children[Symbol.iterator]()
                }
                get childCount() {
                    return this._children.length
                }
                get isEmpty() {
                    return this.childCount === 0
                }
                get root() {
                    return this
                }
                get parent() {
                    return null
                }
                get name() {}
                get getFillerOffset() {}
                getCustomProperty(e) {
                    return this._customProperties.get(e)
                }
                *getCustomProperties() {
                    yield*this._customProperties.entries()
                }
                _appendChild(e) {
                    return this._insertChild(this.childCount, e)
                }
                getChild(e) {
                    return this._children[e]
                }
                getChildIndex(e) {
                    return this._children.indexOf(e)
                }
                getChildren() {
                    return this._children[Symbol.iterator]()
                }
                _insertChild(e, t) {
                    this._fireChange("children", this);
                    let r = 0;
                    const i = function(l, d) {
                        return typeof d == "string" ? [new We(l,d)] : (yo(d) || (d = [d]),
                        Array.from(d).map(h => typeof h == "string" ? new We(l,h) : h instanceof Mr ? new We(l,h.data) : h))
                    }(this.document, t);
                    for (const l of i)
                        l.parent !== null && l._remove(),
                        l.parent = this,
                        this._children.splice(e, 0, l),
                        e++,
                        r++;
                    return r
                }
                _removeChildren(e, t=1) {
                    this._fireChange("children", this);
                    for (let r = e; r < e + t; r++)
                        this._children[r].parent = null;
                    return this._children.splice(e, t)
                }
                _fireChange(e, t) {
                    this.fire("change:" + e, t)
                }
                _setCustomProperty(e, t) {
                    this._customProperties.set(e, t)
                }
                _removeCustomProperty(e) {
                    return this._customProperties.delete(e)
                }
            }
            Ti.prototype.is = function(s) {
                return s === "documentFragment" || s === "view:documentFragment"
            }
            ;
            class jv {
                constructor(e) {
                    C(this, "document"),
                    C(this, "_cloneGroups", new Map),
                    C(this, "_slotFactory", null),
                    this.document = e
                }
                setSelection(...e) {
                    this.document.selection._setTo(...e)
                }
                setSelectionFocus(e, t) {
                    this.document.selection._setFocus(e, t)
                }
                createDocumentFragment(e) {
                    return new Ti(this.document,e)
                }
                createText(e) {
                    return new We(this.document,e)
                }
                createAttributeElement(e, t, r={}) {
                    const i = new Di(this.document,e,t);
                    return typeof r.priority == "number" && (i._priority = r.priority),
                    r.id && (i._id = r.id),
                    r.renderUnsafeAttributes && i._unsafeAttributesToRender.push(...r.renderUnsafeAttributes),
                    i
                }
                createContainerElement(e, t, r={}, i={}) {
                    let l = null;
                    Eo(r) ? i = r : l = r;
                    const d = new pl(this.document,e,t,l);
                    return i.renderUnsafeAttributes && d._unsafeAttributesToRender.push(...i.renderUnsafeAttributes),
                    d
                }
                createEditableElement(e, t, r={}) {
                    const i = new jd(this.document,e,t);
                    return r.renderUnsafeAttributes && i._unsafeAttributesToRender.push(...r.renderUnsafeAttributes),
                    i
                }
                createEmptyElement(e, t, r={}) {
                    const i = new Ap(this.document,e,t);
                    return r.renderUnsafeAttributes && i._unsafeAttributesToRender.push(...r.renderUnsafeAttributes),
                    i
                }
                createUIElement(e, t, r) {
                    const i = new Od(this.document,e,t);
                    return r && (i.render = r),
                    i
                }
                createRawElement(e, t, r, i={}) {
                    const l = new vp(this.document,e,t);
                    return r && (l.render = r),
                    i.renderUnsafeAttributes && l._unsafeAttributesToRender.push(...i.renderUnsafeAttributes),
                    l
                }
                setAttribute(e, t, r) {
                    r._setAttribute(e, t)
                }
                removeAttribute(e, t) {
                    t._removeAttribute(e)
                }
                addClass(e, t) {
                    t._addClass(e)
                }
                removeClass(e, t) {
                    t._removeClass(e)
                }
                setStyle(e, t, r) {
                    Eo(e) && r === void 0 ? t._setStyle(e) : r._setStyle(e, t)
                }
                removeStyle(e, t) {
                    t._removeStyle(e)
                }
                setCustomProperty(e, t, r) {
                    r._setCustomProperty(e, t)
                }
                removeCustomProperty(e, t) {
                    return t._removeCustomProperty(e)
                }
                breakAttributes(e) {
                    return e instanceof ae ? this._breakAttributes(e) : this._breakAttributesRange(e)
                }
                breakContainer(e) {
                    const t = e.parent;
                    if (!t.is("containerElement"))
                        throw new U("view-writer-break-non-container-element",this.document);
                    if (!t.parent)
                        throw new U("view-writer-break-root",this.document);
                    if (e.isAtStart)
                        return ae._createBefore(t);
                    if (!e.isAtEnd) {
                        const r = t._clone(!1);
                        this.insert(ae._createAfter(t), r);
                        const i = new fe(e,ae._createAt(t, "end"))
                          , l = new ae(r,0);
                        this.move(i, l)
                    }
                    return ae._createAfter(t)
                }
                mergeAttributes(e) {
                    const t = e.offset
                      , r = e.parent;
                    if (r.is("$text"))
                        return e;
                    if (r.is("attributeElement") && r.childCount === 0) {
                        const d = r.parent
                          , h = r.index;
                        return r._remove(),
                        this._removeFromClonedElementsGroup(r),
                        this.mergeAttributes(new ae(d,h))
                    }
                    const i = r.getChild(t - 1)
                      , l = r.getChild(t);
                    if (!i || !l)
                        return e;
                    if (i.is("$text") && l.is("$text"))
                        return zv(i, l);
                    if (i.is("attributeElement") && l.is("attributeElement") && i.isSimilar(l)) {
                        const d = i.childCount;
                        return i._appendChild(l.getChildren()),
                        l._remove(),
                        this._removeFromClonedElementsGroup(l),
                        this.mergeAttributes(new ae(i,d))
                    }
                    return e
                }
                mergeContainers(e) {
                    const t = e.nodeBefore
                      , r = e.nodeAfter;
                    if (!(t && r && t.is("containerElement") && r.is("containerElement")))
                        throw new U("view-writer-merge-containers-invalid-position",this.document);
                    const i = t.getChild(t.childCount - 1)
                      , l = i instanceof We ? ae._createAt(i, "end") : ae._createAt(t, "end");
                    return this.move(fe._createIn(r), ae._createAt(t, "end")),
                    this.remove(fe._createOn(r)),
                    l
                }
                insert(e, t) {
                    Ov(t = yo(t) ? [...t] : [t], this.document);
                    const r = t.reduce( (d, h) => {
                        const m = d[d.length - 1]
                          , g = !h.is("uiElement");
                        return m && m.breakAttributes == g ? m.nodes.push(h) : d.push({
                            breakAttributes: g,
                            nodes: [h]
                        }),
                        d
                    }
                    , []);
                    let i = null
                      , l = e;
                    for (const {nodes: d, breakAttributes: h} of r) {
                        const m = this._insertNodes(l, d, h);
                        i || (i = m.start),
                        l = m.end
                    }
                    return i ? new fe(i,l) : new fe(e)
                }
                remove(e) {
                    const t = e instanceof fe ? e : fe._createOn(e);
                    if (fl(t, this.document),
                    t.isCollapsed)
                        return new Ti(this.document);
                    const {start: r, end: i} = this._breakAttributesRange(t, !0)
                      , l = r.parent
                      , d = i.offset - r.offset
                      , h = l._removeChildren(r.offset, d);
                    for (const g of h)
                        this._removeFromClonedElementsGroup(g);
                    const m = this.mergeAttributes(r);
                    return t.start = m,
                    t.end = m.clone(),
                    new Ti(this.document,h)
                }
                clear(e, t) {
                    fl(e, this.document);
                    const r = e.getWalker({
                        direction: "backward",
                        ignoreElementEnd: !0
                    });
                    for (const i of r) {
                        const l = i.item;
                        let d;
                        if (l.is("element") && t.isSimilar(l))
                            d = fe._createOn(l);
                        else if (!i.nextPosition.isAfter(e.start) && l.is("$textProxy")) {
                            const h = l.getAncestors().find(m => m.is("element") && t.isSimilar(m));
                            h && (d = fe._createIn(h))
                        }
                        d && (d.end.isAfter(e.end) && (d.end = e.end),
                        d.start.isBefore(e.start) && (d.start = e.start),
                        this.remove(d))
                    }
                }
                move(e, t) {
                    let r;
                    if (t.isAfter(e.end)) {
                        const i = (t = this._breakAttributes(t, !0)).parent
                          , l = i.childCount;
                        e = this._breakAttributesRange(e, !0),
                        r = this.remove(e),
                        t.offset += i.childCount - l
                    } else
                        r = this.remove(e);
                    return this.insert(t, r)
                }
                wrap(e, t) {
                    if (!(t instanceof Di))
                        throw new U("view-writer-wrap-invalid-attribute",this.document);
                    if (fl(e, this.document),
                    e.isCollapsed) {
                        let i = e.start;
                        i.parent.is("element") && (r = i.parent,
                        !Array.from(r.getChildren()).some(d => !d.is("uiElement"))) && (i = i.getLastMatchingPosition(d => d.item.is("uiElement"))),
                        i = this._wrapPosition(i, t);
                        const l = this.document.selection;
                        return l.isCollapsed && l.getFirstPosition().isEqual(e.start) && this.setSelection(i),
                        new fe(i)
                    }
                    return this._wrapRange(e, t);
                    var r
                }
                unwrap(e, t) {
                    if (!(t instanceof Di))
                        throw new U("view-writer-unwrap-invalid-attribute",this.document);
                    if (fl(e, this.document),
                    e.isCollapsed)
                        return e;
                    const {start: r, end: i} = this._breakAttributesRange(e, !0)
                      , l = r.parent
                      , d = this._unwrapChildren(l, r.offset, i.offset, t)
                      , h = this.mergeAttributes(d.start);
                    h.isEqual(d.start) || d.end.offset--;
                    const m = this.mergeAttributes(d.end);
                    return new fe(h,m)
                }
                rename(e, t) {
                    const r = new pl(this.document,e,t.getAttributes());
                    return this.insert(ae._createAfter(t), r),
                    this.move(fe._createIn(t), ae._createAt(r, 0)),
                    this.remove(fe._createOn(t)),
                    r
                }
                clearClonedElementsGroup(e) {
                    this._cloneGroups.delete(e)
                }
                createPositionAt(e, t) {
                    return ae._createAt(e, t)
                }
                createPositionAfter(e) {
                    return ae._createAfter(e)
                }
                createPositionBefore(e) {
                    return ae._createBefore(e)
                }
                createRange(e, t) {
                    return new fe(e,t)
                }
                createRangeOn(e) {
                    return fe._createOn(e)
                }
                createRangeIn(e) {
                    return fe._createIn(e)
                }
                createSelection(...e) {
                    return new mr(...e)
                }
                createSlot(e="children") {
                    if (!this._slotFactory)
                        throw new U("view-writer-invalid-create-slot-context",this.document);
                    return this._slotFactory(this, e)
                }
                _registerSlotFactory(e) {
                    this._slotFactory = e
                }
                _clearSlotFactory() {
                    this._slotFactory = null
                }
                _insertNodes(e, t, r) {
                    let i, l;
                    if (i = r ? _p(e) : e.parent.is("$text") ? e.parent.parent : e.parent,
                    !i)
                        throw new U("view-writer-invalid-position-container",this.document);
                    l = r ? this._breakAttributes(e, !0) : e.parent.is("$text") ? Cp(e) : e;
                    const d = i._insertChild(l.offset, t);
                    for (const b of t)
                        this._addToClonedElementsGroup(b);
                    const h = l.getShiftedBy(d)
                      , m = this.mergeAttributes(l);
                    m.isEqual(l) || h.offset--;
                    const g = this.mergeAttributes(h);
                    return new fe(m,g)
                }
                _wrapChildren(e, t, r, i) {
                    let l = t;
                    const d = [];
                    for (; l < r; ) {
                        const m = e.getChild(l)
                          , g = m.is("$text")
                          , b = m.is("attributeElement");
                        if (b && this._wrapAttributeElement(i, m))
                            d.push(new ae(e,l));
                        else if (g || !b || dP(i, m)) {
                            const v = i._clone();
                            m._remove(),
                            v._appendChild(m),
                            e._insertChild(l, v),
                            this._addToClonedElementsGroup(v),
                            d.push(new ae(e,l))
                        } else
                            this._wrapChildren(m, 0, m.childCount, i);
                        l++
                    }
                    let h = 0;
                    for (const m of d)
                        m.offset -= h,
                        m.offset != t && (this.mergeAttributes(m).isEqual(m) || (h++,
                        r--));
                    return fe._createFromParentsAndOffsets(e, t, e, r)
                }
                _unwrapChildren(e, t, r, i) {
                    let l = t;
                    const d = [];
                    for (; l < r; ) {
                        const m = e.getChild(l);
                        if (m.is("attributeElement"))
                            if (m.isSimilar(i)) {
                                const g = m.getChildren()
                                  , b = m.childCount;
                                m._remove(),
                                e._insertChild(l, g),
                                this._removeFromClonedElementsGroup(m),
                                d.push(new ae(e,l), new ae(e,l + b)),
                                l += b,
                                r += b - 1
                            } else
                                this._unwrapAttributeElement(i, m) ? (d.push(new ae(e,l), new ae(e,l + 1)),
                                l++) : (this._unwrapChildren(m, 0, m.childCount, i),
                                l++);
                        else
                            l++
                    }
                    let h = 0;
                    for (const m of d)
                        m.offset -= h,
                        !(m.offset == t || m.offset == r) && (this.mergeAttributes(m).isEqual(m) || (h++,
                        r--));
                    return fe._createFromParentsAndOffsets(e, t, e, r)
                }
                _wrapRange(e, t) {
                    const {start: r, end: i} = this._breakAttributesRange(e, !0)
                      , l = r.parent
                      , d = this._wrapChildren(l, r.offset, i.offset, t)
                      , h = this.mergeAttributes(d.start);
                    h.isEqual(d.start) || d.end.offset--;
                    const m = this.mergeAttributes(d.end);
                    return new fe(h,m)
                }
                _wrapPosition(e, t) {
                    if (t.isSimilar(e.parent))
                        return Lv(e.clone());
                    e.parent.is("$text") && (e = Cp(e));
                    const r = this.createAttributeElement("_wrapPosition-fake-element");
                    r._priority = Number.POSITIVE_INFINITY,
                    r.isSimilar = () => !1,
                    e.parent._insertChild(e.offset, r);
                    const i = new fe(e,e.getShiftedBy(1));
                    this.wrap(i, t);
                    const l = new ae(r.parent,r.index);
                    r._remove();
                    const d = l.nodeBefore
                      , h = l.nodeAfter;
                    return d instanceof We && h instanceof We ? zv(d, h) : Lv(l)
                }
                _wrapAttributeElement(e, t) {
                    if (!Rv(e, t) || e.name !== t.name || e.priority !== t.priority)
                        return !1;
                    for (const r of e.getAttributeKeys())
                        if (r !== "class" && r !== "style" && t.hasAttribute(r) && t.getAttribute(r) !== e.getAttribute(r))
                            return !1;
                    for (const r of e.getStyleNames())
                        if (t.hasStyle(r) && t.getStyle(r) !== e.getStyle(r))
                            return !1;
                    for (const r of e.getAttributeKeys())
                        r !== "class" && r !== "style" && (t.hasAttribute(r) || this.setAttribute(r, e.getAttribute(r), t));
                    for (const r of e.getStyleNames())
                        t.hasStyle(r) || this.setStyle(r, e.getStyle(r), t);
                    for (const r of e.getClassNames())
                        t.hasClass(r) || this.addClass(r, t);
                    return !0
                }
                _unwrapAttributeElement(e, t) {
                    if (!Rv(e, t) || e.name !== t.name || e.priority !== t.priority)
                        return !1;
                    for (const r of e.getAttributeKeys())
                        if (r !== "class" && r !== "style" && (!t.hasAttribute(r) || t.getAttribute(r) !== e.getAttribute(r)))
                            return !1;
                    if (!t.hasClass(...e.getClassNames()))
                        return !1;
                    for (const r of e.getStyleNames())
                        if (!t.hasStyle(r) || t.getStyle(r) !== e.getStyle(r))
                            return !1;
                    for (const r of e.getAttributeKeys())
                        r !== "class" && r !== "style" && this.removeAttribute(r, t);
                    return this.removeClass(Array.from(e.getClassNames()), t),
                    this.removeStyle(Array.from(e.getStyleNames()), t),
                    !0
                }
                _breakAttributesRange(e, t=!1) {
                    const r = e.start
                      , i = e.end;
                    if (fl(e, this.document),
                    e.isCollapsed) {
                        const m = this._breakAttributes(e.start, t);
                        return new fe(m,m)
                    }
                    const l = this._breakAttributes(i, t)
                      , d = l.parent.childCount
                      , h = this._breakAttributes(r, t);
                    return l.offset += l.parent.childCount - d,
                    new fe(h,l)
                }
                _breakAttributes(e, t=!1) {
                    const r = e.offset
                      , i = e.parent;
                    if (e.parent.is("emptyElement"))
                        throw new U("view-writer-cannot-break-empty-element",this.document);
                    if (e.parent.is("uiElement"))
                        throw new U("view-writer-cannot-break-ui-element",this.document);
                    if (e.parent.is("rawElement"))
                        throw new U("view-writer-cannot-break-raw-element",this.document);
                    if (!t && i.is("$text") && yp(i.parent) || yp(i))
                        return e.clone();
                    if (i.is("$text"))
                        return this._breakAttributes(Cp(e), t);
                    if (r == i.childCount) {
                        const l = new ae(i.parent,i.index + 1);
                        return this._breakAttributes(l, t)
                    }
                    if (r === 0) {
                        const l = new ae(i.parent,i.index);
                        return this._breakAttributes(l, t)
                    }
                    {
                        const l = i.index + 1
                          , d = i._clone();
                        i.parent._insertChild(l, d),
                        this._addToClonedElementsGroup(d);
                        const h = i.childCount - r
                          , m = i._removeChildren(r, h);
                        d._appendChild(m);
                        const g = new ae(i.parent,l);
                        return this._breakAttributes(g, t)
                    }
                }
                _addToClonedElementsGroup(e) {
                    if (!e.root.is("rootElement"))
                        return;
                    if (e.is("element"))
                        for (const i of e.getChildren())
                            this._addToClonedElementsGroup(i);
                    const t = e.id;
                    if (!t)
                        return;
                    let r = this._cloneGroups.get(t);
                    r || (r = new Set,
                    this._cloneGroups.set(t, r)),
                    r.add(e),
                    e._clonesGroup = r
                }
                _removeFromClonedElementsGroup(e) {
                    if (e.is("element"))
                        for (const i of e.getChildren())
                            this._removeFromClonedElementsGroup(i);
                    const t = e.id;
                    if (!t)
                        return;
                    const r = this._cloneGroups.get(t);
                    r && r.delete(e)
                }
            }
            function _p(s) {
                let e = s.parent;
                for (; !yp(e); ) {
                    if (!e)
                        return;
                    e = e.parent
                }
                return e
            }
            function dP(s, e) {
                return s.priority < e.priority || !(s.priority > e.priority) && s.getIdentity() < e.getIdentity()
            }
            function Lv(s) {
                const e = s.nodeBefore;
                if (e && e.is("$text"))
                    return new ae(e,e.data.length);
                const t = s.nodeAfter;
                return t && t.is("$text") ? new ae(t,0) : s
            }
            function Cp(s) {
                if (s.offset == s.parent.data.length)
                    return new ae(s.parent.parent,s.parent.index + 1);
                if (s.offset === 0)
                    return new ae(s.parent.parent,s.parent.index);
                const e = s.parent.data.slice(s.offset);
                return s.parent._data = s.parent.data.slice(0, s.offset),
                s.parent.parent._insertChild(s.parent.index + 1, new We(s.root.document,e)),
                new ae(s.parent.parent,s.parent.index + 1)
            }
            function zv(s, e) {
                const t = s.data.length;
                return s._data += e.data,
                e._remove(),
                new ae(s,t)
            }
            const uP = [We, Di, pl, Ap, vp, Od];
            function Ov(s, e) {
                for (const t of s) {
                    if (!uP.some(r => t instanceof r))
                        throw new U("view-writer-insert-invalid-node-type",e);
                    t.is("$text") || Ov(t.getChildren(), e)
                }
            }
            function yp(s) {
                return s && (s.is("containerElement") || s.is("documentFragment"))
            }
            function fl(s, e) {
                const t = _p(s.start)
                  , r = _p(s.end);
                if (!t || !r || t !== r)
                    throw new U("view-writer-invalid-range-container",e)
            }
            function Rv(s, e) {
                return s.id === null && e.id === null
            }
            const Fv = s => s.createTextNode(" ")
              , Vv = s => {
                const e = s.createElement("span");
                return e.dataset.ckeFiller = "true",
                e.innerText = " ",
                e
            }
              , Uv = s => {
                const e = s.createElement("br");
                return e.dataset.ckeFiller = "true",
                e
            }
              , pr = 7
              , kl = "⁠".repeat(pr);
            function Do(s) {
                return typeof s == "string" ? s.substr(0, pr) === kl : bt(s) && s.data.substr(0, pr) === kl
            }
            function Ss(s) {
                return s.data.length == pr && Do(s)
            }
            function Hv(s) {
                const e = typeof s == "string" ? s : s.data;
                return Do(s) ? e.slice(pr) : e
            }
            function hP(s, e) {
                if (e.keyCode == Me.arrowleft) {
                    const t = e.domTarget.ownerDocument.defaultView.getSelection();
                    if (t.rangeCount == 1 && t.getRangeAt(0).collapsed) {
                        const r = t.getRangeAt(0).startContainer
                          , i = t.getRangeAt(0).startOffset;
                        Do(r) && i <= pr && t.collapse(r, 0)
                    }
                }
            }
            var Wv = u(8264)
              , mP = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(Wv.A, mP),
            Wv.A.locals;
            class pP extends ye() {
                constructor(e, t) {
                    super(),
                    C(this, "domDocuments", new Set),
                    C(this, "domConverter"),
                    C(this, "markedAttributes", new Set),
                    C(this, "markedChildren", new Set),
                    C(this, "markedTexts", new Set),
                    C(this, "selection"),
                    C(this, "_inlineFiller", null),
                    C(this, "_fakeSelectionContainer", null),
                    this.domConverter = e,
                    this.selection = t,
                    this.set("isFocused", !1),
                    this.set("isSelecting", !1),
                    E.isBlink && !E.isAndroid && this.on("change:isSelecting", () => {
                        this.isSelecting || this.render()
                    }
                    ),
                    this.set("isComposing", !1),
                    this.on("change:isComposing", () => {
                        this.isComposing || this.render()
                    }
                    )
                }
                markToSync(e, t) {
                    if (e === "text")
                        this.domConverter.mapViewToDom(t.parent) && this.markedTexts.add(t);
                    else {
                        if (!this.domConverter.mapViewToDom(t))
                            return;
                        if (e === "attributes")
                            this.markedAttributes.add(t);
                        else {
                            if (e !== "children")
                                throw new U("view-renderer-unknown-type",this);
                            this.markedChildren.add(t)
                        }
                    }
                }
                render() {
                    if (this.isComposing && !E.isAndroid)
                        return;
                    let e = null;
                    const t = !(E.isBlink && !E.isAndroid) || !this.isSelecting;
                    for (const r of this.markedChildren)
                        this._updateChildrenMappings(r);
                    t ? (this._inlineFiller && !this._isSelectionInInlineFiller() && this._removeInlineFiller(),
                    this._inlineFiller ? e = this._getInlineFillerPosition() : this._needsInlineFillerAtSelection() && (e = this.selection.getFirstPosition(),
                    this.markedChildren.add(e.parent))) : this._inlineFiller && this._inlineFiller.parentNode && (e = this.domConverter.domPositionToView(this._inlineFiller),
                    e && e.parent.is("$text") && (e = ae._createBefore(e.parent)));
                    for (const r of this.markedAttributes)
                        this._updateAttrs(r);
                    for (const r of this.markedChildren)
                        this._updateChildren(r, {
                            inlineFillerPosition: e
                        });
                    for (const r of this.markedTexts)
                        !this.markedChildren.has(r.parent) && this.domConverter.mapViewToDom(r.parent) && this._updateText(r, {
                            inlineFillerPosition: e
                        });
                    if (t)
                        if (e) {
                            const r = this.domConverter.viewPositionToDom(e)
                              , i = r.parent.ownerDocument;
                            Do(r.parent) ? this._inlineFiller = r.parent : this._inlineFiller = $v(i, r.parent, r.offset)
                        } else
                            this._inlineFiller = null;
                    this._updateFocus(),
                    this._updateSelection(),
                    this.domConverter._clearTemporaryCustomProperties(),
                    this.markedTexts.clear(),
                    this.markedAttributes.clear(),
                    this.markedChildren.clear()
                }
                _updateChildrenMappings(e) {
                    const t = this.domConverter.mapViewToDom(e);
                    if (!t)
                        return;
                    const r = Array.from(t.childNodes)
                      , i = Array.from(this.domConverter.viewChildrenToDom(e, {
                        withChildren: !1
                    }))
                      , l = this._diffNodeLists(r, i)
                      , d = this._findUpdateActions(l, r, i, gP);
                    if (d.indexOf("update") !== -1) {
                        const h = {
                            equal: 0,
                            insert: 0,
                            delete: 0
                        };
                        for (const m of d)
                            if (m === "update") {
                                const g = h.equal + h.insert
                                  , b = h.equal + h.delete
                                  , v = e.getChild(g);
                                !v || v.is("uiElement") || v.is("rawElement") || this._updateElementMappings(v, r[b]),
                                KA(i[g]),
                                h.equal++
                            } else
                                h[m]++
                    }
                }
                _updateElementMappings(e, t) {
                    this.domConverter.unbindDomElement(t),
                    this.domConverter.bindElements(t, e),
                    this.markedChildren.add(e),
                    this.markedAttributes.add(e)
                }
                _getInlineFillerPosition() {
                    const e = this.selection.getFirstPosition();
                    return e.parent.is("$text") ? ae._createBefore(e.parent) : e
                }
                _isSelectionInInlineFiller() {
                    if (this.selection.rangeCount != 1 || !this.selection.isCollapsed)
                        return !1;
                    const e = this.selection.getFirstPosition()
                      , t = this.domConverter.viewPositionToDom(e);
                    return !!(t && bt(t.parent) && Do(t.parent))
                }
                _removeInlineFiller() {
                    const e = this._inlineFiller;
                    if (!Do(e))
                        throw new U("view-renderer-filler-was-lost",this);
                    Ss(e) ? e.remove() : e.data = e.data.substr(pr),
                    this._inlineFiller = null
                }
                _needsInlineFillerAtSelection() {
                    if (this.selection.rangeCount != 1 || !this.selection.isCollapsed)
                        return !1;
                    const e = this.selection.getFirstPosition()
                      , t = e.parent
                      , r = e.offset;
                    if (!this.domConverter.mapViewToDom(t.root) || !t.is("element") || !function(d) {
                        if (d.getAttribute("contenteditable") == "false")
                            return !1;
                        const h = d.findAncestor(m => m.hasAttribute("contenteditable"));
                        return !h || h.getAttribute("contenteditable") == "true"
                    }(t))
                        return !1;
                    const i = e.nodeBefore
                      , l = e.nodeAfter;
                    return !(i instanceof We || l instanceof We) && !!(r !== t.getFillerOffset() || i && i.is("element", "br")) && (!E.isAndroid || !i && !l)
                }
                _updateText(e, t) {
                    const r = this.domConverter.findCorrespondingDomText(e);
                    let i = this.domConverter.viewToDom(e).data;
                    const l = t.inlineFillerPosition;
                    l && l.parent == e.parent && l.offset == e.index && (i = kl + i),
                    qv(r, i)
                }
                _updateAttrs(e) {
                    const t = this.domConverter.mapViewToDom(e);
                    if (!t)
                        return;
                    const r = Array.from(t.attributes).map(l => l.name)
                      , i = e.getAttributeKeys();
                    for (const l of i)
                        this.domConverter.setDomElementAttribute(t, l, e.getAttribute(l), e);
                    for (const l of r)
                        e.hasAttribute(l) || this.domConverter.removeDomElementAttribute(t, l)
                }
                _updateChildren(e, t) {
                    const r = this.domConverter.mapViewToDom(e);
                    if (!r)
                        return;
                    if (E.isAndroid) {
                        let v = null;
                        for (const x of Array.from(r.childNodes)) {
                            if (v && bt(v) && bt(x)) {
                                r.normalize();
                                break
                            }
                            v = x
                        }
                    }
                    const i = t.inlineFillerPosition
                      , l = r.childNodes
                      , d = Array.from(this.domConverter.viewChildrenToDom(e, {
                        bind: !0
                    }));
                    i && i.parent === e && $v(r.ownerDocument, d, i.offset);
                    const h = this._diffNodeLists(l, d)
                      , m = this._findUpdateActions(h, l, d, fP);
                    let g = 0;
                    const b = new Set;
                    for (const v of m)
                        v === "delete" ? (b.add(l[g]),
                        KA(l[g])) : v !== "equal" && v !== "update" || g++;
                    g = 0;
                    for (const v of m)
                        v === "insert" ? ($A(r, g, d[g]),
                        g++) : v === "update" ? (qv(l[g], d[g].data),
                        g++) : v === "equal" && (this._markDescendantTextToSync(this.domConverter.domToView(d[g])),
                        g++);
                    for (const v of b)
                        v.parentNode || this.domConverter.unbindDomElement(v)
                }
                _diffNodeLists(e, t) {
                    return e = function(r, i) {
                        const l = Array.from(r);
                        return l.length == 0 || !i || l[l.length - 1] == i && l.pop(),
                        l
                    }(e, this._fakeSelectionContainer),
                    Y(e, t, kP.bind(null, this.domConverter))
                }
                _findUpdateActions(e, t, r, i) {
                    if (e.indexOf("insert") === -1 || e.indexOf("delete") === -1)
                        return e;
                    let l = []
                      , d = []
                      , h = [];
                    const m = {
                        equal: 0,
                        insert: 0,
                        delete: 0
                    };
                    for (const g of e)
                        g === "insert" ? h.push(r[m.equal + m.insert]) : g === "delete" ? d.push(t[m.equal + m.delete]) : (l = l.concat(Y(d, h, i).map(b => b === "equal" ? "update" : b)),
                        l.push("equal"),
                        d = [],
                        h = []),
                        m[g]++;
                    return l.concat(Y(d, h, i).map(g => g === "equal" ? "update" : g))
                }
                _markDescendantTextToSync(e) {
                    if (e) {
                        if (e.is("$text"))
                            this.markedTexts.add(e);
                        else if (e.is("element"))
                            for (const t of e.getChildren())
                                this._markDescendantTextToSync(t)
                    }
                }
                _updateSelection() {
                    if (E.isBlink && !E.isAndroid && this.isSelecting && !this.markedChildren.size)
                        return;
                    if (this.selection.rangeCount === 0)
                        return this._removeDomSelection(),
                        void this._removeFakeSelection();
                    const e = this.domConverter.mapViewToDom(this.selection.editableElement);
                    this.isFocused && e && (this.selection.isFake ? this._updateFakeSelection(e) : this._fakeSelectionContainer && this._fakeSelectionContainer.isConnected ? (this._removeFakeSelection(),
                    this._updateDomSelection(e)) : this.isComposing && E.isAndroid || this._updateDomSelection(e))
                }
                _updateFakeSelection(e) {
                    const t = e.ownerDocument;
                    this._fakeSelectionContainer || (this._fakeSelectionContainer = function(d) {
                        const h = d.createElement("div");
                        return h.className = "ck-fake-selection-container",
                        Object.assign(h.style, {
                            position: "fixed",
                            top: 0,
                            left: "-9999px",
                            width: "42px"
                        }),
                        h.textContent = " ",
                        h
                    }(t));
                    const r = this._fakeSelectionContainer;
                    if (this.domConverter.bindFakeSelection(r, this.selection),
                    !this._fakeSelectionNeedsUpdate(e))
                        return;
                    r.parentElement && r.parentElement == e || e.appendChild(r),
                    r.textContent = this.selection.fakeSelectionLabel || " ";
                    const i = t.getSelection()
                      , l = t.createRange();
                    i.removeAllRanges(),
                    l.selectNodeContents(r),
                    i.addRange(l)
                }
                _updateDomSelection(e) {
                    const t = e.ownerDocument.defaultView.getSelection();
                    if (!this._domSelectionNeedsUpdate(t))
                        return;
                    const r = this.domConverter.viewPositionToDom(this.selection.anchor)
                      , i = this.domConverter.viewPositionToDom(this.selection.focus);
                    t.setBaseAndExtent(r.parent, r.offset, i.parent, i.offset),
                    E.isGecko && function(l, d) {
                        let h = l.parent
                          , m = l.offset;
                        if (bt(h) && Ss(h) && (m = dl(h) + 1,
                        h = h.parentNode),
                        h.nodeType != Node.ELEMENT_NODE || m != h.childNodes.length - 1)
                            return;
                        const g = h.childNodes[m];
                        g && g.tagName == "BR" && d.addRange(d.getRangeAt(0))
                    }(i, t)
                }
                _domSelectionNeedsUpdate(e) {
                    if (!this.domConverter.isDomSelectionCorrect(e))
                        return !0;
                    const t = e && this.domConverter.domSelectionToView(e);
                    return (!t || !this.selection.isEqual(t)) && !(!this.selection.isCollapsed && this.selection.isSimilar(t))
                }
                _fakeSelectionNeedsUpdate(e) {
                    const t = this._fakeSelectionContainer
                      , r = e.ownerDocument.getSelection();
                    return !t || t.parentElement !== e || r.anchorNode !== t && !t.contains(r.anchorNode) || t.textContent !== this.selection.fakeSelectionLabel
                }
                _removeDomSelection() {
                    for (const e of this.domDocuments) {
                        const t = e.getSelection();
                        if (t.rangeCount) {
                            const r = e.activeElement
                              , i = this.domConverter.mapDomToView(r);
                            r && i && t.removeAllRanges()
                        }
                    }
                }
                _removeFakeSelection() {
                    const e = this._fakeSelectionContainer;
                    e && e.remove()
                }
                _updateFocus() {
                    if (this.isFocused) {
                        const e = this.selection.editableElement;
                        e && this.domConverter.focus(e)
                    }
                }
            }
            function $v(s, e, t) {
                const r = e instanceof Array ? e : e.childNodes
                  , i = r[t];
                if (bt(i))
                    return i.data = kl + i.data,
                    i;
                {
                    const l = s.createTextNode(kl);
                    return Array.isArray(e) ? r.splice(t, 0, l) : $A(e, t, l),
                    l
                }
            }
            function gP(s, e) {
                return Tn(s) && Tn(e) && !bt(s) && !bt(e) && !ul(s) && !ul(e) && s.tagName.toLowerCase() === e.tagName.toLowerCase()
            }
            function fP(s, e) {
                return Tn(s) && Tn(e) && bt(s) && bt(e)
            }
            function kP(s, e, t) {
                return e === t || (bt(e) && bt(t) ? e.data === t.data : !(!s.isBlockFiller(e) || !s.isBlockFiller(t)))
            }
            function qv(s, e) {
                const t = s.data;
                if (t == e)
                    return;
                const r = j(t, e);
                for (const i of r)
                    i.type === "insert" ? s.insertData(i.index, i.values.join("")) : s.deleteData(i.index, i.howMany)
            }
            const bP = Uv(w.document)
              , wP = Fv(w.document)
              , AP = Vv(w.document)
              , Rd = "data-ck-unsafe-attribute-"
              , Gv = "data-ck-unsafe-element";
            class Fd {
                constructor(e, {blockFillerMode: t, renderingMode: r="editing"}={}) {
                    C(this, "document"),
                    C(this, "renderingMode"),
                    C(this, "blockFillerMode"),
                    C(this, "preElements"),
                    C(this, "blockElements"),
                    C(this, "inlineObjectElements"),
                    C(this, "unsafeElements"),
                    C(this, "_domDocument"),
                    C(this, "_domToViewMapping", new WeakMap),
                    C(this, "_viewToDomMapping", new WeakMap),
                    C(this, "_fakeSelectionMapping", new WeakMap),
                    C(this, "_rawContentElementMatcher", new Br),
                    C(this, "_inlineObjectElementMatcher", new Br),
                    C(this, "_elementsWithTemporaryCustomProperties", new Set),
                    this.document = e,
                    this.renderingMode = r,
                    this.blockFillerMode = t || (r === "editing" ? "br" : "nbsp"),
                    this.preElements = ["pre"],
                    this.blockElements = ["address", "article", "aside", "blockquote", "caption", "center", "dd", "details", "dir", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "legend", "li", "main", "menu", "nav", "ol", "p", "pre", "section", "summary", "table", "tbody", "td", "tfoot", "th", "thead", "tr", "ul"],
                    this.inlineObjectElements = ["object", "iframe", "input", "button", "textarea", "select", "option", "video", "embed", "audio", "img", "canvas"],
                    this.unsafeElements = ["script", "style"],
                    this._domDocument = this.renderingMode === "editing" ? w.document : w.document.implementation.createHTMLDocument("")
                }
                bindFakeSelection(e, t) {
                    this._fakeSelectionMapping.set(e, new mr(t))
                }
                fakeSelectionToView(e) {
                    return this._fakeSelectionMapping.get(e)
                }
                bindElements(e, t) {
                    this._domToViewMapping.set(e, t),
                    this._viewToDomMapping.set(t, e)
                }
                unbindDomElement(e) {
                    const t = this._domToViewMapping.get(e);
                    if (t) {
                        this._domToViewMapping.delete(e),
                        this._viewToDomMapping.delete(t);
                        for (const r of Array.from(e.children))
                            this.unbindDomElement(r)
                    }
                }
                bindDocumentFragments(e, t) {
                    this._domToViewMapping.set(e, t),
                    this._viewToDomMapping.set(t, e)
                }
                shouldRenderAttribute(e, t, r) {
                    return this.renderingMode === "data" || !(e = e.toLowerCase()).startsWith("on") && (e !== "srcdoc" || !t.match(/\bon\S+\s*=|javascript:|<\s*\/*script/i)) && (r === "img" && (e === "src" || e === "srcset") || r === "source" && e === "srcset" || !t.match(/^\s*(javascript:|data:(image\/svg|text\/x?html))/i))
                }
                setContentOf(e, t) {
                    if (this.renderingMode === "data")
                        return void (e.innerHTML = t);
                    const r = new DOMParser().parseFromString(t, "text/html")
                      , i = r.createDocumentFragment()
                      , l = r.body.childNodes;
                    for (; l.length > 0; )
                        i.appendChild(l[0]);
                    const d = r.createTreeWalker(i, NodeFilter.SHOW_ELEMENT)
                      , h = [];
                    let m;
                    for (; m = d.nextNode(); )
                        h.push(m);
                    for (const g of h) {
                        for (const v of g.getAttributeNames())
                            this.setDomElementAttribute(g, v, g.getAttribute(v));
                        const b = g.tagName.toLowerCase();
                        this._shouldRenameElement(b) && (Qv(b),
                        g.replaceWith(this._createReplacementDomElement(b, g)))
                    }
                    for (; e.firstChild; )
                        e.firstChild.remove();
                    e.append(i)
                }
                viewToDom(e, t={}) {
                    if (e.is("$text")) {
                        const r = this._processDataFromViewText(e);
                        return this._domDocument.createTextNode(r)
                    }
                    {
                        const r = e;
                        if (this.mapViewToDom(r)) {
                            if (!r.getCustomProperty("editingPipeline:doNotReuseOnce"))
                                return this.mapViewToDom(r);
                            this._elementsWithTemporaryCustomProperties.add(r)
                        }
                        let i;
                        if (r.is("documentFragment"))
                            i = this._domDocument.createDocumentFragment(),
                            t.bind && this.bindDocumentFragments(i, r);
                        else {
                            if (r.is("uiElement"))
                                return i = r.name === "$comment" ? this._domDocument.createComment(r.getCustomProperty("$rawContent")) : r.render(this._domDocument, this),
                                t.bind && this.bindElements(i, r),
                                i;
                            this._shouldRenameElement(r.name) ? (Qv(r.name),
                            i = this._createReplacementDomElement(r.name)) : i = r.hasAttribute("xmlns") ? this._domDocument.createElementNS(r.getAttribute("xmlns"), r.name) : this._domDocument.createElement(r.name),
                            r.is("rawElement") && r.render(i, this),
                            t.bind && this.bindElements(i, r);
                            for (const l of r.getAttributeKeys())
                                this.setDomElementAttribute(i, l, r.getAttribute(l), r)
                        }
                        if (t.withChildren !== !1)
                            for (const l of this.viewChildrenToDom(r, t))
                                i instanceof HTMLTemplateElement ? i.content.appendChild(l) : i.appendChild(l);
                        return i
                    }
                }
                setDomElementAttribute(e, t, r, i) {
                    const l = this.shouldRenderAttribute(t, r, e.tagName.toLowerCase()) || i && i.shouldRenderUnsafeAttribute(t);
                    l || de("domconverter-unsafe-attribute-detected", {
                        domElement: e,
                        key: t,
                        value: r
                    }),
                    function(d) {
                        try {
                            w.document.createAttribute(d)
                        } catch {
                            return !1
                        }
                        return !0
                    }(t) ? (e.hasAttribute(t) && !l ? e.removeAttribute(t) : e.hasAttribute(Rd + t) && l && e.removeAttribute(Rd + t),
                    e.setAttribute(l ? t : Rd + t, r)) : de("domconverter-invalid-attribute-detected", {
                        domElement: e,
                        key: t,
                        value: r
                    })
                }
                removeDomElementAttribute(e, t) {
                    t != Gv && (e.removeAttribute(t),
                    e.removeAttribute(Rd + t))
                }
                *viewChildrenToDom(e, t={}) {
                    const r = e.getFillerOffset && e.getFillerOffset();
                    let i = 0;
                    for (const l of e.getChildren()) {
                        r === i && (yield this._getBlockFiller());
                        const d = l.is("element") && !!l.getCustomProperty("dataPipeline:transparentRendering") && !zt(l.getAttributes());
                        d && this.renderingMode == "data" ? yield*this.viewChildrenToDom(l, t) : (d && de("domconverter-transparent-rendering-unsupported-in-editing-pipeline", {
                            viewElement: l
                        }),
                        yield this.viewToDom(l, t)),
                        i++
                    }
                    r === i && (yield this._getBlockFiller())
                }
                viewRangeToDom(e) {
                    const t = this.viewPositionToDom(e.start)
                      , r = this.viewPositionToDom(e.end)
                      , i = this._domDocument.createRange();
                    return i.setStart(t.parent, t.offset),
                    i.setEnd(r.parent, r.offset),
                    i
                }
                viewPositionToDom(e) {
                    const t = e.parent;
                    if (t.is("$text")) {
                        const r = this.findCorrespondingDomText(t);
                        if (!r)
                            return null;
                        let i = e.offset;
                        return Do(r) && (i += pr),
                        {
                            parent: r,
                            offset: i
                        }
                    }
                    {
                        let r, i, l;
                        if (e.offset === 0) {
                            if (r = this.mapViewToDom(t),
                            !r)
                                return null;
                            l = r.childNodes[0]
                        } else {
                            const d = e.nodeBefore;
                            if (i = d.is("$text") ? this.findCorrespondingDomText(d) : this.mapViewToDom(d),
                            !i)
                                return null;
                            r = i.parentNode,
                            l = i.nextSibling
                        }
                        return bt(l) && Do(l) ? {
                            parent: l,
                            offset: pr
                        } : {
                            parent: r,
                            offset: i ? dl(i) + 1 : 0
                        }
                    }
                }
                domToView(e, t={}) {
                    const r = []
                      , i = this._domToView(e, t, r)
                      , l = i.next().value;
                    return l ? (i.next(),
                    this._processDomInlineNodes(null, r, t),
                    l.is("$text") && l.data.length == 0 ? null : l) : null
                }
                *domChildrenToView(e, t={}, r=[]) {
                    let i = [];
                    i = e instanceof HTMLTemplateElement ? [...e.content.childNodes] : [...e.childNodes];
                    for (let l = 0; l < i.length; l++) {
                        const d = i[l]
                          , h = this._domToView(d, t, r)
                          , m = h.next().value;
                        m !== null && (this._isBlockViewElement(m) && this._processDomInlineNodes(e, r, t),
                        yield m,
                        h.next())
                    }
                    this._processDomInlineNodes(e, r, t)
                }
                domSelectionToView(e) {
                    if (function(i) {
                        if (!E.isGecko || !i.rangeCount)
                            return !1;
                        const l = i.getRangeAt(0).startContainer;
                        try {
                            Object.prototype.toString.call(l)
                        } catch {
                            return !0
                        }
                        return !1
                    }(e))
                        return new mr([]);
                    if (e.rangeCount === 1) {
                        let i = e.getRangeAt(0).startContainer;
                        bt(i) && (i = i.parentNode);
                        const l = this.fakeSelectionToView(i);
                        if (l)
                            return l
                    }
                    const t = this.isDomSelectionBackward(e)
                      , r = [];
                    for (let i = 0; i < e.rangeCount; i++) {
                        const l = e.getRangeAt(i)
                          , d = this.domRangeToView(l);
                        d && r.push(d)
                    }
                    return new mr(r,{
                        backward: t
                    })
                }
                domRangeToView(e) {
                    const t = this.domPositionToView(e.startContainer, e.startOffset)
                      , r = this.domPositionToView(e.endContainer, e.endOffset);
                    return t && r ? new fe(t,r) : null
                }
                domPositionToView(e, t=0) {
                    if (this.isBlockFiller(e))
                        return this.domPositionToView(e.parentNode, dl(e));
                    const r = this.mapDomToView(e);
                    if (r && (r.is("uiElement") || r.is("rawElement")))
                        return ae._createBefore(r);
                    if (bt(e)) {
                        if (Ss(e))
                            return this.domPositionToView(e.parentNode, dl(e));
                        const i = this.findCorrespondingViewText(e);
                        let l = t;
                        return i ? (Do(e) && (l -= pr,
                        l = l < 0 ? 0 : l),
                        new ae(i,l)) : null
                    }
                    if (t === 0) {
                        const i = this.mapDomToView(e);
                        if (i)
                            return new ae(i,0)
                    } else {
                        const i = e.childNodes[t - 1];
                        if (bt(i) && Ss(i) || i && this.isBlockFiller(i))
                            return this.domPositionToView(i.parentNode, dl(i));
                        const l = bt(i) ? this.findCorrespondingViewText(i) : this.mapDomToView(i);
                        if (l && l.parent)
                            return new ae(l.parent,l.index + 1)
                    }
                    return null
                }
                mapDomToView(e) {
                    return this.getHostViewElement(e) || this._domToViewMapping.get(e)
                }
                findCorrespondingViewText(e) {
                    if (Ss(e))
                        return null;
                    const t = this.getHostViewElement(e);
                    if (t)
                        return t;
                    const r = e.previousSibling;
                    if (r) {
                        if (!this.isElement(r))
                            return null;
                        const i = this.mapDomToView(r);
                        if (i) {
                            const l = i.nextSibling;
                            return l instanceof We ? l : null
                        }
                    } else {
                        const i = this.mapDomToView(e.parentNode);
                        if (i) {
                            const l = i.getChild(0);
                            return l instanceof We ? l : null
                        }
                    }
                    return null
                }
                mapViewToDom(e) {
                    return this._viewToDomMapping.get(e)
                }
                findCorrespondingDomText(e) {
                    const t = e.previousSibling;
                    return t && this.mapViewToDom(t) ? this.mapViewToDom(t).nextSibling : !t && e.parent && this.mapViewToDom(e.parent) ? this.mapViewToDom(e.parent).childNodes[0] : null
                }
                focus(e) {
                    const t = this.mapViewToDom(e);
                    if (t && t.ownerDocument.activeElement !== t) {
                        const {scrollX: r, scrollY: i} = w.window
                          , l = [];
                        Kv(t, d => {
                            const {scrollLeft: h, scrollTop: m} = d;
                            l.push([h, m])
                        }
                        ),
                        t.focus(),
                        Kv(t, d => {
                            const [h,m] = l.shift();
                            d.scrollLeft = h,
                            d.scrollTop = m
                        }
                        ),
                        w.window.scrollTo(r, i)
                    }
                }
                _clearDomSelection() {
                    const e = this.mapViewToDom(this.document.selection.editableElement);
                    if (!e)
                        return;
                    const t = e.ownerDocument.defaultView.getSelection()
                      , r = this.domSelectionToView(t);
                    r && r.rangeCount > 0 && t.removeAllRanges()
                }
                isElement(e) {
                    return e && e.nodeType == Node.ELEMENT_NODE
                }
                isDocumentFragment(e) {
                    return e && e.nodeType == Node.DOCUMENT_FRAGMENT_NODE
                }
                isBlockFiller(e) {
                    return this.blockFillerMode == "br" ? e.isEqualNode(bP) : !(e.tagName !== "BR" || !Yv(e, this.blockElements) || e.parentNode.childNodes.length !== 1) || e.isEqualNode(AP) || function(t, r) {
                        return t.isEqualNode(wP) && Yv(t, r) && t.parentNode.childNodes.length === 1
                    }(e, this.blockElements)
                }
                isDomSelectionBackward(e) {
                    if (e.isCollapsed)
                        return !1;
                    const t = this._domDocument.createRange();
                    try {
                        t.setStart(e.anchorNode, e.anchorOffset),
                        t.setEnd(e.focusNode, e.focusOffset)
                    } catch {
                        return !1
                    }
                    const r = t.collapsed;
                    return t.detach(),
                    r
                }
                getHostViewElement(e) {
                    const t = function(r) {
                        const i = [];
                        let l = r;
                        for (; l && l.nodeType != Node.DOCUMENT_NODE; )
                            i.unshift(l),
                            l = l.parentNode;
                        return i
                    }(e);
                    for (t.pop(); t.length; ) {
                        const r = t.pop()
                          , i = this._domToViewMapping.get(r);
                        if (i && (i.is("uiElement") || i.is("rawElement")))
                            return i
                    }
                    return null
                }
                isDomSelectionCorrect(e) {
                    return this._isDomSelectionPositionCorrect(e.anchorNode, e.anchorOffset) && this._isDomSelectionPositionCorrect(e.focusNode, e.focusOffset)
                }
                registerRawContentMatcher(e) {
                    this._rawContentElementMatcher.add(e)
                }
                registerInlineObjectMatcher(e) {
                    this._inlineObjectElementMatcher.add(e)
                }
                _clearTemporaryCustomProperties() {
                    for (const e of this._elementsWithTemporaryCustomProperties)
                        e._removeCustomProperty("editingPipeline:doNotReuseOnce");
                    this._elementsWithTemporaryCustomProperties.clear()
                }
                _getBlockFiller() {
                    switch (this.blockFillerMode) {
                    case "nbsp":
                        return Fv(this._domDocument);
                    case "markedNbsp":
                        return Vv(this._domDocument);
                    case "br":
                        return Uv(this._domDocument)
                    }
                }
                _isDomSelectionPositionCorrect(e, t) {
                    if (bt(e) && Do(e) && t < pr || this.isElement(e) && Do(e.childNodes[t]))
                        return !1;
                    const r = this.mapDomToView(e);
                    return !r || !r.is("uiElement") && !r.is("rawElement")
                }
                *_domToView(e, t, r) {
                    if (this.isBlockFiller(e))
                        return null;
                    const i = this.getHostViewElement(e);
                    if (i)
                        return i;
                    if (ul(e) && t.skipComments)
                        return null;
                    if (bt(e)) {
                        if (Ss(e))
                            return null;
                        {
                            const l = e.data;
                            if (l === "")
                                return null;
                            const d = new We(this.document,l);
                            return r.push(d),
                            d
                        }
                    }
                    {
                        let l = this.mapDomToView(e);
                        if (l)
                            return this._isInlineObjectElement(l) && r.push(l),
                            l;
                        if (this.isDocumentFragment(e))
                            l = new Ti(this.document),
                            t.bind && this.bindDocumentFragments(e, l);
                        else {
                            l = this._createViewElement(e, t),
                            t.bind && this.bindElements(e, l);
                            const h = e.attributes;
                            if (h)
                                for (let m = h.length, g = 0; g < m; g++)
                                    l._setAttribute(h[g].name, h[g].value);
                            if (this._isViewElementWithRawContent(l, t))
                                return l._setCustomProperty("$rawContent", e.innerHTML),
                                this._isBlockViewElement(l) || r.push(l),
                                l;
                            if (ul(e))
                                return l._setCustomProperty("$rawContent", e.data),
                                l
                        }
                        yield l;
                        const d = [];
                        if (t.withChildren !== !1)
                            for (const h of this.domChildrenToView(e, t, d))
                                l._appendChild(h);
                        if (this._isInlineObjectElement(l))
                            r.push(l);
                        else
                            for (const h of d)
                                r.push(h)
                    }
                }
                _processDomInlineNodes(e, t, r) {
                    if (!t.length || e && !this.isDocumentFragment(e) && !this._isBlockDomElement(e))
                        return;
                    let i = !1;
                    for (let l = 0; l < t.length; l++) {
                        const d = t[l];
                        if (!d.is("$text")) {
                            i = !1;
                            continue
                        }
                        let h, m = !1;
                        if (this._isPreFormatted(d))
                            h = Hv(d.data);
                        else {
                            h = d.data.replace(/[ \n\t\r]{1,}/g, " "),
                            m = /[^\S\u00A0]/.test(h.charAt(h.length - 1));
                            const g = l > 0 ? t[l - 1] : null
                              , b = l + 1 < t.length ? t[l + 1] : null
                              , v = !g || g.is("element") && g.name == "br" || i
                              , x = !b && !Do(d.data);
                            r.withChildren !== !1 && (v && (h = h.replace(/^ /, "")),
                            x && (h = h.replace(/ $/, ""))),
                            h = Hv(h),
                            h = h.replace(/ \u00A0/g, "  ");
                            const T = b && b.is("element") && b.name != "br"
                              , I = b && b.is("$text") && b.data.charAt(0) == " ";
                            (/[ \u00A0]\u00A0$/.test(h) || !b || T || I) && (h = h.replace(/\u00A0$/, " ")),
                            (v || g && g.is("element") && g.name != "br") && (h = h.replace(/^\u00A0/, " "))
                        }
                        h.length == 0 && d.parent ? (d._remove(),
                        t.splice(l, 1),
                        l--) : (d._data = h,
                        i = m)
                    }
                    t.length = 0
                }
                _processDataFromViewText(e) {
                    let t = e.data;
                    if (this._isPreFormatted(e))
                        return t;
                    if (t.charAt(0) == " ") {
                        const r = this._getTouchingInlineViewNode(e, !1);
                        !(r && r.is("$textProxy") && this._nodeEndsWithSpace(r)) && r || (t = " " + t.substr(1))
                    }
                    if (t.charAt(t.length - 1) == " ") {
                        const r = this._getTouchingInlineViewNode(e, !0)
                          , i = r && r.is("$textProxy") && r.data.charAt(0) == " ";
                        t.charAt(t.length - 2) != " " && r && !i || (t = t.substr(0, t.length - 1) + " ")
                    }
                    return t.replace(/ {2}/g, "  ")
                }
                _nodeEndsWithSpace(e) {
                    if (this._isPreFormatted(e))
                        return !1;
                    const t = this._processDataFromViewText(e);
                    return t.charAt(t.length - 1) == " "
                }
                _isPreFormatted(e) {
                    if (function(t, r) {
                        return t.getAncestors().some(i => i.is("element") && r.includes(i.name))
                    }(e, this.preElements))
                        return !0;
                    for (const t of e.getAncestors({
                        parentFirst: !0
                    }))
                        if (t.is("element") && t.hasStyle("white-space") && t.getStyle("white-space") !== "inherit")
                            return ["pre", "pre-wrap", "break-spaces"].includes(t.getStyle("white-space"));
                    return !1
                }
                _getTouchingInlineViewNode(e, t) {
                    const r = new Si({
                        startPosition: t ? ae._createAfter(e) : ae._createBefore(e),
                        direction: t ? "forward" : "backward"
                    });
                    for (const i of r) {
                        if (i.item.is("element", "br"))
                            return null;
                        if (this._isInlineObjectElement(i.item))
                            return i.item;
                        if (i.item.is("containerElement"))
                            return null;
                        if (i.item.is("$textProxy"))
                            return i.item
                    }
                    return null
                }
                _isBlockDomElement(e) {
                    return this.isElement(e) && this.blockElements.includes(e.tagName.toLowerCase())
                }
                _isBlockViewElement(e) {
                    return e.is("element") && this.blockElements.includes(e.name)
                }
                _isInlineObjectElement(e) {
                    return !!e.is("element") && (e.name == "br" || this.inlineObjectElements.includes(e.name) || !!this._inlineObjectElementMatcher.match(e))
                }
                _createViewElement(e, t) {
                    if (ul(e))
                        return new Od(this.document,"$comment");
                    const r = t.keepOriginalCase ? e.tagName : e.tagName.toLowerCase();
                    return new So(this.document,r)
                }
                _isViewElementWithRawContent(e, t) {
                    return t.withChildren !== !1 && e.is("element") && !!this._rawContentElementMatcher.match(e)
                }
                _shouldRenameElement(e) {
                    const t = e.toLowerCase();
                    return this.renderingMode === "editing" && this.unsafeElements.includes(t)
                }
                _createReplacementDomElement(e, t) {
                    const r = this._domDocument.createElement("span");
                    if (r.setAttribute(Gv, e),
                    t) {
                        for (; t.firstChild; )
                            r.appendChild(t.firstChild);
                        for (const i of t.getAttributeNames())
                            r.setAttribute(i, t.getAttribute(i))
                    }
                    return r
                }
            }
            function Kv(s, e) {
                let t = s;
                for (; t; )
                    e(t),
                    t = t.parentElement
            }
            function Yv(s, e) {
                const t = s.parentNode;
                return !!t && !!t.tagName && e.includes(t.tagName.toLowerCase())
            }
            function Qv(s) {
                s === "script" && de("domconverter-unsafe-script-element-detected"),
                s === "style" && de("domconverter-unsafe-style-element-detected")
            }
            class Nr extends qo() {
                constructor(e) {
                    super(),
                    C(this, "view"),
                    C(this, "document"),
                    C(this, "_isEnabled", !1),
                    this.view = e,
                    this.document = e.document
                }
                get isEnabled() {
                    return this._isEnabled
                }
                enable() {
                    this._isEnabled = !0
                }
                disable() {
                    this._isEnabled = !1
                }
                destroy() {
                    this.disable(),
                    this.stopListening()
                }
                checkShouldIgnoreEventFromTarget(e) {
                    return e && e.nodeType === 3 && (e = e.parentNode),
                    !(!e || e.nodeType !== 1) && e.matches("[data-cke-ignore-events], [data-cke-ignore-events] *")
                }
            }
            const Zv = nv(function(s, e) {
                ws(e, vs(e), s)
            });
            class Ds {
                constructor(e, t, r) {
                    C(this, "view"),
                    C(this, "document"),
                    C(this, "domEvent"),
                    C(this, "domTarget"),
                    this.view = e,
                    this.document = e.document,
                    this.domEvent = t,
                    this.domTarget = t.target,
                    Zv(this, r)
                }
                get target() {
                    return this.view.domConverter.mapDomToView(this.domTarget)
                }
                preventDefault() {
                    this.domEvent.preventDefault()
                }
                stopPropagation() {
                    this.domEvent.stopPropagation()
                }
            }
            class Mn extends Nr {
                constructor() {
                    super(...arguments),
                    C(this, "useCapture", !1)
                }
                observe(e) {
                    (typeof this.domEventType == "string" ? [this.domEventType] : this.domEventType).forEach(t => {
                        this.listenTo(e, t, (r, i) => {
                            this.isEnabled && !this.checkShouldIgnoreEventFromTarget(i.target) && this.onDomEvent(i)
                        }
                        , {
                            useCapture: this.useCapture
                        })
                    }
                    )
                }
                stopObserving(e) {
                    this.stopListening(e)
                }
                fire(e, t, r) {
                    this.isEnabled && this.document.fire(e, new Ds(this.view,t,r))
                }
            }
            class vP extends Mn {
                constructor() {
                    super(...arguments),
                    C(this, "domEventType", ["keydown", "keyup"])
                }
                onDomEvent(e) {
                    const t = {
                        keyCode: e.keyCode,
                        altKey: e.altKey,
                        ctrlKey: e.ctrlKey,
                        shiftKey: e.shiftKey,
                        metaKey: e.metaKey,
                        get keystroke() {
                            return _s(this)
                        }
                    };
                    this.fire(e.type, e, t)
                }
            }
            const xp = function() {
                return cr.Date.now()
            };
            var _P = /\s/;
            const CP = function(s) {
                for (var e = s.length; e-- && _P.test(s.charAt(e)); )
                    ;
                return e
            };
            var yP = /^\s+/;
            const xP = function(s) {
                return s && s.slice(0, CP(s) + 1).replace(yP, "")
            };
            var EP = /^[-+]0x[0-9a-f]+$/i
              , SP = /^0b[01]+$/i
              , DP = /^0o[0-7]+$/i
              , TP = parseInt;
            const Jv = function(s) {
                if (typeof s == "number")
                    return s;
                if (Nd(s))
                    return NaN;
                if (Le(s)) {
                    var e = typeof s.valueOf == "function" ? s.valueOf() : s;
                    s = Le(e) ? e + "" : e
                }
                if (typeof s != "string")
                    return s === 0 ? s : +s;
                s = xP(s);
                var t = SP.test(s);
                return t || DP.test(s) ? TP(s.slice(2), t ? 2 : 8) : EP.test(s) ? NaN : +s
            };
            var IP = Math.max
              , MP = Math.min;
            const Ts = function(s, e, t) {
                var r, i, l, d, h, m, g = 0, b = !1, v = !1, x = !0;
                if (typeof s != "function")
                    throw new TypeError("Expected a function");
                function T(q) {
                    var Q = r
                      , X = i;
                    return r = i = void 0,
                    g = q,
                    d = s.apply(X, Q)
                }
                function I(q) {
                    var Q = q - m;
                    return m === void 0 || Q >= e || Q < 0 || v && q - g >= l
                }
                function P() {
                    var q = xp();
                    if (I(q))
                        return O(q);
                    h = setTimeout(P, function(Q) {
                        var X = e - (Q - m);
                        return v ? MP(X, l - (Q - g)) : X
                    }(q))
                }
                function O(q) {
                    return h = void 0,
                    x && r ? T(q) : (r = i = void 0,
                    d)
                }
                function F() {
                    var q = xp()
                      , Q = I(q);
                    if (r = arguments,
                    i = this,
                    m = q,
                    Q) {
                        if (h === void 0)
                            return function(X) {
                                return g = X,
                                h = setTimeout(P, e),
                                b ? T(X) : d
                            }(m);
                        if (v)
                            return clearTimeout(h),
                            h = setTimeout(P, e),
                            T(m)
                    }
                    return h === void 0 && (h = setTimeout(P, e)),
                    d
                }
                return e = Jv(e) || 0,
                Le(t) && (b = !!t.leading,
                l = (v = "maxWait"in t) ? IP(Jv(t.maxWait) || 0, e) : l,
                x = "trailing"in t ? !!t.trailing : x),
                F.cancel = function() {
                    h !== void 0 && clearTimeout(h),
                    g = 0,
                    r = m = i = h = void 0
                }
                ,
                F.flush = function() {
                    return h === void 0 ? d : O(xp())
                }
                ,
                F
            };
            class BP extends Nr {
                constructor(e) {
                    super(e),
                    C(this, "_fireSelectionChangeDoneDebounced"),
                    this._fireSelectionChangeDoneDebounced = Ts(t => {
                        this.document.fire("selectionChangeDone", t)
                    }
                    , 200)
                }
                observe() {
                    const e = this.document;
                    e.on("arrowKey", (t, r) => {
                        e.selection.isFake && this.isEnabled && r.preventDefault()
                    }
                    , {
                        context: "$capture"
                    }),
                    e.on("arrowKey", (t, r) => {
                        e.selection.isFake && this.isEnabled && this._handleSelectionMove(r.keyCode)
                    }
                    , {
                        priority: "lowest"
                    })
                }
                stopObserving() {}
                destroy() {
                    super.destroy(),
                    this._fireSelectionChangeDoneDebounced.cancel()
                }
                _handleSelectionMove(e) {
                    const t = this.document.selection
                      , r = new mr(t.getRanges(),{
                        backward: t.isBackward,
                        fake: !1
                    });
                    e != Me.arrowleft && e != Me.arrowup || r.setTo(r.getFirstPosition()),
                    e != Me.arrowright && e != Me.arrowdown || r.setTo(r.getLastPosition());
                    const i = {
                        oldSelection: t,
                        newSelection: r,
                        domSelection: null
                    };
                    this.document.fire("selectionChange", i),
                    this._fireSelectionChangeDoneDebounced(i)
                }
            }
            const NP = function(s) {
                return this.__data__.set(s, "__lodash_hash_undefined__"),
                this
            }
              , PP = function(s) {
                return this.__data__.has(s)
            };
            function Vd(s) {
                var e = -1
                  , t = s == null ? 0 : s.length;
                for (this.__data__ = new gd; ++e < t; )
                    this.add(s[e])
            }
            Vd.prototype.add = Vd.prototype.push = NP,
            Vd.prototype.has = PP;
            const jP = Vd
              , LP = function(s, e) {
                for (var t = -1, r = s == null ? 0 : s.length; ++t < r; )
                    if (e(s[t], t, s))
                        return !0;
                return !1
            }
              , zP = function(s, e) {
                return s.has(e)
            }
              , Xv = function(s, e, t, r, i, l) {
                var d = 1 & t
                  , h = s.length
                  , m = e.length;
                if (h != m && !(d && m > h))
                    return !1;
                var g = l.get(s)
                  , b = l.get(e);
                if (g && b)
                    return g == e && b == s;
                var v = -1
                  , x = !0
                  , T = 2 & t ? new jP : void 0;
                for (l.set(s, e),
                l.set(e, s); ++v < h; ) {
                    var I = s[v]
                      , P = e[v];
                    if (r)
                        var O = d ? r(P, I, v, e, s, l) : r(I, P, v, s, e, l);
                    if (O !== void 0) {
                        if (O)
                            continue;
                        x = !1;
                        break
                    }
                    if (T) {
                        if (!LP(e, function(F, q) {
                            if (!zP(T, q) && (I === F || i(I, F, t, r, l)))
                                return T.push(q)
                        })) {
                            x = !1;
                            break
                        }
                    } else if (I !== P && !i(I, P, t, r, l)) {
                        x = !1;
                        break
                    }
                }
                return l.delete(s),
                l.delete(e),
                x
            }
              , OP = function(s) {
                var e = -1
                  , t = Array(s.size);
                return s.forEach(function(r, i) {
                    t[++e] = [i, r]
                }),
                t
            }
              , RP = function(s) {
                var e = -1
                  , t = Array(s.size);
                return s.forEach(function(r) {
                    t[++e] = r
                }),
                t
            };
            var e_ = Tr ? Tr.prototype : void 0
              , Ep = e_ ? e_.valueOf : void 0;
            const FP = function(s, e, t, r, i, l, d) {
                switch (t) {
                case "[object DataView]":
                    if (s.byteLength != e.byteLength || s.byteOffset != e.byteOffset)
                        return !1;
                    s = s.buffer,
                    e = e.buffer;
                case "[object ArrayBuffer]":
                    return !(s.byteLength != e.byteLength || !l(new vd(s), new vd(e)));
                case "[object Boolean]":
                case "[object Date]":
                case "[object Number]":
                    return ol(+s, +e);
                case "[object Error]":
                    return s.name == e.name && s.message == e.message;
                case "[object RegExp]":
                case "[object String]":
                    return s == e + "";
                case "[object Map]":
                    var h = OP;
                case "[object Set]":
                    var m = 1 & r;
                    if (h || (h = RP),
                    s.size != e.size && !m)
                        return !1;
                    var g = d.get(s);
                    if (g)
                        return g == e;
                    r |= 2,
                    d.set(s, e);
                    var b = Xv(h(s), h(e), r, i, l, d);
                    return d.delete(s),
                    b;
                case "[object Symbol]":
                    if (Ep)
                        return Ep.call(s) == Ep.call(e)
                }
                return !1
            };
            var VP = Object.prototype.hasOwnProperty;
            const UP = function(s, e, t, r, i, l) {
                var d = 1 & t
                  , h = zm(s)
                  , m = h.length;
                if (m != zm(e).length && !d)
                    return !1;
                for (var g = m; g--; ) {
                    var b = h[g];
                    if (!(d ? b in e : VP.call(e, b)))
                        return !1
                }
                var v = l.get(s)
                  , x = l.get(e);
                if (v && x)
                    return v == e && x == s;
                var T = !0;
                l.set(s, e),
                l.set(e, s);
                for (var I = d; ++g < m; ) {
                    var P = s[b = h[g]]
                      , O = e[b];
                    if (r)
                        var F = d ? r(O, P, b, e, s, l) : r(P, O, b, s, e, l);
                    if (!(F === void 0 ? P === O || i(P, O, t, r, l) : F)) {
                        T = !1;
                        break
                    }
                    I || (I = b == "constructor")
                }
                if (T && !I) {
                    var q = s.constructor
                      , Q = e.constructor;
                    q == Q || !("constructor"in s) || !("constructor"in e) || typeof q == "function" && q instanceof q && typeof Q == "function" && Q instanceof Q || (T = !1)
                }
                return l.delete(s),
                l.delete(e),
                T
            };
            var t_ = "[object Arguments]"
              , o_ = "[object Array]"
              , Ud = "[object Object]"
              , r_ = Object.prototype.hasOwnProperty;
            const HP = function(s, e, t, r, i, l) {
                var d = xo(s)
                  , h = xo(e)
                  , m = d ? o_ : ll(s)
                  , g = h ? o_ : ll(e)
                  , b = (m = m == t_ ? Ud : m) == Ud
                  , v = (g = g == t_ ? Ud : g) == Ud
                  , x = m == g;
                if (x && il(s)) {
                    if (!il(e))
                        return !1;
                    d = !0,
                    b = !1
                }
                if (x && !b)
                    return l || (l = new bs),
                    d || Pm(s) ? Xv(s, e, t, r, i, l) : FP(s, e, m, t, r, i, l);
                if (!(1 & t)) {
                    var T = b && r_.call(s, "__wrapped__")
                      , I = v && r_.call(e, "__wrapped__");
                    if (T || I) {
                        var P = T ? s.value() : s
                          , O = I ? e.value() : e;
                        return l || (l = new bs),
                        i(P, O, t, r, l)
                    }
                }
                return !!x && (l || (l = new bs),
                UP(s, e, t, r, i, l))
            }
              , Hd = function s(e, t, r, i, l) {
                return e === t || (e == null || t == null || !Wo(e) && !Wo(t) ? e != e && t != t : HP(e, t, r, i, s, l))
            }
              , WP = function(s, e, t) {
                var r = (t = typeof t == "function" ? t : void 0) ? t(s, e) : void 0;
                return r === void 0 ? Hd(s, e, void 0, t) : !!r
            };
            class n_ extends Nr {
                constructor(e) {
                    super(e),
                    C(this, "domConverter"),
                    C(this, "renderer"),
                    C(this, "_config"),
                    C(this, "_domElements"),
                    C(this, "_mutationObserver"),
                    this._config = {
                        childList: !0,
                        characterData: !0,
                        subtree: !0
                    },
                    this.domConverter = e.domConverter,
                    this.renderer = e._renderer,
                    this._domElements = new Set,
                    this._mutationObserver = new window.MutationObserver(this._onMutations.bind(this))
                }
                flush() {
                    this._onMutations(this._mutationObserver.takeRecords())
                }
                observe(e) {
                    this._domElements.add(e),
                    this.isEnabled && this._mutationObserver.observe(e, this._config)
                }
                stopObserving(e) {
                    if (this._domElements.delete(e),
                    this.isEnabled) {
                        this._mutationObserver.disconnect();
                        for (const t of this._domElements)
                            this._mutationObserver.observe(t, this._config)
                    }
                }
                enable() {
                    super.enable();
                    for (const e of this._domElements)
                        this._mutationObserver.observe(e, this._config)
                }
                disable() {
                    super.disable(),
                    this._mutationObserver.disconnect()
                }
                destroy() {
                    super.destroy(),
                    this._mutationObserver.disconnect()
                }
                _onMutations(e) {
                    if (e.length === 0)
                        return;
                    const t = this.domConverter
                      , r = new Set
                      , i = new Set;
                    for (const d of e) {
                        const h = t.mapDomToView(d.target);
                        h && (h.is("uiElement") || h.is("rawElement") || d.type !== "childList" || this._isBogusBrMutation(d) || i.add(h))
                    }
                    for (const d of e) {
                        const h = t.mapDomToView(d.target);
                        if ((!h || !h.is("uiElement") && !h.is("rawElement")) && d.type === "characterData") {
                            const m = t.findCorrespondingViewText(d.target);
                            m && !i.has(m.parent) ? r.add(m) : !m && Do(d.target) && i.add(t.mapDomToView(d.target.parentNode))
                        }
                    }
                    let l = !1;
                    for (const d of r)
                        l = !0,
                        this.renderer.markToSync("text", d);
                    for (const d of i) {
                        const h = t.mapViewToDom(d)
                          , m = Array.from(d.getChildren())
                          , g = Array.from(t.domChildrenToView(h, {
                            withChildren: !1
                        }));
                        WP(m, g, $P) || (l = !0,
                        this.renderer.markToSync("children", d))
                    }
                    l && this.view.forceRender()
                }
                _isBogusBrMutation(e) {
                    let t = null;
                    return e.nextSibling === null && e.removedNodes.length === 0 && e.addedNodes.length == 1 && (t = this.domConverter.domToView(e.addedNodes[0], {
                        withChildren: !1
                    })),
                    t && t.is("element", "br")
                }
            }
            function $P(s, e) {
                if (!Array.isArray(s))
                    return s === e || !(!s.is("$text") || !e.is("$text")) && s.data === e.data
            }
            class Wd extends Mn {
                constructor(e) {
                    super(e),
                    C(this, "_renderTimeoutId"),
                    C(this, "_isFocusChanging", !1),
                    C(this, "domEventType", ["focus", "blur"]),
                    this.useCapture = !0;
                    const t = this.document;
                    t.on("focus", () => {
                        this._isFocusChanging = !0,
                        this._renderTimeoutId = setTimeout( () => {
                            this.flush(),
                            e.change( () => {}
                            )
                        }
                        , 50)
                    }
                    ),
                    t.on("blur", (r, i) => {
                        const l = t.selection.editableElement;
                        l !== null && l !== i.target || (t.isFocused = !1,
                        this._isFocusChanging = !1,
                        e.change( () => {}
                        ))
                    }
                    )
                }
                flush() {
                    this._isFocusChanging && (this._isFocusChanging = !1,
                    this.document.isFocused = !0)
                }
                onDomEvent(e) {
                    this.fire(e.type, e)
                }
                destroy() {
                    this._renderTimeoutId && clearTimeout(this._renderTimeoutId),
                    super.destroy()
                }
            }
            class qP extends Nr {
                constructor(e) {
                    super(e),
                    C(this, "mutationObserver"),
                    C(this, "focusObserver"),
                    C(this, "selection"),
                    C(this, "domConverter"),
                    C(this, "_documents"),
                    C(this, "_fireSelectionChangeDoneDebounced"),
                    C(this, "_clearInfiniteLoopInterval"),
                    C(this, "_documentIsSelectingInactivityTimeoutDebounced"),
                    C(this, "_loopbackCounter"),
                    this.mutationObserver = e.getObserver(n_),
                    this.focusObserver = e.getObserver(Wd),
                    this.selection = this.document.selection,
                    this.domConverter = e.domConverter,
                    this._documents = new WeakSet,
                    this._fireSelectionChangeDoneDebounced = Ts(t => {
                        this.document.fire("selectionChangeDone", t)
                    }
                    , 200),
                    this._clearInfiniteLoopInterval = setInterval( () => this._clearInfiniteLoop(), 1e3),
                    this._documentIsSelectingInactivityTimeoutDebounced = Ts( () => this.document.isSelecting = !1, 5e3),
                    this._loopbackCounter = 0
                }
                observe(e) {
                    const t = e.ownerDocument
                      , r = () => {
                        this.document.isSelecting && (this._handleSelectionChange(null, t),
                        this.document.isSelecting = !1,
                        this._documentIsSelectingInactivityTimeoutDebounced.cancel())
                    }
                    ;
                    this.listenTo(e, "selectstart", () => {
                        this.document.isSelecting = !0,
                        this._documentIsSelectingInactivityTimeoutDebounced()
                    }
                    , {
                        priority: "highest"
                    }),
                    this.listenTo(e, "keydown", r, {
                        priority: "highest",
                        useCapture: !0
                    }),
                    this.listenTo(e, "keyup", r, {
                        priority: "highest",
                        useCapture: !0
                    }),
                    this._documents.has(t) || (this.listenTo(t, "mouseup", r, {
                        priority: "highest",
                        useCapture: !0
                    }),
                    this.listenTo(t, "selectionchange", (i, l) => {
                        this.document.isComposing && !E.isAndroid || (this._handleSelectionChange(l, t),
                        this._documentIsSelectingInactivityTimeoutDebounced())
                    }
                    ),
                    this._documents.add(t))
                }
                stopObserving(e) {
                    this.stopListening(e)
                }
                destroy() {
                    super.destroy(),
                    clearInterval(this._clearInfiniteLoopInterval),
                    this._fireSelectionChangeDoneDebounced.cancel(),
                    this._documentIsSelectingInactivityTimeoutDebounced.cancel()
                }
                _reportInfiniteLoop() {}
                _handleSelectionChange(e, t) {
                    if (!this.isEnabled)
                        return;
                    const r = t.defaultView.getSelection();
                    if (this.checkShouldIgnoreEventFromTarget(r.anchorNode))
                        return;
                    this.mutationObserver.flush();
                    const i = this.domConverter.domSelectionToView(r);
                    if (i.rangeCount != 0) {
                        if (this.view.hasDomSelection = !0,
                        this.focusObserver.flush(),
                        !this.selection.isEqual(i) || !this.domConverter.isDomSelectionCorrect(r))
                            if (++this._loopbackCounter > 60)
                                this._reportInfiniteLoop();
                            else if (this.selection.isSimilar(i))
                                this.view.forceRender();
                            else {
                                const l = {
                                    oldSelection: this.selection,
                                    newSelection: i,
                                    domSelection: r
                                };
                                this.document.fire("selectionChange", l),
                                this._fireSelectionChangeDoneDebounced(l)
                            }
                    } else
                        this.view.hasDomSelection = !1
                }
                _clearInfiniteLoop() {
                    this._loopbackCounter = 0
                }
            }
            class GP extends Mn {
                constructor(e) {
                    super(e),
                    C(this, "domEventType", ["compositionstart", "compositionupdate", "compositionend"]);
                    const t = this.document;
                    t.on("compositionstart", () => {
                        t.isComposing = !0
                    }
                    , {
                        priority: "low"
                    }),
                    t.on("compositionend", () => {
                        t.isComposing = !1
                    }
                    , {
                        priority: "low"
                    })
                }
                onDomEvent(e) {
                    this.fire(e.type, e, {
                        data: e.data
                    })
                }
            }
            class i_ {
                constructor(e, t={}) {
                    C(this, "_files"),
                    C(this, "_native"),
                    this._files = t.cacheFiles ? s_(e) : null,
                    this._native = e
                }
                get files() {
                    return this._files || (this._files = s_(this._native)),
                    this._files
                }
                get types() {
                    return this._native.types
                }
                getData(e) {
                    return this._native.getData(e)
                }
                setData(e, t) {
                    this._native.setData(e, t)
                }
                set effectAllowed(e) {
                    this._native.effectAllowed = e
                }
                get effectAllowed() {
                    return this._native.effectAllowed
                }
                set dropEffect(e) {
                    this._native.dropEffect = e
                }
                get dropEffect() {
                    return this._native.dropEffect
                }
                setDragImage(e, t, r) {
                    this._native.setDragImage(e, t, r)
                }
                get isCanceled() {
                    return this._native.dropEffect == "none" || !!this._native.mozUserCancelled
                }
            }
            function s_(s) {
                const e = Array.from(s.files || [])
                  , t = Array.from(s.items || []);
                return e.length ? e : t.filter(r => r.kind === "file").map(r => r.getAsFile())
            }
            class KP extends Mn {
                constructor() {
                    super(...arguments),
                    C(this, "domEventType", "beforeinput")
                }
                onDomEvent(e) {
                    const t = e.getTargetRanges()
                      , r = this.view
                      , i = r.document;
                    let l = null
                      , d = null
                      , h = [];
                    if (e.dataTransfer && (l = new i_(e.dataTransfer)),
                    e.data !== null ? d = e.data : l && (d = l.getData("text/plain")),
                    i.selection.isFake)
                        h = Array.from(i.selection.getRanges());
                    else if (t.length)
                        h = t.map(m => {
                            const g = r.domConverter.domPositionToView(m.startContainer, m.startOffset)
                              , b = r.domConverter.domPositionToView(m.endContainer, m.endOffset);
                            return g ? r.createRange(g, b) : b ? r.createRange(b) : void 0
                        }
                        ).filter(m => !!m);
                    else if (E.isAndroid) {
                        const m = e.target.ownerDocument.defaultView.getSelection();
                        h = Array.from(r.domConverter.domSelectionToView(m).getRanges())
                    }
                    if (E.isAndroid && e.inputType == "insertCompositionText" && d && d.endsWith(`
`))
                        this.fire(e.type, e, {
                            inputType: "insertParagraph",
                            targetRanges: [r.createRange(h[0].end)]
                        });
                    else if (e.inputType == "insertText" && d && d.includes(`
`)) {
                        const m = d.split(/\n{1,2}/g);
                        let g = h;
                        for (let b = 0; b < m.length; b++) {
                            const v = m[b];
                            v != "" && (this.fire(e.type, e, {
                                data: v,
                                dataTransfer: l,
                                targetRanges: g,
                                inputType: e.inputType,
                                isComposing: e.isComposing
                            }),
                            g = [i.selection.getFirstRange()]),
                            b + 1 < m.length && (this.fire(e.type, e, {
                                inputType: "insertParagraph",
                                targetRanges: g
                            }),
                            g = [i.selection.getFirstRange()])
                        }
                    } else
                        this.fire(e.type, e, {
                            data: d,
                            dataTransfer: l,
                            targetRanges: h,
                            inputType: e.inputType,
                            isComposing: e.isComposing
                        })
                }
            }
            class YP extends Nr {
                constructor(e) {
                    super(e),
                    this.document.on("keydown", (t, r) => {
                        if (this.isEnabled && ((i = r.keyCode) == Me.arrowright || i == Me.arrowleft || i == Me.arrowup || i == Me.arrowdown)) {
                            const l = new xs(this.document,"arrowKey",this.document.selection.getFirstRange());
                            this.document.fire(l, r),
                            l.stop.called && t.stop()
                        }
                        var i
                    }
                    )
                }
                observe() {}
                stopObserving() {}
            }
            class QP extends Nr {
                constructor(e) {
                    super(e);
                    const t = this.document;
                    t.on("keydown", (r, i) => {
                        if (!this.isEnabled || i.keyCode != Me.tab || i.ctrlKey)
                            return;
                        const l = new xs(t,"tab",t.selection.getFirstRange());
                        t.fire(l, i),
                        l.stop.called && r.stop()
                    }
                    )
                }
                observe() {}
                stopObserving() {}
            }
            const gr = function(s) {
                return Hm(s, 5)
            };
            class ZP extends ye() {
                constructor(e) {
                    super(),
                    C(this, "document"),
                    C(this, "domConverter"),
                    C(this, "domRoots", new Map),
                    C(this, "_renderer"),
                    C(this, "_initialDomRootAttributes", new WeakMap),
                    C(this, "_observers", new Map),
                    C(this, "_writer"),
                    C(this, "_ongoingChange", !1),
                    C(this, "_postFixersInProgress", !1),
                    C(this, "_renderingDisabled", !1),
                    C(this, "_hasChangedSinceTheLastRendering", !1),
                    this.document = new zd(e),
                    this.domConverter = new Fd(this.document),
                    this.set("isRenderingInProgress", !1),
                    this.set("hasDomSelection", !1),
                    this._renderer = new pP(this.domConverter,this.document.selection),
                    this._renderer.bind("isFocused", "isSelecting", "isComposing").to(this.document, "isFocused", "isSelecting", "isComposing"),
                    this._writer = new jv(this.document),
                    this.addObserver(n_),
                    this.addObserver(Wd),
                    this.addObserver(qP),
                    this.addObserver(vP),
                    this.addObserver(BP),
                    this.addObserver(GP),
                    this.addObserver(YP),
                    this.addObserver(KP),
                    this.addObserver(QP),
                    this.document.on("arrowKey", hP, {
                        priority: "low"
                    }),
                    aP(this),
                    this.on("render", () => {
                        this._render(),
                        this.document.fire("layoutChanged"),
                        this._hasChangedSinceTheLastRendering = !1
                    }
                    ),
                    this.listenTo(this.document.selection, "change", () => {
                        this._hasChangedSinceTheLastRendering = !0
                    }
                    ),
                    this.listenTo(this.document, "change:isFocused", () => {
                        this._hasChangedSinceTheLastRendering = !0
                    }
                    ),
                    E.isiOS && this.listenTo(this.document, "blur", (t, r) => {
                        this.domConverter.mapDomToView(r.domEvent.relatedTarget) || this.domConverter._clearDomSelection()
                    }
                    )
                }
                attachDomRoot(e, t="main") {
                    const r = this.document.getRoot(t);
                    r._name = e.tagName.toLowerCase();
                    const i = {};
                    for (const {name: d, value: h} of Array.from(e.attributes))
                        i[d] = h,
                        d === "class" ? this._writer.addClass(h.split(" "), r) : this._writer.setAttribute(d, h, r);
                    this._initialDomRootAttributes.set(e, i);
                    const l = () => {
                        this._writer.setAttribute("contenteditable", (!r.isReadOnly).toString(), r),
                        r.isReadOnly ? this._writer.addClass("ck-read-only", r) : this._writer.removeClass("ck-read-only", r)
                    }
                    ;
                    l(),
                    this.domRoots.set(t, e),
                    this.domConverter.bindElements(e, r),
                    this._renderer.markToSync("children", r),
                    this._renderer.markToSync("attributes", r),
                    this._renderer.domDocuments.add(e.ownerDocument),
                    r.on("change:children", (d, h) => this._renderer.markToSync("children", h)),
                    r.on("change:attributes", (d, h) => this._renderer.markToSync("attributes", h)),
                    r.on("change:text", (d, h) => this._renderer.markToSync("text", h)),
                    r.on("change:isReadOnly", () => this.change(l)),
                    r.on("change", () => {
                        this._hasChangedSinceTheLastRendering = !0
                    }
                    );
                    for (const d of this._observers.values())
                        d.observe(e, t)
                }
                detachDomRoot(e) {
                    const t = this.domRoots.get(e);
                    Array.from(t.attributes).forEach( ({name: i}) => t.removeAttribute(i));
                    const r = this._initialDomRootAttributes.get(t);
                    for (const i in r)
                        t.setAttribute(i, r[i]);
                    this.domRoots.delete(e),
                    this.domConverter.unbindDomElement(t);
                    for (const i of this._observers.values())
                        i.stopObserving(t)
                }
                getDomRoot(e="main") {
                    return this.domRoots.get(e)
                }
                addObserver(e) {
                    let t = this._observers.get(e);
                    if (t)
                        return t;
                    t = new e(this),
                    this._observers.set(e, t);
                    for (const [r,i] of this.domRoots)
                        t.observe(i, r);
                    return t.enable(),
                    t
                }
                getObserver(e) {
                    return this._observers.get(e)
                }
                disableObservers() {
                    for (const e of this._observers.values())
                        e.disable()
                }
                enableObservers() {
                    for (const e of this._observers.values())
                        e.enable()
                }
                scrollToTheSelection({alignToTop: e, forceScroll: t, viewportOffset: r=20, ancestorOffset: i=20}={}) {
                    const l = this.document.selection.getFirstRange();
                    if (!l)
                        return;
                    const d = gr({
                        alignToTop: e,
                        forceScroll: t,
                        viewportOffset: r,
                        ancestorOffset: i
                    });
                    typeof r == "number" && (r = {
                        top: r,
                        bottom: r,
                        left: r,
                        right: r
                    });
                    const h = {
                        target: this.domConverter.viewRangeToDom(l),
                        viewportOffset: r,
                        ancestorOffset: i,
                        alignToTop: e,
                        forceScroll: t
                    };
                    this.fire("scrollToTheSelection", h, d),
                    function({target: m, viewportOffset: g=0, ancestorOffset: b=0, alignToTop: v, forceScroll: x}) {
                        const T = Ym(m);
                        let I = T
                          , P = null;
                        for (g = function(O) {
                            return typeof O == "number" ? {
                                top: O,
                                bottom: O,
                                left: O,
                                right: O
                            } : O
                        }(g); I; ) {
                            let O;
                            O = l4(I == T ? m : P),
                            a4({
                                parent: O,
                                getRect: () => XA(m, I),
                                alignToTop: v,
                                ancestorOffset: b,
                                forceScroll: x
                            });
                            const F = XA(m, I);
                            if (s4({
                                window: I,
                                rect: F,
                                viewportOffset: g,
                                alignToTop: v,
                                forceScroll: x
                            }),
                            I.parent != I) {
                                if (P = I.frameElement,
                                I = I.parent,
                                !P)
                                    return
                            } else
                                I = null
                        }
                    }(h)
                }
                focus() {
                    if (!this.document.isFocused) {
                        const e = this.document.selection.editableElement;
                        e && (this.domConverter.focus(e),
                        this.forceRender())
                    }
                }
                change(e) {
                    if (this.isRenderingInProgress || this._postFixersInProgress)
                        throw new U("cannot-change-view-tree",this);
                    try {
                        if (this._ongoingChange)
                            return e(this._writer);
                        this._ongoingChange = !0;
                        const t = e(this._writer);
                        return this._ongoingChange = !1,
                        !this._renderingDisabled && this._hasChangedSinceTheLastRendering && (this._postFixersInProgress = !0,
                        this.document._callPostFixers(this._writer),
                        this._postFixersInProgress = !1,
                        this.fire("render")),
                        t
                    } catch (t) {
                        U.rethrowUnexpectedError(t, this)
                    }
                }
                forceRender() {
                    this._hasChangedSinceTheLastRendering = !0,
                    this.getObserver(Wd).flush(),
                    this.change( () => {}
                    )
                }
                destroy() {
                    for (const e of this._observers.values())
                        e.destroy();
                    this.document.destroy(),
                    this.stopListening()
                }
                createPositionAt(e, t) {
                    return ae._createAt(e, t)
                }
                createPositionAfter(e) {
                    return ae._createAfter(e)
                }
                createPositionBefore(e) {
                    return ae._createBefore(e)
                }
                createRange(e, t) {
                    return new fe(e,t)
                }
                createRangeOn(e) {
                    return fe._createOn(e)
                }
                createRangeIn(e) {
                    return fe._createIn(e)
                }
                createSelection(...e) {
                    return new mr(...e)
                }
                _disableRendering(e) {
                    this._renderingDisabled = e,
                    e == 0 && this.change( () => {}
                    )
                }
                _render() {
                    this.isRenderingInProgress = !0,
                    this.disableObservers(),
                    this._renderer.render(),
                    this.enableObservers(),
                    this.isRenderingInProgress = !1
                }
            }
            class Bn {
                is() {
                    throw new Error("is() method is abstract")
                }
            }
            class Ii extends Bn {
                constructor(e) {
                    super(),
                    C(this, "parent", null),
                    C(this, "_attrs"),
                    this._attrs = Ir(e)
                }
                get document() {
                    return null
                }
                get index() {
                    let e;
                    if (!this.parent)
                        return null;
                    if ((e = this.parent.getChildIndex(this)) === null)
                        throw new U("model-node-not-found-in-parent",this);
                    return e
                }
                get startOffset() {
                    let e;
                    if (!this.parent)
                        return null;
                    if ((e = this.parent.getChildStartOffset(this)) === null)
                        throw new U("model-node-not-found-in-parent",this);
                    return e
                }
                get offsetSize() {
                    return 1
                }
                get endOffset() {
                    return this.parent ? this.startOffset + this.offsetSize : null
                }
                get nextSibling() {
                    const e = this.index;
                    return e !== null && this.parent.getChild(e + 1) || null
                }
                get previousSibling() {
                    const e = this.index;
                    return e !== null && this.parent.getChild(e - 1) || null
                }
                get root() {
                    let e = this;
                    for (; e.parent; )
                        e = e.parent;
                    return e
                }
                isAttached() {
                    return this.parent !== null && this.root.isAttached()
                }
                getPath() {
                    const e = [];
                    let t = this;
                    for (; t.parent; )
                        e.unshift(t.startOffset),
                        t = t.parent;
                    return e
                }
                getAncestors(e={}) {
                    const t = [];
                    let r = e.includeSelf ? this : this.parent;
                    for (; r; )
                        t[e.parentFirst ? "push" : "unshift"](r),
                        r = r.parent;
                    return t
                }
                getCommonAncestor(e, t={}) {
                    const r = this.getAncestors(t)
                      , i = e.getAncestors(t);
                    let l = 0;
                    for (; r[l] == i[l] && r[l]; )
                        l++;
                    return l === 0 ? null : r[l - 1]
                }
                isBefore(e) {
                    if (this == e || this.root !== e.root)
                        return !1;
                    const t = this.getPath()
                      , r = e.getPath()
                      , i = ro(t, r);
                    switch (i) {
                    case "prefix":
                        return !0;
                    case "extension":
                        return !1;
                    default:
                        return t[i] < r[i]
                    }
                }
                isAfter(e) {
                    return this != e && this.root === e.root && !this.isBefore(e)
                }
                hasAttribute(e) {
                    return this._attrs.has(e)
                }
                getAttribute(e) {
                    return this._attrs.get(e)
                }
                getAttributes() {
                    return this._attrs.entries()
                }
                getAttributeKeys() {
                    return this._attrs.keys()
                }
                toJSON() {
                    const e = {};
                    return this._attrs.size && (e.attributes = Array.from(this._attrs).reduce( (t, r) => (t[r[0]] = r[1],
                    t), {})),
                    e
                }
                _clone(e) {
                    return new this.constructor(this._attrs)
                }
                _remove() {
                    this.parent._removeChildren(this.index)
                }
                _setAttribute(e, t) {
                    this._attrs.set(e, t)
                }
                _setAttributesTo(e) {
                    this._attrs = Ir(e)
                }
                _removeAttribute(e) {
                    return this._attrs.delete(e)
                }
                _clearAttributes() {
                    this._attrs.clear()
                }
            }
            Ii.prototype.is = function(s) {
                return s === "node" || s === "model:node"
            }
            ;
            class bl {
                constructor(e) {
                    C(this, "_nodes", []),
                    e && this._insertNodes(0, e)
                }
                [Symbol.iterator]() {
                    return this._nodes[Symbol.iterator]()
                }
                get length() {
                    return this._nodes.length
                }
                get maxOffset() {
                    return this._nodes.reduce( (e, t) => e + t.offsetSize, 0)
                }
                getNode(e) {
                    return this._nodes[e] || null
                }
                getNodeIndex(e) {
                    const t = this._nodes.indexOf(e);
                    return t == -1 ? null : t
                }
                getNodeStartOffset(e) {
                    const t = this.getNodeIndex(e);
                    return t === null ? null : this._nodes.slice(0, t).reduce( (r, i) => r + i.offsetSize, 0)
                }
                indexToOffset(e) {
                    if (e == this._nodes.length)
                        return this.maxOffset;
                    const t = this._nodes[e];
                    if (!t)
                        throw new U("model-nodelist-index-out-of-bounds",this);
                    return this.getNodeStartOffset(t)
                }
                offsetToIndex(e) {
                    let t = 0;
                    for (const r of this._nodes) {
                        if (e >= t && e < t + r.offsetSize)
                            return this.getNodeIndex(r);
                        t += r.offsetSize
                    }
                    if (t != e)
                        throw new U("model-nodelist-offset-out-of-bounds",this,{
                            offset: e,
                            nodeList: this
                        });
                    return this.length
                }
                _insertNodes(e, t) {
                    for (const r of t)
                        if (!(r instanceof Ii))
                            throw new U("model-nodelist-insertnodes-not-node",this);
                    this._nodes = function(r, i, l, d) {
                        if (Math.max(i.length, r.length) > 1e4)
                            return r.slice(0, l).concat(i).concat(r.slice(l + d, r.length));
                        {
                            const h = Array.from(r);
                            return h.splice(l, d, ...i),
                            h
                        }
                    }(this._nodes, Array.from(t), e, 0)
                }
                _removeNodes(e, t=1) {
                    return this._nodes.splice(e, t)
                }
                toJSON() {
                    return this._nodes.map(e => e.toJSON())
                }
            }
            class $e extends Ii {
                constructor(e, t) {
                    super(t),
                    C(this, "_data"),
                    this._data = e || ""
                }
                get offsetSize() {
                    return this.data.length
                }
                get data() {
                    return this._data
                }
                toJSON() {
                    const e = super.toJSON();
                    return e.data = this.data,
                    e
                }
                _clone() {
                    return new $e(this.data,this.getAttributes())
                }
                static fromJSON(e) {
                    return new $e(e.data,e.attributes)
                }
            }
            $e.prototype.is = function(s) {
                return s === "$text" || s === "model:$text" || s === "text" || s === "model:text" || s === "node" || s === "model:node"
            }
            ;
            class fr extends Bn {
                constructor(e, t, r) {
                    if (super(),
                    C(this, "textNode"),
                    C(this, "data"),
                    C(this, "offsetInText"),
                    this.textNode = e,
                    t < 0 || t > e.offsetSize)
                        throw new U("model-textproxy-wrong-offsetintext",this);
                    if (r < 0 || t + r > e.offsetSize)
                        throw new U("model-textproxy-wrong-length",this);
                    this.data = e.data.substring(t, t + r),
                    this.offsetInText = t
                }
                get startOffset() {
                    return this.textNode.startOffset !== null ? this.textNode.startOffset + this.offsetInText : null
                }
                get offsetSize() {
                    return this.data.length
                }
                get endOffset() {
                    return this.startOffset !== null ? this.startOffset + this.offsetSize : null
                }
                get isPartial() {
                    return this.offsetSize !== this.textNode.offsetSize
                }
                get parent() {
                    return this.textNode.parent
                }
                get root() {
                    return this.textNode.root
                }
                getPath() {
                    const e = this.textNode.getPath();
                    return e.length > 0 && (e[e.length - 1] += this.offsetInText),
                    e
                }
                getAncestors(e={}) {
                    const t = [];
                    let r = e.includeSelf ? this : this.parent;
                    for (; r; )
                        t[e.parentFirst ? "push" : "unshift"](r),
                        r = r.parent;
                    return t
                }
                hasAttribute(e) {
                    return this.textNode.hasAttribute(e)
                }
                getAttribute(e) {
                    return this.textNode.getAttribute(e)
                }
                getAttributes() {
                    return this.textNode.getAttributes()
                }
                getAttributeKeys() {
                    return this.textNode.getAttributeKeys()
                }
            }
            fr.prototype.is = function(s) {
                return s === "$textProxy" || s === "model:$textProxy" || s === "textProxy" || s === "model:textProxy"
            }
            ;
            class Fe extends Ii {
                constructor(e, t, r) {
                    super(t),
                    C(this, "name"),
                    C(this, "_children", new bl),
                    this.name = e,
                    r && this._insertChild(0, r)
                }
                get childCount() {
                    return this._children.length
                }
                get maxOffset() {
                    return this._children.maxOffset
                }
                get isEmpty() {
                    return this.childCount === 0
                }
                getChild(e) {
                    return this._children.getNode(e)
                }
                getChildren() {
                    return this._children[Symbol.iterator]()
                }
                getChildIndex(e) {
                    return this._children.getNodeIndex(e)
                }
                getChildStartOffset(e) {
                    return this._children.getNodeStartOffset(e)
                }
                offsetToIndex(e) {
                    return this._children.offsetToIndex(e)
                }
                getNodeByPath(e) {
                    let t = this;
                    for (const r of e)
                        t = t.getChild(t.offsetToIndex(r));
                    return t
                }
                findAncestor(e, t={}) {
                    let r = t.includeSelf ? this : this.parent;
                    for (; r; ) {
                        if (r.name === e)
                            return r;
                        r = r.parent
                    }
                    return null
                }
                toJSON() {
                    const e = super.toJSON();
                    if (e.name = this.name,
                    this._children.length > 0) {
                        e.children = [];
                        for (const t of this._children)
                            e.children.push(t.toJSON())
                    }
                    return e
                }
                _clone(e=!1) {
                    const t = e ? Array.from(this._children).map(r => r._clone(!0)) : void 0;
                    return new Fe(this.name,this.getAttributes(),t)
                }
                _appendChild(e) {
                    this._insertChild(this.childCount, e)
                }
                _insertChild(e, t) {
                    const r = function(i) {
                        return typeof i == "string" ? [new $e(i)] : (yo(i) || (i = [i]),
                        Array.from(i).map(l => typeof l == "string" ? new $e(l) : l instanceof fr ? new $e(l.data,l.getAttributes()) : l))
                    }(t);
                    for (const i of r)
                        i.parent !== null && i._remove(),
                        i.parent = this;
                    this._children._insertNodes(e, r)
                }
                _removeChildren(e, t=1) {
                    const r = this._children._removeNodes(e, t);
                    for (const i of r)
                        i.parent = null;
                    return r
                }
                static fromJSON(e) {
                    let t;
                    if (e.children) {
                        t = [];
                        for (const r of e.children)
                            r.name ? t.push(Fe.fromJSON(r)) : t.push($e.fromJSON(r))
                    }
                    return new Fe(e.name,e.attributes,t)
                }
            }
            Fe.prototype.is = function(s, e) {
                return e ? e === this.name && (s === "element" || s === "model:element") : s === "element" || s === "model:element" || s === "node" || s === "model:node"
            }
            ;
            class Kr {
                constructor(e) {
                    if (C(this, "direction"),
                    C(this, "boundaries"),
                    C(this, "singleCharacters"),
                    C(this, "shallow"),
                    C(this, "ignoreElementEnd"),
                    C(this, "_position"),
                    C(this, "_boundaryStartParent"),
                    C(this, "_boundaryEndParent"),
                    C(this, "_visitedParent"),
                    !e || !e.boundaries && !e.startPosition)
                        throw new U("model-tree-walker-no-start-position",null);
                    const t = e.direction || "forward";
                    if (t != "forward" && t != "backward")
                        throw new U("model-tree-walker-unknown-direction",e,{
                            direction: t
                        });
                    this.direction = t,
                    this.boundaries = e.boundaries || null,
                    e.startPosition ? this._position = e.startPosition.clone() : this._position = ne._createAt(this.boundaries[this.direction == "backward" ? "end" : "start"]),
                    this.position.stickiness = "toNone",
                    this.singleCharacters = !!e.singleCharacters,
                    this.shallow = !!e.shallow,
                    this.ignoreElementEnd = !!e.ignoreElementEnd,
                    this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null,
                    this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null,
                    this._visitedParent = this.position.parent
                }
                [Symbol.iterator]() {
                    return this
                }
                get position() {
                    return this._position
                }
                skip(e) {
                    let t, r, i, l;
                    do
                        i = this.position,
                        l = this._visitedParent,
                        {done: t, value: r} = this.next();
                    while (!t && e(r));
                    t || (this._position = i,
                    this._visitedParent = l)
                }
                next() {
                    return this.direction == "forward" ? this._next() : this._previous()
                }
                _next() {
                    const e = this.position
                      , t = this.position.clone()
                      , r = this._visitedParent;
                    if (r.parent === null && t.offset === r.maxOffset)
                        return {
                            done: !0,
                            value: void 0
                        };
                    if (r === this._boundaryEndParent && t.offset == this.boundaries.end.offset)
                        return {
                            done: !0,
                            value: void 0
                        };
                    const i = wl(t, r)
                      , l = i || a_(t, r, i);
                    if (l instanceof Fe) {
                        if (this.shallow) {
                            if (this.boundaries && this.boundaries.end.isBefore(t))
                                return {
                                    done: !0,
                                    value: void 0
                                };
                            t.offset++
                        } else
                            t.path.push(0),
                            this._visitedParent = l;
                        return this._position = t,
                        Mi("elementStart", l, e, t, 1)
                    }
                    if (l instanceof $e) {
                        let d;
                        if (this.singleCharacters)
                            d = 1;
                        else {
                            let g = l.endOffset;
                            this._boundaryEndParent == r && this.boundaries.end.offset < g && (g = this.boundaries.end.offset),
                            d = g - t.offset
                        }
                        const h = t.offset - l.startOffset
                          , m = new fr(l,h,d);
                        return t.offset += d,
                        this._position = t,
                        Mi("text", m, e, t, d)
                    }
                    return t.path.pop(),
                    t.offset++,
                    this._position = t,
                    this._visitedParent = r.parent,
                    this.ignoreElementEnd ? this._next() : Mi("elementEnd", r, e, t)
                }
                _previous() {
                    const e = this.position
                      , t = this.position.clone()
                      , r = this._visitedParent;
                    if (r.parent === null && t.offset === 0)
                        return {
                            done: !0,
                            value: void 0
                        };
                    if (r == this._boundaryStartParent && t.offset == this.boundaries.start.offset)
                        return {
                            done: !0,
                            value: void 0
                        };
                    const i = t.parent
                      , l = wl(t, i)
                      , d = l || l_(t, i, l);
                    if (d instanceof Fe)
                        return t.offset--,
                        this.shallow ? (this._position = t,
                        Mi("elementStart", d, e, t, 1)) : (t.path.push(d.maxOffset),
                        this._position = t,
                        this._visitedParent = d,
                        this.ignoreElementEnd ? this._previous() : Mi("elementEnd", d, e, t));
                    if (d instanceof $e) {
                        let h;
                        if (this.singleCharacters)
                            h = 1;
                        else {
                            let b = d.startOffset;
                            this._boundaryStartParent == r && this.boundaries.start.offset > b && (b = this.boundaries.start.offset),
                            h = t.offset - b
                        }
                        const m = t.offset - d.startOffset
                          , g = new fr(d,m - h,h);
                        return t.offset -= h,
                        this._position = t,
                        Mi("text", g, e, t, h)
                    }
                    return t.path.pop(),
                    this._position = t,
                    this._visitedParent = r.parent,
                    Mi("elementStart", r, e, t, 1)
                }
            }
            function Mi(s, e, t, r, i) {
                return {
                    done: !1,
                    value: {
                        type: s,
                        item: e,
                        previousPosition: t,
                        nextPosition: r,
                        length: i
                    }
                }
            }
            class ne extends Bn {
                constructor(e, t, r="toNone") {
                    if (super(),
                    C(this, "root"),
                    C(this, "path"),
                    C(this, "stickiness"),
                    !e.is("element") && !e.is("documentFragment"))
                        throw new U("model-position-root-invalid",e);
                    if (!(t instanceof Array) || t.length === 0)
                        throw new U("model-position-path-incorrect-format",e,{
                            path: t
                        });
                    e.is("rootElement") ? t = t.slice() : (t = [...e.getPath(), ...t],
                    e = e.root),
                    this.root = e,
                    this.path = t,
                    this.stickiness = r
                }
                get offset() {
                    return this.path[this.path.length - 1]
                }
                set offset(e) {
                    this.path[this.path.length - 1] = e
                }
                get parent() {
                    let e = this.root;
                    for (let t = 0; t < this.path.length - 1; t++)
                        if (e = e.getChild(e.offsetToIndex(this.path[t])),
                        !e)
                            throw new U("model-position-path-incorrect",this,{
                                position: this
                            });
                    if (e.is("$text"))
                        throw new U("model-position-path-incorrect",this,{
                            position: this
                        });
                    return e
                }
                get index() {
                    return this.parent.offsetToIndex(this.offset)
                }
                get textNode() {
                    return wl(this, this.parent)
                }
                get nodeAfter() {
                    const e = this.parent;
                    return a_(this, e, wl(this, e))
                }
                get nodeBefore() {
                    const e = this.parent;
                    return l_(this, e, wl(this, e))
                }
                get isAtStart() {
                    return this.offset === 0
                }
                get isAtEnd() {
                    return this.offset == this.parent.maxOffset
                }
                compareWith(e) {
                    if (this.root != e.root)
                        return "different";
                    const t = ro(this.path, e.path);
                    switch (t) {
                    case "same":
                        return "same";
                    case "prefix":
                        return "before";
                    case "extension":
                        return "after";
                    default:
                        return this.path[t] < e.path[t] ? "before" : "after"
                    }
                }
                getLastMatchingPosition(e, t={}) {
                    t.startPosition = this;
                    const r = new Kr(t);
                    return r.skip(e),
                    r.position
                }
                getParentPath() {
                    return this.path.slice(0, -1)
                }
                getAncestors() {
                    const e = this.parent;
                    return e.is("documentFragment") ? [e] : e.getAncestors({
                        includeSelf: !0
                    })
                }
                findAncestor(e) {
                    const t = this.parent;
                    return t.is("element") ? t.findAncestor(e, {
                        includeSelf: !0
                    }) : null
                }
                getCommonPath(e) {
                    if (this.root != e.root)
                        return [];
                    const t = ro(this.path, e.path)
                      , r = typeof t == "string" ? Math.min(this.path.length, e.path.length) : t;
                    return this.path.slice(0, r)
                }
                getCommonAncestor(e) {
                    const t = this.getAncestors()
                      , r = e.getAncestors();
                    let i = 0;
                    for (; t[i] == r[i] && t[i]; )
                        i++;
                    return i === 0 ? null : t[i - 1]
                }
                getShiftedBy(e) {
                    const t = this.clone()
                      , r = t.offset + e;
                    return t.offset = r < 0 ? 0 : r,
                    t
                }
                isAfter(e) {
                    return this.compareWith(e) == "after"
                }
                isBefore(e) {
                    return this.compareWith(e) == "before"
                }
                isEqual(e) {
                    return this.compareWith(e) == "same"
                }
                isTouching(e) {
                    if (this.root !== e.root)
                        return !1;
                    const t = Math.min(this.path.length, e.path.length);
                    for (let r = 0; r < t; r++) {
                        const i = this.path[r] - e.path[r];
                        if (i < -1 || i > 1)
                            return !1;
                        if (i === 1)
                            return c_(e, this, r);
                        if (i === -1)
                            return c_(this, e, r)
                    }
                    return this.path.length === e.path.length || (this.path.length > e.path.length ? Sp(this.path, t) : Sp(e.path, t))
                }
                hasSameParentAs(e) {
                    return this.root !== e.root ? !1 : ro(this.getParentPath(), e.getParentPath()) == "same"
                }
                getTransformedByOperation(e) {
                    let t;
                    switch (e.type) {
                    case "insert":
                        t = this._getTransformedByInsertOperation(e);
                        break;
                    case "move":
                    case "remove":
                    case "reinsert":
                        t = this._getTransformedByMoveOperation(e);
                        break;
                    case "split":
                        t = this._getTransformedBySplitOperation(e);
                        break;
                    case "merge":
                        t = this._getTransformedByMergeOperation(e);
                        break;
                    default:
                        t = ne._createAt(this)
                    }
                    return t
                }
                _getTransformedByInsertOperation(e) {
                    return this._getTransformedByInsertion(e.position, e.howMany)
                }
                _getTransformedByMoveOperation(e) {
                    return this._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany)
                }
                _getTransformedBySplitOperation(e) {
                    const t = e.movedRange;
                    return t.containsPosition(this) || t.start.isEqual(this) && this.stickiness == "toNext" ? this._getCombined(e.splitPosition, e.moveTargetPosition) : e.graveyardPosition ? this._getTransformedByMove(e.graveyardPosition, e.insertionPosition, 1) : this._getTransformedByInsertion(e.insertionPosition, 1)
                }
                _getTransformedByMergeOperation(e) {
                    const t = e.movedRange;
                    let r;
                    return t.containsPosition(this) || t.start.isEqual(this) ? (r = this._getCombined(e.sourcePosition, e.targetPosition),
                    e.sourcePosition.isBefore(e.targetPosition) && (r = r._getTransformedByDeletion(e.deletionPosition, 1))) : r = this.isEqual(e.deletionPosition) ? ne._createAt(e.deletionPosition) : this._getTransformedByMove(e.deletionPosition, e.graveyardPosition, 1),
                    r
                }
                _getTransformedByDeletion(e, t) {
                    const r = ne._createAt(this);
                    if (this.root != e.root)
                        return r;
                    if (ro(e.getParentPath(), this.getParentPath()) == "same") {
                        if (e.offset < this.offset) {
                            if (e.offset + t > this.offset)
                                return null;
                            r.offset -= t
                        }
                    } else if (ro(e.getParentPath(), this.getParentPath()) == "prefix") {
                        const i = e.path.length - 1;
                        if (e.offset <= this.path[i]) {
                            if (e.offset + t > this.path[i])
                                return null;
                            r.path[i] -= t
                        }
                    }
                    return r
                }
                _getTransformedByInsertion(e, t) {
                    const r = ne._createAt(this);
                    if (this.root != e.root)
                        return r;
                    if (ro(e.getParentPath(), this.getParentPath()) == "same")
                        (e.offset < this.offset || e.offset == this.offset && this.stickiness != "toPrevious") && (r.offset += t);
                    else if (ro(e.getParentPath(), this.getParentPath()) == "prefix") {
                        const i = e.path.length - 1;
                        e.offset <= this.path[i] && (r.path[i] += t)
                    }
                    return r
                }
                _getTransformedByMove(e, t, r) {
                    if (t = t._getTransformedByDeletion(e, r),
                    e.isEqual(t))
                        return ne._createAt(this);
                    const i = this._getTransformedByDeletion(e, r);
                    return i === null || e.isEqual(this) && this.stickiness == "toNext" || e.getShiftedBy(r).isEqual(this) && this.stickiness == "toPrevious" ? this._getCombined(e, t) : i._getTransformedByInsertion(t, r)
                }
                _getCombined(e, t) {
                    const r = e.path.length - 1
                      , i = ne._createAt(t);
                    return i.stickiness = this.stickiness,
                    i.offset = i.offset + this.path[r] - e.offset,
                    i.path = [...i.path, ...this.path.slice(r + 1)],
                    i
                }
                toJSON() {
                    return {
                        root: this.root.toJSON(),
                        path: Array.from(this.path),
                        stickiness: this.stickiness
                    }
                }
                clone() {
                    return new this.constructor(this.root,this.path,this.stickiness)
                }
                static _createAt(e, t, r="toNone") {
                    if (e instanceof ne)
                        return new ne(e.root,e.path,e.stickiness);
                    {
                        const i = e;
                        if (t == "end")
                            t = i.maxOffset;
                        else {
                            if (t == "before")
                                return this._createBefore(i, r);
                            if (t == "after")
                                return this._createAfter(i, r);
                            if (t !== 0 && !t)
                                throw new U("model-createpositionat-offset-required",[this, e])
                        }
                        if (!i.is("element") && !i.is("documentFragment"))
                            throw new U("model-position-parent-incorrect",[this, e]);
                        const l = i.getPath();
                        return l.push(t),
                        new this(i.root,l,r)
                    }
                }
                static _createAfter(e, t) {
                    if (!e.parent)
                        throw new U("model-position-after-root",[this, e],{
                            root: e
                        });
                    return this._createAt(e.parent, e.endOffset, t)
                }
                static _createBefore(e, t) {
                    if (!e.parent)
                        throw new U("model-position-before-root",e,{
                            root: e
                        });
                    return this._createAt(e.parent, e.startOffset, t)
                }
                static fromJSON(e, t) {
                    if (e.root === "$graveyard") {
                        const r = new ne(t.graveyard,e.path);
                        return r.stickiness = e.stickiness,
                        r
                    }
                    if (!t.getRoot(e.root))
                        throw new U("model-position-fromjson-no-root",t,{
                            rootName: e.root
                        });
                    return new ne(t.getRoot(e.root),e.path,e.stickiness)
                }
            }
            function wl(s, e) {
                const t = e.getChild(e.offsetToIndex(s.offset));
                return t && t.is("$text") && t.startOffset < s.offset ? t : null
            }
            function a_(s, e, t) {
                return t !== null ? null : e.getChild(e.offsetToIndex(s.offset))
            }
            function l_(s, e, t) {
                return t !== null ? null : e.getChild(e.offsetToIndex(s.offset) - 1)
            }
            function c_(s, e, t) {
                return t + 1 !== s.path.length && !!Sp(e.path, t + 1) && !!function(r, i) {
                    let l = r.parent
                      , d = r.path.length - 1
                      , h = 0;
                    for (; d >= i; ) {
                        if (r.path[d] + h !== l.maxOffset)
                            return !1;
                        h = 1,
                        d--,
                        l = l.parent
                    }
                    return !0
                }(s, t + 1)
            }
            function Sp(s, e) {
                for (; e < s.length; ) {
                    if (s[e] !== 0)
                        return !1;
                    e++
                }
                return !0
            }
            ne.prototype.is = function(s) {
                return s === "position" || s === "model:position"
            }
            ;
            class J extends Bn {
                constructor(e, t) {
                    super(),
                    C(this, "start"),
                    C(this, "end"),
                    this.start = ne._createAt(e),
                    this.end = t ? ne._createAt(t) : ne._createAt(e),
                    this.start.stickiness = this.isCollapsed ? "toNone" : "toNext",
                    this.end.stickiness = this.isCollapsed ? "toNone" : "toPrevious"
                }
                *[Symbol.iterator]() {
                    yield*new Kr({
                        boundaries: this,
                        ignoreElementEnd: !0
                    })
                }
                get isCollapsed() {
                    return this.start.isEqual(this.end)
                }
                get isFlat() {
                    return ro(this.start.getParentPath(), this.end.getParentPath()) == "same"
                }
                get root() {
                    return this.start.root
                }
                containsPosition(e) {
                    return e.isAfter(this.start) && e.isBefore(this.end)
                }
                containsRange(e, t=!1) {
                    e.isCollapsed && (t = !1);
                    const r = this.containsPosition(e.start) || t && this.start.isEqual(e.start)
                      , i = this.containsPosition(e.end) || t && this.end.isEqual(e.end);
                    return r && i
                }
                containsItem(e) {
                    const t = ne._createBefore(e);
                    return this.containsPosition(t) || this.start.isEqual(t)
                }
                isEqual(e) {
                    return this.start.isEqual(e.start) && this.end.isEqual(e.end)
                }
                isIntersecting(e) {
                    return this.start.isBefore(e.end) && this.end.isAfter(e.start)
                }
                getDifference(e) {
                    const t = [];
                    return this.isIntersecting(e) ? (this.containsPosition(e.start) && t.push(new J(this.start,e.start)),
                    this.containsPosition(e.end) && t.push(new J(e.end,this.end))) : t.push(new J(this.start,this.end)),
                    t
                }
                getIntersection(e) {
                    if (this.isIntersecting(e)) {
                        let t = this.start
                          , r = this.end;
                        return this.containsPosition(e.start) && (t = e.start),
                        this.containsPosition(e.end) && (r = e.end),
                        new J(t,r)
                    }
                    return null
                }
                getJoined(e, t=!1) {
                    let r = this.isIntersecting(e);
                    if (r || (r = this.start.isBefore(e.start) ? t ? this.end.isTouching(e.start) : this.end.isEqual(e.start) : t ? e.end.isTouching(this.start) : e.end.isEqual(this.start)),
                    !r)
                        return null;
                    let i = this.start
                      , l = this.end;
                    return e.start.isBefore(i) && (i = e.start),
                    e.end.isAfter(l) && (l = e.end),
                    new J(i,l)
                }
                getMinimalFlatRanges() {
                    const e = []
                      , t = this.start.getCommonPath(this.end).length
                      , r = ne._createAt(this.start);
                    let i = r.parent;
                    for (; r.path.length > t + 1; ) {
                        const l = i.maxOffset - r.offset;
                        l !== 0 && e.push(new J(r,r.getShiftedBy(l))),
                        r.path = r.path.slice(0, -1),
                        r.offset++,
                        i = i.parent
                    }
                    for (; r.path.length <= this.end.path.length; ) {
                        const l = this.end.path[r.path.length - 1]
                          , d = l - r.offset;
                        d !== 0 && e.push(new J(r,r.getShiftedBy(d))),
                        r.offset = l,
                        r.path.push(0)
                    }
                    return e
                }
                getWalker(e={}) {
                    return e.boundaries = this,
                    new Kr(e)
                }
                *getItems(e={}) {
                    e.boundaries = this,
                    e.ignoreElementEnd = !0;
                    const t = new Kr(e);
                    for (const r of t)
                        yield r.item
                }
                *getPositions(e={}) {
                    e.boundaries = this;
                    const t = new Kr(e);
                    yield t.position;
                    for (const r of t)
                        yield r.nextPosition
                }
                getTransformedByOperation(e) {
                    switch (e.type) {
                    case "insert":
                        return this._getTransformedByInsertOperation(e);
                    case "move":
                    case "remove":
                    case "reinsert":
                        return this._getTransformedByMoveOperation(e);
                    case "split":
                        return [this._getTransformedBySplitOperation(e)];
                    case "merge":
                        return [this._getTransformedByMergeOperation(e)]
                    }
                    return [new J(this.start,this.end)]
                }
                getTransformedByOperations(e) {
                    const t = [new J(this.start,this.end)];
                    for (const r of e)
                        for (let i = 0; i < t.length; i++) {
                            const l = t[i].getTransformedByOperation(r);
                            t.splice(i, 1, ...l),
                            i += l.length - 1
                        }
                    for (let r = 0; r < t.length; r++) {
                        const i = t[r];
                        for (let l = r + 1; l < t.length; l++) {
                            const d = t[l];
                            (i.containsRange(d) || d.containsRange(i) || i.isEqual(d)) && t.splice(l, 1)
                        }
                    }
                    return t
                }
                getCommonAncestor() {
                    return this.start.getCommonAncestor(this.end)
                }
                getContainedElement() {
                    if (this.isCollapsed)
                        return null;
                    const e = this.start.nodeAfter
                      , t = this.end.nodeBefore;
                    return e && e.is("element") && e === t ? e : null
                }
                toJSON() {
                    return {
                        start: this.start.toJSON(),
                        end: this.end.toJSON()
                    }
                }
                clone() {
                    return new this.constructor(this.start,this.end)
                }
                _getTransformedByInsertOperation(e, t=!1) {
                    return this._getTransformedByInsertion(e.position, e.howMany, t)
                }
                _getTransformedByMoveOperation(e, t=!1) {
                    const r = e.sourcePosition
                      , i = e.howMany
                      , l = e.targetPosition;
                    return this._getTransformedByMove(r, l, i, t)
                }
                _getTransformedBySplitOperation(e) {
                    const t = this.start._getTransformedBySplitOperation(e);
                    let r = this.end._getTransformedBySplitOperation(e);
                    return this.end.isEqual(e.insertionPosition) && (r = this.end.getShiftedBy(1)),
                    t.root != r.root && (r = this.end.getShiftedBy(-1)),
                    new J(t,r)
                }
                _getTransformedByMergeOperation(e) {
                    if (this.start.isEqual(e.targetPosition) && this.end.isEqual(e.deletionPosition))
                        return new J(this.start);
                    let t = this.start._getTransformedByMergeOperation(e)
                      , r = this.end._getTransformedByMergeOperation(e);
                    return t.root != r.root && (r = this.end.getShiftedBy(-1)),
                    t.isAfter(r) ? (e.sourcePosition.isBefore(e.targetPosition) ? (t = ne._createAt(r),
                    t.offset = 0) : (e.deletionPosition.isEqual(t) || (r = e.deletionPosition),
                    t = e.targetPosition),
                    new J(t,r)) : new J(t,r)
                }
                _getTransformedByInsertion(e, t, r=!1) {
                    if (r && this.containsPosition(e))
                        return [new J(this.start,e), new J(e.getShiftedBy(t),this.end._getTransformedByInsertion(e, t))];
                    {
                        const i = new J(this.start,this.end);
                        return i.start = i.start._getTransformedByInsertion(e, t),
                        i.end = i.end._getTransformedByInsertion(e, t),
                        [i]
                    }
                }
                _getTransformedByMove(e, t, r, i=!1) {
                    if (this.isCollapsed) {
                        const v = this.start._getTransformedByMove(e, t, r);
                        return [new J(v)]
                    }
                    const l = J._createFromPositionAndShift(e, r)
                      , d = t._getTransformedByDeletion(e, r);
                    if (this.containsPosition(t) && !i && (l.containsPosition(this.start) || l.containsPosition(this.end))) {
                        const v = this.start._getTransformedByMove(e, t, r)
                          , x = this.end._getTransformedByMove(e, t, r);
                        return [new J(v,x)]
                    }
                    let h;
                    const m = this.getDifference(l);
                    let g = null;
                    const b = this.getIntersection(l);
                    if (m.length == 1 ? g = new J(m[0].start._getTransformedByDeletion(e, r),m[0].end._getTransformedByDeletion(e, r)) : m.length == 2 && (g = new J(this.start,this.end._getTransformedByDeletion(e, r))),
                    h = g ? g._getTransformedByInsertion(d, r, b !== null || i) : [],
                    b) {
                        const v = new J(b.start._getCombined(l.start, d),b.end._getCombined(l.start, d));
                        h.length == 2 ? h.splice(1, 0, v) : h.push(v)
                    }
                    return h
                }
                _getTransformedByDeletion(e, t) {
                    let r = this.start._getTransformedByDeletion(e, t)
                      , i = this.end._getTransformedByDeletion(e, t);
                    return r == null && i == null ? null : (r == null && (r = e),
                    i == null && (i = e),
                    new J(r,i))
                }
                static _createFromPositionAndShift(e, t) {
                    const r = e
                      , i = e.getShiftedBy(t);
                    return t > 0 ? new this(r,i) : new this(i,r)
                }
                static _createIn(e) {
                    return new this(ne._createAt(e, 0),ne._createAt(e, e.maxOffset))
                }
                static _createOn(e) {
                    return this._createFromPositionAndShift(ne._createBefore(e), e.offsetSize)
                }
                static _createFromRanges(e) {
                    if (e.length === 0)
                        throw new U("range-create-from-ranges-empty-array",null);
                    if (e.length == 1)
                        return e[0].clone();
                    const t = e[0];
                    e.sort( (l, d) => l.start.isAfter(d.start) ? 1 : -1);
                    const r = e.indexOf(t)
                      , i = new this(t.start,t.end);
                    if (r > 0)
                        for (let l = r - 1; e[l].end.isEqual(i.start); l++)
                            i.start = ne._createAt(e[l].start);
                    for (let l = r + 1; l < e.length && e[l].start.isEqual(i.end); l++)
                        i.end = ne._createAt(e[l].end);
                    return i
                }
                static fromJSON(e, t) {
                    return new this(ne.fromJSON(e.start, t),ne.fromJSON(e.end, t))
                }
            }
            J.prototype.is = function(s) {
                return s === "range" || s === "model:range"
            }
            ;
            class d_ extends Se() {
                constructor() {
                    super(),
                    C(this, "_modelToViewMapping", new WeakMap),
                    C(this, "_viewToModelMapping", new WeakMap),
                    C(this, "_viewToModelLengthCallbacks", new Map),
                    C(this, "_markerNameToElements", new Map),
                    C(this, "_elementToMarkerNames", new Map),
                    C(this, "_deferredBindingRemovals", new Map),
                    C(this, "_unboundMarkerNames", new Set),
                    this.on("modelToViewPosition", (e, t) => {
                        if (t.viewPosition)
                            return;
                        const r = this._modelToViewMapping.get(t.modelPosition.parent);
                        if (!r)
                            throw new U("mapping-model-position-view-parent-not-found",this,{
                                modelPosition: t.modelPosition
                            });
                        t.viewPosition = this.findPositionIn(r, t.modelPosition.offset)
                    }
                    , {
                        priority: "low"
                    }),
                    this.on("viewToModelPosition", (e, t) => {
                        if (t.modelPosition)
                            return;
                        const r = this.findMappedViewAncestor(t.viewPosition)
                          , i = this._viewToModelMapping.get(r)
                          , l = this._toModelOffset(t.viewPosition.parent, t.viewPosition.offset, r);
                        t.modelPosition = ne._createAt(i, l)
                    }
                    , {
                        priority: "low"
                    })
                }
                bindElements(e, t) {
                    this._modelToViewMapping.set(e, t),
                    this._viewToModelMapping.set(t, e)
                }
                unbindViewElement(e, t={}) {
                    const r = this.toModelElement(e);
                    if (this._elementToMarkerNames.has(e))
                        for (const i of this._elementToMarkerNames.get(e))
                            this._unboundMarkerNames.add(i);
                    t.defer ? this._deferredBindingRemovals.set(e, e.root) : (this._viewToModelMapping.delete(e),
                    this._modelToViewMapping.get(r) == e && this._modelToViewMapping.delete(r))
                }
                unbindModelElement(e) {
                    const t = this.toViewElement(e);
                    this._modelToViewMapping.delete(e),
                    this._viewToModelMapping.get(t) == e && this._viewToModelMapping.delete(t)
                }
                bindElementToMarker(e, t) {
                    const r = this._markerNameToElements.get(t) || new Set;
                    r.add(e);
                    const i = this._elementToMarkerNames.get(e) || new Set;
                    i.add(t),
                    this._markerNameToElements.set(t, r),
                    this._elementToMarkerNames.set(e, i)
                }
                unbindElementFromMarkerName(e, t) {
                    const r = this._markerNameToElements.get(t);
                    r && (r.delete(e),
                    r.size == 0 && this._markerNameToElements.delete(t));
                    const i = this._elementToMarkerNames.get(e);
                    i && (i.delete(t),
                    i.size == 0 && this._elementToMarkerNames.delete(e))
                }
                flushUnboundMarkerNames() {
                    const e = Array.from(this._unboundMarkerNames);
                    return this._unboundMarkerNames.clear(),
                    e
                }
                flushDeferredBindings() {
                    for (const [e,t] of this._deferredBindingRemovals)
                        e.root == t && this.unbindViewElement(e);
                    this._deferredBindingRemovals = new Map
                }
                clearBindings() {
                    this._modelToViewMapping = new WeakMap,
                    this._viewToModelMapping = new WeakMap,
                    this._markerNameToElements = new Map,
                    this._elementToMarkerNames = new Map,
                    this._unboundMarkerNames = new Set,
                    this._deferredBindingRemovals = new Map
                }
                toModelElement(e) {
                    return this._viewToModelMapping.get(e)
                }
                toViewElement(e) {
                    return this._modelToViewMapping.get(e)
                }
                toModelRange(e) {
                    return new J(this.toModelPosition(e.start),this.toModelPosition(e.end))
                }
                toViewRange(e) {
                    return new fe(this.toViewPosition(e.start),this.toViewPosition(e.end))
                }
                toModelPosition(e) {
                    const t = {
                        viewPosition: e,
                        mapper: this
                    };
                    return this.fire("viewToModelPosition", t),
                    t.modelPosition
                }
                toViewPosition(e, t={}) {
                    const r = {
                        modelPosition: e,
                        mapper: this,
                        isPhantom: t.isPhantom
                    };
                    return this.fire("modelToViewPosition", r),
                    r.viewPosition
                }
                markerNameToElements(e) {
                    const t = this._markerNameToElements.get(e);
                    if (!t)
                        return null;
                    const r = new Set;
                    for (const i of t)
                        if (i.is("attributeElement"))
                            for (const l of i.getElementsWithSameId())
                                r.add(l);
                        else
                            r.add(i);
                    return r
                }
                registerViewToModelLength(e, t) {
                    this._viewToModelLengthCallbacks.set(e, t)
                }
                findMappedViewAncestor(e) {
                    let t = e.parent;
                    for (; !this._viewToModelMapping.has(t); )
                        t = t.parent;
                    return t
                }
                _toModelOffset(e, t, r) {
                    if (r != e)
                        return this._toModelOffset(e.parent, e.index, r) + this._toModelOffset(e, t, e);
                    if (e.is("$text"))
                        return t;
                    let i = 0;
                    for (let l = 0; l < t; l++)
                        i += this.getModelLength(e.getChild(l));
                    return i
                }
                getModelLength(e) {
                    if (this._viewToModelLengthCallbacks.get(e.name))
                        return this._viewToModelLengthCallbacks.get(e.name)(e);
                    if (this._viewToModelMapping.has(e))
                        return 1;
                    if (e.is("$text"))
                        return e.data.length;
                    if (e.is("uiElement"))
                        return 0;
                    {
                        let t = 0;
                        for (const r of e.getChildren())
                            t += this.getModelLength(r);
                        return t
                    }
                }
                findPositionIn(e, t) {
                    let r, i = 0, l = 0, d = 0;
                    if (e.is("$text"))
                        return new ae(e,t);
                    for (; l < t; )
                        r = e.getChild(d),
                        i = this.getModelLength(r),
                        l += i,
                        d++;
                    return l == t ? this._moveViewPositionToTextNode(new ae(e,d)) : this.findPositionIn(r, t - (l - i))
                }
                _moveViewPositionToTextNode(e) {
                    const t = e.nodeBefore
                      , r = e.nodeAfter;
                    return t instanceof We ? new ae(t,t.data.length) : r instanceof We ? new ae(r,0) : e
                }
            }
            class JP {
                constructor() {
                    C(this, "_consumable", new Map),
                    C(this, "_textProxyRegistry", new Map)
                }
                add(e, t) {
                    t = $d(t),
                    e instanceof fr && (e = this._getSymbolForTextProxy(e)),
                    this._consumable.has(e) || this._consumable.set(e, new Map),
                    this._consumable.get(e).set(t, !0)
                }
                consume(e, t) {
                    return t = $d(t),
                    e instanceof fr && (e = this._getSymbolForTextProxy(e)),
                    !!this.test(e, t) && (this._consumable.get(e).set(t, !1),
                    !0)
                }
                test(e, t) {
                    t = $d(t),
                    e instanceof fr && (e = this._getSymbolForTextProxy(e));
                    const r = this._consumable.get(e);
                    if (r === void 0)
                        return null;
                    const i = r.get(t);
                    return i === void 0 ? null : i
                }
                revert(e, t) {
                    t = $d(t),
                    e instanceof fr && (e = this._getSymbolForTextProxy(e));
                    const r = this.test(e, t);
                    return r === !1 ? (this._consumable.get(e).set(t, !0),
                    !0) : r !== !0 && null
                }
                verifyAllConsumed(e) {
                    const t = [];
                    for (const [r,i] of this._consumable)
                        for (const [l,d] of i) {
                            const h = l.split(":")[0];
                            d && e == h && t.push({
                                event: l,
                                item: r.name || r.description
                            })
                        }
                    if (t.length)
                        throw new U("conversion-model-consumable-not-consumed",null,{
                            items: t
                        })
                }
                _getSymbolForTextProxy(e) {
                    let t = null;
                    const r = this._textProxyRegistry.get(e.startOffset);
                    if (r) {
                        const i = r.get(e.endOffset);
                        i && (t = i.get(e.parent))
                    }
                    return t || (t = this._addSymbolForTextProxy(e)),
                    t
                }
                _addSymbolForTextProxy(e) {
                    const t = e.startOffset
                      , r = e.endOffset
                      , i = e.parent
                      , l = Symbol("$textProxy:" + e.data);
                    let d, h;
                    return d = this._textProxyRegistry.get(t),
                    d || (d = new Map,
                    this._textProxyRegistry.set(t, d)),
                    h = d.get(r),
                    h || (h = new Map,
                    d.set(r, h)),
                    h.set(i, l),
                    l
                }
            }
            function $d(s) {
                const e = s.split(":");
                return e[0] == "insert" ? e[0] : e[0] == "addMarker" || e[0] == "removeMarker" ? s : e.length > 1 ? e[0] + ":" + e[1] : e[0]
            }
            class u_ extends Se() {
                constructor(e) {
                    super(),
                    C(this, "_conversionApi"),
                    C(this, "_firedEventsMap"),
                    this._conversionApi = {
                        dispatcher: this,
                        ...e
                    },
                    this._firedEventsMap = new WeakMap
                }
                convertChanges(e, t, r) {
                    const i = this._createConversionApi(r, e.getRefreshedItems());
                    for (const d of e.getMarkersToRemove())
                        this._convertMarkerRemove(d.name, d.range, i);
                    const l = this._reduceChanges(e.getChanges());
                    for (const d of l)
                        d.type === "insert" ? this._convertInsert(J._createFromPositionAndShift(d.position, d.length), i) : d.type === "reinsert" ? this._convertReinsert(J._createFromPositionAndShift(d.position, d.length), i) : d.type === "remove" ? this._convertRemove(d.position, d.length, d.name, i) : this._convertAttribute(d.range, d.attributeKey, d.attributeOldValue, d.attributeNewValue, i);
                    i.mapper.flushDeferredBindings();
                    for (const d of i.mapper.flushUnboundMarkerNames()) {
                        const h = t.get(d).getRange();
                        this._convertMarkerRemove(d, h, i),
                        this._convertMarkerAdd(d, h, i)
                    }
                    for (const d of e.getMarkersToAdd())
                        this._convertMarkerAdd(d.name, d.range, i);
                    i.consumable.verifyAllConsumed("insert")
                }
                convert(e, t, r, i={}) {
                    const l = this._createConversionApi(r, void 0, i);
                    this._convertInsert(e, l);
                    for (const [d,h] of t)
                        this._convertMarkerAdd(d, h, l);
                    l.consumable.verifyAllConsumed("insert")
                }
                convertSelection(e, t, r) {
                    const i = this._createConversionApi(r);
                    this.fire("cleanSelection", {
                        selection: e
                    }, i);
                    const l = e.getFirstPosition().root;
                    if (!i.mapper.toViewElement(l))
                        return;
                    const d = Array.from(t.getMarkersAtPosition(e.getFirstPosition()));
                    if (this._addConsumablesForSelection(i.consumable, e, d),
                    this.fire("selection", {
                        selection: e
                    }, i),
                    e.isCollapsed) {
                        for (const h of d)
                            if (i.consumable.test(e, "addMarker:" + h.name)) {
                                const m = h.getRange();
                                if (!XP(e.getFirstPosition(), h, i.mapper))
                                    continue;
                                const g = {
                                    item: e,
                                    markerName: h.name,
                                    markerRange: m
                                };
                                this.fire(`addMarker:${h.name}`, g, i)
                            }
                        for (const h of e.getAttributeKeys())
                            if (i.consumable.test(e, "attribute:" + h)) {
                                const m = {
                                    item: e,
                                    range: e.getFirstRange(),
                                    attributeKey: h,
                                    attributeOldValue: null,
                                    attributeNewValue: e.getAttribute(h)
                                };
                                this.fire(`attribute:${h}:$text`, m, i)
                            }
                    }
                }
                _convertInsert(e, t, r={}) {
                    r.doNotAddConsumables || this._addConsumablesForInsert(t.consumable, e);
                    for (const i of Array.from(e.getWalker({
                        shallow: !0
                    })).map(h_))
                        this._testAndFire("insert", i, t)
                }
                _convertRemove(e, t, r, i) {
                    this.fire(`remove:${r}`, {
                        position: e,
                        length: t
                    }, i)
                }
                _convertAttribute(e, t, r, i, l) {
                    this._addConsumablesForRange(l.consumable, e, `attribute:${t}`);
                    for (const d of e) {
                        const h = {
                            item: d.item,
                            range: J._createFromPositionAndShift(d.previousPosition, d.length),
                            attributeKey: t,
                            attributeOldValue: r,
                            attributeNewValue: i
                        };
                        this._testAndFire(`attribute:${t}`, h, l)
                    }
                }
                _convertReinsert(e, t) {
                    const r = Array.from(e.getWalker({
                        shallow: !0
                    }));
                    this._addConsumablesForInsert(t.consumable, r);
                    for (const i of r.map(h_))
                        this._testAndFire("insert", {
                            ...i,
                            reconversion: !0
                        }, t)
                }
                _convertMarkerAdd(e, t, r) {
                    if (t.root.rootName == "$graveyard")
                        return;
                    const i = `addMarker:${e}`;
                    if (r.consumable.add(t, i),
                    this.fire(i, {
                        markerName: e,
                        markerRange: t
                    }, r),
                    r.consumable.consume(t, i)) {
                        this._addConsumablesForRange(r.consumable, t, i);
                        for (const l of t.getItems()) {
                            if (!r.consumable.test(l, i))
                                continue;
                            const d = {
                                item: l,
                                range: J._createOn(l),
                                markerName: e,
                                markerRange: t
                            };
                            this.fire(i, d, r)
                        }
                    }
                }
                _convertMarkerRemove(e, t, r) {
                    t.root.rootName != "$graveyard" && this.fire(`removeMarker:${e}`, {
                        markerName: e,
                        markerRange: t
                    }, r)
                }
                _reduceChanges(e) {
                    const t = {
                        changes: e
                    };
                    return this.fire("reduceChanges", t),
                    t.changes
                }
                _addConsumablesForInsert(e, t) {
                    for (const r of t) {
                        const i = r.item;
                        if (e.test(i, "insert") === null) {
                            e.add(i, "insert");
                            for (const l of i.getAttributeKeys())
                                e.add(i, "attribute:" + l)
                        }
                    }
                    return e
                }
                _addConsumablesForRange(e, t, r) {
                    for (const i of t.getItems())
                        e.add(i, r);
                    return e
                }
                _addConsumablesForSelection(e, t, r) {
                    e.add(t, "selection");
                    for (const i of r)
                        e.add(t, "addMarker:" + i.name);
                    for (const i of t.getAttributeKeys())
                        e.add(t, "attribute:" + i);
                    return e
                }
                _testAndFire(e, t, r) {
                    const i = function(m, g) {
                        const b = g.item.is("element") ? g.item.name : "$text";
                        return `${m}:${b}`
                    }(e, t)
                      , l = t.item.is("$textProxy") ? r.consumable._getSymbolForTextProxy(t.item) : t.item
                      , d = this._firedEventsMap.get(r)
                      , h = d.get(l);
                    if (h) {
                        if (h.has(i))
                            return;
                        h.add(i)
                    } else
                        d.set(l, new Set([i]));
                    this.fire(i, t, r)
                }
                _testAndFireAddAttributes(e, t) {
                    const r = {
                        item: e,
                        range: J._createOn(e)
                    };
                    for (const i of r.item.getAttributeKeys())
                        r.attributeKey = i,
                        r.attributeOldValue = null,
                        r.attributeNewValue = r.item.getAttribute(i),
                        this._testAndFire(`attribute:${i}`, r, t)
                }
                _createConversionApi(e, t=new Set, r={}) {
                    const i = {
                        ...this._conversionApi,
                        consumable: new JP,
                        writer: e,
                        options: r,
                        convertItem: l => this._convertInsert(J._createOn(l), i),
                        convertChildren: l => this._convertInsert(J._createIn(l), i, {
                            doNotAddConsumables: !0
                        }),
                        convertAttributes: l => this._testAndFireAddAttributes(l, i),
                        canReuseView: l => !t.has(i.mapper.toModelElement(l))
                    };
                    return this._firedEventsMap.set(i, new Map),
                    i
                }
            }
            function XP(s, e, t) {
                const r = e.getRange()
                  , i = Array.from(s.getAncestors());
                return i.shift(),
                i.reverse(),
                !i.some(l => {
                    if (r.containsItem(l))
                        return !!t.toViewElement(l).getCustomProperty("addHighlight")
                }
                )
            }
            function h_(s) {
                return {
                    item: s.item,
                    range: J._createFromPositionAndShift(s.previousPosition, s.length)
                }
            }
            class To extends Se(Bn) {
                constructor(...e) {
                    super(),
                    C(this, "_lastRangeBackward", !1),
                    C(this, "_attrs", new Map),
                    C(this, "_ranges", []),
                    e.length && this.setTo(...e)
                }
                get anchor() {
                    if (this._ranges.length > 0) {
                        const e = this._ranges[this._ranges.length - 1];
                        return this._lastRangeBackward ? e.end : e.start
                    }
                    return null
                }
                get focus() {
                    if (this._ranges.length > 0) {
                        const e = this._ranges[this._ranges.length - 1];
                        return this._lastRangeBackward ? e.start : e.end
                    }
                    return null
                }
                get isCollapsed() {
                    return this._ranges.length === 1 && this._ranges[0].isCollapsed
                }
                get rangeCount() {
                    return this._ranges.length
                }
                get isBackward() {
                    return !this.isCollapsed && this._lastRangeBackward
                }
                isEqual(e) {
                    if (this.rangeCount != e.rangeCount)
                        return !1;
                    if (this.rangeCount === 0)
                        return !0;
                    if (!this.anchor.isEqual(e.anchor) || !this.focus.isEqual(e.focus))
                        return !1;
                    for (const t of this._ranges) {
                        let r = !1;
                        for (const i of e._ranges)
                            if (t.isEqual(i)) {
                                r = !0;
                                break
                            }
                        if (!r)
                            return !1
                    }
                    return !0
                }
                *getRanges() {
                    for (const e of this._ranges)
                        yield new J(e.start,e.end)
                }
                getFirstRange() {
                    let e = null;
                    for (const t of this._ranges)
                        e && !t.start.isBefore(e.start) || (e = t);
                    return e ? new J(e.start,e.end) : null
                }
                getLastRange() {
                    let e = null;
                    for (const t of this._ranges)
                        e && !t.end.isAfter(e.end) || (e = t);
                    return e ? new J(e.start,e.end) : null
                }
                getFirstPosition() {
                    const e = this.getFirstRange();
                    return e ? e.start.clone() : null
                }
                getLastPosition() {
                    const e = this.getLastRange();
                    return e ? e.end.clone() : null
                }
                setTo(...e) {
                    let[t,r,i] = e;
                    if (typeof r == "object" && (i = r,
                    r = void 0),
                    t === null)
                        this._setRanges([]);
                    else if (t instanceof To)
                        this._setRanges(t.getRanges(), t.isBackward);
                    else if (t && typeof t.getRanges == "function")
                        this._setRanges(t.getRanges(), t.isBackward);
                    else if (t instanceof J)
                        this._setRanges([t], !!i && !!i.backward);
                    else if (t instanceof ne)
                        this._setRanges([new J(t)]);
                    else if (t instanceof Ii) {
                        const l = !!i && !!i.backward;
                        let d;
                        if (r == "in")
                            d = J._createIn(t);
                        else if (r == "on")
                            d = J._createOn(t);
                        else {
                            if (r === void 0)
                                throw new U("model-selection-setto-required-second-parameter",[this, t]);
                            d = new J(ne._createAt(t, r))
                        }
                        this._setRanges([d], l)
                    } else {
                        if (!yo(t))
                            throw new U("model-selection-setto-not-selectable",[this, t]);
                        this._setRanges(t, i && !!i.backward)
                    }
                }
                _setRanges(e, t=!1) {
                    const r = Array.from(e)
                      , i = r.some(l => {
                        if (!(l instanceof J))
                            throw new U("model-selection-set-ranges-not-range",[this, e]);
                        return this._ranges.every(d => !d.isEqual(l))
                    }
                    );
                    (r.length !== this._ranges.length || i) && (this._replaceAllRanges(r),
                    this._lastRangeBackward = !!t,
                    this.fire("change:range", {
                        directChange: !0
                    }))
                }
                setFocus(e, t) {
                    if (this.anchor === null)
                        throw new U("model-selection-setfocus-no-ranges",[this, e]);
                    const r = ne._createAt(e, t);
                    if (r.compareWith(this.focus) == "same")
                        return;
                    const i = this.anchor;
                    this._ranges.length && this._popRange(),
                    r.compareWith(i) == "before" ? (this._pushRange(new J(r,i)),
                    this._lastRangeBackward = !0) : (this._pushRange(new J(i,r)),
                    this._lastRangeBackward = !1),
                    this.fire("change:range", {
                        directChange: !0
                    })
                }
                getAttribute(e) {
                    return this._attrs.get(e)
                }
                getAttributes() {
                    return this._attrs.entries()
                }
                getAttributeKeys() {
                    return this._attrs.keys()
                }
                hasAttribute(e) {
                    return this._attrs.has(e)
                }
                removeAttribute(e) {
                    this.hasAttribute(e) && (this._attrs.delete(e),
                    this.fire("change:attribute", {
                        attributeKeys: [e],
                        directChange: !0
                    }))
                }
                setAttribute(e, t) {
                    this.getAttribute(e) !== t && (this._attrs.set(e, t),
                    this.fire("change:attribute", {
                        attributeKeys: [e],
                        directChange: !0
                    }))
                }
                getSelectedElement() {
                    return this.rangeCount !== 1 ? null : this.getFirstRange().getContainedElement()
                }
                *getSelectedBlocks() {
                    const e = new WeakSet;
                    for (const t of this.getRanges()) {
                        const r = p_(t.start, e);
                        t3(r, t) && (yield r);
                        for (const l of t.getWalker()) {
                            const d = l.item;
                            l.type == "elementEnd" && e3(d, e, t) && (yield d)
                        }
                        const i = p_(t.end, e);
                        o3(i, t) && (yield i)
                    }
                }
                containsEntireContent(e=this.anchor.root) {
                    const t = ne._createAt(e, 0)
                      , r = ne._createAt(e, "end");
                    return t.isTouching(this.getFirstPosition()) && r.isTouching(this.getLastPosition())
                }
                _pushRange(e) {
                    this._checkRange(e),
                    this._ranges.push(new J(e.start,e.end))
                }
                _checkRange(e) {
                    for (let t = 0; t < this._ranges.length; t++)
                        if (e.isIntersecting(this._ranges[t]))
                            throw new U("model-selection-range-intersects",[this, e],{
                                addedRange: e,
                                intersectingRange: this._ranges[t]
                            })
                }
                _replaceAllRanges(e) {
                    this._removeAllRanges();
                    for (const t of e)
                        this._pushRange(t)
                }
                _removeAllRanges() {
                    for (; this._ranges.length > 0; )
                        this._popRange()
                }
                _popRange() {
                    this._ranges.pop()
                }
            }
            function m_(s, e) {
                return !e.has(s) && (e.add(s),
                s.root.document.model.schema.isBlock(s) && !!s.parent)
            }
            function e3(s, e, t) {
                return m_(s, e) && Dp(s, t)
            }
            function p_(s, e) {
                const t = s.parent.root.document.model.schema
                  , r = s.parent.getAncestors({
                    parentFirst: !0,
                    includeSelf: !0
                });
                let i = !1;
                const l = r.find(d => !i && (i = t.isLimit(d),
                !i && m_(d, e)));
                return r.forEach(d => e.add(d)),
                l
            }
            function Dp(s, e) {
                const t = function(r) {
                    const i = r.root.document.model.schema;
                    let l = r.parent;
                    for (; l; ) {
                        if (i.isBlock(l))
                            return l;
                        l = l.parent
                    }
                }(s);
                return t ? !e.containsRange(J._createOn(t), !0) : !0
            }
            function t3(s, e) {
                return !!s && (!(!e.isCollapsed && !s.isEmpty) || !e.start.isTouching(ne._createAt(s, s.maxOffset)) && Dp(s, e))
            }
            function o3(s, e) {
                return !!s && (!(!e.isCollapsed && !s.isEmpty) || !e.end.isTouching(ne._createAt(s, 0)) && Dp(s, e))
            }
            To.prototype.is = function(s) {
                return s === "selection" || s === "model:selection"
            }
            ;
            class Io extends Se(J) {
                constructor(e, t) {
                    super(e, t),
                    r3.call(this)
                }
                detach() {
                    this.stopListening()
                }
                toRange() {
                    return new J(this.start,this.end)
                }
                static fromRange(e) {
                    return new Io(e.start,e.end)
                }
            }
            function r3() {
                this.listenTo(this.root.document.model, "applyOperation", (s, e) => {
                    const t = e[0];
                    t.isDocumentOperation && n3.call(this, t)
                }
                , {
                    priority: "low"
                })
            }
            function n3(s) {
                const e = this.getTransformedByOperation(s)
                  , t = J._createFromRanges(e)
                  , r = !t.isEqual(this)
                  , i = function(d, h) {
                    switch (h.type) {
                    case "insert":
                        return d.containsPosition(h.position);
                    case "move":
                    case "remove":
                    case "reinsert":
                    case "merge":
                        return d.containsPosition(h.sourcePosition) || d.start.isEqual(h.sourcePosition) || d.containsPosition(h.targetPosition);
                    case "split":
                        return d.containsPosition(h.splitPosition) || d.containsPosition(h.insertionPosition)
                    }
                    return !1
                }(this, s);
                let l = null;
                if (r) {
                    t.root.rootName == "$graveyard" && (l = s.type == "remove" ? s.sourcePosition : s.deletionPosition);
                    const d = this.toRange();
                    this.start = t.start,
                    this.end = t.end,
                    this.fire("change:range", d, {
                        deletionPosition: l
                    })
                } else
                    i && this.fire("change:content", this.toRange(), {
                        deletionPosition: l
                    })
            }
            Io.prototype.is = function(s) {
                return s === "liveRange" || s === "model:liveRange" || s == "range" || s === "model:range"
            }
            ;
            const qd = "selection:";
            class kr extends Se(Bn) {
                constructor(e) {
                    super(),
                    C(this, "_selection"),
                    this._selection = new i3(e),
                    this._selection.delegate("change:range").to(this),
                    this._selection.delegate("change:attribute").to(this),
                    this._selection.delegate("change:marker").to(this)
                }
                get isCollapsed() {
                    return this._selection.isCollapsed
                }
                get anchor() {
                    return this._selection.anchor
                }
                get focus() {
                    return this._selection.focus
                }
                get rangeCount() {
                    return this._selection.rangeCount
                }
                get hasOwnRange() {
                    return this._selection.hasOwnRange
                }
                get isBackward() {
                    return this._selection.isBackward
                }
                get isGravityOverridden() {
                    return this._selection.isGravityOverridden
                }
                get markers() {
                    return this._selection.markers
                }
                get _ranges() {
                    return this._selection._ranges
                }
                getRanges() {
                    return this._selection.getRanges()
                }
                getFirstPosition() {
                    return this._selection.getFirstPosition()
                }
                getLastPosition() {
                    return this._selection.getLastPosition()
                }
                getFirstRange() {
                    return this._selection.getFirstRange()
                }
                getLastRange() {
                    return this._selection.getLastRange()
                }
                getSelectedBlocks() {
                    return this._selection.getSelectedBlocks()
                }
                getSelectedElement() {
                    return this._selection.getSelectedElement()
                }
                containsEntireContent(e) {
                    return this._selection.containsEntireContent(e)
                }
                destroy() {
                    this._selection.destroy()
                }
                getAttributeKeys() {
                    return this._selection.getAttributeKeys()
                }
                getAttributes() {
                    return this._selection.getAttributes()
                }
                getAttribute(e) {
                    return this._selection.getAttribute(e)
                }
                hasAttribute(e) {
                    return this._selection.hasAttribute(e)
                }
                refresh() {
                    this._selection.updateMarkers(),
                    this._selection._updateAttributes(!1)
                }
                observeMarkers(e) {
                    this._selection.observeMarkers(e)
                }
                _setFocus(e, t) {
                    this._selection.setFocus(e, t)
                }
                _setTo(...e) {
                    this._selection.setTo(...e)
                }
                _setAttribute(e, t) {
                    this._selection.setAttribute(e, t)
                }
                _removeAttribute(e) {
                    this._selection.removeAttribute(e)
                }
                _getStoredAttributes() {
                    return this._selection.getStoredAttributes()
                }
                _overrideGravity() {
                    return this._selection.overrideGravity()
                }
                _restoreGravity(e) {
                    this._selection.restoreGravity(e)
                }
                static _getStoreAttributeKey(e) {
                    return qd + e
                }
                static _isStoreAttributeKey(e) {
                    return e.startsWith(qd)
                }
            }
            kr.prototype.is = function(s) {
                return s === "selection" || s == "model:selection" || s == "documentSelection" || s == "model:documentSelection"
            }
            ;
            class i3 extends To {
                constructor(e) {
                    super(),
                    C(this, "markers", new dr({
                        idProperty: "name"
                    })),
                    C(this, "_model"),
                    C(this, "_document"),
                    C(this, "_attributePriority", new Map),
                    C(this, "_selectionRestorePosition", null),
                    C(this, "_hasChangedRange", !1),
                    C(this, "_overriddenGravityRegister", new Set),
                    C(this, "_observedMarkers", new Set),
                    this._model = e.model,
                    this._document = e,
                    this.listenTo(this._model, "applyOperation", (t, r) => {
                        const i = r[0];
                        i.isDocumentOperation && i.type != "marker" && i.type != "rename" && i.type != "noop" && (this._ranges.length == 0 && this._selectionRestorePosition && this._fixGraveyardSelection(this._selectionRestorePosition),
                        this._selectionRestorePosition = null,
                        this._hasChangedRange && (this._hasChangedRange = !1,
                        this.fire("change:range", {
                            directChange: !1
                        })))
                    }
                    , {
                        priority: "lowest"
                    }),
                    this.on("change:range", () => {
                        this._validateSelectionRanges(this.getRanges())
                    }
                    ),
                    this.listenTo(this._model.markers, "update", (t, r, i, l) => {
                        this._updateMarker(r, l)
                    }
                    ),
                    this.listenTo(this._document, "change", (t, r) => {
                        (function(i, l) {
                            const d = i.document.differ;
                            for (const h of d.getChanges()) {
                                if (h.type != "insert")
                                    continue;
                                const m = h.position.parent;
                                h.length === m.maxOffset && i.enqueueChange(l, g => {
                                    const b = Array.from(m.getAttributeKeys()).filter(v => v.startsWith(qd));
                                    for (const v of b)
                                        g.removeAttribute(v, m)
                                }
                                )
                            }
                        }
                        )(this._model, r)
                    }
                    )
                }
                get isCollapsed() {
                    return this._ranges.length === 0 ? this._document._getDefaultRange().isCollapsed : super.isCollapsed
                }
                get anchor() {
                    return super.anchor || this._document._getDefaultRange().start
                }
                get focus() {
                    return super.focus || this._document._getDefaultRange().end
                }
                get rangeCount() {
                    return this._ranges.length ? this._ranges.length : 1
                }
                get hasOwnRange() {
                    return this._ranges.length > 0
                }
                get isGravityOverridden() {
                    return !!this._overriddenGravityRegister.size
                }
                destroy() {
                    for (let e = 0; e < this._ranges.length; e++)
                        this._ranges[e].detach();
                    this.stopListening()
                }
                *getRanges() {
                    this._ranges.length ? yield*super.getRanges() : yield this._document._getDefaultRange()
                }
                getFirstRange() {
                    return super.getFirstRange() || this._document._getDefaultRange()
                }
                getLastRange() {
                    return super.getLastRange() || this._document._getDefaultRange()
                }
                setTo(...e) {
                    super.setTo(...e),
                    this._updateAttributes(!0),
                    this.updateMarkers()
                }
                setFocus(e, t) {
                    super.setFocus(e, t),
                    this._updateAttributes(!0),
                    this.updateMarkers()
                }
                setAttribute(e, t) {
                    if (this._setAttribute(e, t)) {
                        const r = [e];
                        this.fire("change:attribute", {
                            attributeKeys: r,
                            directChange: !0
                        })
                    }
                }
                removeAttribute(e) {
                    if (this._removeAttribute(e)) {
                        const t = [e];
                        this.fire("change:attribute", {
                            attributeKeys: t,
                            directChange: !0
                        })
                    }
                }
                overrideGravity() {
                    const e = H();
                    return this._overriddenGravityRegister.add(e),
                    this._overriddenGravityRegister.size === 1 && this._updateAttributes(!0),
                    e
                }
                restoreGravity(e) {
                    if (!this._overriddenGravityRegister.has(e))
                        throw new U("document-selection-gravity-wrong-restore",this,{
                            uid: e
                        });
                    this._overriddenGravityRegister.delete(e),
                    this.isGravityOverridden || this._updateAttributes(!0)
                }
                observeMarkers(e) {
                    this._observedMarkers.add(e),
                    this.updateMarkers()
                }
                _replaceAllRanges(e) {
                    this._validateSelectionRanges(e),
                    super._replaceAllRanges(e)
                }
                _popRange() {
                    this._ranges.pop().detach()
                }
                _pushRange(e) {
                    const t = this._prepareRange(e);
                    t && this._ranges.push(t)
                }
                _validateSelectionRanges(e) {
                    for (const t of e)
                        if (!this._document._validateSelectionRange(t))
                            throw new U("document-selection-wrong-position",this,{
                                range: t
                            })
                }
                _prepareRange(e) {
                    if (this._checkRange(e),
                    e.root == this._document.graveyard)
                        return;
                    const t = Io.fromRange(e);
                    return t.on("change:range", (r, i, l) => {
                        if (this._hasChangedRange = !0,
                        t.root == this._document.graveyard) {
                            this._selectionRestorePosition = l.deletionPosition;
                            const d = this._ranges.indexOf(t);
                            this._ranges.splice(d, 1),
                            t.detach()
                        }
                    }
                    ),
                    t
                }
                updateMarkers() {
                    if (!this._observedMarkers.size)
                        return;
                    const e = [];
                    let t = !1;
                    for (const i of this._model.markers) {
                        const l = i.name.split(":", 1)[0];
                        if (!this._observedMarkers.has(l))
                            continue;
                        const d = i.getRange();
                        for (const h of this.getRanges())
                            d.containsRange(h, !h.isCollapsed) && e.push(i)
                    }
                    const r = Array.from(this.markers);
                    for (const i of e)
                        this.markers.has(i) || (this.markers.add(i),
                        t = !0);
                    for (const i of Array.from(this.markers))
                        e.includes(i) || (this.markers.remove(i),
                        t = !0);
                    t && this.fire("change:marker", {
                        oldMarkers: r,
                        directChange: !1
                    })
                }
                _updateMarker(e, t) {
                    const r = e.name.split(":", 1)[0];
                    if (!this._observedMarkers.has(r))
                        return;
                    let i = !1;
                    const l = Array.from(this.markers)
                      , d = this.markers.has(e);
                    if (t) {
                        let h = !1;
                        for (const m of this.getRanges())
                            if (t.containsRange(m, !m.isCollapsed)) {
                                h = !0;
                                break
                            }
                        h && !d ? (this.markers.add(e),
                        i = !0) : !h && d && (this.markers.remove(e),
                        i = !0)
                    } else
                        d && (this.markers.remove(e),
                        i = !0);
                    i && this.fire("change:marker", {
                        oldMarkers: l,
                        directChange: !1
                    })
                }
                _updateAttributes(e) {
                    const t = Ir(this._getSurroundingAttributes())
                      , r = Ir(this.getAttributes());
                    if (e)
                        this._attributePriority = new Map,
                        this._attrs = new Map;
                    else
                        for (const [l,d] of this._attributePriority)
                            d == "low" && (this._attrs.delete(l),
                            this._attributePriority.delete(l));
                    this._setAttributesTo(t);
                    const i = [];
                    for (const [l,d] of this.getAttributes())
                        r.has(l) && r.get(l) === d || i.push(l);
                    for (const [l] of r)
                        this.hasAttribute(l) || i.push(l);
                    i.length > 0 && this.fire("change:attribute", {
                        attributeKeys: i,
                        directChange: !1
                    })
                }
                _setAttribute(e, t, r=!0) {
                    const i = r ? "normal" : "low";
                    return i == "low" && this._attributePriority.get(e) == "normal" ? !1 : super.getAttribute(e) !== t && (this._attrs.set(e, t),
                    this._attributePriority.set(e, i),
                    !0)
                }
                _removeAttribute(e, t=!0) {
                    const r = t ? "normal" : "low";
                    return (r != "low" || this._attributePriority.get(e) != "normal") && (this._attributePriority.set(e, r),
                    !!super.hasAttribute(e) && (this._attrs.delete(e),
                    !0))
                }
                _setAttributesTo(e) {
                    const t = new Set;
                    for (const [r,i] of this.getAttributes())
                        e.get(r) !== i && this._removeAttribute(r, !1);
                    for (const [r,i] of e)
                        this._setAttribute(r, i, !1) && t.add(r);
                    return t
                }
                *getStoredAttributes() {
                    const e = this.getFirstPosition().parent;
                    if (this.isCollapsed && e.isEmpty)
                        for (const t of e.getAttributeKeys())
                            t.startsWith(qd) && (yield[t.substr(10), e.getAttribute(t)])
                }
                _getSurroundingAttributes() {
                    const e = this.getFirstPosition()
                      , t = this._model.schema;
                    if (e.root.rootName == "$graveyard")
                        return null;
                    let r = null;
                    if (this.isCollapsed) {
                        const i = e.textNode ? e.textNode : e.nodeBefore
                          , l = e.textNode ? e.textNode : e.nodeAfter;
                        if (this.isGravityOverridden || (r = Al(i, t)),
                        r || (r = Al(l, t)),
                        !this.isGravityOverridden && !r) {
                            let d = i;
                            for (; d && !r; )
                                d = d.previousSibling,
                                r = Al(d, t)
                        }
                        if (!r) {
                            let d = l;
                            for (; d && !r; )
                                d = d.nextSibling,
                                r = Al(d, t)
                        }
                        r || (r = this.getStoredAttributes())
                    } else {
                        const i = this.getFirstRange();
                        for (const l of i) {
                            if (l.item.is("element") && t.isObject(l.item)) {
                                r = Al(l.item, t);
                                break
                            }
                            if (l.type == "text") {
                                r = l.item.getAttributes();
                                break
                            }
                        }
                    }
                    return r
                }
                _fixGraveyardSelection(e) {
                    const t = this._model.schema.getNearestSelectionRange(e);
                    t && this._pushRange(t)
                }
            }
            function Al(s, e) {
                if (!s)
                    return null;
                if (s instanceof fr || s instanceof $e)
                    return s.getAttributes();
                if (!e.isInline(s))
                    return null;
                if (!e.isObject(s))
                    return [];
                const t = [];
                for (const [r,i] of s.getAttributes())
                    e.checkAttribute("$text", r) && e.getAttributeProperties(r).copyFromObject !== !1 && t.push([r, i]);
                return t
            }
            class g_ {
                constructor(e) {
                    C(this, "_dispatchers"),
                    this._dispatchers = e
                }
                add(e) {
                    for (const t of this._dispatchers)
                        e(t);
                    return this
                }
            }
            class s3 extends g_ {
                elementToElement(e) {
                    return this.add(function(t) {
                        const r = b_(t.model)
                          , i = vl(t.view, "container");
                        return r.attributes.length && (r.children = !0),
                        l => {
                            l.on(`insert:${r.name}`, l3(i, __(r)), {
                                priority: t.converterPriority || "normal"
                            }),
                            (r.children || r.attributes.length) && l.on("reduceChanges", v_(r), {
                                priority: "low"
                            })
                        }
                    }(e))
                }
                elementToStructure(e) {
                    return this.add(function(t) {
                        const r = b_(t.model)
                          , i = vl(t.view, "container");
                        return r.children = !0,
                        l => {
                            if (l._conversionApi.schema.checkChild(r.name, "$text"))
                                throw new U("conversion-element-to-structure-disallowed-text",l,{
                                    elementName: r.name
                                });
                            var d, h;
                            l.on(`insert:${r.name}`, (d = i,
                            h = __(r),
                            (m, g, b) => {
                                if (!h(g.item, b.consumable, {
                                    preflight: !0
                                }))
                                    return;
                                const v = new Map;
                                b.writer._registerSlotFactory(function(I, P, O) {
                                    return (F, q) => {
                                        const Q = F.createContainerElement("$slot");
                                        let X = null;
                                        if (q === "children")
                                            X = Array.from(I.getChildren());
                                        else {
                                            if (typeof q != "function")
                                                throw new U("conversion-slot-mode-unknown",O.dispatcher,{
                                                    modeOrFilter: q
                                                });
                                            X = Array.from(I.getChildren()).filter(le => q(le))
                                        }
                                        return P.set(Q, X),
                                        Q
                                    }
                                }(g.item, v, b));
                                const x = d(g.item, b, g);
                                if (b.writer._clearSlotFactory(),
                                !x)
                                    return;
                                (function(I, P, O) {
                                    const F = Array.from(P.values()).flat()
                                      , q = new Set(F);
                                    if (q.size != F.length)
                                        throw new U("conversion-slot-filter-overlap",O.dispatcher,{
                                            element: I
                                        });
                                    if (q.size != I.childCount)
                                        throw new U("conversion-slot-filter-incomplete",O.dispatcher,{
                                            element: I
                                        })
                                }
                                )(g.item, v, b),
                                h(g.item, b.consumable);
                                const T = b.mapper.toViewPosition(g.range.start);
                                b.mapper.bindElements(g.item, x),
                                b.writer.insert(T, x),
                                b.convertAttributes(g.item),
                                function(I, P, O, F) {
                                    O.mapper.on("modelToViewPosition", X, {
                                        priority: "highest"
                                    });
                                    let q = null
                                      , Q = null;
                                    for ([q,Q] of P)
                                        C_(I, Q, O, F),
                                        O.writer.move(O.writer.createRangeIn(q), O.writer.createPositionBefore(q)),
                                        O.writer.remove(q);
                                    function X(le, ge) {
                                        const ke = ge.modelPosition.nodeAfter
                                          , vt = Q.indexOf(ke);
                                        vt < 0 || (ge.viewPosition = ge.mapper.findPositionIn(q, vt))
                                    }
                                    O.mapper.off("modelToViewPosition", X)
                                }(x, v, b, {
                                    reconversion: g.reconversion
                                })
                            }
                            ), {
                                priority: t.converterPriority || "normal"
                            }),
                            l.on("reduceChanges", v_(r), {
                                priority: "low"
                            })
                        }
                    }(e))
                }
                attributeToElement(e) {
                    return this.add(function(t) {
                        t = gr(t);
                        let r = t.model;
                        typeof r == "string" && (r = {
                            key: r
                        });
                        let i = `attribute:${r.key}`;
                        if (r.name && (i += ":" + r.name),
                        r.values)
                            for (const d of r.values)
                                t.view[d] = vl(t.view[d], "attribute");
                        else
                            t.view = vl(t.view, "attribute");
                        const l = w_(t);
                        return d => {
                            d.on(i, a3(l), {
                                priority: t.converterPriority || "normal"
                            })
                        }
                    }(e))
                }
                attributeToAttribute(e) {
                    return this.add(function(t) {
                        t = gr(t);
                        let r = t.model;
                        typeof r == "string" && (r = {
                            key: r
                        });
                        let i = `attribute:${r.key}`;
                        if (r.name && (i += ":" + r.name),
                        r.values)
                            for (const d of r.values)
                                t.view[d] = A_(t.view[d]);
                        else
                            t.view = A_(t.view);
                        const l = w_(t);
                        return d => {
                            var h;
                            d.on(i, (h = l,
                            (m, g, b) => {
                                if (!b.consumable.test(g.item, m.name))
                                    return;
                                const v = h(g.attributeOldValue, b, g)
                                  , x = h(g.attributeNewValue, b, g);
                                if (!v && !x)
                                    return;
                                b.consumable.consume(g.item, m.name);
                                const T = b.mapper.toViewElement(g.item)
                                  , I = b.writer;
                                if (!T)
                                    throw new U("conversion-attribute-to-attribute-on-text",b.dispatcher,g);
                                if (g.attributeOldValue !== null && v)
                                    if (v.key == "class") {
                                        const P = typeof v.value == "string" ? v.value.split(/\s+/) : v.value;
                                        for (const O of P)
                                            I.removeClass(O, T)
                                    } else if (v.key == "style")
                                        if (typeof v.value == "string") {
                                            const P = new hp(I.document.stylesProcessor);
                                            P.setTo(v.value);
                                            for (const [O] of P.getStylesEntries())
                                                I.removeStyle(O, T)
                                        } else {
                                            const P = Object.keys(v.value);
                                            for (const O of P)
                                                I.removeStyle(O, T)
                                        }
                                    else
                                        I.removeAttribute(v.key, T);
                                if (g.attributeNewValue !== null && x)
                                    if (x.key == "class") {
                                        const P = typeof x.value == "string" ? x.value.split(/\s+/) : x.value;
                                        for (const O of P)
                                            I.addClass(O, T)
                                    } else if (x.key == "style")
                                        if (typeof x.value == "string") {
                                            const P = new hp(I.document.stylesProcessor);
                                            P.setTo(x.value);
                                            for (const [O,F] of P.getStylesEntries())
                                                I.setStyle(O, F, T)
                                        } else {
                                            const P = Object.keys(x.value);
                                            for (const O of P)
                                                I.setStyle(O, x.value[O], T)
                                        }
                                    else
                                        I.setAttribute(x.key, x.value, T)
                            }
                            ), {
                                priority: t.converterPriority || "normal"
                            })
                        }
                    }(e))
                }
                markerToElement(e) {
                    return this.add(function(t) {
                        const r = vl(t.view, "ui");
                        return i => {
                            i.on(`addMarker:${t.model}`, c3(r), {
                                priority: t.converterPriority || "normal"
                            }),
                            i.on(`removeMarker:${t.model}`, (l, d, h) => {
                                const m = h.mapper.markerNameToElements(d.markerName);
                                if (m) {
                                    for (const g of m)
                                        h.mapper.unbindElementFromMarkerName(g, d.markerName),
                                        h.writer.clear(h.writer.createRangeOn(g), g);
                                    h.writer.clearClonedElementsGroup(d.markerName),
                                    l.stop()
                                }
                            }
                            , {
                                priority: t.converterPriority || "normal"
                            })
                        }
                    }(e))
                }
                markerToHighlight(e) {
                    return this.add(function(t) {
                        return r => {
                            var i;
                            r.on(`addMarker:${t.model}`, (i = t.view,
                            (l, d, h) => {
                                if (!d.item || !(d.item instanceof To || d.item instanceof kr || d.item.is("$textProxy")))
                                    return;
                                const m = Tp(i, d, h);
                                if (!m || !h.consumable.consume(d.item, l.name))
                                    return;
                                const g = h.writer
                                  , b = f_(g, m)
                                  , v = g.document.selection;
                                if (d.item instanceof To || d.item instanceof kr)
                                    g.wrap(v.getFirstRange(), b);
                                else {
                                    const x = h.mapper.toViewRange(d.range)
                                      , T = g.wrap(x, b);
                                    for (const I of T.getItems())
                                        if (I.is("attributeElement") && I.isSimilar(b)) {
                                            h.mapper.bindElementToMarker(I, d.markerName);
                                            break
                                        }
                                }
                            }
                            ), {
                                priority: t.converterPriority || "normal"
                            }),
                            r.on(`addMarker:${t.model}`, function(l) {
                                return (d, h, m) => {
                                    if (!h.item || !(h.item instanceof Fe))
                                        return;
                                    const g = Tp(l, h, m);
                                    if (!g || !m.consumable.test(h.item, d.name))
                                        return;
                                    const b = m.mapper.toViewElement(h.item);
                                    if (b && b.getCustomProperty("addHighlight")) {
                                        m.consumable.consume(h.item, d.name);
                                        for (const v of J._createIn(h.item))
                                            m.consumable.consume(v.item, d.name);
                                        b.getCustomProperty("addHighlight")(b, g, m.writer),
                                        m.mapper.bindElementToMarker(b, h.markerName)
                                    }
                                }
                            }(t.view), {
                                priority: t.converterPriority || "normal"
                            }),
                            r.on(`removeMarker:${t.model}`, function(l) {
                                return (d, h, m) => {
                                    if (h.markerRange.isCollapsed)
                                        return;
                                    const g = Tp(l, h, m);
                                    if (!g)
                                        return;
                                    const b = f_(m.writer, g)
                                      , v = m.mapper.markerNameToElements(h.markerName);
                                    if (v) {
                                        for (const x of v)
                                            m.mapper.unbindElementFromMarkerName(x, h.markerName),
                                            x.is("attributeElement") ? m.writer.unwrap(m.writer.createRangeOn(x), b) : x.getCustomProperty("removeHighlight")(x, g.id, m.writer);
                                        m.writer.clearClonedElementsGroup(h.markerName),
                                        d.stop()
                                    }
                                }
                            }(t.view), {
                                priority: t.converterPriority || "normal"
                            })
                        }
                    }(e))
                }
                markerToData(e) {
                    return this.add(function(t) {
                        t = gr(t);
                        const r = t.model;
                        let i = t.view;
                        return i || (i = l => ({
                            group: r,
                            name: l.substr(t.model.length + 1)
                        })),
                        l => {
                            var d;
                            l.on(`addMarker:${r}`, (d = i,
                            (h, m, g) => {
                                const b = d(m.markerName, g);
                                if (!b)
                                    return;
                                const v = m.markerRange;
                                g.consumable.consume(v, h.name) && (k_(v, !1, g, m, b),
                                k_(v, !0, g, m, b),
                                h.stop())
                            }
                            ), {
                                priority: t.converterPriority || "normal"
                            }),
                            l.on(`removeMarker:${r}`, function(h) {
                                return (m, g, b) => {
                                    const v = h(g.markerName, b);
                                    if (!v)
                                        return;
                                    const x = b.mapper.markerNameToElements(g.markerName);
                                    if (x) {
                                        for (const I of x)
                                            b.mapper.unbindElementFromMarkerName(I, g.markerName),
                                            I.is("containerElement") ? (T(`data-${v.group}-start-before`, I),
                                            T(`data-${v.group}-start-after`, I),
                                            T(`data-${v.group}-end-before`, I),
                                            T(`data-${v.group}-end-after`, I)) : b.writer.clear(b.writer.createRangeOn(I), I);
                                        b.writer.clearClonedElementsGroup(g.markerName),
                                        m.stop()
                                    }
                                    function T(I, P) {
                                        if (P.hasAttribute(I)) {
                                            const O = new Set(P.getAttribute(I).split(","));
                                            O.delete(v.name),
                                            O.size == 0 ? b.writer.removeAttribute(I, P) : b.writer.setAttribute(I, Array.from(O).join(","), P)
                                        }
                                    }
                                }
                            }(i), {
                                priority: t.converterPriority || "normal"
                            })
                        }
                    }(e))
                }
            }
            function f_(s, e) {
                const t = s.createAttributeElement("span", e.attributes);
                return e.classes && t._addClass(e.classes),
                typeof e.priority == "number" && (t._priority = e.priority),
                t._id = e.id,
                t
            }
            function a3(s) {
                return (e, t, r) => {
                    if (!r.consumable.test(t.item, e.name))
                        return;
                    const i = s(t.attributeOldValue, r, t)
                      , l = s(t.attributeNewValue, r, t);
                    if (!i && !l)
                        return;
                    r.consumable.consume(t.item, e.name);
                    const d = r.writer
                      , h = d.document.selection;
                    if (t.item instanceof To || t.item instanceof kr)
                        d.wrap(h.getFirstRange(), l);
                    else {
                        let m = r.mapper.toViewRange(t.range);
                        t.attributeOldValue !== null && i && (m = d.unwrap(m, i)),
                        t.attributeNewValue !== null && l && d.wrap(m, l)
                    }
                }
            }
            function l3(s, e=u3) {
                return (t, r, i) => {
                    if (!e(r.item, i.consumable, {
                        preflight: !0
                    }))
                        return;
                    const l = s(r.item, i, r);
                    if (!l)
                        return;
                    e(r.item, i.consumable);
                    const d = i.mapper.toViewPosition(r.range.start);
                    i.mapper.bindElements(r.item, l),
                    i.writer.insert(d, l),
                    i.convertAttributes(r.item),
                    C_(l, r.item.getChildren(), i, {
                        reconversion: r.reconversion
                    })
                }
            }
            function c3(s) {
                return (e, t, r) => {
                    t.isOpening = !0;
                    const i = s(t, r);
                    t.isOpening = !1;
                    const l = s(t, r);
                    if (!i || !l)
                        return;
                    const d = t.markerRange;
                    if (d.isCollapsed && !r.consumable.consume(d, e.name))
                        return;
                    for (const g of d)
                        if (!r.consumable.consume(g.item, e.name))
                            return;
                    const h = r.mapper
                      , m = r.writer;
                    m.insert(h.toViewPosition(d.start), i),
                    r.mapper.bindElementToMarker(i, t.markerName),
                    d.isCollapsed || (m.insert(h.toViewPosition(d.end), l),
                    r.mapper.bindElementToMarker(l, t.markerName)),
                    e.stop()
                }
            }
            function k_(s, e, t, r, i) {
                const l = e ? s.start : s.end
                  , d = l.nodeAfter && l.nodeAfter.is("element") ? l.nodeAfter : null
                  , h = l.nodeBefore && l.nodeBefore.is("element") ? l.nodeBefore : null;
                if (d || h) {
                    let m, g;
                    e && d || !e && !h ? (m = d,
                    g = !0) : (m = h,
                    g = !1);
                    const b = t.mapper.toViewElement(m);
                    if (b)
                        return void function(v, x, T, I, P, O) {
                            const F = `data-${O.group}-${x ? "start" : "end"}-${T ? "before" : "after"}`
                              , q = v.hasAttribute(F) ? v.getAttribute(F).split(",") : [];
                            q.unshift(O.name),
                            I.writer.setAttribute(F, q.join(","), v),
                            I.mapper.bindElementToMarker(v, P.markerName)
                        }(b, e, g, t, r, i)
                }
                (function(m, g, b, v, x) {
                    const T = `${x.group}-${g ? "start" : "end"}`
                      , I = x.name ? {
                        name: x.name
                    } : null
                      , P = b.writer.createUIElement(T, I);
                    b.writer.insert(m, P),
                    b.mapper.bindElementToMarker(P, v.markerName)
                }
                )(t.mapper.toViewPosition(l), e, t, r, i)
            }
            function b_(s) {
                return typeof s == "string" && (s = {
                    name: s
                }),
                {
                    name: s.name,
                    attributes: s.attributes ? Ze(s.attributes) : [],
                    children: !!s.children
                }
            }
            function vl(s, e) {
                return typeof s == "function" ? s : (t, r) => function(i, l, d) {
                    typeof i == "string" && (i = {
                        name: i
                    });
                    let h;
                    const m = l.writer
                      , g = Object.assign({}, i.attributes);
                    if (d == "container")
                        h = m.createContainerElement(i.name, g);
                    else if (d == "attribute") {
                        const b = {
                            priority: i.priority || Di.DEFAULT_PRIORITY
                        };
                        h = m.createAttributeElement(i.name, g, b)
                    } else
                        h = m.createUIElement(i.name, g);
                    if (i.styles) {
                        const b = Object.keys(i.styles);
                        for (const v of b)
                            m.setStyle(v, i.styles[v], h)
                    }
                    if (i.classes) {
                        const b = i.classes;
                        if (typeof b == "string")
                            m.addClass(b, h);
                        else
                            for (const v of b)
                                m.addClass(v, h)
                    }
                    return h
                }(s, r, e)
            }
            function w_(s) {
                return s.model.values ? (e, t, r) => {
                    const i = s.view[e];
                    return i ? i(e, t, r) : null
                }
                : s.view
            }
            function A_(s) {
                return typeof s == "string" ? e => ({
                    key: s,
                    value: e
                }) : typeof s == "object" ? s.value ? () => s : e => ({
                    key: s.key,
                    value: e
                }) : s
            }
            function Tp(s, e, t) {
                const r = typeof s == "function" ? s(e, t) : s;
                return r ? (r.priority || (r.priority = 10),
                r.id || (r.id = e.markerName),
                r) : null
            }
            function v_(s) {
                const e = function(t) {
                    return (r, i) => {
                        if (!r.is("element", t.name))
                            return !1;
                        if (i.type == "attribute") {
                            if (t.attributes.includes(i.attributeKey))
                                return !0
                        } else if (t.children)
                            return !0;
                        return !1
                    }
                }(s);
                return (t, r) => {
                    const i = [];
                    r.reconvertedElements || (r.reconvertedElements = new Set);
                    for (const l of r.changes) {
                        const d = l.type == "attribute" ? l.range.start.nodeAfter : l.position.parent;
                        if (d && e(d, l)) {
                            if (!r.reconvertedElements.has(d)) {
                                r.reconvertedElements.add(d);
                                const h = ne._createBefore(d);
                                let m = i.length;
                                for (let g = i.length - 1; g >= 0; g--) {
                                    const b = i[g]
                                      , v = (b.type == "attribute" ? b.range.start : b.position).compareWith(h);
                                    if (v == "before" || b.type == "remove" && v == "same")
                                        break;
                                    m = g
                                }
                                i.splice(m, 0, {
                                    type: "remove",
                                    name: d.name,
                                    position: h,
                                    length: 1
                                }, {
                                    type: "reinsert",
                                    name: d.name,
                                    position: h,
                                    length: 1
                                })
                            }
                        } else
                            i.push(l)
                    }
                    r.changes = i
                }
            }
            function __(s) {
                return (e, t, r={}) => {
                    const i = ["insert"];
                    for (const l of s.attributes)
                        e.hasAttribute(l) && i.push(`attribute:${l}`);
                    return !!i.every(l => t.test(e, l)) && (r.preflight || i.forEach(l => t.consume(e, l)),
                    !0)
                }
            }
            function C_(s, e, t, r) {
                for (const i of e)
                    d3(s.root, i, t, r) || t.convertItem(i)
            }
            function d3(s, e, t, r) {
                const {writer: i, mapper: l} = t;
                if (!r.reconversion)
                    return !1;
                const d = l.toViewElement(e);
                return !(!d || d.root == s) && !!t.canReuseView(d) && (i.move(i.createRangeOn(d), l.toViewPosition(ne._createBefore(e))),
                !0)
            }
            function u3(s, e, {preflight: t}={}) {
                return t ? e.test(s, "insert") : e.consume(s, "insert")
            }
            function y_(s) {
                const {schema: e, document: t} = s.model;
                for (const r of t.getRoots())
                    if (r.isEmpty && !e.checkChild(r, "$text") && e.checkChild(r, "paragraph"))
                        return s.insertElement("paragraph", r),
                        !0;
                return !1
            }
            function x_(s, e, t) {
                const r = t.createContext(s);
                return !!t.checkChild(r, "paragraph") && !!t.checkChild(r.push("paragraph"), e)
            }
            function E_(s, e) {
                const t = e.createElement("paragraph");
                return e.insert(t, s),
                e.createPositionAt(t, 0)
            }
            class h3 extends g_ {
                elementToElement(e) {
                    return this.add(S_(e))
                }
                elementToAttribute(e) {
                    return this.add(function(t) {
                        t = gr(t),
                        D_(t);
                        const r = T_(t, !1)
                          , i = Ip(t.view)
                          , l = i ? `element:${i}` : "element";
                        return d => {
                            d.on(l, r, {
                                priority: t.converterPriority || "low"
                            })
                        }
                    }(e))
                }
                attributeToAttribute(e) {
                    return this.add(function(t) {
                        t = gr(t);
                        let r = null;
                        (typeof t.view == "string" || t.view.key) && (r = function(l) {
                            typeof l.view == "string" && (l.view = {
                                key: l.view
                            });
                            const d = l.view.key
                              , h = l.view.value === void 0 ? /[\s\S]*/ : l.view.value;
                            let m;
                            return d == "class" || d == "style" ? m = {
                                [d == "class" ? "classes" : "styles"]: h
                            } : m = {
                                attributes: {
                                    [d]: h
                                }
                            },
                            l.view.name && (m.name = l.view.name),
                            l.view = m,
                            d
                        }(t)),
                        D_(t, r);
                        const i = T_(t, !0);
                        return l => {
                            l.on("element", i, {
                                priority: t.converterPriority || "low"
                            })
                        }
                    }(e))
                }
                elementToMarker(e) {
                    return this.add(function(t) {
                        const r = function(i) {
                            return (l, d) => {
                                const h = typeof i == "string" ? i : i(l, d);
                                return d.writer.createElement("$marker", {
                                    "data-name": h
                                })
                            }
                        }(t.model);
                        return S_({
                            ...t,
                            model: r
                        })
                    }(e))
                }
                dataToMarker(e) {
                    return this.add(function(t) {
                        t = gr(t),
                        t.model || (t.model = d => d ? t.view + ":" + d : t.view);
                        const r = {
                            view: t.view,
                            model: t.model
                        }
                          , i = Mp(I_(r, "start"))
                          , l = Mp(I_(r, "end"));
                        return d => {
                            d.on(`element:${t.view}-start`, i, {
                                priority: t.converterPriority || "normal"
                            }),
                            d.on(`element:${t.view}-end`, l, {
                                priority: t.converterPriority || "normal"
                            });
                            const h = W.low
                              , m = W.highest
                              , g = W.get(t.converterPriority) / m;
                            d.on("element", function(b) {
                                return (v, x, T) => {
                                    const I = `data-${b.view}`;
                                    function P(O, F) {
                                        for (const q of F) {
                                            const Q = b.model(q, T)
                                              , X = T.writer.createElement("$marker", {
                                                "data-name": Q
                                            });
                                            T.writer.insert(X, O),
                                            x.modelCursor.isEqual(O) ? x.modelCursor = x.modelCursor.getShiftedBy(1) : x.modelCursor = x.modelCursor._getTransformedByInsertion(O, 1),
                                            x.modelRange = x.modelRange._getTransformedByInsertion(O, 1)[0]
                                        }
                                    }
                                    (T.consumable.test(x.viewItem, {
                                        attributes: I + "-end-after"
                                    }) || T.consumable.test(x.viewItem, {
                                        attributes: I + "-start-after"
                                    }) || T.consumable.test(x.viewItem, {
                                        attributes: I + "-end-before"
                                    }) || T.consumable.test(x.viewItem, {
                                        attributes: I + "-start-before"
                                    })) && (x.modelRange || Object.assign(x, T.convertChildren(x.viewItem, x.modelCursor)),
                                    T.consumable.consume(x.viewItem, {
                                        attributes: I + "-end-after"
                                    }) && P(x.modelRange.end, x.viewItem.getAttribute(I + "-end-after").split(",")),
                                    T.consumable.consume(x.viewItem, {
                                        attributes: I + "-start-after"
                                    }) && P(x.modelRange.end, x.viewItem.getAttribute(I + "-start-after").split(",")),
                                    T.consumable.consume(x.viewItem, {
                                        attributes: I + "-end-before"
                                    }) && P(x.modelRange.start, x.viewItem.getAttribute(I + "-end-before").split(",")),
                                    T.consumable.consume(x.viewItem, {
                                        attributes: I + "-start-before"
                                    }) && P(x.modelRange.start, x.viewItem.getAttribute(I + "-start-before").split(",")))
                                }
                            }(r), {
                                priority: h + g
                            })
                        }
                    }(e))
                }
            }
            function S_(s) {
                const e = Mp(s = gr(s))
                  , t = Ip(s.view)
                  , r = t ? `element:${t}` : "element";
                return i => {
                    i.on(r, e, {
                        priority: s.converterPriority || "normal"
                    })
                }
            }
            function Ip(s) {
                return typeof s == "string" ? s : typeof s == "object" && typeof s.name == "string" ? s.name : null
            }
            function Mp(s) {
                const e = new Br(s.view);
                return (t, r, i) => {
                    const l = e.match(r.viewItem);
                    if (!l)
                        return;
                    const d = l.match;
                    if (d.name = !0,
                    !i.consumable.test(r.viewItem, d))
                        return;
                    const h = function(m, g, b) {
                        return m instanceof Function ? m(g, b) : b.writer.createElement(m)
                    }(s.model, r.viewItem, i);
                    h && i.safeInsert(h, r.modelCursor) && (i.consumable.consume(r.viewItem, d),
                    i.convertChildren(r.viewItem, h),
                    i.updateConversionResult(h, r))
                }
            }
            function D_(s, e=null) {
                const t = e === null || (l => l.getAttribute(e))
                  , r = typeof s.model != "object" ? s.model : s.model.key
                  , i = typeof s.model != "object" || s.model.value === void 0 ? t : s.model.value;
                s.model = {
                    key: r,
                    value: i
                }
            }
            function T_(s, e) {
                const t = new Br(s.view);
                return (r, i, l) => {
                    if (!i.modelRange && e)
                        return;
                    const d = t.match(i.viewItem);
                    if (!d || (function(g, b) {
                        const v = typeof g == "function" ? g(b) : g;
                        return typeof v == "object" && !Ip(v) ? !1 : !v.classes && !v.attributes && !v.styles
                    }(s.view, i.viewItem) ? d.match.name = !0 : delete d.match.name,
                    !l.consumable.test(i.viewItem, d.match)))
                        return;
                    const h = s.model.key
                      , m = typeof s.model.value == "function" ? s.model.value(i.viewItem, l) : s.model.value;
                    m !== null && (i.modelRange || Object.assign(i, l.convertChildren(i.viewItem, i.modelCursor)),
                    function(g, b, v, x) {
                        let T = !1;
                        for (const I of Array.from(g.getItems({
                            shallow: v
                        })))
                            x.schema.checkAttribute(I, b.key) && (T = !0,
                            I.hasAttribute(b.key) || x.writer.setAttribute(b.key, b.value, I));
                        return T
                    }(i.modelRange, {
                        key: h,
                        value: m
                    }, e, l) && (l.consumable.test(i.viewItem, {
                        name: !0
                    }) && (d.match.name = !0),
                    l.consumable.consume(i.viewItem, d.match)))
                }
            }
            function I_(s, e) {
                return {
                    view: `${s.view}-${e}`,
                    model: (t, r) => {
                        const i = t.getAttribute("name")
                          , l = s.model(i, r);
                        return r.writer.createElement("$marker", {
                            "data-name": l
                        })
                    }
                }
            }
            function m3(s) {
                s.document.registerPostFixer(e => function(t, r) {
                    const i = r.document.selection
                      , l = r.schema
                      , d = [];
                    let h = !1;
                    for (const m of i.getRanges()) {
                        const g = M_(m, l);
                        g && !g.isEqual(m) ? (d.push(g),
                        h = !0) : d.push(m)
                    }
                    return h && t.setSelection(function(m) {
                        const g = [...m]
                          , b = new Set;
                        let v = 1;
                        for (; v < g.length; ) {
                            const x = g[v]
                              , T = g.slice(0, v);
                            for (const [I,P] of T.entries())
                                if (!b.has(I)) {
                                    if (x.isEqual(P))
                                        b.add(I);
                                    else if (x.isIntersecting(P)) {
                                        b.add(I),
                                        b.add(v);
                                        const O = x.getJoined(P);
                                        g.push(O)
                                    }
                                }
                            v++
                        }
                        return g.filter( (x, T) => !b.has(T))
                    }(d), {
                        backward: i.isBackward
                    }),
                    !1
                }(e, s))
            }
            function M_(s, e) {
                return s.isCollapsed ? function(t, r) {
                    const i = t.start
                      , l = r.getNearestSelectionRange(i);
                    if (!l) {
                        const h = i.getAncestors().reverse().find(m => r.isObject(m));
                        return h ? J._createOn(h) : null
                    }
                    if (!l.isCollapsed)
                        return l;
                    const d = l.start;
                    return i.isEqual(d) ? null : new J(d)
                }(s, e) : function(t, r) {
                    const {start: i, end: l} = t
                      , d = r.checkChild(i, "$text")
                      , h = r.checkChild(l, "$text")
                      , m = r.getLimitElement(i)
                      , g = r.getLimitElement(l);
                    if (m === g) {
                        if (d && h)
                            return null;
                        if (function(x, T, I) {
                            const P = x.nodeAfter && !I.isLimit(x.nodeAfter) || I.checkChild(x, "$text")
                              , O = T.nodeBefore && !I.isLimit(T.nodeBefore) || I.checkChild(T, "$text");
                            return P || O
                        }(i, l, r)) {
                            const x = i.nodeAfter && r.isSelectable(i.nodeAfter) ? null : r.getNearestSelectionRange(i, "forward")
                              , T = l.nodeBefore && r.isSelectable(l.nodeBefore) ? null : r.getNearestSelectionRange(l, "backward")
                              , I = x ? x.start : i
                              , P = T ? T.end : l;
                            return new J(I,P)
                        }
                    }
                    const b = m && !m.is("rootElement")
                      , v = g && !g.is("rootElement");
                    if (b || v) {
                        const x = i.nodeAfter && l.nodeBefore && i.nodeAfter.parent === l.nodeBefore.parent
                          , T = b && (!x || !N_(i.nodeAfter, r))
                          , I = v && (!x || !N_(l.nodeBefore, r));
                        let P = i
                          , O = l;
                        return T && (P = ne._createBefore(B_(m, r))),
                        I && (O = ne._createAfter(B_(g, r))),
                        new J(P,O)
                    }
                    return null
                }(s, e)
            }
            function B_(s, e) {
                let t = s
                  , r = t;
                for (; e.isLimit(r) && r.parent; )
                    t = r,
                    r = r.parent;
                return t
            }
            function N_(s, e) {
                return s && e.isSelectable(s)
            }
            class p3 extends ye() {
                constructor(e, t) {
                    super(),
                    C(this, "model"),
                    C(this, "view"),
                    C(this, "mapper"),
                    C(this, "downcastDispatcher"),
                    this.model = e,
                    this.view = new ZP(t),
                    this.mapper = new d_,
                    this.downcastDispatcher = new u_({
                        mapper: this.mapper,
                        schema: e.schema
                    });
                    const r = this.model.document
                      , i = r.selection
                      , l = this.model.markers;
                    var d, h, m;
                    this.listenTo(this.model, "_beforeChanges", () => {
                        this.view._disableRendering(!0)
                    }
                    , {
                        priority: "highest"
                    }),
                    this.listenTo(this.model, "_afterChanges", () => {
                        this.view._disableRendering(!1)
                    }
                    , {
                        priority: "lowest"
                    }),
                    this.listenTo(r, "change", () => {
                        this.view.change(g => {
                            this.downcastDispatcher.convertChanges(r.differ, l, g),
                            this.downcastDispatcher.convertSelection(i, l, g)
                        }
                        )
                    }
                    , {
                        priority: "low"
                    }),
                    this.listenTo(this.view.document, "selectionChange", function(g, b) {
                        return (v, x) => {
                            const T = x.newSelection
                              , I = [];
                            for (const O of T.getRanges())
                                I.push(b.toModelRange(O));
                            const P = g.createSelection(I, {
                                backward: T.isBackward
                            });
                            P.isEqual(g.document.selection) || g.change(O => {
                                O.setSelection(P)
                            }
                            )
                        }
                    }(this.model, this.mapper)),
                    this.listenTo(this.view.document, "beforeinput", (d = this.mapper,
                    h = this.model.schema,
                    m = this.view,
                    (g, b) => {
                        if (!m.document.isComposing || E.isAndroid)
                            for (let v = 0; v < b.targetRanges.length; v++) {
                                const x = b.targetRanges[v]
                                  , T = d.toModelRange(x)
                                  , I = M_(T, h);
                                I && !I.isEqual(T) && (b.targetRanges[v] = d.toViewRange(I))
                            }
                    }
                    ), {
                        priority: "high"
                    }),
                    this.downcastDispatcher.on("insert:$text", (g, b, v) => {
                        if (!v.consumable.consume(b.item, g.name))
                            return;
                        const x = v.writer
                          , T = v.mapper.toViewPosition(b.range.start)
                          , I = x.createText(b.item.data);
                        x.insert(T, I)
                    }
                    , {
                        priority: "lowest"
                    }),
                    this.downcastDispatcher.on("insert", (g, b, v) => {
                        v.convertAttributes(b.item),
                        b.reconversion || !b.item.is("element") || b.item.isEmpty || v.convertChildren(b.item)
                    }
                    , {
                        priority: "lowest"
                    }),
                    this.downcastDispatcher.on("remove", (g, b, v) => {
                        const x = v.mapper.toViewPosition(b.position)
                          , T = b.position.getShiftedBy(b.length)
                          , I = v.mapper.toViewPosition(T, {
                            isPhantom: !0
                        })
                          , P = v.writer.createRange(x, I)
                          , O = v.writer.remove(P.getTrimmed());
                        for (const F of v.writer.createRangeIn(O).getItems())
                            v.mapper.unbindViewElement(F, {
                                defer: !0
                            })
                    }
                    , {
                        priority: "low"
                    }),
                    this.downcastDispatcher.on("cleanSelection", (g, b, v) => {
                        const x = v.writer
                          , T = x.document.selection;
                        for (const I of T.getRanges())
                            I.isCollapsed && I.end.parent.isAttached() && v.writer.mergeAttributes(I.start);
                        x.setSelection(null)
                    }
                    ),
                    this.downcastDispatcher.on("selection", (g, b, v) => {
                        const x = b.selection;
                        if (x.isCollapsed || !v.consumable.consume(x, "selection"))
                            return;
                        const T = [];
                        for (const I of x.getRanges())
                            T.push(v.mapper.toViewRange(I));
                        v.writer.setSelection(T, {
                            backward: x.isBackward
                        })
                    }
                    , {
                        priority: "low"
                    }),
                    this.downcastDispatcher.on("selection", (g, b, v) => {
                        const x = b.selection;
                        if (!x.isCollapsed || !v.consumable.consume(x, "selection"))
                            return;
                        const T = v.writer
                          , I = x.getFirstPosition()
                          , P = v.mapper.toViewPosition(I)
                          , O = T.breakAttributes(P);
                        T.setSelection(O)
                    }
                    , {
                        priority: "low"
                    }),
                    this.view.document.roots.bindTo(this.model.document.roots).using(g => {
                        if (g.rootName == "$graveyard")
                            return null;
                        const b = new Nv(this.view.document,g.name);
                        return b.rootName = g.rootName,
                        this.mapper.bindElements(g, b),
                        b
                    }
                    )
                }
                destroy() {
                    this.view.destroy(),
                    this.stopListening()
                }
                reconvertMarker(e) {
                    const t = typeof e == "string" ? e : e.name
                      , r = this.model.markers.get(t);
                    if (!r)
                        throw new U("editingcontroller-reconvertmarker-marker-not-exist",this,{
                            markerName: t
                        });
                    this.model.change( () => {
                        this.model.markers._refresh(r)
                    }
                    )
                }
                reconvertItem(e) {
                    this.model.change( () => {
                        this.model.document.differ._refreshItem(e)
                    }
                    )
                }
            }
            class _l {
                constructor() {
                    C(this, "_consumables", new Map)
                }
                add(e, t) {
                    let r;
                    e.is("$text") || e.is("documentFragment") ? this._consumables.set(e, !0) : (this._consumables.has(e) ? r = this._consumables.get(e) : (r = new g3(e),
                    this._consumables.set(e, r)),
                    r.add(t))
                }
                test(e, t) {
                    const r = this._consumables.get(e);
                    return r === void 0 ? null : e.is("$text") || e.is("documentFragment") ? r : r.test(t)
                }
                consume(e, t) {
                    return !!this.test(e, t) && (e.is("$text") || e.is("documentFragment") ? this._consumables.set(e, !1) : this._consumables.get(e).consume(t),
                    !0)
                }
                revert(e, t) {
                    const r = this._consumables.get(e);
                    r !== void 0 && (e.is("$text") || e.is("documentFragment") ? this._consumables.set(e, !0) : r.revert(t))
                }
                static consumablesFromElement(e) {
                    const t = {
                        element: e,
                        name: !0,
                        attributes: [],
                        classes: [],
                        styles: []
                    }
                      , r = e.getAttributeKeys();
                    for (const d of r)
                        d != "style" && d != "class" && t.attributes.push(d);
                    const i = e.getClassNames();
                    for (const d of i)
                        t.classes.push(d);
                    const l = e.getStyleNames();
                    for (const d of l)
                        t.styles.push(d);
                    return t
                }
                static createFrom(e, t) {
                    if (t || (t = new _l),
                    e.is("$text"))
                        return t.add(e),
                        t;
                    e.is("element") && t.add(e, _l.consumablesFromElement(e)),
                    e.is("documentFragment") && t.add(e);
                    for (const r of e.getChildren())
                        t = _l.createFrom(r, t);
                    return t
                }
            }
            const Gd = ["attributes", "classes", "styles"];
            class g3 {
                constructor(e) {
                    C(this, "element"),
                    C(this, "_canConsumeName"),
                    C(this, "_consumables"),
                    this.element = e,
                    this._canConsumeName = null,
                    this._consumables = {
                        attributes: new Map,
                        styles: new Map,
                        classes: new Map
                    }
                }
                add(e) {
                    e.name && (this._canConsumeName = !0);
                    for (const t of Gd)
                        t in e && this._add(t, e[t])
                }
                test(e) {
                    if (e.name && !this._canConsumeName)
                        return this._canConsumeName;
                    for (const t of Gd)
                        if (t in e) {
                            const r = this._test(t, e[t]);
                            if (r !== !0)
                                return r
                        }
                    return !0
                }
                consume(e) {
                    e.name && (this._canConsumeName = !1);
                    for (const t of Gd)
                        t in e && this._consume(t, e[t])
                }
                revert(e) {
                    e.name && (this._canConsumeName = !0);
                    for (const t of Gd)
                        t in e && this._revert(t, e[t])
                }
                _add(e, t) {
                    const r = Ze(t)
                      , i = this._consumables[e];
                    for (const l of r) {
                        if (e === "attributes" && (l === "class" || l === "style"))
                            throw new U("viewconsumable-invalid-attribute",this);
                        if (i.set(l, !0),
                        e === "styles")
                            for (const d of this.element.document.stylesProcessor.getRelatedStyles(l))
                                i.set(d, !0)
                    }
                }
                _test(e, t) {
                    const r = Ze(t)
                      , i = this._consumables[e];
                    for (const l of r)
                        if (e !== "attributes" || l !== "class" && l !== "style") {
                            const d = i.get(l);
                            if (d === void 0)
                                return null;
                            if (!d)
                                return !1
                        } else {
                            const d = l == "class" ? "classes" : "styles"
                              , h = this._test(d, [...this._consumables[d].keys()]);
                            if (h !== !0)
                                return h
                        }
                    return !0
                }
                _consume(e, t) {
                    const r = Ze(t)
                      , i = this._consumables[e];
                    for (const l of r)
                        if (e !== "attributes" || l !== "class" && l !== "style") {
                            if (i.set(l, !1),
                            e == "styles")
                                for (const d of this.element.document.stylesProcessor.getRelatedStyles(l))
                                    i.set(d, !1)
                        } else {
                            const d = l == "class" ? "classes" : "styles";
                            this._consume(d, [...this._consumables[d].keys()])
                        }
                }
                _revert(e, t) {
                    const r = Ze(t)
                      , i = this._consumables[e];
                    for (const l of r)
                        if (e !== "attributes" || l !== "class" && l !== "style")
                            i.get(l) === !1 && i.set(l, !0);
                        else {
                            const d = l == "class" ? "classes" : "styles";
                            this._revert(d, [...this._consumables[d].keys()])
                        }
                }
            }
            class f3 extends ye() {
                constructor() {
                    super(),
                    C(this, "_sourceDefinitions", {}),
                    C(this, "_attributeProperties", {}),
                    C(this, "_compiledDefinitions"),
                    this.decorate("checkChild"),
                    this.decorate("checkAttribute"),
                    this.on("checkAttribute", (e, t) => {
                        t[0] = new Bi(t[0])
                    }
                    , {
                        priority: "highest"
                    }),
                    this.on("checkChild", (e, t) => {
                        t[0] = new Bi(t[0]),
                        t[1] = this.getDefinition(t[1])
                    }
                    , {
                        priority: "highest"
                    })
                }
                register(e, t) {
                    if (this._sourceDefinitions[e])
                        throw new U("schema-cannot-register-item-twice",this,{
                            itemName: e
                        });
                    this._sourceDefinitions[e] = [Object.assign({}, t)],
                    this._clearCache()
                }
                extend(e, t) {
                    if (!this._sourceDefinitions[e])
                        throw new U("schema-cannot-extend-missing-item",this,{
                            itemName: e
                        });
                    this._sourceDefinitions[e].push(Object.assign({}, t)),
                    this._clearCache()
                }
                getDefinitions() {
                    return this._compiledDefinitions || this._compile(),
                    this._compiledDefinitions
                }
                getDefinition(e) {
                    let t;
                    return t = typeof e == "string" ? e : "is"in e && (e.is("$text") || e.is("$textProxy")) ? "$text" : e.name,
                    this.getDefinitions()[t]
                }
                isRegistered(e) {
                    return !!this.getDefinition(e)
                }
                isBlock(e) {
                    const t = this.getDefinition(e);
                    return !(!t || !t.isBlock)
                }
                isLimit(e) {
                    const t = this.getDefinition(e);
                    return !!t && !(!t.isLimit && !t.isObject)
                }
                isObject(e) {
                    const t = this.getDefinition(e);
                    return !!t && !!(t.isObject || t.isLimit && t.isSelectable && t.isContent)
                }
                isInline(e) {
                    const t = this.getDefinition(e);
                    return !(!t || !t.isInline)
                }
                isSelectable(e) {
                    const t = this.getDefinition(e);
                    return !!t && !(!t.isSelectable && !t.isObject)
                }
                isContent(e) {
                    const t = this.getDefinition(e);
                    return !!t && !(!t.isContent && !t.isObject)
                }
                checkChild(e, t) {
                    return !!t && this._checkContextMatch(t, e)
                }
                checkAttribute(e, t) {
                    const r = this.getDefinition(e.last);
                    return !!r && r.allowAttributes.includes(t)
                }
                checkMerge(e, t) {
                    if (e instanceof ne) {
                        const r = e.nodeBefore
                          , i = e.nodeAfter;
                        if (!(r instanceof Fe))
                            throw new U("schema-check-merge-no-element-before",this);
                        if (!(i instanceof Fe))
                            throw new U("schema-check-merge-no-element-after",this);
                        return this.checkMerge(r, i)
                    }
                    for (const r of t.getChildren())
                        if (!this.checkChild(e, r))
                            return !1;
                    return !0
                }
                addChildCheck(e) {
                    this.on("checkChild", (t, [r,i]) => {
                        if (!i)
                            return;
                        const l = e(r, i);
                        typeof l == "boolean" && (t.stop(),
                        t.return = l)
                    }
                    , {
                        priority: "high"
                    })
                }
                addAttributeCheck(e) {
                    this.on("checkAttribute", (t, [r,i]) => {
                        const l = e(r, i);
                        typeof l == "boolean" && (t.stop(),
                        t.return = l)
                    }
                    , {
                        priority: "high"
                    })
                }
                setAttributeProperties(e, t) {
                    this._attributeProperties[e] = Object.assign(this.getAttributeProperties(e), t)
                }
                getAttributeProperties(e) {
                    return this._attributeProperties[e] || {}
                }
                getLimitElement(e) {
                    let t;
                    for (e instanceof ne ? t = e.parent : t = (e instanceof J ? [e] : Array.from(e.getRanges())).reduce( (r, i) => {
                        const l = i.getCommonAncestor();
                        return r ? r.getCommonAncestor(l, {
                            includeSelf: !0
                        }) : l
                    }
                    , null); !this.isLimit(t) && t.parent; )
                        t = t.parent;
                    return t
                }
                checkAttributeInSelection(e, t) {
                    if (e.isCollapsed) {
                        const r = [...e.getFirstPosition().getAncestors(), new $e("",e.getAttributes())];
                        return this.checkAttribute(r, t)
                    }
                    {
                        const r = e.getRanges();
                        for (const i of r)
                            for (const l of i)
                                if (this.checkAttribute(l.item, t))
                                    return !0
                    }
                    return !1
                }
                *getValidRanges(e, t) {
                    e = function*(r) {
                        for (const i of r)
                            yield*i.getMinimalFlatRanges()
                    }(e);
                    for (const r of e)
                        yield*this._getValidRangesForRange(r, t)
                }
                getNearestSelectionRange(e, t="both") {
                    if (e.root.rootName == "$graveyard")
                        return null;
                    if (this.checkChild(e, "$text"))
                        return new J(e);
                    let r, i;
                    const l = e.getAncestors().reverse().find(d => this.isLimit(d)) || e.root;
                    t != "both" && t != "backward" || (r = new Kr({
                        boundaries: J._createIn(l),
                        startPosition: e,
                        direction: "backward"
                    })),
                    t != "both" && t != "forward" || (i = new Kr({
                        boundaries: J._createIn(l),
                        startPosition: e
                    }));
                    for (const d of function*(h, m) {
                        let g = !1;
                        for (; !g; ) {
                            if (g = !0,
                            h) {
                                const b = h.next();
                                b.done || (g = !1,
                                yield{
                                    walker: h,
                                    value: b.value
                                })
                            }
                            if (m) {
                                const b = m.next();
                                b.done || (g = !1,
                                yield{
                                    walker: m,
                                    value: b.value
                                })
                            }
                        }
                    }(r, i)) {
                        const h = d.walker == r ? "elementEnd" : "elementStart"
                          , m = d.value;
                        if (m.type == h && this.isObject(m.item))
                            return J._createOn(m.item);
                        if (this.checkChild(m.nextPosition, "$text"))
                            return new J(m.nextPosition)
                    }
                    return null
                }
                findAllowedParent(e, t) {
                    let r = e.parent;
                    for (; r; ) {
                        if (this.checkChild(r, t))
                            return r;
                        if (this.isLimit(r))
                            return null;
                        r = r.parent
                    }
                    return null
                }
                setAllowedAttributes(e, t, r) {
                    const i = r.model;
                    for (const [l,d] of Object.entries(t))
                        i.schema.checkAttribute(e, l) && r.setAttribute(l, d, e)
                }
                removeDisallowedAttributes(e, t) {
                    for (const r of e)
                        if (r.is("$text"))
                            P_(this, r, t);
                        else {
                            const i = J._createIn(r).getPositions();
                            for (const l of i)
                                P_(this, l.nodeBefore || l.parent, t)
                        }
                }
                getAttributesWithProperty(e, t, r) {
                    const i = {};
                    for (const [l,d] of e.getAttributes()) {
                        const h = this.getAttributeProperties(l);
                        h[t] !== void 0 && (r !== void 0 && r !== h[t] || (i[l] = d))
                    }
                    return i
                }
                createContext(e) {
                    return new Bi(e)
                }
                _clearCache() {
                    this._compiledDefinitions = null
                }
                _compile() {
                    const e = {}
                      , t = this._sourceDefinitions
                      , r = Object.keys(t);
                    for (const l of r)
                        e[l] = k3(t[l], l);
                    const i = Object.values(e);
                    for (const l of i)
                        b3(e, l),
                        w3(e, l),
                        A3(e, l),
                        v3(e, l);
                    for (const l of i)
                        _3(e, l);
                    for (const l of i)
                        C3(e, l);
                    for (const l of i)
                        y3(e, l);
                    for (const l of i)
                        x3(e, l);
                    for (const l of i)
                        E3(e, l);
                    this._compiledDefinitions = function(l) {
                        const d = {};
                        for (const h of Object.values(l))
                            d[h.name] = {
                                name: h.name,
                                isBlock: !!h.isBlock,
                                isContent: !!h.isContent,
                                isInline: !!h.isInline,
                                isLimit: !!h.isLimit,
                                isObject: !!h.isObject,
                                isSelectable: !!h.isSelectable,
                                allowIn: Array.from(h.allowIn).filter(m => !!l[m]),
                                allowChildren: Array.from(h.allowChildren).filter(m => !!l[m]),
                                allowAttributes: Array.from(h.allowAttributes)
                            };
                        return d
                    }(e)
                }
                _checkContextMatch(e, t, r=t.length - 1) {
                    const i = t.getItem(r);
                    if (e.allowIn.includes(i.name)) {
                        if (r == 0)
                            return !0;
                        {
                            const l = this.getDefinition(i);
                            return this._checkContextMatch(l, t, r - 1)
                        }
                    }
                    return !1
                }
                *_getValidRangesForRange(e, t) {
                    let r = e.start
                      , i = e.start;
                    for (const l of e.getItems({
                        shallow: !0
                    }))
                        l.is("element") && (yield*this._getValidRangesForRange(J._createIn(l), t)),
                        this.checkAttribute(l, t) || (r.isEqual(i) || (yield new J(r,i)),
                        r = ne._createAfter(l)),
                        i = ne._createAfter(l);
                    r.isEqual(i) || (yield new J(r,i))
                }
                findOptimalInsertionRange(e, t) {
                    const r = e.getSelectedElement();
                    if (r && this.isObject(r) && !this.isInline(r))
                        return t == "before" || t == "after" ? new J(ne._createAt(r, t)) : J._createOn(r);
                    const i = zt(e.getSelectedBlocks());
                    if (!i)
                        return new J(e.focus);
                    if (i.isEmpty)
                        return new J(ne._createAt(i, 0));
                    const l = ne._createAfter(i);
                    return e.focus.isTouching(l) ? new J(l) : new J(ne._createBefore(i))
                }
            }
            class Bi {
                constructor(e) {
                    if (C(this, "_items"),
                    e instanceof Bi)
                        return e;
                    let t;
                    t = typeof e == "string" ? [e] : Array.isArray(e) ? e : e.getAncestors({
                        includeSelf: !0
                    }),
                    this._items = t.map(S3)
                }
                get length() {
                    return this._items.length
                }
                get last() {
                    return this._items[this._items.length - 1]
                }
                [Symbol.iterator]() {
                    return this._items[Symbol.iterator]()
                }
                push(e) {
                    const t = new Bi([e]);
                    return t._items = [...this._items, ...t._items],
                    t
                }
                getItem(e) {
                    return this._items[e]
                }
                *getNames() {
                    yield*this._items.map(e => e.name)
                }
                endsWith(e) {
                    return Array.from(this.getNames()).join(" ").endsWith(e)
                }
                startsWith(e) {
                    return Array.from(this.getNames()).join(" ").startsWith(e)
                }
            }
            function k3(s, e) {
                const t = {
                    name: e,
                    allowIn: new Set,
                    allowChildren: new Set,
                    disallowIn: new Set,
                    disallowChildren: new Set,
                    allowContentOf: new Set,
                    allowWhere: new Set,
                    allowAttributes: new Set,
                    disallowAttributes: new Set,
                    allowAttributesOf: new Set,
                    inheritTypesFrom: new Set
                };
                return function(r, i) {
                    for (const l of r) {
                        const d = Object.keys(l).filter(h => h.startsWith("is"));
                        for (const h of d)
                            i[h] = !!l[h]
                    }
                }(s, t),
                Pr(s, t, "allowIn"),
                Pr(s, t, "allowChildren"),
                Pr(s, t, "disallowIn"),
                Pr(s, t, "disallowChildren"),
                Pr(s, t, "allowContentOf"),
                Pr(s, t, "allowWhere"),
                Pr(s, t, "allowAttributes"),
                Pr(s, t, "disallowAttributes"),
                Pr(s, t, "allowAttributesOf"),
                Pr(s, t, "inheritTypesFrom"),
                function(r, i) {
                    for (const l of r) {
                        const d = l.inheritAllFrom;
                        d && (i.allowContentOf.add(d),
                        i.allowWhere.add(d),
                        i.allowAttributesOf.add(d),
                        i.inheritTypesFrom.add(d))
                    }
                }(s, t),
                t
            }
            function b3(s, e) {
                for (const t of e.allowIn) {
                    const r = s[t];
                    r ? r.allowChildren.add(e.name) : e.allowIn.delete(t)
                }
            }
            function w3(s, e) {
                for (const t of e.allowChildren) {
                    const r = s[t];
                    r ? r.allowIn.add(e.name) : e.allowChildren.delete(t)
                }
            }
            function A3(s, e) {
                for (const t of e.disallowIn) {
                    const r = s[t];
                    r ? r.disallowChildren.add(e.name) : e.disallowIn.delete(t)
                }
            }
            function v3(s, e) {
                for (const t of e.disallowChildren) {
                    const r = s[t];
                    r ? r.disallowIn.add(e.name) : e.disallowChildren.delete(t)
                }
            }
            function _3(s, e) {
                for (const t of e.disallowChildren)
                    e.allowChildren.delete(t);
                for (const t of e.disallowIn)
                    e.allowIn.delete(t);
                for (const t of e.disallowAttributes)
                    e.allowAttributes.delete(t)
            }
            function C3(s, e) {
                for (const t of e.allowContentOf) {
                    const r = s[t];
                    r && (r.disallowChildren.forEach(i => {
                        e.allowChildren.has(i) || (e.disallowChildren.add(i),
                        s[i].disallowIn.add(e.name))
                    }
                    ),
                    r.allowChildren.forEach(i => {
                        e.disallowChildren.has(i) || (e.allowChildren.add(i),
                        s[i].allowIn.add(e.name))
                    }
                    ))
                }
            }
            function y3(s, e) {
                for (const t of e.allowWhere) {
                    const r = s[t];
                    r && (r.disallowIn.forEach(i => {
                        e.allowIn.has(i) || (e.disallowIn.add(i),
                        s[i].disallowChildren.add(e.name))
                    }
                    ),
                    r.allowIn.forEach(i => {
                        e.disallowIn.has(i) || (e.allowIn.add(i),
                        s[i].allowChildren.add(e.name))
                    }
                    ))
                }
            }
            function x3(s, e) {
                for (const t of e.allowAttributesOf) {
                    const r = s[t];
                    if (!r)
                        return;
                    r.allowAttributes.forEach(i => {
                        e.disallowAttributes.has(i) || e.allowAttributes.add(i)
                    }
                    )
                }
            }
            function E3(s, e) {
                for (const t of e.inheritTypesFrom) {
                    const r = s[t];
                    if (r) {
                        const i = Object.keys(r).filter(l => l.startsWith("is"));
                        for (const l of i)
                            l in e || (e[l] = r[l])
                    }
                }
            }
            function Pr(s, e, t) {
                for (const r of s) {
                    let i = r[t];
                    typeof i == "string" && (i = [i]),
                    Array.isArray(i) && i.forEach(l => e[t].add(l))
                }
            }
            function S3(s) {
                return typeof s == "string" || s.is("documentFragment") ? {
                    name: typeof s == "string" ? s : "$documentFragment",
                    *getAttributeKeys() {},
                    getAttribute() {}
                } : {
                    name: s.is("element") ? s.name : "$text",
                    *getAttributeKeys() {
                        yield*s.getAttributeKeys()
                    },
                    getAttribute: e => s.getAttribute(e)
                }
            }
            function P_(s, e, t) {
                for (const r of e.getAttributeKeys())
                    s.checkAttribute(e, r) || t.removeAttribute(r, e)
            }
            class D3 extends Se() {
                constructor(e) {
                    super(),
                    C(this, "conversionApi"),
                    C(this, "_splitParts", new Map),
                    C(this, "_cursorParents", new Map),
                    C(this, "_modelCursor", null),
                    C(this, "_emptyElementsToKeep", new Set),
                    this.conversionApi = {
                        ...e,
                        consumable: null,
                        writer: null,
                        store: null,
                        convertItem: (t, r) => this._convertItem(t, r),
                        convertChildren: (t, r) => this._convertChildren(t, r),
                        safeInsert: (t, r) => this._safeInsert(t, r),
                        updateConversionResult: (t, r) => this._updateConversionResult(t, r),
                        splitToAllowedParent: (t, r) => this._splitToAllowedParent(t, r),
                        getSplitParts: t => this._getSplitParts(t),
                        keepEmptyElement: t => this._keepEmptyElement(t)
                    }
                }
                convert(e, t, r=["$root"]) {
                    this.fire("viewCleanup", e),
                    this._modelCursor = function(d, h) {
                        let m;
                        for (const g of new Bi(d)) {
                            const b = {};
                            for (const x of g.getAttributeKeys())
                                b[x] = g.getAttribute(x);
                            const v = h.createElement(g.name, b);
                            m && h.insert(v, m),
                            m = ne._createAt(v, 0)
                        }
                        return m
                    }(r, t),
                    this.conversionApi.writer = t,
                    this.conversionApi.consumable = _l.createFrom(e),
                    this.conversionApi.store = {};
                    const {modelRange: i} = this._convertItem(e, this._modelCursor)
                      , l = t.createDocumentFragment();
                    if (i) {
                        this._removeEmptyElements();
                        for (const d of Array.from(this._modelCursor.parent.getChildren()))
                            t.append(d, l);
                        l.markers = function(d, h) {
                            const m = new Set
                              , g = new Map
                              , b = J._createIn(d).getItems();
                            for (const v of b)
                                v.is("element", "$marker") && m.add(v);
                            for (const v of m) {
                                const x = v.getAttribute("data-name")
                                  , T = h.createPositionBefore(v);
                                g.has(x) ? g.get(x).end = T.clone() : g.set(x, new J(T.clone())),
                                h.remove(v)
                            }
                            return g
                        }(l, t)
                    }
                    return this._modelCursor = null,
                    this._splitParts.clear(),
                    this._cursorParents.clear(),
                    this._emptyElementsToKeep.clear(),
                    this.conversionApi.writer = null,
                    this.conversionApi.store = null,
                    l
                }
                _convertItem(e, t) {
                    const r = {
                        viewItem: e,
                        modelCursor: t,
                        modelRange: null
                    };
                    if (e.is("element") ? this.fire(`element:${e.name}`, r, this.conversionApi) : e.is("$text") ? this.fire("text", r, this.conversionApi) : this.fire("documentFragment", r, this.conversionApi),
                    r.modelRange && !(r.modelRange instanceof J))
                        throw new U("view-conversion-dispatcher-incorrect-result",this);
                    return {
                        modelRange: r.modelRange,
                        modelCursor: r.modelCursor
                    }
                }
                _convertChildren(e, t) {
                    let r = t.is("position") ? t : ne._createAt(t, 0);
                    const i = new J(r);
                    for (const l of Array.from(e.getChildren())) {
                        const d = this._convertItem(l, r);
                        d.modelRange instanceof J && (i.end = d.modelRange.end,
                        r = d.modelCursor)
                    }
                    return {
                        modelRange: i,
                        modelCursor: r
                    }
                }
                _safeInsert(e, t) {
                    const r = this._splitToAllowedParent(e, t);
                    return !!r && (this.conversionApi.writer.insert(e, r.position),
                    !0)
                }
                _updateConversionResult(e, t) {
                    const r = this._getSplitParts(e)
                      , i = this.conversionApi.writer;
                    t.modelRange || (t.modelRange = i.createRange(i.createPositionBefore(e), i.createPositionAfter(r[r.length - 1])));
                    const l = this._cursorParents.get(e);
                    t.modelCursor = l ? i.createPositionAt(l, 0) : t.modelRange.end
                }
                _splitToAllowedParent(e, t) {
                    const {schema: r, writer: i} = this.conversionApi;
                    let l = r.findAllowedParent(t, e);
                    if (l) {
                        if (l === t.parent)
                            return {
                                position: t
                            };
                        this._modelCursor.parent.getAncestors().includes(l) && (l = null)
                    }
                    if (!l)
                        return x_(t, e, r) ? {
                            position: E_(t, i)
                        } : null;
                    const d = this.conversionApi.writer.split(t, l)
                      , h = [];
                    for (const g of d.range.getWalker())
                        if (g.type == "elementEnd")
                            h.push(g.item);
                        else {
                            const b = h.pop()
                              , v = g.item;
                            this._registerSplitPair(b, v)
                        }
                    const m = d.range.end.parent;
                    return this._cursorParents.set(e, m),
                    {
                        position: d.position,
                        cursorParent: m
                    }
                }
                _registerSplitPair(e, t) {
                    this._splitParts.has(e) || this._splitParts.set(e, [e]);
                    const r = this._splitParts.get(e);
                    this._splitParts.set(t, r),
                    r.push(t)
                }
                _getSplitParts(e) {
                    let t;
                    return t = this._splitParts.has(e) ? this._splitParts.get(e) : [e],
                    t
                }
                _keepEmptyElement(e) {
                    this._emptyElementsToKeep.add(e)
                }
                _removeEmptyElements() {
                    let e = !1;
                    for (const t of this._splitParts.keys())
                        t.isEmpty && !this._emptyElementsToKeep.has(t) && (this.conversionApi.writer.remove(t),
                        this._splitParts.delete(t),
                        e = !0);
                    e && this._removeEmptyElements()
                }
            }
            class T3 {
                getHtml(e) {
                    const t = w.document.implementation.createHTMLDocument("").createElement("div");
                    return t.appendChild(e),
                    t.innerHTML
                }
            }
            class I3 {
                constructor(e) {
                    C(this, "domParser"),
                    C(this, "domConverter"),
                    C(this, "htmlWriter"),
                    C(this, "skipComments", !0),
                    this.domParser = new DOMParser,
                    this.domConverter = new Fd(e,{
                        renderingMode: "data"
                    }),
                    this.htmlWriter = new T3
                }
                toData(e) {
                    const t = this.domConverter.viewToDom(e);
                    return this.htmlWriter.getHtml(t)
                }
                toView(e) {
                    const t = this._toDom(e);
                    return this.domConverter.domToView(t, {
                        skipComments: this.skipComments
                    })
                }
                registerRawContentMatcher(e) {
                    this.domConverter.registerRawContentMatcher(e)
                }
                useFillerType(e) {
                    this.domConverter.blockFillerMode = e == "marked" ? "markedNbsp" : "nbsp"
                }
                _toDom(e) {
                    e.match(/<(?:html|body|head|meta)(?:\s[^>]*)?>/i) || (e = `<body>${e}</body>`);
                    const t = this.domParser.parseFromString(e, "text/html")
                      , r = t.createDocumentFragment()
                      , i = t.body.childNodes;
                    for (; i.length > 0; )
                        r.appendChild(i[0]);
                    return r
                }
            }
            class M3 extends Se() {
                constructor(e, t) {
                    super(),
                    C(this, "model"),
                    C(this, "mapper"),
                    C(this, "downcastDispatcher"),
                    C(this, "upcastDispatcher"),
                    C(this, "viewDocument"),
                    C(this, "stylesProcessor"),
                    C(this, "htmlProcessor"),
                    C(this, "processor"),
                    C(this, "_viewWriter"),
                    this.model = e,
                    this.mapper = new d_,
                    this.downcastDispatcher = new u_({
                        mapper: this.mapper,
                        schema: e.schema
                    }),
                    this.downcastDispatcher.on("insert:$text", (r, i, l) => {
                        if (!l.consumable.consume(i.item, r.name))
                            return;
                        const d = l.writer
                          , h = l.mapper.toViewPosition(i.range.start)
                          , m = d.createText(i.item.data);
                        d.insert(h, m)
                    }
                    , {
                        priority: "lowest"
                    }),
                    this.downcastDispatcher.on("insert", (r, i, l) => {
                        l.convertAttributes(i.item),
                        i.reconversion || !i.item.is("element") || i.item.isEmpty || l.convertChildren(i.item)
                    }
                    , {
                        priority: "lowest"
                    }),
                    this.upcastDispatcher = new D3({
                        schema: e.schema
                    }),
                    this.viewDocument = new zd(t),
                    this.stylesProcessor = t,
                    this.htmlProcessor = new I3(this.viewDocument),
                    this.processor = this.htmlProcessor,
                    this._viewWriter = new jv(this.viewDocument),
                    this.upcastDispatcher.on("text", (r, i, {schema: l, consumable: d, writer: h}) => {
                        let m = i.modelCursor;
                        if (!d.test(i.viewItem))
                            return;
                        if (!l.checkChild(m, "$text")) {
                            if (!x_(m, "$text", l) || i.viewItem.data.trim().length == 0)
                                return;
                            const b = m.nodeBefore;
                            m = E_(m, h),
                            b && b.is("element", "$marker") && (h.move(h.createRangeOn(b), m),
                            m = h.createPositionAfter(b))
                        }
                        d.consume(i.viewItem);
                        const g = h.createText(i.viewItem.data);
                        h.insert(g, m),
                        i.modelRange = h.createRange(m, m.getShiftedBy(g.offsetSize)),
                        i.modelCursor = i.modelRange.end
                    }
                    , {
                        priority: "lowest"
                    }),
                    this.upcastDispatcher.on("element", (r, i, l) => {
                        if (!i.modelRange && l.consumable.consume(i.viewItem, {
                            name: !0
                        })) {
                            const {modelRange: d, modelCursor: h} = l.convertChildren(i.viewItem, i.modelCursor);
                            i.modelRange = d,
                            i.modelCursor = h
                        }
                    }
                    , {
                        priority: "lowest"
                    }),
                    this.upcastDispatcher.on("documentFragment", (r, i, l) => {
                        if (!i.modelRange && l.consumable.consume(i.viewItem, {
                            name: !0
                        })) {
                            const {modelRange: d, modelCursor: h} = l.convertChildren(i.viewItem, i.modelCursor);
                            i.modelRange = d,
                            i.modelCursor = h
                        }
                    }
                    , {
                        priority: "lowest"
                    }),
                    ye().prototype.decorate.call(this, "init"),
                    ye().prototype.decorate.call(this, "set"),
                    ye().prototype.decorate.call(this, "get"),
                    ye().prototype.decorate.call(this, "toView"),
                    ye().prototype.decorate.call(this, "toModel"),
                    this.on("init", () => {
                        this.fire("ready")
                    }
                    , {
                        priority: "lowest"
                    }),
                    this.on("ready", () => {
                        this.model.enqueueChange({
                            isUndoable: !1
                        }, y_)
                    }
                    , {
                        priority: "lowest"
                    })
                }
                get(e={}) {
                    const {rootName: t="main", trim: r="empty"} = e;
                    if (!this._checkIfRootsExists([t]))
                        throw new U("datacontroller-get-non-existent-root",this);
                    const i = this.model.document.getRoot(t);
                    return i.isAttached() || de("datacontroller-get-detached-root", this),
                    r !== "empty" || this.model.hasContent(i, {
                        ignoreWhitespaces: !0
                    }) ? this.stringify(i, e) : ""
                }
                stringify(e, t={}) {
                    const r = this.toView(e, t);
                    return this.processor.toData(r)
                }
                toView(e, t={}) {
                    const r = this.viewDocument
                      , i = this._viewWriter;
                    this.mapper.clearBindings();
                    const l = J._createIn(e)
                      , d = new Ti(r);
                    this.mapper.bindElements(e, d);
                    const h = e.is("documentFragment") ? e.markers : function(m) {
                        const g = []
                          , b = m.root.document;
                        if (!b)
                            return new Map;
                        const v = J._createIn(m);
                        for (const x of b.model.markers) {
                            const T = x.getRange()
                              , I = T.isCollapsed
                              , P = T.start.isEqual(v.start) || T.end.isEqual(v.end);
                            if (I && P)
                                g.push([x.name, T]);
                            else {
                                const O = v.getIntersection(T);
                                O && g.push([x.name, O])
                            }
                        }
                        return g.sort( ([x,T], [I,P]) => {
                            if (T.end.compareWith(P.start) !== "after")
                                return 1;
                            if (T.start.compareWith(P.end) !== "before")
                                return -1;
                            switch (T.start.compareWith(P.start)) {
                            case "before":
                                return 1;
                            case "after":
                                return -1;
                            default:
                                switch (T.end.compareWith(P.end)) {
                                case "before":
                                    return 1;
                                case "after":
                                    return -1;
                                default:
                                    return I.localeCompare(x)
                                }
                            }
                        }
                        ),
                        new Map(g)
                    }(e);
                    return this.downcastDispatcher.convert(l, h, i, t),
                    d
                }
                init(e) {
                    if (this.model.document.version)
                        throw new U("datacontroller-init-document-not-empty",this);
                    let t = {};
                    if (typeof e == "string" ? t.main = e : t = e,
                    !this._checkIfRootsExists(Object.keys(t)))
                        throw new U("datacontroller-init-non-existent-root",this);
                    return this.model.enqueueChange({
                        isUndoable: !1
                    }, r => {
                        for (const i of Object.keys(t)) {
                            const l = this.model.document.getRoot(i);
                            r.insert(this.parse(t[i], l), l, 0)
                        }
                    }
                    ),
                    Promise.resolve()
                }
                set(e, t={}) {
                    let r = {};
                    if (typeof e == "string" ? r.main = e : r = e,
                    !this._checkIfRootsExists(Object.keys(r)))
                        throw new U("datacontroller-set-non-existent-root",this);
                    this.model.enqueueChange(t.batchType || {}, i => {
                        i.setSelection(null),
                        i.removeSelectionAttribute(this.model.document.selection.getAttributeKeys());
                        for (const l of Object.keys(r)) {
                            const d = this.model.document.getRoot(l);
                            i.remove(i.createRangeIn(d)),
                            i.insert(this.parse(r[l], d), d, 0)
                        }
                    }
                    )
                }
                parse(e, t="$root") {
                    const r = this.processor.toView(e);
                    return this.toModel(r, t)
                }
                toModel(e, t="$root") {
                    return this.model.change(r => this.upcastDispatcher.convert(e, r, t))
                }
                addStyleProcessorRules(e) {
                    e(this.stylesProcessor)
                }
                registerRawContentMatcher(e) {
                    this.processor && this.processor !== this.htmlProcessor && this.processor.registerRawContentMatcher(e),
                    this.htmlProcessor.registerRawContentMatcher(e)
                }
                destroy() {
                    this.stopListening()
                }
                _checkIfRootsExists(e) {
                    for (const t of e)
                        if (!this.model.document.getRoot(t))
                            return !1;
                    return !0
                }
            }
            class B3 {
                constructor(e, t) {
                    C(this, "_helpers", new Map),
                    C(this, "_downcast"),
                    C(this, "_upcast"),
                    this._downcast = Ze(e),
                    this._createConversionHelpers({
                        name: "downcast",
                        dispatchers: this._downcast,
                        isDowncast: !0
                    }),
                    this._upcast = Ze(t),
                    this._createConversionHelpers({
                        name: "upcast",
                        dispatchers: this._upcast,
                        isDowncast: !1
                    })
                }
                addAlias(e, t) {
                    const r = this._downcast.includes(t);
                    if (!this._upcast.includes(t) && !r)
                        throw new U("conversion-add-alias-dispatcher-not-registered",this);
                    this._createConversionHelpers({
                        name: e,
                        dispatchers: [t],
                        isDowncast: r
                    })
                }
                for(e) {
                    if (!this._helpers.has(e))
                        throw new U("conversion-for-unknown-group",this);
                    return this._helpers.get(e)
                }
                elementToElement(e) {
                    this.for("downcast").elementToElement(e);
                    for (const {model: t, view: r} of Bp(e))
                        this.for("upcast").elementToElement({
                            model: t,
                            view: r,
                            converterPriority: e.converterPriority
                        })
                }
                attributeToElement(e) {
                    this.for("downcast").attributeToElement(e);
                    for (const {model: t, view: r} of Bp(e))
                        this.for("upcast").elementToAttribute({
                            view: r,
                            model: t,
                            converterPriority: e.converterPriority
                        })
                }
                attributeToAttribute(e) {
                    this.for("downcast").attributeToAttribute(e);
                    for (const {model: t, view: r} of Bp(e))
                        this.for("upcast").attributeToAttribute({
                            view: r,
                            model: t
                        })
                }
                _createConversionHelpers({name: e, dispatchers: t, isDowncast: r}) {
                    if (this._helpers.has(e))
                        throw new U("conversion-group-exists",this);
                    const i = r ? new s3(t) : new h3(t);
                    this._helpers.set(e, i)
                }
            }
            function *Bp(s) {
                if (s.model.values)
                    for (const e of s.model.values) {
                        const t = {
                            key: s.model.key,
                            value: e
                        }
                          , r = s.view[e]
                          , i = s.upcastAlso ? s.upcastAlso[e] : void 0;
                        yield*j_(t, r, i)
                    }
                else
                    yield*j_(s.model, s.view, s.upcastAlso)
            }
            function *j_(s, e, t) {
                if (yield{
                    model: s,
                    view: e
                },
                t)
                    for (const r of Ze(t))
                        yield{
                            model: s,
                            view: r
                        }
            }
            class Mo {
                constructor(e) {
                    C(this, "baseVersion"),
                    C(this, "isDocumentOperation"),
                    C(this, "batch"),
                    this.baseVersion = e,
                    this.isDocumentOperation = this.baseVersion !== null,
                    this.batch = null
                }
                _validate() {}
                toJSON() {
                    const e = Object.assign({}, this);
                    return e.__className = this.constructor.className,
                    delete e.batch,
                    delete e.isDocumentOperation,
                    e
                }
                static get className() {
                    return "Operation"
                }
                static fromJSON(e, t) {
                    return new this(e.baseVersion)
                }
            }
            function Np(s, e) {
                const t = z_(e)
                  , r = t.reduce( (d, h) => d + h.offsetSize, 0)
                  , i = s.parent;
                xl(s);
                const l = s.index;
                return i._insertChild(l, t),
                yl(i, l + t.length),
                yl(i, l),
                new J(s,s.getShiftedBy(r))
            }
            function L_(s) {
                if (!s.isFlat)
                    throw new U("operation-utils-remove-range-not-flat",this);
                const e = s.start.parent;
                xl(s.start),
                xl(s.end);
                const t = e._removeChildren(s.start.index, s.end.index - s.start.index);
                return yl(e, s.start.index),
                t
            }
            function Cl(s, e) {
                if (!s.isFlat)
                    throw new U("operation-utils-move-range-not-flat",this);
                const t = L_(s);
                return Np(e = e._getTransformedByDeletion(s.start, s.end.offset - s.start.offset), t)
            }
            function z_(s) {
                const e = [];
                (function t(r) {
                    if (typeof r == "string")
                        e.push(new $e(r));
                    else if (r instanceof fr)
                        e.push(new $e(r.data,r.getAttributes()));
                    else if (r instanceof Ii)
                        e.push(r);
                    else if (yo(r))
                        for (const i of r)
                            t(i)
                }
                )(s);
                for (let t = 1; t < e.length; t++) {
                    const r = e[t]
                      , i = e[t - 1];
                    r instanceof $e && i instanceof $e && O_(r, i) && (e.splice(t - 1, 2, new $e(i.data + r.data,i.getAttributes())),
                    t--)
                }
                return e
            }
            function yl(s, e) {
                const t = s.getChild(e - 1)
                  , r = s.getChild(e);
                if (t && r && t.is("$text") && r.is("$text") && O_(t, r)) {
                    const i = new $e(t.data + r.data,t.getAttributes());
                    s._removeChildren(e - 1, 2),
                    s._insertChild(e - 1, i)
                }
            }
            function xl(s) {
                const e = s.textNode
                  , t = s.parent;
                if (e) {
                    const r = s.offset - e.startOffset
                      , i = e.index;
                    t._removeChildren(i, 1);
                    const l = new $e(e.data.substr(0, r),e.getAttributes())
                      , d = new $e(e.data.substr(r),e.getAttributes());
                    t._insertChild(i, [l, d])
                }
            }
            function O_(s, e) {
                const t = s.getAttributes()
                  , r = e.getAttributes();
                for (const i of t) {
                    if (i[1] !== e.getAttribute(i[0]))
                        return !1;
                    r.next()
                }
                return r.next().done
            }
            class je extends Mo {
                constructor(e, t, r, i) {
                    super(i),
                    C(this, "sourcePosition"),
                    C(this, "howMany"),
                    C(this, "targetPosition"),
                    this.sourcePosition = e.clone(),
                    this.sourcePosition.stickiness = "toNext",
                    this.howMany = t,
                    this.targetPosition = r.clone(),
                    this.targetPosition.stickiness = "toNone"
                }
                get type() {
                    return this.targetPosition.root.rootName == "$graveyard" ? "remove" : this.sourcePosition.root.rootName == "$graveyard" ? "reinsert" : "move"
                }
                get affectedSelectable() {
                    return [J._createFromPositionAndShift(this.sourcePosition, this.howMany), J._createFromPositionAndShift(this.targetPosition, 0)]
                }
                clone() {
                    return new je(this.sourcePosition,this.howMany,this.targetPosition,this.baseVersion)
                }
                getMovedRangeStart() {
                    return this.targetPosition._getTransformedByDeletion(this.sourcePosition, this.howMany)
                }
                getReversed() {
                    const e = this.sourcePosition._getTransformedByInsertion(this.targetPosition, this.howMany);
                    return new je(this.getMovedRangeStart(),this.howMany,e,this.baseVersion + 1)
                }
                _validate() {
                    const e = this.sourcePosition.parent
                      , t = this.targetPosition.parent
                      , r = this.sourcePosition.offset
                      , i = this.targetPosition.offset;
                    if (r + this.howMany > e.maxOffset)
                        throw new U("move-operation-nodes-do-not-exist",this);
                    if (e === t && r < i && i < r + this.howMany)
                        throw new U("move-operation-range-into-itself",this);
                    if (this.sourcePosition.root == this.targetPosition.root && ro(this.sourcePosition.getParentPath(), this.targetPosition.getParentPath()) == "prefix") {
                        const l = this.sourcePosition.path.length - 1;
                        if (this.targetPosition.path[l] >= r && this.targetPosition.path[l] < r + this.howMany)
                            throw new U("move-operation-node-into-itself",this)
                    }
                }
                _execute() {
                    Cl(J._createFromPositionAndShift(this.sourcePosition, this.howMany), this.targetPosition)
                }
                toJSON() {
                    const e = super.toJSON();
                    return e.sourcePosition = this.sourcePosition.toJSON(),
                    e.targetPosition = this.targetPosition.toJSON(),
                    e
                }
                static get className() {
                    return "MoveOperation"
                }
                static fromJSON(e, t) {
                    const r = ne.fromJSON(e.sourcePosition, t)
                      , i = ne.fromJSON(e.targetPosition, t);
                    return new this(r,e.howMany,i,e.baseVersion)
                }
            }
            class Ot extends Mo {
                constructor(e, t, r) {
                    super(r),
                    C(this, "position"),
                    C(this, "nodes"),
                    C(this, "shouldReceiveAttributes"),
                    this.position = e.clone(),
                    this.position.stickiness = "toNone",
                    this.nodes = new bl(z_(t)),
                    this.shouldReceiveAttributes = !1
                }
                get type() {
                    return "insert"
                }
                get howMany() {
                    return this.nodes.maxOffset
                }
                get affectedSelectable() {
                    return this.position.clone()
                }
                clone() {
                    const e = new bl([...this.nodes].map(r => r._clone(!0)))
                      , t = new Ot(this.position,e,this.baseVersion);
                    return t.shouldReceiveAttributes = this.shouldReceiveAttributes,
                    t
                }
                getReversed() {
                    const e = this.position.root.document.graveyard
                      , t = new ne(e,[0]);
                    return new je(this.position,this.nodes.maxOffset,t,this.baseVersion + 1)
                }
                _validate() {
                    const e = this.position.parent;
                    if (!e || e.maxOffset < this.position.offset)
                        throw new U("insert-operation-position-invalid",this)
                }
                _execute() {
                    const e = this.nodes;
                    this.nodes = new bl([...e].map(t => t._clone(!0))),
                    Np(this.position, e)
                }
                toJSON() {
                    const e = super.toJSON();
                    return e.position = this.position.toJSON(),
                    e.nodes = this.nodes.toJSON(),
                    e
                }
                static get className() {
                    return "InsertOperation"
                }
                static fromJSON(e, t) {
                    const r = [];
                    for (const l of e.nodes)
                        l.name ? r.push(Fe.fromJSON(l)) : r.push($e.fromJSON(l));
                    const i = new Ot(ne.fromJSON(e.position, t),r,e.baseVersion);
                    return i.shouldReceiveAttributes = e.shouldReceiveAttributes,
                    i
                }
            }
            class qe extends Mo {
                constructor(e, t, r, i, l) {
                    super(l),
                    C(this, "splitPosition"),
                    C(this, "howMany"),
                    C(this, "insertionPosition"),
                    C(this, "graveyardPosition"),
                    this.splitPosition = e.clone(),
                    this.splitPosition.stickiness = "toNext",
                    this.howMany = t,
                    this.insertionPosition = r,
                    this.graveyardPosition = i ? i.clone() : null,
                    this.graveyardPosition && (this.graveyardPosition.stickiness = "toNext")
                }
                get type() {
                    return "split"
                }
                get moveTargetPosition() {
                    const e = this.insertionPosition.path.slice();
                    return e.push(0),
                    new ne(this.insertionPosition.root,e)
                }
                get movedRange() {
                    const e = this.splitPosition.getShiftedBy(Number.POSITIVE_INFINITY);
                    return new J(this.splitPosition,e)
                }
                get affectedSelectable() {
                    const e = [J._createFromPositionAndShift(this.splitPosition, 0), J._createFromPositionAndShift(this.insertionPosition, 0)];
                    return this.graveyardPosition && e.push(J._createFromPositionAndShift(this.graveyardPosition, 0)),
                    e
                }
                clone() {
                    return new qe(this.splitPosition,this.howMany,this.insertionPosition,this.graveyardPosition,this.baseVersion)
                }
                getReversed() {
                    const e = this.splitPosition.root.document.graveyard
                      , t = new ne(e,[0]);
                    return new mt(this.moveTargetPosition,this.howMany,this.splitPosition,t,this.baseVersion + 1)
                }
                _validate() {
                    const e = this.splitPosition.parent
                      , t = this.splitPosition.offset;
                    if (!e || e.maxOffset < t)
                        throw new U("split-operation-position-invalid",this);
                    if (!e.parent)
                        throw new U("split-operation-split-in-root",this);
                    if (this.howMany != e.maxOffset - this.splitPosition.offset)
                        throw new U("split-operation-how-many-invalid",this);
                    if (this.graveyardPosition && !this.graveyardPosition.nodeAfter)
                        throw new U("split-operation-graveyard-position-invalid",this)
                }
                _execute() {
                    const e = this.splitPosition.parent;
                    if (this.graveyardPosition)
                        Cl(J._createFromPositionAndShift(this.graveyardPosition, 1), this.insertionPosition);
                    else {
                        const t = e._clone();
                        Np(this.insertionPosition, t)
                    }
                    Cl(new J(ne._createAt(e, this.splitPosition.offset),ne._createAt(e, e.maxOffset)), this.moveTargetPosition)
                }
                toJSON() {
                    const e = super.toJSON();
                    return e.splitPosition = this.splitPosition.toJSON(),
                    e.insertionPosition = this.insertionPosition.toJSON(),
                    this.graveyardPosition && (e.graveyardPosition = this.graveyardPosition.toJSON()),
                    e
                }
                static get className() {
                    return "SplitOperation"
                }
                static getInsertionPosition(e) {
                    const t = e.path.slice(0, -1);
                    return t[t.length - 1]++,
                    new ne(e.root,t,"toPrevious")
                }
                static fromJSON(e, t) {
                    const r = ne.fromJSON(e.splitPosition, t)
                      , i = ne.fromJSON(e.insertionPosition, t)
                      , l = e.graveyardPosition ? ne.fromJSON(e.graveyardPosition, t) : null;
                    return new this(r,e.howMany,i,l,e.baseVersion)
                }
            }
            class mt extends Mo {
                constructor(e, t, r, i, l) {
                    super(l),
                    C(this, "sourcePosition"),
                    C(this, "howMany"),
                    C(this, "targetPosition"),
                    C(this, "graveyardPosition"),
                    this.sourcePosition = e.clone(),
                    this.sourcePosition.stickiness = "toPrevious",
                    this.howMany = t,
                    this.targetPosition = r.clone(),
                    this.targetPosition.stickiness = "toNext",
                    this.graveyardPosition = i.clone()
                }
                get type() {
                    return "merge"
                }
                get deletionPosition() {
                    return new ne(this.sourcePosition.root,this.sourcePosition.path.slice(0, -1))
                }
                get movedRange() {
                    const e = this.sourcePosition.getShiftedBy(Number.POSITIVE_INFINITY);
                    return new J(this.sourcePosition,e)
                }
                get affectedSelectable() {
                    const e = this.sourcePosition.parent;
                    return [J._createOn(e), J._createFromPositionAndShift(this.targetPosition, 0), J._createFromPositionAndShift(this.graveyardPosition, 0)]
                }
                clone() {
                    return new mt(this.sourcePosition,this.howMany,this.targetPosition,this.graveyardPosition,this.baseVersion)
                }
                getReversed() {
                    const e = this.targetPosition._getTransformedByMergeOperation(this)
                      , t = this.sourcePosition.path.slice(0, -1)
                      , r = new ne(this.sourcePosition.root,t)._getTransformedByMergeOperation(this);
                    return new qe(e,this.howMany,r,this.graveyardPosition,this.baseVersion + 1)
                }
                _validate() {
                    const e = this.sourcePosition.parent
                      , t = this.targetPosition.parent;
                    if (!e.parent)
                        throw new U("merge-operation-source-position-invalid",this);
                    if (!t.parent)
                        throw new U("merge-operation-target-position-invalid",this);
                    if (this.howMany != e.maxOffset)
                        throw new U("merge-operation-how-many-invalid",this)
                }
                _execute() {
                    const e = this.sourcePosition.parent;
                    Cl(J._createIn(e), this.targetPosition),
                    Cl(J._createOn(e), this.graveyardPosition)
                }
                toJSON() {
                    const e = super.toJSON();
                    return e.sourcePosition = e.sourcePosition.toJSON(),
                    e.targetPosition = e.targetPosition.toJSON(),
                    e.graveyardPosition = e.graveyardPosition.toJSON(),
                    e
                }
                static get className() {
                    return "MergeOperation"
                }
                static fromJSON(e, t) {
                    const r = ne.fromJSON(e.sourcePosition, t)
                      , i = ne.fromJSON(e.targetPosition, t)
                      , l = ne.fromJSON(e.graveyardPosition, t);
                    return new this(r,e.howMany,i,l,e.baseVersion)
                }
            }
            class co extends Mo {
                constructor(e, t, r, i, l, d) {
                    super(d),
                    C(this, "name"),
                    C(this, "oldRange"),
                    C(this, "newRange"),
                    C(this, "affectsData"),
                    C(this, "_markers"),
                    this.name = e,
                    this.oldRange = t ? t.clone() : null,
                    this.newRange = r ? r.clone() : null,
                    this.affectsData = l,
                    this._markers = i
                }
                get type() {
                    return "marker"
                }
                get affectedSelectable() {
                    const e = [];
                    return this.oldRange && e.push(this.oldRange.clone()),
                    this.newRange && (this.oldRange ? e.push(...this.newRange.getDifference(this.oldRange)) : e.push(this.newRange.clone())),
                    e
                }
                clone() {
                    return new co(this.name,this.oldRange,this.newRange,this._markers,this.affectsData,this.baseVersion)
                }
                getReversed() {
                    return new co(this.name,this.newRange,this.oldRange,this._markers,this.affectsData,this.baseVersion + 1)
                }
                _execute() {
                    this.newRange ? this._markers._set(this.name, this.newRange, !0, this.affectsData) : this._markers._remove(this.name)
                }
                toJSON() {
                    const e = super.toJSON();
                    return this.oldRange && (e.oldRange = this.oldRange.toJSON()),
                    this.newRange && (e.newRange = this.newRange.toJSON()),
                    delete e._markers,
                    e
                }
                static get className() {
                    return "MarkerOperation"
                }
                static fromJSON(e, t) {
                    return new co(e.name,e.oldRange ? J.fromJSON(e.oldRange, t) : null,e.newRange ? J.fromJSON(e.newRange, t) : null,t.model.markers,e.affectsData,e.baseVersion)
                }
            }
            const R_ = function(s, e) {
                return Hd(s, e)
            };
            class wt extends Mo {
                constructor(e, t, r, i, l) {
                    super(l),
                    C(this, "range"),
                    C(this, "key"),
                    C(this, "oldValue"),
                    C(this, "newValue"),
                    this.range = e.clone(),
                    this.key = t,
                    this.oldValue = r === void 0 ? null : r,
                    this.newValue = i === void 0 ? null : i
                }
                get type() {
                    return this.oldValue === null ? "addAttribute" : this.newValue === null ? "removeAttribute" : "changeAttribute"
                }
                get affectedSelectable() {
                    return this.range.clone()
                }
                clone() {
                    return new wt(this.range,this.key,this.oldValue,this.newValue,this.baseVersion)
                }
                getReversed() {
                    return new wt(this.range,this.key,this.newValue,this.oldValue,this.baseVersion + 1)
                }
                toJSON() {
                    const e = super.toJSON();
                    return e.range = this.range.toJSON(),
                    e
                }
                _validate() {
                    if (!this.range.isFlat)
                        throw new U("attribute-operation-range-not-flat",this);
                    for (const e of this.range.getItems({
                        shallow: !0
                    })) {
                        if (this.oldValue !== null && !R_(e.getAttribute(this.key), this.oldValue))
                            throw new U("attribute-operation-wrong-old-value",this,{
                                item: e,
                                key: this.key,
                                value: this.oldValue
                            });
                        if (this.oldValue === null && this.newValue !== null && e.hasAttribute(this.key))
                            throw new U("attribute-operation-attribute-exists",this,{
                                node: e,
                                key: this.key
                            })
                    }
                }
                _execute() {
                    R_(this.oldValue, this.newValue) || function(e, t, r) {
                        xl(e.start),
                        xl(e.end);
                        for (const i of e.getItems({
                            shallow: !0
                        })) {
                            const l = i.is("$textProxy") ? i.textNode : i;
                            r !== null ? l._setAttribute(t, r) : l._removeAttribute(t),
                            yl(l.parent, l.index)
                        }
                        yl(e.end.parent, e.end.index)
                    }(this.range, this.key, this.newValue)
                }
                static get className() {
                    return "AttributeOperation"
                }
                static fromJSON(e, t) {
                    return new wt(J.fromJSON(e.range, t),e.key,e.oldValue,e.newValue,e.baseVersion)
                }
            }
            class Mt extends Mo {
                get type() {
                    return "noop"
                }
                get affectedSelectable() {
                    return null
                }
                clone() {
                    return new Mt(this.baseVersion)
                }
                getReversed() {
                    return new Mt(this.baseVersion + 1)
                }
                _execute() {}
                static get className() {
                    return "NoOperation"
                }
            }
            class uo extends Mo {
                constructor(e, t, r, i) {
                    super(i),
                    C(this, "position"),
                    C(this, "oldName"),
                    C(this, "newName"),
                    this.position = e,
                    this.position.stickiness = "toNext",
                    this.oldName = t,
                    this.newName = r
                }
                get type() {
                    return "rename"
                }
                get affectedSelectable() {
                    return this.position.nodeAfter
                }
                clone() {
                    return new uo(this.position.clone(),this.oldName,this.newName,this.baseVersion)
                }
                getReversed() {
                    return new uo(this.position.clone(),this.newName,this.oldName,this.baseVersion + 1)
                }
                _validate() {
                    const e = this.position.nodeAfter;
                    if (!(e instanceof Fe))
                        throw new U("rename-operation-wrong-position",this);
                    if (e.name !== this.oldName)
                        throw new U("rename-operation-wrong-name",this)
                }
                _execute() {
                    this.position.nodeAfter.name = this.newName
                }
                toJSON() {
                    const e = super.toJSON();
                    return e.position = this.position.toJSON(),
                    e
                }
                static get className() {
                    return "RenameOperation"
                }
                static fromJSON(e, t) {
                    return new uo(ne.fromJSON(e.position, t),e.oldName,e.newName,e.baseVersion)
                }
            }
            class Yr extends Mo {
                constructor(e, t, r, i, l) {
                    super(l),
                    C(this, "root"),
                    C(this, "key"),
                    C(this, "oldValue"),
                    C(this, "newValue"),
                    this.root = e,
                    this.key = t,
                    this.oldValue = r === void 0 ? null : r,
                    this.newValue = i === void 0 ? null : i
                }
                get type() {
                    return this.oldValue === null ? "addRootAttribute" : this.newValue === null ? "removeRootAttribute" : "changeRootAttribute"
                }
                get affectedSelectable() {
                    return this.root
                }
                clone() {
                    return new Yr(this.root,this.key,this.oldValue,this.newValue,this.baseVersion)
                }
                getReversed() {
                    return new Yr(this.root,this.key,this.newValue,this.oldValue,this.baseVersion + 1)
                }
                _validate() {
                    if (this.root != this.root.root || this.root.is("documentFragment"))
                        throw new U("rootattribute-operation-not-a-root",this,{
                            root: this.root,
                            key: this.key
                        });
                    if (this.oldValue !== null && this.root.getAttribute(this.key) !== this.oldValue)
                        throw new U("rootattribute-operation-wrong-old-value",this,{
                            root: this.root,
                            key: this.key
                        });
                    if (this.oldValue === null && this.newValue !== null && this.root.hasAttribute(this.key))
                        throw new U("rootattribute-operation-attribute-exists",this,{
                            root: this.root,
                            key: this.key
                        })
                }
                _execute() {
                    this.newValue !== null ? this.root._setAttribute(this.key, this.newValue) : this.root._removeAttribute(this.key)
                }
                toJSON() {
                    const e = super.toJSON();
                    return e.root = this.root.toJSON(),
                    e
                }
                static get className() {
                    return "RootAttributeOperation"
                }
                static fromJSON(e, t) {
                    if (!t.getRoot(e.root))
                        throw new U("rootattribute-operation-fromjson-no-root",this,{
                            rootName: e.root
                        });
                    return new Yr(t.getRoot(e.root),e.key,e.oldValue,e.newValue,e.baseVersion)
                }
            }
            class jr extends Mo {
                constructor(e, t, r, i, l) {
                    super(l),
                    C(this, "rootName"),
                    C(this, "elementName"),
                    C(this, "isAdd"),
                    C(this, "_document"),
                    this.rootName = e,
                    this.elementName = t,
                    this.isAdd = r,
                    this._document = i,
                    !this._document.getRoot(this.rootName) && (this._document.createRoot(this.elementName, this.rootName)._isAttached = !1)
                }
                get type() {
                    return this.isAdd ? "addRoot" : "detachRoot"
                }
                get affectedSelectable() {
                    return this._document.getRoot(this.rootName)
                }
                clone() {
                    return new jr(this.rootName,this.elementName,this.isAdd,this._document,this.baseVersion)
                }
                getReversed() {
                    return new jr(this.rootName,this.elementName,!this.isAdd,this._document,this.baseVersion + 1)
                }
                _execute() {
                    this._document.getRoot(this.rootName)._isAttached = this.isAdd
                }
                toJSON() {
                    const e = super.toJSON();
                    return delete e._document,
                    e
                }
                static get className() {
                    return "RootOperation"
                }
                static fromJSON(e, t) {
                    return new jr(e.rootName,e.elementName,e.isAdd,t,e.baseVersion)
                }
            }
            const Go = {};
            Go[wt.className] = wt,
            Go[Ot.className] = Ot,
            Go[co.className] = co,
            Go[je.className] = je,
            Go[Mt.className] = Mt,
            Go[Mo.className] = Mo,
            Go[uo.className] = uo,
            Go[Yr.className] = Yr,
            Go[jr.className] = jr,
            Go[qe.className] = qe,
            Go[mt.className] = mt;
            class N3 {
                static fromJSON(e, t) {
                    return Go[e.__className].fromJSON(e, t)
                }
            }
            const Pp = new Map;
            function Pe(s, e, t) {
                let r = Pp.get(s);
                r || (r = new Map,
                Pp.set(s, r)),
                r.set(e, t)
            }
            function P3(s) {
                return [s]
            }
            function F_(s, e, t={}) {
                const r = function(i, l) {
                    const d = Pp.get(i);
                    return d && d.has(l) ? d.get(l) : P3
                }(s.constructor, e.constructor);
                try {
                    return r(s = s.clone(), e, t)
                } catch (i) {
                    throw i
                }
            }
            function j3(s, e, t) {
                s = s.slice(),
                e = e.slice();
                const r = new L3(t.document,t.useRelations,t.forceWeakRemove);
                r.setOriginalOperations(s),
                r.setOriginalOperations(e);
                const i = r.originalOperations;
                if (s.length == 0 || e.length == 0)
                    return {
                        operationsA: s,
                        operationsB: e,
                        originalOperations: i
                    };
                const l = new WeakMap;
                for (const m of s)
                    l.set(m, 0);
                const d = {
                    nextBaseVersionA: s[s.length - 1].baseVersion + 1,
                    nextBaseVersionB: e[e.length - 1].baseVersion + 1,
                    originalOperationsACount: s.length,
                    originalOperationsBCount: e.length
                };
                let h = 0;
                for (; h < s.length; ) {
                    const m = s[h]
                      , g = l.get(m);
                    if (g == e.length) {
                        h++;
                        continue
                    }
                    const b = e[g]
                      , v = F_(m, b, r.getContext(m, b, !0))
                      , x = F_(b, m, r.getContext(b, m, !1));
                    r.updateRelation(m, b),
                    r.setOriginalOperations(v, m),
                    r.setOriginalOperations(x, b);
                    for (const T of v)
                        l.set(T, g + x.length);
                    s.splice(h, 1, ...v),
                    e.splice(g, 1, ...x)
                }
                return V_(s, d.nextBaseVersionB),
                V_(e, d.nextBaseVersionA),
                {
                    operationsA: s,
                    operationsB: e,
                    originalOperations: i
                }
            }
            class L3 {
                constructor(e, t, r=!1) {
                    C(this, "originalOperations"),
                    C(this, "_history"),
                    C(this, "_useRelations"),
                    C(this, "_forceWeakRemove"),
                    C(this, "_relations"),
                    this.originalOperations = new Map,
                    this._history = e.history,
                    this._useRelations = t,
                    this._forceWeakRemove = !!r,
                    this._relations = new Map
                }
                setOriginalOperations(e, t=null) {
                    const r = t ? this.originalOperations.get(t) : null;
                    for (const i of e)
                        this.originalOperations.set(i, r || i)
                }
                updateRelation(e, t) {
                    if (e instanceof je)
                        t instanceof mt ? e.targetPosition.isEqual(t.sourcePosition) || t.movedRange.containsPosition(e.targetPosition) ? this._setRelation(e, t, "insertAtSource") : e.targetPosition.isEqual(t.deletionPosition) ? this._setRelation(e, t, "insertBetween") : e.targetPosition.isAfter(t.sourcePosition) && this._setRelation(e, t, "moveTargetAfter") : t instanceof je && (e.targetPosition.isEqual(t.sourcePosition) || e.targetPosition.isBefore(t.sourcePosition) ? this._setRelation(e, t, "insertBefore") : this._setRelation(e, t, "insertAfter"));
                    else if (e instanceof qe) {
                        if (t instanceof mt)
                            e.splitPosition.isBefore(t.sourcePosition) && this._setRelation(e, t, "splitBefore");
                        else if (t instanceof je)
                            if (e.splitPosition.isEqual(t.sourcePosition) || e.splitPosition.isBefore(t.sourcePosition))
                                this._setRelation(e, t, "splitBefore");
                            else {
                                const r = J._createFromPositionAndShift(t.sourcePosition, t.howMany);
                                if (e.splitPosition.hasSameParentAs(t.sourcePosition) && r.containsPosition(e.splitPosition)) {
                                    const i = r.end.offset - e.splitPosition.offset
                                      , l = e.splitPosition.offset - r.start.offset;
                                    this._setRelation(e, t, {
                                        howMany: i,
                                        offset: l
                                    })
                                }
                            }
                    } else if (e instanceof mt)
                        t instanceof mt ? (e.targetPosition.isEqual(t.sourcePosition) || this._setRelation(e, t, "mergeTargetNotMoved"),
                        e.sourcePosition.isEqual(t.targetPosition) && this._setRelation(e, t, "mergeSourceNotMoved"),
                        e.sourcePosition.isEqual(t.sourcePosition) && this._setRelation(e, t, "mergeSameElement")) : t instanceof qe ? e.sourcePosition.isEqual(t.splitPosition) && this._setRelation(e, t, "splitAtSource") : t instanceof je && t.howMany > 0 && (e.sourcePosition.isEqual(t.sourcePosition.getShiftedBy(t.howMany)) && this._setRelation(e, t, "mergeSourceAffected"),
                        e.targetPosition.isEqual(t.sourcePosition) && this._setRelation(e, t, "mergeTargetWasBefore"));
                    else if (e instanceof co) {
                        const r = e.newRange;
                        if (!r)
                            return;
                        if (t instanceof je) {
                            const i = J._createFromPositionAndShift(t.sourcePosition, t.howMany)
                              , l = i.containsPosition(r.start) || i.start.isEqual(r.start)
                              , d = i.containsPosition(r.end) || i.end.isEqual(r.end);
                            !l && !d || i.containsRange(r) || this._setRelation(e, t, {
                                side: l ? "left" : "right",
                                path: l ? r.start.path.slice() : r.end.path.slice()
                            })
                        } else if (t instanceof mt) {
                            const i = r.start.isEqual(t.targetPosition)
                              , l = r.start.isEqual(t.deletionPosition)
                              , d = r.end.isEqual(t.deletionPosition)
                              , h = r.end.isEqual(t.sourcePosition);
                            (i || l || d || h) && this._setRelation(e, t, {
                                wasInLeftElement: i,
                                wasStartBeforeMergedElement: l,
                                wasEndBeforeMergedElement: d,
                                wasInRightElement: h
                            })
                        }
                    }
                }
                getContext(e, t, r) {
                    return {
                        aIsStrong: r,
                        aWasUndone: this._wasUndone(e),
                        bWasUndone: this._wasUndone(t),
                        abRelation: this._useRelations ? this._getRelation(e, t) : null,
                        baRelation: this._useRelations ? this._getRelation(t, e) : null,
                        forceWeakRemove: this._forceWeakRemove
                    }
                }
                _wasUndone(e) {
                    const t = this.originalOperations.get(e);
                    return t.wasUndone || this._history.isUndoneOperation(t)
                }
                _getRelation(e, t) {
                    const r = this.originalOperations.get(t)
                      , i = this._history.getUndoneOperation(r);
                    if (!i)
                        return null;
                    const l = this.originalOperations.get(e)
                      , d = this._relations.get(l);
                    return d && d.get(i) || null
                }
                _setRelation(e, t, r) {
                    const i = this.originalOperations.get(e)
                      , l = this.originalOperations.get(t);
                    let d = this._relations.get(i);
                    d || (d = new Map,
                    this._relations.set(i, d)),
                    d.set(l, r)
                }
            }
            function V_(s, e) {
                for (const t of s)
                    t.baseVersion = e++
            }
            function U_(s, e, t) {
                const r = s.nodes.getNode(0).getAttribute(e);
                if (r == t)
                    return null;
                const i = new J(s.position,s.position.getShiftedBy(s.howMany));
                return new wt(i,e,r,t,0)
            }
            function H_(s, e) {
                return s.targetPosition._getTransformedByDeletion(e.sourcePosition, e.howMany) === null
            }
            function Is(s, e) {
                const t = [];
                for (let r = 0; r < s.length; r++) {
                    const i = s[r]
                      , l = new je(i.start,i.end.offset - i.start.offset,e,0);
                    t.push(l);
                    for (let d = r + 1; d < s.length; d++)
                        s[d] = s[d]._getTransformedByMove(l.sourcePosition, l.targetPosition, l.howMany)[0];
                    e = e._getTransformedByMove(l.sourcePosition, l.targetPosition, l.howMany)
                }
                return t
            }
            Pe(wt, wt, (s, e, t) => {
                if (s.key === e.key && s.range.start.hasSameParentAs(e.range.start)) {
                    const r = s.range.getDifference(e.range).map(l => new wt(l,s.key,s.oldValue,s.newValue,0))
                      , i = s.range.getIntersection(e.range);
                    return i && t.aIsStrong && r.push(new wt(i,e.key,e.newValue,s.newValue,0)),
                    r.length == 0 ? [new Mt(0)] : r
                }
                return [s]
            }
            ),
            Pe(wt, Ot, (s, e) => {
                if (s.range.start.hasSameParentAs(e.position) && s.range.containsPosition(e.position)) {
                    const t = s.range._getTransformedByInsertion(e.position, e.howMany, !e.shouldReceiveAttributes).map(r => new wt(r,s.key,s.oldValue,s.newValue,s.baseVersion));
                    if (e.shouldReceiveAttributes) {
                        const r = U_(e, s.key, s.oldValue);
                        r && t.unshift(r)
                    }
                    return t
                }
                return s.range = s.range._getTransformedByInsertion(e.position, e.howMany, !1)[0],
                [s]
            }
            ),
            Pe(wt, mt, (s, e) => {
                const t = [];
                s.range.start.hasSameParentAs(e.deletionPosition) && (s.range.containsPosition(e.deletionPosition) || s.range.start.isEqual(e.deletionPosition)) && t.push(J._createFromPositionAndShift(e.graveyardPosition, 1));
                const r = s.range._getTransformedByMergeOperation(e);
                return r.isCollapsed || t.push(r),
                t.map(i => new wt(i,s.key,s.oldValue,s.newValue,s.baseVersion))
            }
            ),
            Pe(wt, je, (s, e) => function(t, r) {
                const i = J._createFromPositionAndShift(r.sourcePosition, r.howMany);
                let l = null
                  , d = [];
                i.containsRange(t, !0) ? l = t : t.start.hasSameParentAs(i.start) ? (d = t.getDifference(i),
                l = t.getIntersection(i)) : d = [t];
                const h = [];
                for (let m of d) {
                    m = m._getTransformedByDeletion(r.sourcePosition, r.howMany);
                    const g = r.getMovedRangeStart()
                      , b = m.start.hasSameParentAs(g)
                      , v = m._getTransformedByInsertion(g, r.howMany, b);
                    h.push(...v)
                }
                return l && h.push(l._getTransformedByMove(r.sourcePosition, r.targetPosition, r.howMany, !1)[0]),
                h
            }(s.range, e).map(t => new wt(t,s.key,s.oldValue,s.newValue,s.baseVersion))),
            Pe(wt, qe, (s, e) => {
                if (s.range.end.isEqual(e.insertionPosition))
                    return e.graveyardPosition || s.range.end.offset++,
                    [s];
                if (s.range.start.hasSameParentAs(e.splitPosition) && s.range.containsPosition(e.splitPosition)) {
                    const t = s.clone();
                    return t.range = new J(e.moveTargetPosition.clone(),s.range.end._getCombined(e.splitPosition, e.moveTargetPosition)),
                    s.range.end = e.splitPosition.clone(),
                    s.range.end.stickiness = "toPrevious",
                    [s, t]
                }
                return s.range = s.range._getTransformedBySplitOperation(e),
                [s]
            }
            ),
            Pe(Ot, wt, (s, e) => {
                const t = [s];
                if (s.shouldReceiveAttributes && s.position.hasSameParentAs(e.range.start) && e.range.containsPosition(s.position)) {
                    const r = U_(s, e.key, e.newValue);
                    r && t.push(r)
                }
                return t
            }
            ),
            Pe(Ot, Ot, (s, e, t) => (s.position.isEqual(e.position) && t.aIsStrong || (s.position = s.position._getTransformedByInsertOperation(e)),
            [s])),
            Pe(Ot, je, (s, e) => (s.position = s.position._getTransformedByMoveOperation(e),
            [s])),
            Pe(Ot, qe, (s, e) => (s.position = s.position._getTransformedBySplitOperation(e),
            [s])),
            Pe(Ot, mt, (s, e) => (s.position = s.position._getTransformedByMergeOperation(e),
            [s])),
            Pe(co, Ot, (s, e) => (s.oldRange && (s.oldRange = s.oldRange._getTransformedByInsertOperation(e)[0]),
            s.newRange && (s.newRange = s.newRange._getTransformedByInsertOperation(e)[0]),
            [s])),
            Pe(co, co, (s, e, t) => {
                if (s.name == e.name) {
                    if (!t.aIsStrong)
                        return [new Mt(0)];
                    s.oldRange = e.newRange ? e.newRange.clone() : null
                }
                return [s]
            }
            ),
            Pe(co, mt, (s, e) => (s.oldRange && (s.oldRange = s.oldRange._getTransformedByMergeOperation(e)),
            s.newRange && (s.newRange = s.newRange._getTransformedByMergeOperation(e)),
            [s])),
            Pe(co, je, (s, e, t) => {
                if (s.oldRange && (s.oldRange = J._createFromRanges(s.oldRange._getTransformedByMoveOperation(e))),
                s.newRange) {
                    if (t.abRelation) {
                        const r = J._createFromRanges(s.newRange._getTransformedByMoveOperation(e));
                        if (t.abRelation.side == "left" && e.targetPosition.isEqual(s.newRange.start))
                            return s.newRange.end = r.end,
                            s.newRange.start.path = t.abRelation.path,
                            [s];
                        if (t.abRelation.side == "right" && e.targetPosition.isEqual(s.newRange.end))
                            return s.newRange.start = r.start,
                            s.newRange.end.path = t.abRelation.path,
                            [s]
                    }
                    s.newRange = J._createFromRanges(s.newRange._getTransformedByMoveOperation(e))
                }
                return [s]
            }
            ),
            Pe(co, qe, (s, e, t) => {
                if (s.oldRange && (s.oldRange = s.oldRange._getTransformedBySplitOperation(e)),
                s.newRange) {
                    if (t.abRelation) {
                        const r = s.newRange._getTransformedBySplitOperation(e);
                        return s.newRange.start.isEqual(e.splitPosition) && t.abRelation.wasStartBeforeMergedElement ? s.newRange.start = ne._createAt(e.insertionPosition) : s.newRange.start.isEqual(e.splitPosition) && !t.abRelation.wasInLeftElement && (s.newRange.start = ne._createAt(e.moveTargetPosition)),
                        s.newRange.end.isEqual(e.splitPosition) && t.abRelation.wasInRightElement ? s.newRange.end = ne._createAt(e.moveTargetPosition) : s.newRange.end.isEqual(e.splitPosition) && t.abRelation.wasEndBeforeMergedElement ? s.newRange.end = ne._createAt(e.insertionPosition) : s.newRange.end = r.end,
                        [s]
                    }
                    s.newRange = s.newRange._getTransformedBySplitOperation(e)
                }
                return [s]
            }
            ),
            Pe(mt, Ot, (s, e) => (s.sourcePosition.hasSameParentAs(e.position) && (s.howMany += e.howMany),
            s.sourcePosition = s.sourcePosition._getTransformedByInsertOperation(e),
            s.targetPosition = s.targetPosition._getTransformedByInsertOperation(e),
            [s])),
            Pe(mt, mt, (s, e, t) => {
                if (s.sourcePosition.isEqual(e.sourcePosition) && s.targetPosition.isEqual(e.targetPosition)) {
                    if (t.bWasUndone) {
                        const r = e.graveyardPosition.path.slice();
                        return r.push(0),
                        s.sourcePosition = new ne(e.graveyardPosition.root,r),
                        s.howMany = 0,
                        [s]
                    }
                    return [new Mt(0)]
                }
                if (s.sourcePosition.isEqual(e.sourcePosition) && !s.targetPosition.isEqual(e.targetPosition) && !t.bWasUndone && t.abRelation != "splitAtSource") {
                    const r = s.targetPosition.root.rootName == "$graveyard"
                      , i = e.targetPosition.root.rootName == "$graveyard";
                    if (i && !r || !(r && !i) && t.aIsStrong) {
                        const l = e.targetPosition._getTransformedByMergeOperation(e)
                          , d = s.targetPosition._getTransformedByMergeOperation(e);
                        return [new je(l,s.howMany,d,0)]
                    }
                    return [new Mt(0)]
                }
                return s.sourcePosition.hasSameParentAs(e.targetPosition) && (s.howMany += e.howMany),
                s.sourcePosition = s.sourcePosition._getTransformedByMergeOperation(e),
                s.targetPosition = s.targetPosition._getTransformedByMergeOperation(e),
                s.graveyardPosition.isEqual(e.graveyardPosition) && t.aIsStrong || (s.graveyardPosition = s.graveyardPosition._getTransformedByMergeOperation(e)),
                [s]
            }
            ),
            Pe(mt, je, (s, e, t) => {
                const r = J._createFromPositionAndShift(e.sourcePosition, e.howMany);
                return e.type == "remove" && !t.bWasUndone && !t.forceWeakRemove && s.deletionPosition.hasSameParentAs(e.sourcePosition) && r.containsPosition(s.sourcePosition) ? [new Mt(0)] : (e.sourcePosition.getShiftedBy(e.howMany).isEqual(s.sourcePosition) ? s.sourcePosition.stickiness = "toNone" : e.targetPosition.isEqual(s.sourcePosition) && t.abRelation == "mergeSourceAffected" ? s.sourcePosition.stickiness = "toNext" : e.sourcePosition.isEqual(s.targetPosition) ? (s.targetPosition.stickiness = "toNone",
                s.howMany -= e.howMany) : e.targetPosition.isEqual(s.targetPosition) && t.abRelation == "mergeTargetWasBefore" ? (s.targetPosition.stickiness = "toPrevious",
                s.howMany += e.howMany) : (s.sourcePosition.hasSameParentAs(e.targetPosition) && (s.howMany += e.howMany),
                s.sourcePosition.hasSameParentAs(e.sourcePosition) && (s.howMany -= e.howMany)),
                s.sourcePosition = s.sourcePosition._getTransformedByMoveOperation(e),
                s.targetPosition = s.targetPosition._getTransformedByMoveOperation(e),
                s.sourcePosition.stickiness = "toPrevious",
                s.targetPosition.stickiness = "toNext",
                s.graveyardPosition.isEqual(e.targetPosition) || (s.graveyardPosition = s.graveyardPosition._getTransformedByMoveOperation(e)),
                [s])
            }
            ),
            Pe(mt, qe, (s, e, t) => {
                if (e.graveyardPosition && (s.graveyardPosition = s.graveyardPosition._getTransformedByDeletion(e.graveyardPosition, 1),
                s.deletionPosition.isEqual(e.graveyardPosition) && (s.howMany = e.howMany)),
                s.targetPosition.isEqual(e.splitPosition)) {
                    const r = e.howMany != 0
                      , i = e.graveyardPosition && s.deletionPosition.isEqual(e.graveyardPosition);
                    if (r || i || t.abRelation == "mergeTargetNotMoved")
                        return s.sourcePosition = s.sourcePosition._getTransformedBySplitOperation(e),
                        [s]
                }
                if (s.sourcePosition.isEqual(e.splitPosition)) {
                    if (t.abRelation == "mergeSourceNotMoved")
                        return s.howMany = 0,
                        s.targetPosition = s.targetPosition._getTransformedBySplitOperation(e),
                        [s];
                    if (t.abRelation == "mergeSameElement" || s.sourcePosition.offset > 0)
                        return s.sourcePosition = e.moveTargetPosition.clone(),
                        s.targetPosition = s.targetPosition._getTransformedBySplitOperation(e),
                        [s]
                }
                return s.sourcePosition.hasSameParentAs(e.splitPosition) && (s.howMany = e.splitPosition.offset),
                s.sourcePosition = s.sourcePosition._getTransformedBySplitOperation(e),
                s.targetPosition = s.targetPosition._getTransformedBySplitOperation(e),
                [s]
            }
            ),
            Pe(je, Ot, (s, e) => {
                const t = J._createFromPositionAndShift(s.sourcePosition, s.howMany)._getTransformedByInsertOperation(e, !1)[0];
                return s.sourcePosition = t.start,
                s.howMany = t.end.offset - t.start.offset,
                s.targetPosition.isEqual(e.position) || (s.targetPosition = s.targetPosition._getTransformedByInsertOperation(e)),
                [s]
            }
            ),
            Pe(je, je, (s, e, t) => {
                const r = J._createFromPositionAndShift(s.sourcePosition, s.howMany)
                  , i = J._createFromPositionAndShift(e.sourcePosition, e.howMany);
                let l, d = t.aIsStrong, h = !t.aIsStrong;
                if (t.abRelation == "insertBefore" || t.baRelation == "insertAfter" ? h = !0 : t.abRelation != "insertAfter" && t.baRelation != "insertBefore" || (h = !1),
                l = s.targetPosition.isEqual(e.targetPosition) && h ? s.targetPosition._getTransformedByDeletion(e.sourcePosition, e.howMany) : s.targetPosition._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany),
                H_(s, e) && H_(e, s))
                    return [e.getReversed()];
                if (r.containsPosition(e.targetPosition) && r.containsRange(i, !0))
                    return r.start = r.start._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany),
                    r.end = r.end._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany),
                    Is([r], l);
                if (i.containsPosition(s.targetPosition) && i.containsRange(r, !0))
                    return r.start = r.start._getCombined(e.sourcePosition, e.getMovedRangeStart()),
                    r.end = r.end._getCombined(e.sourcePosition, e.getMovedRangeStart()),
                    Is([r], l);
                const m = ro(s.sourcePosition.getParentPath(), e.sourcePosition.getParentPath());
                if (m == "prefix" || m == "extension")
                    return r.start = r.start._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany),
                    r.end = r.end._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany),
                    Is([r], l);
                s.type != "remove" || e.type == "remove" || t.aWasUndone || t.forceWeakRemove ? s.type == "remove" || e.type != "remove" || t.bWasUndone || t.forceWeakRemove || (d = !1) : d = !0;
                const g = []
                  , b = r.getDifference(i);
                for (const x of b) {
                    x.start = x.start._getTransformedByDeletion(e.sourcePosition, e.howMany),
                    x.end = x.end._getTransformedByDeletion(e.sourcePosition, e.howMany);
                    const T = ro(x.start.getParentPath(), e.getMovedRangeStart().getParentPath()) == "same"
                      , I = x._getTransformedByInsertion(e.getMovedRangeStart(), e.howMany, T);
                    g.push(...I)
                }
                const v = r.getIntersection(i);
                return v !== null && d && (v.start = v.start._getCombined(e.sourcePosition, e.getMovedRangeStart()),
                v.end = v.end._getCombined(e.sourcePosition, e.getMovedRangeStart()),
                g.length === 0 ? g.push(v) : g.length == 1 ? i.start.isBefore(r.start) || i.start.isEqual(r.start) ? g.unshift(v) : g.push(v) : g.splice(1, 0, v)),
                g.length === 0 ? [new Mt(s.baseVersion)] : Is(g, l)
            }
            ),
            Pe(je, qe, (s, e, t) => {
                let r = s.targetPosition.clone();
                s.targetPosition.isEqual(e.insertionPosition) && e.graveyardPosition && t.abRelation != "moveTargetAfter" || (r = s.targetPosition._getTransformedBySplitOperation(e));
                const i = J._createFromPositionAndShift(s.sourcePosition, s.howMany);
                if (i.end.isEqual(e.insertionPosition))
                    return e.graveyardPosition || s.howMany++,
                    s.targetPosition = r,
                    [s];
                if (i.start.hasSameParentAs(e.splitPosition) && i.containsPosition(e.splitPosition)) {
                    let d = new J(e.splitPosition,i.end);
                    return d = d._getTransformedBySplitOperation(e),
                    Is([new J(i.start,e.splitPosition), d], r)
                }
                s.targetPosition.isEqual(e.splitPosition) && t.abRelation == "insertAtSource" && (r = e.moveTargetPosition),
                s.targetPosition.isEqual(e.insertionPosition) && t.abRelation == "insertBetween" && (r = s.targetPosition);
                const l = [i._getTransformedBySplitOperation(e)];
                if (e.graveyardPosition) {
                    const d = i.start.isEqual(e.graveyardPosition) || i.containsPosition(e.graveyardPosition);
                    s.howMany > 1 && d && !t.aWasUndone && l.push(J._createFromPositionAndShift(e.insertionPosition, 1))
                }
                return Is(l, r)
            }
            ),
            Pe(je, mt, (s, e, t) => {
                const r = J._createFromPositionAndShift(s.sourcePosition, s.howMany);
                if (e.deletionPosition.hasSameParentAs(s.sourcePosition) && r.containsPosition(e.sourcePosition)) {
                    if (s.type != "remove" || t.forceWeakRemove) {
                        if (s.howMany == 1)
                            return t.bWasUndone ? (s.sourcePosition = e.graveyardPosition.clone(),
                            s.targetPosition = s.targetPosition._getTransformedByMergeOperation(e),
                            [s]) : [new Mt(0)]
                    } else if (!t.aWasUndone) {
                        const l = [];
                        let d = e.graveyardPosition.clone()
                          , h = e.targetPosition._getTransformedByMergeOperation(e);
                        s.howMany > 1 && (l.push(new je(s.sourcePosition,s.howMany - 1,s.targetPosition,0)),
                        d = d._getTransformedByMove(s.sourcePosition, s.targetPosition, s.howMany - 1),
                        h = h._getTransformedByMove(s.sourcePosition, s.targetPosition, s.howMany - 1));
                        const m = e.deletionPosition._getCombined(s.sourcePosition, s.targetPosition)
                          , g = new je(d,1,m,0)
                          , b = g.getMovedRangeStart().path.slice();
                        b.push(0);
                        const v = new ne(g.targetPosition.root,b);
                        h = h._getTransformedByMove(d, m, 1);
                        const x = new je(h,e.howMany,v,0);
                        return l.push(g),
                        l.push(x),
                        l
                    }
                }
                const i = J._createFromPositionAndShift(s.sourcePosition, s.howMany)._getTransformedByMergeOperation(e);
                return s.sourcePosition = i.start,
                s.howMany = i.end.offset - i.start.offset,
                s.targetPosition = s.targetPosition._getTransformedByMergeOperation(e),
                [s]
            }
            ),
            Pe(uo, Ot, (s, e) => (s.position = s.position._getTransformedByInsertOperation(e),
            [s])),
            Pe(uo, mt, (s, e) => s.position.isEqual(e.deletionPosition) ? (s.position = e.graveyardPosition.clone(),
            s.position.stickiness = "toNext",
            [s]) : (s.position = s.position._getTransformedByMergeOperation(e),
            [s])),
            Pe(uo, je, (s, e) => (s.position = s.position._getTransformedByMoveOperation(e),
            [s])),
            Pe(uo, uo, (s, e, t) => {
                if (s.position.isEqual(e.position)) {
                    if (!t.aIsStrong)
                        return [new Mt(0)];
                    s.oldName = e.newName
                }
                return [s]
            }
            ),
            Pe(uo, qe, (s, e) => {
                if (ro(s.position.path, e.splitPosition.getParentPath()) == "same" && !e.graveyardPosition) {
                    const t = new uo(s.position.getShiftedBy(1),s.oldName,s.newName,0);
                    return [s, t]
                }
                return s.position = s.position._getTransformedBySplitOperation(e),
                [s]
            }
            ),
            Pe(Yr, Yr, (s, e, t) => {
                if (s.root === e.root && s.key === e.key) {
                    if (!t.aIsStrong || s.newValue === e.newValue)
                        return [new Mt(0)];
                    s.oldValue = e.newValue
                }
                return [s]
            }
            ),
            Pe(jr, jr, (s, e) => s.rootName === e.rootName && s.isAdd === e.isAdd ? [new Mt(0)] : [s]),
            Pe(qe, Ot, (s, e) => (s.splitPosition.hasSameParentAs(e.position) && s.splitPosition.offset < e.position.offset && (s.howMany += e.howMany),
            s.splitPosition = s.splitPosition._getTransformedByInsertOperation(e),
            s.insertionPosition = s.insertionPosition._getTransformedByInsertOperation(e),
            [s])),
            Pe(qe, mt, (s, e, t) => {
                if (!s.graveyardPosition && !t.bWasUndone && s.splitPosition.hasSameParentAs(e.sourcePosition)) {
                    const r = e.graveyardPosition.path.slice();
                    r.push(0);
                    const i = new ne(e.graveyardPosition.root,r)
                      , l = qe.getInsertionPosition(new ne(e.graveyardPosition.root,r))
                      , d = new qe(i,0,l,null,0);
                    return s.splitPosition = s.splitPosition._getTransformedByMergeOperation(e),
                    s.insertionPosition = qe.getInsertionPosition(s.splitPosition),
                    s.graveyardPosition = d.insertionPosition.clone(),
                    s.graveyardPosition.stickiness = "toNext",
                    [d, s]
                }
                return s.splitPosition.hasSameParentAs(e.deletionPosition) && !s.splitPosition.isAfter(e.deletionPosition) && s.howMany--,
                s.splitPosition.hasSameParentAs(e.targetPosition) && (s.howMany += e.howMany),
                s.splitPosition = s.splitPosition._getTransformedByMergeOperation(e),
                s.insertionPosition = qe.getInsertionPosition(s.splitPosition),
                s.graveyardPosition && (s.graveyardPosition = s.graveyardPosition._getTransformedByMergeOperation(e)),
                [s]
            }
            ),
            Pe(qe, je, (s, e, t) => {
                const r = J._createFromPositionAndShift(e.sourcePosition, e.howMany);
                if (s.graveyardPosition) {
                    const l = r.start.isEqual(s.graveyardPosition) || r.containsPosition(s.graveyardPosition);
                    if (!t.bWasUndone && l) {
                        const d = s.splitPosition._getTransformedByMoveOperation(e)
                          , h = s.graveyardPosition._getTransformedByMoveOperation(e)
                          , m = h.path.slice();
                        m.push(0);
                        const g = new ne(h.root,m);
                        return [new je(d,s.howMany,g,0)]
                    }
                    s.graveyardPosition = s.graveyardPosition._getTransformedByMoveOperation(e)
                }
                const i = s.splitPosition.isEqual(e.targetPosition);
                if (i && (t.baRelation == "insertAtSource" || t.abRelation == "splitBefore"))
                    return s.howMany += e.howMany,
                    s.splitPosition = s.splitPosition._getTransformedByDeletion(e.sourcePosition, e.howMany),
                    s.insertionPosition = qe.getInsertionPosition(s.splitPosition),
                    [s];
                if (i && t.abRelation && t.abRelation.howMany) {
                    const {howMany: l, offset: d} = t.abRelation;
                    return s.howMany += l,
                    s.splitPosition = s.splitPosition.getShiftedBy(d),
                    [s]
                }
                if (s.splitPosition.hasSameParentAs(e.sourcePosition) && r.containsPosition(s.splitPosition)) {
                    const l = e.howMany - (s.splitPosition.offset - e.sourcePosition.offset);
                    return s.howMany -= l,
                    s.splitPosition.hasSameParentAs(e.targetPosition) && s.splitPosition.offset < e.targetPosition.offset && (s.howMany += e.howMany),
                    s.splitPosition = e.sourcePosition.clone(),
                    s.insertionPosition = qe.getInsertionPosition(s.splitPosition),
                    [s]
                }
                return e.sourcePosition.isEqual(e.targetPosition) || (s.splitPosition.hasSameParentAs(e.sourcePosition) && s.splitPosition.offset <= e.sourcePosition.offset && (s.howMany -= e.howMany),
                s.splitPosition.hasSameParentAs(e.targetPosition) && s.splitPosition.offset < e.targetPosition.offset && (s.howMany += e.howMany)),
                s.splitPosition.stickiness = "toNone",
                s.splitPosition = s.splitPosition._getTransformedByMoveOperation(e),
                s.splitPosition.stickiness = "toNext",
                s.graveyardPosition ? s.insertionPosition = s.insertionPosition._getTransformedByMoveOperation(e) : s.insertionPosition = qe.getInsertionPosition(s.splitPosition),
                [s]
            }
            ),
            Pe(qe, qe, (s, e, t) => {
                if (s.splitPosition.isEqual(e.splitPosition)) {
                    if (!s.graveyardPosition && !e.graveyardPosition)
                        return [new Mt(0)];
                    if (s.graveyardPosition && e.graveyardPosition && s.graveyardPosition.isEqual(e.graveyardPosition))
                        return [new Mt(0)];
                    if (t.abRelation == "splitBefore")
                        return s.howMany = 0,
                        s.graveyardPosition = s.graveyardPosition._getTransformedBySplitOperation(e),
                        [s]
                }
                if (s.graveyardPosition && e.graveyardPosition && s.graveyardPosition.isEqual(e.graveyardPosition)) {
                    const r = s.splitPosition.root.rootName == "$graveyard"
                      , i = e.splitPosition.root.rootName == "$graveyard";
                    if (i && !r || !(r && !i) && t.aIsStrong) {
                        const l = [];
                        return e.howMany && l.push(new je(e.moveTargetPosition,e.howMany,e.splitPosition,0)),
                        s.howMany && l.push(new je(s.splitPosition,s.howMany,s.moveTargetPosition,0)),
                        l
                    }
                    return [new Mt(0)]
                }
                if (s.graveyardPosition && (s.graveyardPosition = s.graveyardPosition._getTransformedBySplitOperation(e)),
                s.splitPosition.isEqual(e.insertionPosition) && t.abRelation == "splitBefore")
                    return s.howMany++,
                    [s];
                if (e.splitPosition.isEqual(s.insertionPosition) && t.baRelation == "splitBefore") {
                    const r = e.insertionPosition.path.slice();
                    r.push(0);
                    const i = new ne(e.insertionPosition.root,r);
                    return [s, new je(s.insertionPosition,1,i,0)]
                }
                return s.splitPosition.hasSameParentAs(e.splitPosition) && s.splitPosition.offset < e.splitPosition.offset && (s.howMany -= e.howMany),
                s.splitPosition = s.splitPosition._getTransformedBySplitOperation(e),
                s.insertionPosition = qe.getInsertionPosition(s.splitPosition),
                [s]
            }
            );
            class Ut extends Se(ne) {
                constructor(e, t, r="toNone") {
                    if (super(e, t, r),
                    !this.root.is("rootElement"))
                        throw new U("model-liveposition-root-not-rootelement",e);
                    z3.call(this)
                }
                detach() {
                    this.stopListening()
                }
                toPosition() {
                    return new ne(this.root,this.path.slice(),this.stickiness)
                }
                static fromPosition(e, t) {
                    return new this(e.root,e.path.slice(),t || e.stickiness)
                }
            }
            function z3() {
                this.listenTo(this.root.document.model, "applyOperation", (s, e) => {
                    const t = e[0];
                    t.isDocumentOperation && O3.call(this, t)
                }
                , {
                    priority: "low"
                })
            }
            function O3(s) {
                const e = this.getTransformedByOperation(s);
                if (!this.isEqual(e)) {
                    const t = this.toPosition();
                    this.path = e.path,
                    this.root = e.root,
                    this.fire("change", t)
                }
            }
            Ut.prototype.is = function(s) {
                return s === "livePosition" || s === "model:livePosition" || s == "position" || s === "model:position"
            }
            ;
            class Ms {
                constructor(e={}) {
                    C(this, "operations"),
                    C(this, "isUndoable"),
                    C(this, "isLocal"),
                    C(this, "isUndo"),
                    C(this, "isTyping"),
                    typeof e == "string" && (e = e === "transparent" ? {
                        isUndoable: !1
                    } : {},
                    de("batch-constructor-deprecated-string-type"));
                    const {isUndoable: t=!0, isLocal: r=!0, isUndo: i=!1, isTyping: l=!1} = e;
                    this.operations = [],
                    this.isUndoable = t,
                    this.isLocal = r,
                    this.isUndo = i,
                    this.isTyping = l
                }
                get type() {
                    return de("batch-type-deprecated"),
                    "default"
                }
                get baseVersion() {
                    for (const e of this.operations)
                        if (e.baseVersion !== null)
                            return e.baseVersion;
                    return null
                }
                addOperation(e) {
                    return e.batch = this,
                    this.operations.push(e),
                    e
                }
            }
            const W_ = class ob {
                constructor(e) {
                    C(this, "_markerCollection"),
                    C(this, "_changesInElement", new Map),
                    C(this, "_elementsSnapshots", new Map),
                    C(this, "_elementChildrenSnapshots", new Map),
                    C(this, "_elementState", new Map),
                    C(this, "_changedMarkers", new Map),
                    C(this, "_changedRoots", new Map),
                    C(this, "_changeCount", 0),
                    C(this, "_cachedChanges", null),
                    C(this, "_cachedChangesWithGraveyard", null),
                    C(this, "_refreshedItems", new Set),
                    this._markerCollection = e
                }
                get isEmpty() {
                    return this._changesInElement.size == 0 && this._changedMarkers.size == 0 && this._changedRoots.size == 0
                }
                bufferOperation(e) {
                    const t = e;
                    switch (t.type) {
                    case "insert":
                        if (this._isInInsertedElement(t.position.parent))
                            return;
                        this._markInsert(t.position.parent, t.position.offset, t.nodes.maxOffset);
                        break;
                    case "addAttribute":
                    case "removeAttribute":
                    case "changeAttribute":
                        for (const r of t.range.getItems({
                            shallow: !0
                        }))
                            this._isInInsertedElement(r.parent) || this._markAttribute(r);
                        break;
                    case "remove":
                    case "move":
                    case "reinsert":
                        {
                            if (t.sourcePosition.isEqual(t.targetPosition) || t.sourcePosition.getShiftedBy(t.howMany).isEqual(t.targetPosition))
                                return;
                            const r = this._isInInsertedElement(t.sourcePosition.parent)
                              , i = this._isInInsertedElement(t.targetPosition.parent);
                            r || this._markRemove(t.sourcePosition.parent, t.sourcePosition.offset, t.howMany),
                            i || this._markInsert(t.targetPosition.parent, t.getMovedRangeStart().offset, t.howMany);
                            const l = J._createFromPositionAndShift(t.sourcePosition, t.howMany);
                            for (const d of l.getItems({
                                shallow: !0
                            }))
                                this._setElementState(d, "move");
                            break
                        }
                    case "rename":
                        {
                            if (this._isInInsertedElement(t.position.parent))
                                return;
                            this._markRemove(t.position.parent, t.position.offset, 1),
                            this._markInsert(t.position.parent, t.position.offset, 1);
                            const r = J._createFromPositionAndShift(t.position, 1);
                            for (const i of this._markerCollection.getMarkersIntersectingRange(r)) {
                                const l = i.getData();
                                this.bufferMarkerChange(i.name, l, l)
                            }
                            this._setElementState(t.position.nodeAfter, "rename");
                            break
                        }
                    case "split":
                        {
                            const r = t.splitPosition.parent;
                            if (!this._isInInsertedElement(r)) {
                                this._markRemove(r, t.splitPosition.offset, t.howMany);
                                const i = J._createFromPositionAndShift(t.splitPosition, t.howMany);
                                for (const l of i.getItems({
                                    shallow: !0
                                }))
                                    this._setElementState(l, "move")
                            }
                            this._isInInsertedElement(t.insertionPosition.parent) || this._markInsert(t.insertionPosition.parent, t.insertionPosition.offset, 1),
                            t.graveyardPosition && (this._markRemove(t.graveyardPosition.parent, t.graveyardPosition.offset, 1),
                            this._setElementState(t.graveyardPosition.nodeAfter, "move"));
                            break
                        }
                    case "merge":
                        {
                            const r = t.sourcePosition.parent;
                            this._isInInsertedElement(r.parent) || this._markRemove(r.parent, r.startOffset, 1);
                            const i = t.graveyardPosition.parent;
                            this._markInsert(i, t.graveyardPosition.offset, 1),
                            this._setElementState(r, "move");
                            const l = t.targetPosition.parent;
                            if (!this._isInInsertedElement(l)) {
                                this._markInsert(l, t.targetPosition.offset, r.maxOffset);
                                const d = J._createFromPositionAndShift(t.sourcePosition, t.howMany);
                                for (const h of d.getItems({
                                    shallow: !0
                                }))
                                    this._setElementState(h, "move")
                            }
                            break
                        }
                    case "detachRoot":
                    case "addRoot":
                        {
                            const r = t.affectedSelectable;
                            if (!r._isLoaded || r.isAttached() == t.isAdd)
                                return;
                            this._bufferRootStateChange(t.rootName, t.isAdd);
                            break
                        }
                    case "addRootAttribute":
                    case "removeRootAttribute":
                    case "changeRootAttribute":
                        {
                            if (!t.root._isLoaded)
                                return;
                            const r = t.root.rootName;
                            this._bufferRootAttributeChange(r, t.key, t.oldValue, t.newValue);
                            break
                        }
                    }
                    this._cachedChanges = null
                }
                bufferMarkerChange(e, t, r) {
                    t.range && t.range.root.is("rootElement") && !t.range.root._isLoaded && (t.range = null),
                    r.range && r.range.root.is("rootElement") && !r.range.root._isLoaded && (r.range = null);
                    let i = this._changedMarkers.get(e);
                    i ? i.newMarkerData = r : (i = {
                        newMarkerData: r,
                        oldMarkerData: t
                    },
                    this._changedMarkers.set(e, i)),
                    i.oldMarkerData.range == null && r.range == null && this._changedMarkers.delete(e)
                }
                getMarkersToRemove() {
                    const e = [];
                    for (const [t,r] of this._changedMarkers)
                        r.oldMarkerData.range != null && e.push({
                            name: t,
                            range: r.oldMarkerData.range
                        });
                    return e
                }
                getMarkersToAdd() {
                    const e = [];
                    for (const [t,r] of this._changedMarkers)
                        r.newMarkerData.range != null && e.push({
                            name: t,
                            range: r.newMarkerData.range
                        });
                    return e
                }
                getChangedMarkers() {
                    return Array.from(this._changedMarkers).map( ([e,t]) => ({
                        name: e,
                        data: {
                            oldRange: t.oldMarkerData.range,
                            newRange: t.newMarkerData.range
                        }
                    }))
                }
                hasDataChanges() {
                    if (this.getChanges().length || this._changedRoots.size > 0)
                        return !0;
                    for (const {newMarkerData: e, oldMarkerData: t} of this._changedMarkers.values()) {
                        if (e.affectsData !== t.affectsData)
                            return !0;
                        if (e.affectsData) {
                            const r = e.range && !t.range
                              , i = !e.range && t.range
                              , l = e.range && t.range && !e.range.isEqual(t.range);
                            if (r || i || l)
                                return !0
                        }
                    }
                    return !1
                }
                getChanges(e={}) {
                    if (this._cachedChanges)
                        return e.includeChangesInGraveyard ? this._cachedChangesWithGraveyard.slice() : this._cachedChanges.slice();
                    let t = [];
                    for (const r of this._changesInElement.keys()) {
                        const i = this._changesInElement.get(r).sort( (b, v) => b.offset === v.offset ? b.type != v.type ? b.type == "remove" ? -1 : 1 : 0 : b.offset < v.offset ? -1 : 1)
                          , l = this._elementChildrenSnapshots.get(r)
                          , d = q_(r.getChildren())
                          , h = F3(l.length, i);
                        let m = 0
                          , g = 0;
                        for (const b of h)
                            if (b === "i") {
                                const v = this._getDiffActionForNode(d[m].node, "insert")
                                  , x = this._elementsSnapshots.get(d[m].node)
                                  , T = this._getInsertDiff(r, m, v, d[m], x);
                                t.push(T),
                                m++
                            } else if (b === "r") {
                                const v = this._getDiffActionForNode(l[g].node, "remove")
                                  , x = this._getRemoveDiff(r, m, v, l[g]);
                                t.push(x),
                                g++
                            } else if (b === "a") {
                                const v = l[g].attributes
                                  , x = d[m].attributes;
                                let T;
                                if (d[m].name == "$text")
                                    T = new J(ne._createAt(r, m),ne._createAt(r, m + 1));
                                else {
                                    const P = r.offsetToIndex(m);
                                    T = new J(ne._createAt(r, m),ne._createAt(r.getChild(P), 0))
                                }
                                const I = this._getAttributesDiff(T, v, x);
                                t.push(...I),
                                m++,
                                g++
                            } else
                                m++,
                                g++
                    }
                    t.sort( (r, i) => r.position.root != i.position.root ? r.position.root.rootName < i.position.root.rootName ? -1 : 1 : r.position.isEqual(i.position) ? r.changeCount - i.changeCount : r.position.isBefore(i.position) ? -1 : 1);
                    for (let r = 1, i = 0; r < t.length; r++) {
                        const l = t[i]
                          , d = t[r]
                          , h = l.type == "remove" && d.type == "remove" && l.name == "$text" && d.name == "$text" && l.position.isEqual(d.position)
                          , m = l.type == "insert" && d.type == "insert" && l.name == "$text" && d.name == "$text" && l.position.parent == d.position.parent && l.position.offset + l.length == d.position.offset
                          , g = l.type == "attribute" && d.type == "attribute" && l.position.parent == d.position.parent && l.range.isFlat && d.range.isFlat && l.position.offset + l.length == d.position.offset && l.attributeKey == d.attributeKey && l.attributeOldValue == d.attributeOldValue && l.attributeNewValue == d.attributeNewValue;
                        h || m || g ? (l.length++,
                        g && (l.range.end = l.range.end.getShiftedBy(1)),
                        t[r] = null) : i = r
                    }
                    t = t.filter(r => r);
                    for (const r of t)
                        delete r.changeCount,
                        r.type == "attribute" && (delete r.position,
                        delete r.length);
                    return this._changeCount = 0,
                    this._cachedChangesWithGraveyard = t,
                    this._cachedChanges = t.filter(V3),
                    e.includeChangesInGraveyard ? this._cachedChangesWithGraveyard.slice() : this._cachedChanges.slice()
                }
                getChangedRoots() {
                    return Array.from(this._changedRoots.values()).map(e => {
                        const t = {
                            ...e
                        };
                        return t.state !== void 0 && delete t.attributes,
                        t
                    }
                    )
                }
                getRefreshedItems() {
                    return new Set(this._refreshedItems)
                }
                reset() {
                    this._changesInElement.clear(),
                    this._elementChildrenSnapshots.clear(),
                    this._elementsSnapshots.clear(),
                    this._elementState.clear(),
                    this._changedMarkers.clear(),
                    this._changedRoots.clear(),
                    this._refreshedItems.clear(),
                    this._cachedChanges = null
                }
                _refreshItem(e) {
                    if (this._isInInsertedElement(e.parent))
                        return;
                    this._markRemove(e.parent, e.startOffset, e.offsetSize),
                    this._markInsert(e.parent, e.startOffset, e.offsetSize),
                    this._refreshedItems.add(e),
                    this._setElementState(e, "refresh");
                    const t = J._createOn(e);
                    for (const r of this._markerCollection.getMarkersIntersectingRange(t)) {
                        const i = r.getData();
                        this.bufferMarkerChange(r.name, i, i)
                    }
                    this._cachedChanges = null
                }
                _bufferRootLoad(e) {
                    if (e.isAttached()) {
                        this._bufferRootStateChange(e.rootName, !0),
                        this._markInsert(e, 0, e.maxOffset);
                        for (const t of e.getAttributeKeys())
                            this._bufferRootAttributeChange(e.rootName, t, null, e.getAttribute(t));
                        for (const t of this._markerCollection)
                            if (t.getRange().root == e) {
                                const r = t.getData();
                                this.bufferMarkerChange(t.name, {
                                    ...r,
                                    range: null
                                }, r)
                            }
                    }
                }
                _bufferRootStateChange(e, t) {
                    if (!this._changedRoots.has(e))
                        return void this._changedRoots.set(e, {
                            name: e,
                            state: t ? "attached" : "detached"
                        });
                    const r = this._changedRoots.get(e);
                    r.state !== void 0 ? (delete r.state,
                    r.attributes === void 0 && this._changedRoots.delete(e)) : r.state = t ? "attached" : "detached"
                }
                _bufferRootAttributeChange(e, t, r, i) {
                    const l = this._changedRoots.get(e) || {
                        name: e
                    }
                      , d = l.attributes || {};
                    if (d[t]) {
                        const h = d[t];
                        i === h.oldValue ? delete d[t] : h.newValue = i
                    } else
                        d[t] = {
                            oldValue: r,
                            newValue: i
                        };
                    Object.entries(d).length === 0 ? (delete l.attributes,
                    l.state === void 0 && this._changedRoots.delete(e)) : (l.attributes = d,
                    this._changedRoots.set(e, l))
                }
                _markInsert(e, t, r) {
                    if (e.root.is("rootElement") && !e.root._isLoaded)
                        return;
                    const i = {
                        type: "insert",
                        offset: t,
                        howMany: r,
                        count: this._changeCount++
                    };
                    this._markChange(e, i)
                }
                _markRemove(e, t, r) {
                    if (e.root.is("rootElement") && !e.root._isLoaded)
                        return;
                    const i = {
                        type: "remove",
                        offset: t,
                        howMany: r,
                        count: this._changeCount++
                    };
                    this._markChange(e, i),
                    this._removeAllNestedChanges(e, t, r)
                }
                _markAttribute(e) {
                    if (e.root.is("rootElement") && !e.root._isLoaded)
                        return;
                    const t = {
                        type: "attribute",
                        offset: e.startOffset,
                        howMany: e.offsetSize,
                        count: this._changeCount++
                    };
                    this._markChange(e.parent, t)
                }
                _markChange(e, t) {
                    this._makeSnapshots(e);
                    const r = this._getChangesForElement(e);
                    this._handleChange(t, r),
                    r.push(t);
                    for (let i = 0; i < r.length; i++)
                        r[i].howMany < 1 && (r.splice(i, 1),
                        i--)
                }
                _setElementState(e, t) {
                    if (!e.is("element"))
                        return;
                    const r = ob._statesPriority.indexOf(this._elementState.get(e));
                    ob._statesPriority.indexOf(t) > r && this._elementState.set(e, t)
                }
                _getDiffActionForNode(e, t) {
                    if (!e.is("element") || !this._elementsSnapshots.has(e))
                        return t;
                    const r = this._elementState.get(e);
                    return r && r != "move" ? r : t
                }
                _getChangesForElement(e) {
                    let t;
                    return this._changesInElement.has(e) ? t = this._changesInElement.get(e) : (t = [],
                    this._changesInElement.set(e, t)),
                    t
                }
                _makeSnapshots(e) {
                    if (this._elementChildrenSnapshots.has(e))
                        return;
                    const t = q_(e.getChildren());
                    this._elementChildrenSnapshots.set(e, t);
                    for (const r of t)
                        this._elementsSnapshots.set(r.node, r)
                }
                _handleChange(e, t) {
                    e.nodesToHandle = e.howMany;
                    for (const r of t) {
                        const i = e.offset + e.howMany
                          , l = r.offset + r.howMany;
                        if (e.type == "insert" && (r.type == "insert" && (e.offset <= r.offset ? r.offset += e.howMany : e.offset < l && (r.howMany += e.nodesToHandle,
                        e.nodesToHandle = 0)),
                        r.type == "remove" && e.offset < r.offset && (r.offset += e.howMany),
                        r.type == "attribute")) {
                            if (e.offset <= r.offset)
                                r.offset += e.howMany;
                            else if (e.offset < l) {
                                const d = r.howMany;
                                r.howMany = e.offset - r.offset,
                                t.unshift({
                                    type: "attribute",
                                    offset: i,
                                    howMany: d - r.howMany,
                                    count: this._changeCount++
                                })
                            }
                        }
                        if (e.type == "remove") {
                            if (r.type == "insert") {
                                if (i <= r.offset)
                                    r.offset -= e.howMany;
                                else if (i <= l)
                                    if (e.offset < r.offset) {
                                        const d = i - r.offset;
                                        r.offset = e.offset,
                                        r.howMany -= d,
                                        e.nodesToHandle -= d
                                    } else
                                        r.howMany -= e.nodesToHandle,
                                        e.nodesToHandle = 0;
                                else if (e.offset <= r.offset)
                                    e.nodesToHandle -= r.howMany,
                                    r.howMany = 0;
                                else if (e.offset < l) {
                                    const d = l - e.offset;
                                    r.howMany -= d,
                                    e.nodesToHandle -= d
                                }
                            }
                            if (r.type == "remove" && (i <= r.offset ? r.offset -= e.howMany : e.offset < r.offset && (e.nodesToHandle += r.howMany,
                            r.howMany = 0)),
                            r.type == "attribute") {
                                if (i <= r.offset)
                                    r.offset -= e.howMany;
                                else if (e.offset < r.offset) {
                                    const d = i - r.offset;
                                    r.offset = e.offset,
                                    r.howMany -= d
                                } else if (e.offset < l)
                                    if (i <= l) {
                                        const d = r.howMany;
                                        r.howMany = e.offset - r.offset;
                                        const h = d - r.howMany - e.nodesToHandle;
                                        t.unshift({
                                            type: "attribute",
                                            offset: e.offset,
                                            howMany: h,
                                            count: this._changeCount++
                                        })
                                    } else
                                        r.howMany -= l - e.offset
                            }
                        }
                        if (e.type == "attribute") {
                            if (r.type == "insert")
                                if (e.offset < r.offset && i > r.offset) {
                                    if (i > l) {
                                        const d = {
                                            type: "attribute",
                                            offset: l,
                                            howMany: i - l,
                                            count: this._changeCount++
                                        };
                                        this._handleChange(d, t),
                                        t.push(d)
                                    }
                                    e.nodesToHandle = r.offset - e.offset,
                                    e.howMany = e.nodesToHandle
                                } else
                                    e.offset >= r.offset && e.offset < l && (i > l ? (e.nodesToHandle = i - l,
                                    e.offset = l) : e.nodesToHandle = 0);
                            if (r.type == "remove" && e.offset < r.offset && i > r.offset) {
                                const d = {
                                    type: "attribute",
                                    offset: r.offset,
                                    howMany: i - r.offset,
                                    count: this._changeCount++
                                };
                                this._handleChange(d, t),
                                t.push(d),
                                e.nodesToHandle = r.offset - e.offset,
                                e.howMany = e.nodesToHandle
                            }
                            r.type == "attribute" && (e.offset >= r.offset && i <= l ? (e.nodesToHandle = 0,
                            e.howMany = 0,
                            e.offset = 0) : e.offset <= r.offset && i >= l && (r.howMany = 0))
                        }
                    }
                    e.howMany = e.nodesToHandle,
                    delete e.nodesToHandle
                }
                _getInsertDiff(e, t, r, i, l) {
                    const d = {
                        type: "insert",
                        position: ne._createAt(e, t),
                        name: i.name,
                        attributes: new Map(i.attributes),
                        length: 1,
                        changeCount: this._changeCount++,
                        action: r
                    };
                    return r != "insert" && l && (d.before = {
                        name: l.name,
                        attributes: new Map(l.attributes)
                    }),
                    d
                }
                _getRemoveDiff(e, t, r, i) {
                    return {
                        type: "remove",
                        action: r,
                        position: ne._createAt(e, t),
                        name: i.name,
                        attributes: new Map(i.attributes),
                        length: 1,
                        changeCount: this._changeCount++
                    }
                }
                _getAttributesDiff(e, t, r) {
                    const i = [];
                    r = new Map(r);
                    for (const [l,d] of t) {
                        const h = r.has(l) ? r.get(l) : null;
                        h !== d && i.push({
                            type: "attribute",
                            position: e.start,
                            range: e.clone(),
                            length: 1,
                            attributeKey: l,
                            attributeOldValue: d,
                            attributeNewValue: h,
                            changeCount: this._changeCount++
                        }),
                        r.delete(l)
                    }
                    for (const [l,d] of r)
                        i.push({
                            type: "attribute",
                            position: e.start,
                            range: e.clone(),
                            length: 1,
                            attributeKey: l,
                            attributeOldValue: null,
                            attributeNewValue: d,
                            changeCount: this._changeCount++
                        });
                    return i
                }
                _isInInsertedElement(e) {
                    const t = e.parent;
                    if (!t)
                        return !1;
                    const r = this._changesInElement.get(t)
                      , i = e.startOffset;
                    if (r) {
                        for (const l of r)
                            if (l.type == "insert" && i >= l.offset && i < l.offset + l.howMany)
                                return !0
                    }
                    return this._isInInsertedElement(t)
                }
                _removeAllNestedChanges(e, t, r) {
                    const i = new J(ne._createAt(e, t),ne._createAt(e, t + r));
                    for (const l of i.getItems({
                        shallow: !0
                    }))
                        l.is("element") && (this._changesInElement.delete(l),
                        this._removeAllNestedChanges(l, 0, l.maxOffset))
                }
            }
            ;
            C(W_, "_statesPriority", [void 0, "refresh", "rename", "move"]);
            let R3 = W_;
            function $_(s) {
                return {
                    node: s,
                    name: s.is("$text") ? "$text" : s.name,
                    attributes: new Map(s.getAttributes())
                }
            }
            function q_(s) {
                const e = [];
                for (const t of s)
                    if (t.is("$text"))
                        for (let r = 0; r < t.data.length; ++r)
                            e.push($_(t));
                    else
                        e.push($_(t));
                return e
            }
            function F3(s, e) {
                const t = [];
                let r = 0
                  , i = 0;
                for (const l of e) {
                    if (l.offset > r) {
                        for (let d = 0; d < l.offset - r; d++)
                            t.push("e");
                        i += l.offset - r
                    }
                    if (l.type == "insert") {
                        for (let d = 0; d < l.howMany; d++)
                            t.push("i");
                        r = l.offset + l.howMany
                    } else if (l.type == "remove") {
                        for (let d = 0; d < l.howMany; d++)
                            t.push("r");
                        r = l.offset,
                        i += l.howMany
                    } else
                        t.push(..."a".repeat(l.howMany).split("")),
                        r = l.offset + l.howMany,
                        i += l.howMany
                }
                if (i < s)
                    for (let l = 0; l < s - i - r; l++)
                        t.push("e");
                return t
            }
            function V3(s) {
                const e = "position"in s && s.position.root.rootName == "$graveyard"
                  , t = "range"in s && s.range.root.rootName == "$graveyard";
                return !e && !t
            }
            class U3 {
                constructor() {
                    C(this, "_operations", []),
                    C(this, "_undoPairs", new Map),
                    C(this, "_undoneOperations", new Set),
                    C(this, "_baseVersionToOperationIndex", new Map),
                    C(this, "_version", 0),
                    C(this, "_gaps", new Map)
                }
                get version() {
                    return this._version
                }
                set version(e) {
                    this._operations.length && e > this._version + 1 && this._gaps.set(this._version, e),
                    this._version = e
                }
                get lastOperation() {
                    return this._operations[this._operations.length - 1]
                }
                addOperation(e) {
                    if (e.baseVersion !== this.version)
                        throw new U("model-document-history-addoperation-incorrect-version",this,{
                            operation: e,
                            historyVersion: this.version
                        });
                    this._operations.push(e),
                    this._version++,
                    this._baseVersionToOperationIndex.set(e.baseVersion, this._operations.length - 1)
                }
                getOperations(e, t=this.version) {
                    if (!this._operations.length)
                        return [];
                    const r = this._operations[0];
                    e === void 0 && (e = r.baseVersion);
                    let i = t - 1;
                    for (const [h,m] of this._gaps)
                        e > h && e < m && (e = m),
                        i > h && i < m && (i = h - 1);
                    if (i < r.baseVersion || e > this.lastOperation.baseVersion)
                        return [];
                    let l = this._baseVersionToOperationIndex.get(e);
                    l === void 0 && (l = 0);
                    let d = this._baseVersionToOperationIndex.get(i);
                    return d === void 0 && (d = this._operations.length - 1),
                    this._operations.slice(l, d + 1)
                }
                getOperation(e) {
                    const t = this._baseVersionToOperationIndex.get(e);
                    if (t !== void 0)
                        return this._operations[t]
                }
                setOperationAsUndone(e, t) {
                    this._undoPairs.set(t, e),
                    this._undoneOperations.add(e)
                }
                isUndoingOperation(e) {
                    return this._undoPairs.has(e)
                }
                isUndoneOperation(e) {
                    return this._undoneOperations.has(e)
                }
                getUndoneOperation(e) {
                    return this._undoPairs.get(e)
                }
                reset() {
                    this._version = 0,
                    this._undoPairs = new Map,
                    this._operations = [],
                    this._undoneOperations = new Set,
                    this._gaps = new Map,
                    this._baseVersionToOperationIndex = new Map
                }
            }
            class Kd extends Fe {
                constructor(e, t, r="main") {
                    super(t),
                    C(this, "rootName"),
                    C(this, "_document"),
                    C(this, "_isAttached", !0),
                    C(this, "_isLoaded", !0),
                    this._document = e,
                    this.rootName = r
                }
                get document() {
                    return this._document
                }
                isAttached() {
                    return this._isAttached
                }
                toJSON() {
                    return this.rootName
                }
            }
            Kd.prototype.is = function(s, e) {
                return e ? e === this.name && (s === "rootElement" || s === "model:rootElement" || s === "element" || s === "model:element") : s === "rootElement" || s === "model:rootElement" || s === "element" || s === "model:element" || s === "node" || s === "model:node"
            }
            ;
            const G_ = "$graveyard";
            class H3 extends Se() {
                constructor(e) {
                    super(),
                    C(this, "model"),
                    C(this, "history"),
                    C(this, "selection"),
                    C(this, "roots"),
                    C(this, "differ"),
                    C(this, "isReadOnly"),
                    C(this, "_postFixers"),
                    C(this, "_hasSelectionChangedFromTheLastChangeBlock"),
                    this.model = e,
                    this.history = new U3,
                    this.selection = new kr(this),
                    this.roots = new dr({
                        idProperty: "rootName"
                    }),
                    this.differ = new R3(e.markers),
                    this.isReadOnly = !1,
                    this._postFixers = new Set,
                    this._hasSelectionChangedFromTheLastChangeBlock = !1,
                    this.createRoot("$root", G_),
                    this.listenTo(e, "applyOperation", (t, r) => {
                        const i = r[0];
                        i.isDocumentOperation && this.differ.bufferOperation(i)
                    }
                    , {
                        priority: "high"
                    }),
                    this.listenTo(e, "applyOperation", (t, r) => {
                        const i = r[0];
                        i.isDocumentOperation && this.history.addOperation(i)
                    }
                    , {
                        priority: "low"
                    }),
                    this.listenTo(this.selection, "change", () => {
                        this._hasSelectionChangedFromTheLastChangeBlock = !0
                    }
                    ),
                    this.listenTo(e.markers, "update", (t, r, i, l, d) => {
                        const h = {
                            ...r.getData(),
                            range: l
                        };
                        this.differ.bufferMarkerChange(r.name, d, h),
                        i === null && r.on("change", (m, g) => {
                            const b = r.getData();
                            this.differ.bufferMarkerChange(r.name, {
                                ...b,
                                range: g
                            }, b)
                        }
                        )
                    }
                    ),
                    this.registerPostFixer(t => {
                        let r = !1;
                        for (const i of this.roots)
                            i.isAttached() || i.isEmpty || (t.remove(t.createRangeIn(i)),
                            r = !0);
                        for (const i of this.model.markers)
                            i.getRange().root.isAttached() || (t.removeMarker(i),
                            r = !0);
                        return r
                    }
                    )
                }
                get version() {
                    return this.history.version
                }
                set version(e) {
                    this.history.version = e
                }
                get graveyard() {
                    return this.getRoot(G_)
                }
                createRoot(e="$root", t="main") {
                    if (this.roots.get(t))
                        throw new U("model-document-createroot-name-exists",this,{
                            name: t
                        });
                    const r = new Kd(this,e,t);
                    return this.roots.add(r),
                    r
                }
                destroy() {
                    this.selection.destroy(),
                    this.stopListening()
                }
                getRoot(e="main") {
                    return this.roots.get(e)
                }
                getRootNames(e=!1) {
                    return this.getRoots(e).map(t => t.rootName)
                }
                getRoots(e=!1) {
                    return this.roots.filter(t => t != this.graveyard && (e || t.isAttached()) && t._isLoaded)
                }
                registerPostFixer(e) {
                    this._postFixers.add(e)
                }
                toJSON() {
                    const e = Ev(this);
                    return e.selection = "[engine.model.DocumentSelection]",
                    e.model = "[engine.model.Model]",
                    e
                }
                _handleChangeBlock(e) {
                    this._hasDocumentChangedFromTheLastChangeBlock() && (this._callPostFixers(e),
                    this.selection.refresh(),
                    this.differ.hasDataChanges() ? this.fire("change:data", e.batch) : this.fire("change", e.batch),
                    this.selection.refresh(),
                    this.differ.reset()),
                    this._hasSelectionChangedFromTheLastChangeBlock = !1
                }
                _hasDocumentChangedFromTheLastChangeBlock() {
                    return !this.differ.isEmpty || this._hasSelectionChangedFromTheLastChangeBlock
                }
                _getDefaultRoot() {
                    const e = this.getRoots();
                    return e.length ? e[0] : this.graveyard
                }
                _getDefaultRange() {
                    const e = this._getDefaultRoot()
                      , t = this.model
                      , r = t.schema
                      , i = t.createPositionFromPath(e, [0]);
                    return r.getNearestSelectionRange(i) || t.createRange(i)
                }
                _validateSelectionRange(e) {
                    return K_(e.start) && K_(e.end)
                }
                _callPostFixers(e) {
                    let t = !1;
                    do
                        for (const r of this._postFixers)
                            if (this.selection.refresh(),
                            t = r(e),
                            t)
                                break;
                    while (t)
                }
            }
            function K_(s) {
                const e = s.textNode;
                if (e) {
                    const t = e.data
                      , r = s.offset - e.startOffset;
                    return !tp(t, r) && !op(t, r)
                }
                return !0
            }
            class W3 extends Se() {
                constructor() {
                    super(...arguments),
                    C(this, "_markers", new Map)
                }
                [Symbol.iterator]() {
                    return this._markers.values()
                }
                has(e) {
                    const t = e instanceof Bs ? e.name : e;
                    return this._markers.has(t)
                }
                get(e) {
                    return this._markers.get(e) || null
                }
                _set(e, t, r=!1, i=!1) {
                    const l = e instanceof Bs ? e.name : e;
                    if (l.includes(","))
                        throw new U("markercollection-incorrect-marker-name",this);
                    const d = this._markers.get(l);
                    if (d) {
                        const g = d.getData()
                          , b = d.getRange();
                        let v = !1;
                        return b.isEqual(t) || (d._attachLiveRange(Io.fromRange(t)),
                        v = !0),
                        r != d.managedUsingOperations && (d._managedUsingOperations = r,
                        v = !0),
                        typeof i == "boolean" && i != d.affectsData && (d._affectsData = i,
                        v = !0),
                        v && this.fire(`update:${l}`, d, b, t, g),
                        d
                    }
                    const h = Io.fromRange(t)
                      , m = new Bs(l,h,r,i);
                    return this._markers.set(l, m),
                    this.fire(`update:${l}`, m, null, t, {
                        ...m.getData(),
                        range: null
                    }),
                    m
                }
                _remove(e) {
                    const t = e instanceof Bs ? e.name : e
                      , r = this._markers.get(t);
                    return !!r && (this._markers.delete(t),
                    this.fire(`update:${t}`, r, r.getRange(), null, r.getData()),
                    this._destroyMarker(r),
                    !0)
                }
                _refresh(e) {
                    const t = e instanceof Bs ? e.name : e
                      , r = this._markers.get(t);
                    if (!r)
                        throw new U("markercollection-refresh-marker-not-exists",this);
                    const i = r.getRange();
                    this.fire(`update:${t}`, r, i, i, r.getData())
                }
                *getMarkersAtPosition(e) {
                    for (const t of this)
                        t.getRange().containsPosition(e) && (yield t)
                }
                *getMarkersIntersectingRange(e) {
                    for (const t of this)
                        t.getRange().getIntersection(e) !== null && (yield t)
                }
                destroy() {
                    for (const e of this._markers.values())
                        this._destroyMarker(e);
                    this._markers = null,
                    this.stopListening()
                }
                *getMarkersGroup(e) {
                    for (const t of this._markers.values())
                        t.name.startsWith(e + ":") && (yield t)
                }
                _destroyMarker(e) {
                    e.stopListening(),
                    e._detachLiveRange()
                }
            }
            class Bs extends Se(Bn) {
                constructor(e, t, r, i) {
                    super(),
                    C(this, "name"),
                    C(this, "_managedUsingOperations"),
                    C(this, "_affectsData"),
                    C(this, "_liveRange"),
                    this.name = e,
                    this._liveRange = this._attachLiveRange(t),
                    this._managedUsingOperations = r,
                    this._affectsData = i
                }
                get managedUsingOperations() {
                    if (!this._liveRange)
                        throw new U("marker-destroyed",this);
                    return this._managedUsingOperations
                }
                get affectsData() {
                    if (!this._liveRange)
                        throw new U("marker-destroyed",this);
                    return this._affectsData
                }
                getData() {
                    return {
                        range: this.getRange(),
                        affectsData: this.affectsData,
                        managedUsingOperations: this.managedUsingOperations
                    }
                }
                getStart() {
                    if (!this._liveRange)
                        throw new U("marker-destroyed",this);
                    return this._liveRange.start.clone()
                }
                getEnd() {
                    if (!this._liveRange)
                        throw new U("marker-destroyed",this);
                    return this._liveRange.end.clone()
                }
                getRange() {
                    if (!this._liveRange)
                        throw new U("marker-destroyed",this);
                    return this._liveRange.toRange()
                }
                _attachLiveRange(e) {
                    return this._liveRange && this._detachLiveRange(),
                    e.delegate("change:range").to(this),
                    e.delegate("change:content").to(this),
                    this._liveRange = e,
                    e
                }
                _detachLiveRange() {
                    this._liveRange.stopDelegating("change:range", this),
                    this._liveRange.stopDelegating("change:content", this),
                    this._liveRange.detach(),
                    this._liveRange = null
                }
            }
            Bs.prototype.is = function(s) {
                return s === "marker" || s === "model:marker"
            }
            ;
            class $3 extends Mo {
                constructor(e, t) {
                    super(null),
                    C(this, "sourcePosition"),
                    C(this, "howMany"),
                    this.sourcePosition = e.clone(),
                    this.howMany = t
                }
                get type() {
                    return "detach"
                }
                get affectedSelectable() {
                    return null
                }
                toJSON() {
                    const e = super.toJSON();
                    return e.sourcePosition = this.sourcePosition.toJSON(),
                    e
                }
                _validate() {
                    if (this.sourcePosition.root.document)
                        throw new U("detach-operation-on-document-node",this)
                }
                _execute() {
                    L_(J._createFromPositionAndShift(this.sourcePosition, this.howMany))
                }
                static get className() {
                    return "DetachOperation"
                }
            }
            class Qr extends Bn {
                constructor(e) {
                    super(),
                    C(this, "markers", new Map),
                    C(this, "_children", new bl),
                    e && this._insertChild(0, e)
                }
                [Symbol.iterator]() {
                    return this.getChildren()
                }
                get childCount() {
                    return this._children.length
                }
                get maxOffset() {
                    return this._children.maxOffset
                }
                get isEmpty() {
                    return this.childCount === 0
                }
                get nextSibling() {
                    return null
                }
                get previousSibling() {
                    return null
                }
                get root() {
                    return this
                }
                get parent() {
                    return null
                }
                get document() {
                    return null
                }
                isAttached() {
                    return !1
                }
                getAncestors() {
                    return []
                }
                getChild(e) {
                    return this._children.getNode(e)
                }
                getChildren() {
                    return this._children[Symbol.iterator]()
                }
                getChildIndex(e) {
                    return this._children.getNodeIndex(e)
                }
                getChildStartOffset(e) {
                    return this._children.getNodeStartOffset(e)
                }
                getPath() {
                    return []
                }
                getNodeByPath(e) {
                    let t = this;
                    for (const r of e)
                        t = t.getChild(t.offsetToIndex(r));
                    return t
                }
                offsetToIndex(e) {
                    return this._children.offsetToIndex(e)
                }
                toJSON() {
                    const e = [];
                    for (const t of this._children)
                        e.push(t.toJSON());
                    return e
                }
                static fromJSON(e) {
                    const t = [];
                    for (const r of e)
                        r.name ? t.push(Fe.fromJSON(r)) : t.push($e.fromJSON(r));
                    return new Qr(t)
                }
                _appendChild(e) {
                    this._insertChild(this.childCount, e)
                }
                _insertChild(e, t) {
                    const r = function(i) {
                        return typeof i == "string" ? [new $e(i)] : (yo(i) || (i = [i]),
                        Array.from(i).map(l => typeof l == "string" ? new $e(l) : l instanceof fr ? new $e(l.data,l.getAttributes()) : l))
                    }(t);
                    for (const i of r)
                        i.parent !== null && i._remove(),
                        i.parent = this;
                    this._children._insertNodes(e, r)
                }
                _removeChildren(e, t=1) {
                    const r = this._children._removeNodes(e, t);
                    for (const i of r)
                        i.parent = null;
                    return r
                }
            }
            Qr.prototype.is = function(s) {
                return s === "documentFragment" || s === "model:documentFragment"
            }
            ;
            class q3 {
                constructor(e, t) {
                    C(this, "model"),
                    C(this, "batch"),
                    this.model = e,
                    this.batch = t
                }
                createText(e, t) {
                    return new $e(e,t)
                }
                createElement(e, t) {
                    return new Fe(e,t)
                }
                createDocumentFragment() {
                    return new Qr
                }
                cloneElement(e, t=!0) {
                    return e._clone(t)
                }
                insert(e, t, r=0) {
                    if (this._assertWriterUsedCorrectly(),
                    e instanceof $e && e.data == "")
                        return;
                    const i = ne._createAt(t, r);
                    if (e.parent) {
                        if (Z_(e.root, i.root))
                            return void this.move(J._createOn(e), i);
                        if (e.root.document)
                            throw new U("model-writer-insert-forbidden-move",this);
                        this.remove(e)
                    }
                    const l = i.root.document ? i.root.document.version : null
                      , d = new Ot(i,e,l);
                    if (e instanceof $e && (d.shouldReceiveAttributes = !0),
                    this.batch.addOperation(d),
                    this.model.applyOperation(d),
                    e instanceof Qr)
                        for (const [h,m] of e.markers) {
                            const g = ne._createAt(m.root, 0)
                              , b = {
                                range: new J(m.start._getCombined(g, i),m.end._getCombined(g, i)),
                                usingOperation: !0,
                                affectsData: !0
                            };
                            this.model.markers.has(h) ? this.updateMarker(h, b) : this.addMarker(h, b)
                        }
                }
                insertText(e, t, r, i) {
                    t instanceof Qr || t instanceof Fe || t instanceof ne ? this.insert(this.createText(e), t, r) : this.insert(this.createText(e, t), r, i)
                }
                insertElement(e, t, r, i) {
                    t instanceof Qr || t instanceof Fe || t instanceof ne ? this.insert(this.createElement(e), t, r) : this.insert(this.createElement(e, t), r, i)
                }
                append(e, t) {
                    this.insert(e, t, "end")
                }
                appendText(e, t, r) {
                    t instanceof Qr || t instanceof Fe ? this.insert(this.createText(e), t, "end") : this.insert(this.createText(e, t), r, "end")
                }
                appendElement(e, t, r) {
                    t instanceof Qr || t instanceof Fe ? this.insert(this.createElement(e), t, "end") : this.insert(this.createElement(e, t), r, "end")
                }
                setAttribute(e, t, r) {
                    if (this._assertWriterUsedCorrectly(),
                    r instanceof J) {
                        const i = r.getMinimalFlatRanges();
                        for (const l of i)
                            Y_(this, e, t, l)
                    } else
                        Q_(this, e, t, r)
                }
                setAttributes(e, t) {
                    for (const [r,i] of Ir(e))
                        this.setAttribute(r, i, t)
                }
                removeAttribute(e, t) {
                    if (this._assertWriterUsedCorrectly(),
                    t instanceof J) {
                        const r = t.getMinimalFlatRanges();
                        for (const i of r)
                            Y_(this, e, null, i)
                    } else
                        Q_(this, e, null, t)
                }
                clearAttributes(e) {
                    this._assertWriterUsedCorrectly();
                    const t = r => {
                        for (const i of r.getAttributeKeys())
                            this.removeAttribute(i, r)
                    }
                    ;
                    if (e instanceof J)
                        for (const r of e.getItems())
                            t(r);
                    else
                        t(e)
                }
                move(e, t, r) {
                    if (this._assertWriterUsedCorrectly(),
                    !(e instanceof J))
                        throw new U("writer-move-invalid-range",this);
                    if (!e.isFlat)
                        throw new U("writer-move-range-not-flat",this);
                    const i = ne._createAt(t, r);
                    if (i.isEqual(e.start))
                        return;
                    if (this._addOperationForAffectedMarkers("move", e),
                    !Z_(e.root, i.root))
                        throw new U("writer-move-different-document",this);
                    const l = e.root.document ? e.root.document.version : null
                      , d = new je(e.start,e.end.offset - e.start.offset,i,l);
                    this.batch.addOperation(d),
                    this.model.applyOperation(d)
                }
                remove(e) {
                    this._assertWriterUsedCorrectly();
                    const t = (e instanceof J ? e : J._createOn(e)).getMinimalFlatRanges().reverse();
                    for (const r of t)
                        this._addOperationForAffectedMarkers("move", r),
                        G3(r.start, r.end.offset - r.start.offset, this.batch, this.model)
                }
                merge(e) {
                    this._assertWriterUsedCorrectly();
                    const t = e.nodeBefore
                      , r = e.nodeAfter;
                    if (this._addOperationForAffectedMarkers("merge", e),
                    !(t instanceof Fe))
                        throw new U("writer-merge-no-element-before",this);
                    if (!(r instanceof Fe))
                        throw new U("writer-merge-no-element-after",this);
                    e.root.document ? this._merge(e) : this._mergeDetached(e)
                }
                createPositionFromPath(e, t, r) {
                    return this.model.createPositionFromPath(e, t, r)
                }
                createPositionAt(e, t) {
                    return this.model.createPositionAt(e, t)
                }
                createPositionAfter(e) {
                    return this.model.createPositionAfter(e)
                }
                createPositionBefore(e) {
                    return this.model.createPositionBefore(e)
                }
                createRange(e, t) {
                    return this.model.createRange(e, t)
                }
                createRangeIn(e) {
                    return this.model.createRangeIn(e)
                }
                createRangeOn(e) {
                    return this.model.createRangeOn(e)
                }
                createSelection(...e) {
                    return this.model.createSelection(...e)
                }
                _mergeDetached(e) {
                    const t = e.nodeBefore
                      , r = e.nodeAfter;
                    this.move(J._createIn(r), ne._createAt(t, "end")),
                    this.remove(r)
                }
                _merge(e) {
                    const t = ne._createAt(e.nodeBefore, "end")
                      , r = ne._createAt(e.nodeAfter, 0)
                      , i = e.root.document.graveyard
                      , l = new ne(i,[0])
                      , d = e.root.document.version
                      , h = new mt(r,e.nodeAfter.maxOffset,t,l,d);
                    this.batch.addOperation(h),
                    this.model.applyOperation(h)
                }
                rename(e, t) {
                    if (this._assertWriterUsedCorrectly(),
                    !(e instanceof Fe))
                        throw new U("writer-rename-not-element-instance",this);
                    const r = e.root.document ? e.root.document.version : null
                      , i = new uo(ne._createBefore(e),e.name,t,r);
                    this.batch.addOperation(i),
                    this.model.applyOperation(i)
                }
                split(e, t) {
                    this._assertWriterUsedCorrectly();
                    let r, i, l = e.parent;
                    if (!l.parent)
                        throw new U("writer-split-element-no-parent",this);
                    if (t || (t = l.parent),
                    !e.parent.getAncestors({
                        includeSelf: !0
                    }).includes(t))
                        throw new U("writer-split-invalid-limit-element",this);
                    do {
                        const d = l.root.document ? l.root.document.version : null
                          , h = l.maxOffset - e.offset
                          , m = qe.getInsertionPosition(e)
                          , g = new qe(e,h,m,null,d);
                        this.batch.addOperation(g),
                        this.model.applyOperation(g),
                        r || i || (r = l,
                        i = e.parent.nextSibling),
                        l = (e = this.createPositionAfter(e.parent)).parent
                    } while (l !== t);
                    return {
                        position: e,
                        range: new J(ne._createAt(r, "end"),ne._createAt(i, 0))
                    }
                }
                wrap(e, t) {
                    if (this._assertWriterUsedCorrectly(),
                    !e.isFlat)
                        throw new U("writer-wrap-range-not-flat",this);
                    const r = t instanceof Fe ? t : new Fe(t);
                    if (r.childCount > 0)
                        throw new U("writer-wrap-element-not-empty",this);
                    if (r.parent !== null)
                        throw new U("writer-wrap-element-attached",this);
                    this.insert(r, e.start);
                    const i = new J(e.start.getShiftedBy(1),e.end.getShiftedBy(1));
                    this.move(i, ne._createAt(r, 0))
                }
                unwrap(e) {
                    if (this._assertWriterUsedCorrectly(),
                    e.parent === null)
                        throw new U("writer-unwrap-element-no-parent",this);
                    this.move(J._createIn(e), this.createPositionAfter(e)),
                    this.remove(e)
                }
                addMarker(e, t) {
                    if (this._assertWriterUsedCorrectly(),
                    !t || typeof t.usingOperation != "boolean")
                        throw new U("writer-addmarker-no-usingoperation",this);
                    const r = t.usingOperation
                      , i = t.range
                      , l = t.affectsData !== void 0 && t.affectsData;
                    if (this.model.markers.has(e))
                        throw new U("writer-addmarker-marker-exists",this);
                    if (!i)
                        throw new U("writer-addmarker-no-range",this);
                    return r ? (El(this, e, null, i, l),
                    this.model.markers.get(e)) : this.model.markers._set(e, i, r, l)
                }
                updateMarker(e, t) {
                    this._assertWriterUsedCorrectly();
                    const r = typeof e == "string" ? e : e.name
                      , i = this.model.markers.get(r);
                    if (!i)
                        throw new U("writer-updatemarker-marker-not-exists",this);
                    if (!t)
                        return de("writer-updatemarker-reconvert-using-editingcontroller", {
                            markerName: r
                        }),
                        void this.model.markers._refresh(i);
                    const l = typeof t.usingOperation == "boolean"
                      , d = typeof t.affectsData == "boolean"
                      , h = d ? t.affectsData : i.affectsData;
                    if (!l && !t.range && !d)
                        throw new U("writer-updatemarker-wrong-options",this);
                    const m = i.getRange()
                      , g = t.range ? t.range : m;
                    l && t.usingOperation !== i.managedUsingOperations ? t.usingOperation ? El(this, r, null, g, h) : (El(this, r, m, null, h),
                    this.model.markers._set(r, g, void 0, h)) : i.managedUsingOperations ? El(this, r, m, g, h) : this.model.markers._set(r, g, void 0, h)
                }
                removeMarker(e) {
                    this._assertWriterUsedCorrectly();
                    const t = typeof e == "string" ? e : e.name;
                    if (!this.model.markers.has(t))
                        throw new U("writer-removemarker-no-marker",this);
                    const r = this.model.markers.get(t);
                    if (!r.managedUsingOperations)
                        return void this.model.markers._remove(t);
                    El(this, t, r.getRange(), null, r.affectsData)
                }
                addRoot(e, t="$root") {
                    this._assertWriterUsedCorrectly();
                    const r = this.model.document.getRoot(e);
                    if (r && r.isAttached())
                        throw new U("writer-addroot-root-exists",this);
                    const i = this.model.document
                      , l = new jr(e,t,!0,i,i.version);
                    return this.batch.addOperation(l),
                    this.model.applyOperation(l),
                    this.model.document.getRoot(e)
                }
                detachRoot(e) {
                    this._assertWriterUsedCorrectly();
                    const t = typeof e == "string" ? this.model.document.getRoot(e) : e;
                    if (!t || !t.isAttached())
                        throw new U("writer-detachroot-no-root",this);
                    for (const l of this.model.markers)
                        l.getRange().root === t && this.removeMarker(l);
                    for (const l of t.getAttributeKeys())
                        this.removeAttribute(l, t);
                    this.remove(this.createRangeIn(t));
                    const r = this.model.document
                      , i = new jr(t.rootName,t.name,!1,r,r.version);
                    this.batch.addOperation(i),
                    this.model.applyOperation(i)
                }
                setSelection(...e) {
                    this._assertWriterUsedCorrectly(),
                    this.model.document.selection._setTo(...e)
                }
                setSelectionFocus(e, t) {
                    this._assertWriterUsedCorrectly(),
                    this.model.document.selection._setFocus(e, t)
                }
                setSelectionAttribute(e, t) {
                    if (this._assertWriterUsedCorrectly(),
                    typeof e == "string")
                        this._setSelectionAttribute(e, t);
                    else
                        for (const [r,i] of Ir(e))
                            this._setSelectionAttribute(r, i)
                }
                removeSelectionAttribute(e) {
                    if (this._assertWriterUsedCorrectly(),
                    typeof e == "string")
                        this._removeSelectionAttribute(e);
                    else
                        for (const t of e)
                            this._removeSelectionAttribute(t)
                }
                overrideSelectionGravity() {
                    return this.model.document.selection._overrideGravity()
                }
                restoreSelectionGravity(e) {
                    this.model.document.selection._restoreGravity(e)
                }
                _setSelectionAttribute(e, t) {
                    const r = this.model.document.selection;
                    if (r.isCollapsed && r.anchor.parent.isEmpty) {
                        const i = kr._getStoreAttributeKey(e);
                        this.setAttribute(i, t, r.anchor.parent)
                    }
                    r._setAttribute(e, t)
                }
                _removeSelectionAttribute(e) {
                    const t = this.model.document.selection;
                    if (t.isCollapsed && t.anchor.parent.isEmpty) {
                        const r = kr._getStoreAttributeKey(e);
                        this.removeAttribute(r, t.anchor.parent)
                    }
                    t._removeAttribute(e)
                }
                _assertWriterUsedCorrectly() {
                    if (this.model._currentWriter !== this)
                        throw new U("writer-incorrect-use",this)
                }
                _addOperationForAffectedMarkers(e, t) {
                    for (const r of this.model.markers) {
                        if (!r.managedUsingOperations)
                            continue;
                        const i = r.getRange();
                        let l = !1;
                        if (e === "move") {
                            const d = t;
                            l = d.containsPosition(i.start) || d.start.isEqual(i.start) || d.containsPosition(i.end) || d.end.isEqual(i.end)
                        } else {
                            const d = t
                              , h = d.nodeBefore
                              , m = d.nodeAfter
                              , g = i.start.parent == h && i.start.isAtEnd
                              , b = i.end.parent == m && i.end.offset == 0
                              , v = i.end.nodeAfter == m
                              , x = i.start.nodeAfter == m;
                            l = g || b || v || x
                        }
                        l && this.updateMarker(r.name, {
                            range: i
                        })
                    }
                }
            }
            function Y_(s, e, t, r) {
                const i = s.model
                  , l = i.document;
                let d, h, m, g = r.start;
                for (const v of r.getWalker({
                    shallow: !0
                }))
                    m = v.item.getAttribute(e),
                    d && h != m && (h != t && b(),
                    g = d),
                    d = v.nextPosition,
                    h = m;
                function b() {
                    const v = new J(g,d)
                      , x = v.root.document ? l.version : null
                      , T = new wt(v,e,h,t,x);
                    s.batch.addOperation(T),
                    i.applyOperation(T)
                }
                d instanceof ne && d != g && h != t && b()
            }
            function Q_(s, e, t, r) {
                const i = s.model
                  , l = i.document
                  , d = r.getAttribute(e);
                let h, m;
                if (d != t) {
                    if (r.root === r) {
                        const g = r.document ? l.version : null;
                        m = new Yr(r,e,d,t,g)
                    } else {
                        h = new J(ne._createBefore(r),s.createPositionAfter(r));
                        const g = h.root.document ? l.version : null;
                        m = new wt(h,e,d,t,g)
                    }
                    s.batch.addOperation(m),
                    i.applyOperation(m)
                }
            }
            function El(s, e, t, r, i) {
                const l = s.model
                  , d = l.document
                  , h = new co(e,t,r,l.markers,!!i,d.version);
                s.batch.addOperation(h),
                l.applyOperation(h)
            }
            function G3(s, e, t, r) {
                let i;
                if (s.root.document) {
                    const l = r.document
                      , d = new ne(l.graveyard,[0]);
                    i = new je(s,e,d,l.version)
                } else
                    i = new $3(s,e);
                t.addOperation(i),
                r.applyOperation(i)
            }
            function Z_(s, e) {
                return s === e || s instanceof Kd && e instanceof Kd
            }
            function K3(s, e, t={}) {
                if (e.isCollapsed)
                    return;
                const r = e.getFirstRange();
                if (r.root.rootName == "$graveyard")
                    return;
                const i = s.schema;
                s.change(l => {
                    if (!t.doNotResetEntireContent && function(g, b) {
                        const v = g.getLimitElement(b);
                        if (!b.containsEntireContent(v))
                            return !1;
                        const x = b.getFirstRange();
                        return x.start.parent == x.end.parent ? !1 : g.checkChild(v, "paragraph")
                    }(i, e))
                        return void function(g, b) {
                            const v = g.model.schema.getLimitElement(b);
                            g.remove(g.createRangeIn(v)),
                            eC(g, g.createPositionAt(v, 0), b)
                        }(l, e);
                    const d = {};
                    if (!t.doNotAutoparagraph) {
                        const g = e.getSelectedElement();
                        g && Object.assign(d, i.getAttributesWithProperty(g, "copyOnReplace", !0))
                    }
                    const [h,m] = function(g) {
                        const b = g.root.document.model
                          , v = g.start;
                        let x = g.end;
                        if (b.hasContent(g, {
                            ignoreMarkers: !0
                        })) {
                            const T = function(I) {
                                const P = I.parent
                                  , O = P.root.document.model.schema
                                  , F = P.getAncestors({
                                    parentFirst: !0,
                                    includeSelf: !0
                                });
                                for (const q of F) {
                                    if (O.isLimit(q))
                                        return null;
                                    if (O.isBlock(q))
                                        return q
                                }
                            }(x);
                            if (T && x.isTouching(b.createPositionAt(T, 0))) {
                                const I = b.createSelection(g);
                                b.modifySelection(I, {
                                    direction: "backward"
                                });
                                const P = I.getLastPosition()
                                  , O = b.createRange(P, x);
                                b.hasContent(O, {
                                    ignoreMarkers: !0
                                }) || (x = P)
                            }
                        }
                        return [Ut.fromPosition(v, "toPrevious"), Ut.fromPosition(x, "toNext")]
                    }(r);
                    h.isTouching(m) || l.remove(l.createRange(h, m)),
                    t.leaveUnmerged || (function(g, b, v) {
                        const x = g.model;
                        if (!jp(g.model.schema, b, v))
                            return;
                        const [T,I] = function(P, O) {
                            const F = P.getAncestors()
                              , q = O.getAncestors();
                            let Q = 0;
                            for (; F[Q] && F[Q] == q[Q]; )
                                Q++;
                            return [F[Q], q[Q]]
                        }(b, v);
                        !T || !I || (!x.hasContent(T, {
                            ignoreMarkers: !0
                        }) && x.hasContent(I, {
                            ignoreMarkers: !0
                        }) ? X_(g, b, v, T.parent) : J_(g, b, v, T.parent))
                    }(l, h, m),
                    i.removeDisallowedAttributes(h.parent.getChildren(), l)),
                    tC(l, e, h),
                    !t.doNotAutoparagraph && function(g, b) {
                        const v = g.checkChild(b, "$text")
                          , x = g.checkChild(b, "paragraph");
                        return !v && x
                    }(i, h) && eC(l, h, e, d),
                    h.detach(),
                    m.detach()
                }
                )
            }
            function J_(s, e, t, r) {
                const i = e.parent
                  , l = t.parent;
                if (i != r && l != r) {
                    for (e = s.createPositionAfter(i),
                    (t = s.createPositionBefore(l)).isEqual(e) || s.insert(l, e),
                    s.merge(e); t.parent.isEmpty; ) {
                        const d = t.parent;
                        t = s.createPositionBefore(d),
                        s.remove(d)
                    }
                    jp(s.model.schema, e, t) && J_(s, e, t, r)
                }
            }
            function X_(s, e, t, r) {
                const i = e.parent
                  , l = t.parent;
                if (i != r && l != r) {
                    for (e = s.createPositionAfter(i),
                    (t = s.createPositionBefore(l)).isEqual(e) || s.insert(i, t); e.parent.isEmpty; ) {
                        const d = e.parent;
                        e = s.createPositionBefore(d),
                        s.remove(d)
                    }
                    t = s.createPositionBefore(l),
                    function(d, h) {
                        const m = h.nodeBefore
                          , g = h.nodeAfter;
                        m.name != g.name && d.rename(m, g.name),
                        d.clearAttributes(m),
                        d.setAttributes(Object.fromEntries(g.getAttributes()), m),
                        d.merge(h)
                    }(s, t),
                    jp(s.model.schema, e, t) && X_(s, e, t, r)
                }
            }
            function jp(s, e, t) {
                const r = e.parent
                  , i = t.parent;
                return r != i && !s.isLimit(r) && !s.isLimit(i) && function(l, d, h) {
                    const m = new J(l,d);
                    for (const g of m.getWalker())
                        if (h.isLimit(g.item))
                            return !1;
                    return !0
                }(e, t, s)
            }
            function eC(s, e, t, r={}) {
                const i = s.createElement("paragraph");
                s.model.schema.setAllowedAttributes(i, r, s),
                s.insert(i, e),
                tC(s, t, s.createPositionAt(i, 0))
            }
            function tC(s, e, t) {
                e instanceof kr ? s.setSelection(t) : e.setTo(t)
            }
            function oC(s, e) {
                const t = [];
                Array.from(s.getItems({
                    direction: "backward"
                })).map(r => e.createRangeOn(r)).filter(r => (r.start.isAfter(s.start) || r.start.isEqual(s.start)) && (r.end.isBefore(s.end) || r.end.isEqual(s.end))).forEach(r => {
                    t.push(r.start.parent),
                    e.remove(r)
                }
                ),
                t.forEach(r => {
                    let i = r;
                    for (; i.parent && i.isEmpty; ) {
                        const l = e.createRangeOn(i);
                        i = i.parent,
                        e.remove(l)
                    }
                }
                )
            }
            class Y3 {
                constructor(e, t, r) {
                    C(this, "model"),
                    C(this, "writer"),
                    C(this, "position"),
                    C(this, "canMergeWith"),
                    C(this, "schema"),
                    C(this, "_documentFragment"),
                    C(this, "_documentFragmentPosition"),
                    C(this, "_firstNode", null),
                    C(this, "_lastNode", null),
                    C(this, "_lastAutoParagraph", null),
                    C(this, "_filterAttributesOf", []),
                    C(this, "_affectedStart", null),
                    C(this, "_affectedEnd", null),
                    C(this, "_nodeToSelect", null),
                    this.model = e,
                    this.writer = t,
                    this.position = r,
                    this.canMergeWith = new Set([this.position.parent]),
                    this.schema = e.schema,
                    this._documentFragment = t.createDocumentFragment(),
                    this._documentFragmentPosition = t.createPositionAt(this._documentFragment, 0)
                }
                handleNodes(e) {
                    for (const t of Array.from(e))
                        this._handleNode(t);
                    this._insertPartialFragment(),
                    this._lastAutoParagraph && this._updateLastNodeFromAutoParagraph(this._lastAutoParagraph),
                    this._mergeOnRight(),
                    this.schema.removeDisallowedAttributes(this._filterAttributesOf, this.writer),
                    this._filterAttributesOf = []
                }
                _updateLastNodeFromAutoParagraph(e) {
                    const t = this.writer.createPositionAfter(this._lastNode)
                      , r = this.writer.createPositionAfter(e);
                    if (r.isAfter(t)) {
                        if (this._lastNode = e,
                        this.position.parent != e || !this.position.isAtEnd)
                            throw new U("insertcontent-invalid-insertion-position",this);
                        this.position = r,
                        this._setAffectedBoundaries(this.position)
                    }
                }
                getSelectionRange() {
                    return this._nodeToSelect ? J._createOn(this._nodeToSelect) : this.model.schema.getNearestSelectionRange(this.position)
                }
                getAffectedRange() {
                    return this._affectedStart ? new J(this._affectedStart,this._affectedEnd) : null
                }
                destroy() {
                    this._affectedStart && this._affectedStart.detach(),
                    this._affectedEnd && this._affectedEnd.detach()
                }
                _handleNode(e) {
                    if (this.schema.isObject(e))
                        return void this._handleObject(e);
                    let t = this._checkAndAutoParagraphToAllowedPosition(e);
                    t || (t = this._checkAndSplitToAllowedPosition(e),
                    t) ? (this._appendToFragment(e),
                    this._firstNode || (this._firstNode = e),
                    this._lastNode = e) : this._handleDisallowedNode(e)
                }
                _insertPartialFragment() {
                    if (this._documentFragment.isEmpty)
                        return;
                    const e = Ut.fromPosition(this.position, "toNext");
                    this._setAffectedBoundaries(this.position),
                    this._documentFragment.getChild(0) == this._firstNode && (this.writer.insert(this._firstNode, this.position),
                    this._mergeOnLeft(),
                    this.position = e.toPosition()),
                    this._documentFragment.isEmpty || this.writer.insert(this._documentFragment, this.position),
                    this._documentFragmentPosition = this.writer.createPositionAt(this._documentFragment, 0),
                    this.position = e.toPosition(),
                    e.detach()
                }
                _handleObject(e) {
                    this._checkAndSplitToAllowedPosition(e) ? this._appendToFragment(e) : this._tryAutoparagraphing(e)
                }
                _handleDisallowedNode(e) {
                    e.is("element") ? this.handleNodes(e.getChildren()) : this._tryAutoparagraphing(e)
                }
                _appendToFragment(e) {
                    if (!this.schema.checkChild(this.position, e))
                        throw new U("insertcontent-wrong-position",this,{
                            node: e,
                            position: this.position
                        });
                    this.writer.insert(e, this._documentFragmentPosition),
                    this._documentFragmentPosition = this._documentFragmentPosition.getShiftedBy(e.offsetSize),
                    this.schema.isObject(e) && !this.schema.checkChild(this.position, "$text") ? this._nodeToSelect = e : this._nodeToSelect = null,
                    this._filterAttributesOf.push(e)
                }
                _setAffectedBoundaries(e) {
                    this._affectedStart || (this._affectedStart = Ut.fromPosition(e, "toPrevious")),
                    this._affectedEnd && !this._affectedEnd.isBefore(e) || (this._affectedEnd && this._affectedEnd.detach(),
                    this._affectedEnd = Ut.fromPosition(e, "toNext"))
                }
                _mergeOnLeft() {
                    const e = this._firstNode;
                    if (!(e instanceof Fe) || !this._canMergeLeft(e))
                        return;
                    const t = Ut._createBefore(e);
                    t.stickiness = "toNext";
                    const r = Ut.fromPosition(this.position, "toNext");
                    this._affectedStart.isEqual(t) && (this._affectedStart.detach(),
                    this._affectedStart = Ut._createAt(t.nodeBefore, "end", "toPrevious")),
                    this._firstNode === this._lastNode && (this._firstNode = t.nodeBefore,
                    this._lastNode = t.nodeBefore),
                    this.writer.merge(t),
                    t.isEqual(this._affectedEnd) && this._firstNode === this._lastNode && (this._affectedEnd.detach(),
                    this._affectedEnd = Ut._createAt(t.nodeBefore, "end", "toNext")),
                    this.position = r.toPosition(),
                    r.detach(),
                    this._filterAttributesOf.push(this.position.parent),
                    t.detach()
                }
                _mergeOnRight() {
                    const e = this._lastNode;
                    if (!(e instanceof Fe) || !this._canMergeRight(e))
                        return;
                    const t = Ut._createAfter(e);
                    if (t.stickiness = "toNext",
                    !this.position.isEqual(t))
                        throw new U("insertcontent-invalid-insertion-position",this);
                    this.position = ne._createAt(t.nodeBefore, "end");
                    const r = Ut.fromPosition(this.position, "toPrevious");
                    this._affectedEnd.isEqual(t) && (this._affectedEnd.detach(),
                    this._affectedEnd = Ut._createAt(t.nodeBefore, "end", "toNext")),
                    this._firstNode === this._lastNode && (this._firstNode = t.nodeBefore,
                    this._lastNode = t.nodeBefore),
                    this.writer.merge(t),
                    t.getShiftedBy(-1).isEqual(this._affectedStart) && this._firstNode === this._lastNode && (this._affectedStart.detach(),
                    this._affectedStart = Ut._createAt(t.nodeBefore, 0, "toPrevious")),
                    this.position = r.toPosition(),
                    r.detach(),
                    this._filterAttributesOf.push(this.position.parent),
                    t.detach()
                }
                _canMergeLeft(e) {
                    const t = e.previousSibling;
                    return t instanceof Fe && this.canMergeWith.has(t) && this.model.schema.checkMerge(t, e)
                }
                _canMergeRight(e) {
                    const t = e.nextSibling;
                    return t instanceof Fe && this.canMergeWith.has(t) && this.model.schema.checkMerge(e, t)
                }
                _tryAutoparagraphing(e) {
                    const t = this.writer.createElement("paragraph");
                    this._getAllowedIn(this.position.parent, t) && this.schema.checkChild(t, e) && (t._appendChild(e),
                    this._handleNode(t))
                }
                _checkAndAutoParagraphToAllowedPosition(e) {
                    if (this.schema.checkChild(this.position.parent, e))
                        return !0;
                    if (!this.schema.checkChild(this.position.parent, "paragraph") || !this.schema.checkChild("paragraph", e))
                        return !1;
                    this._insertPartialFragment();
                    const t = this.writer.createElement("paragraph");
                    return this.writer.insert(t, this.position),
                    this._setAffectedBoundaries(this.position),
                    this._lastAutoParagraph = t,
                    this.position = this.writer.createPositionAt(t, 0),
                    !0
                }
                _checkAndSplitToAllowedPosition(e) {
                    const t = this._getAllowedIn(this.position.parent, e);
                    if (!t)
                        return !1;
                    for (t != this.position.parent && this._insertPartialFragment(); t != this.position.parent; )
                        if (this.position.isAtStart) {
                            const r = this.position.parent;
                            this.position = this.writer.createPositionBefore(r),
                            r.isEmpty && r.parent === t && this.writer.remove(r)
                        } else if (this.position.isAtEnd)
                            this.position = this.writer.createPositionAfter(this.position.parent);
                        else {
                            const r = this.writer.createPositionAfter(this.position.parent);
                            this._setAffectedBoundaries(this.position),
                            this.writer.split(this.position),
                            this.position = r,
                            this.canMergeWith.add(this.position.nodeAfter)
                        }
                    return !0
                }
                _getAllowedIn(e, t) {
                    return this.schema.checkChild(e, t) ? e : this.schema.isLimit(e) ? null : this._getAllowedIn(e.parent, t)
                }
            }
            function Q3(s, e, t, r={}) {
                if (!s.schema.isObject(e))
                    throw new U("insertobject-element-not-an-object",s,{
                        object: e
                    });
                const i = t || s.document.selection;
                let l = i;
                r.findOptimalPosition && s.schema.isBlock(e) && (l = s.createSelection(s.schema.findOptimalInsertionRange(i, r.findOptimalPosition)));
                const d = zt(i.getSelectedBlocks())
                  , h = {};
                return d && Object.assign(h, s.schema.getAttributesWithProperty(d, "copyOnReplace", !0)),
                s.change(m => {
                    l.isCollapsed || s.deleteContent(l, {
                        doNotAutoparagraph: !0
                    });
                    let g = e;
                    const b = l.anchor.parent;
                    !s.schema.checkChild(b, e) && s.schema.checkChild(b, "paragraph") && s.schema.checkChild("paragraph", e) && (g = m.createElement("paragraph"),
                    m.insert(e, g)),
                    s.schema.setAllowedAttributes(g, h, m);
                    const v = s.insertContent(g, l);
                    return v.isCollapsed || r.setSelection && function(x, T, I, P) {
                        const O = x.model;
                        if (I == "on")
                            return void x.setSelection(T, "on");
                        if (I != "after")
                            throw new U("insertobject-invalid-place-parameter-value",O);
                        let F = T.nextSibling;
                        if (O.schema.isInline(T))
                            return void x.setSelection(T, "after");
                        !(F && O.schema.checkChild(F, "$text")) && O.schema.checkChild(T.parent, "paragraph") && (F = x.createElement("paragraph"),
                        O.schema.setAllowedAttributes(F, P, x),
                        O.insertContent(F, x.createPositionAfter(T))),
                        F && x.setSelection(F, 0)
                    }(m, e, r.setSelection, h),
                    v
                }
                )
            }
            const Z3 = ' ,.?!:;"-()';
            function J3(s, e) {
                const {isForward: t, walker: r, unit: i, schema: l, treatEmojiAsSingleUnit: d} = s
                  , {type: h, item: m, nextPosition: g} = e;
                if (h == "text")
                    return s.unit === "word" ? function(b, v) {
                        let x = b.position.textNode;
                        for (x || (x = v ? b.position.nodeAfter : b.position.nodeBefore); x && x.is("$text"); ) {
                            const T = b.position.offset - x.startOffset;
                            if (tj(x, T, v))
                                x = v ? b.position.nodeAfter : b.position.nodeBefore;
                            else {
                                if (ej(x.data, T, v))
                                    break;
                                b.next()
                            }
                        }
                        return b.position
                    }(r, t) : function(b, v, x) {
                        const T = b.position.textNode;
                        if (T) {
                            const I = T.data;
                            let P = b.position.offset - T.startOffset;
                            for (; tp(I, P) || v == "character" && op(I, P) || x && sv(I, P); )
                                b.next(),
                                P = b.position.offset - T.startOffset
                        }
                        return b.position
                    }(r, i, d);
                if (h == (t ? "elementStart" : "elementEnd")) {
                    if (l.isSelectable(m))
                        return ne._createAt(m, t ? "after" : "before");
                    if (l.checkChild(g, "$text"))
                        return g
                } else {
                    if (l.isLimit(m))
                        return void r.skip( () => !0);
                    if (l.checkChild(g, "$text"))
                        return g
                }
            }
            function X3(s, e) {
                const t = s.root
                  , r = ne._createAt(t, e ? "end" : 0);
                return e ? new J(s,r) : new J(r,s)
            }
            function ej(s, e, t) {
                const r = e + (t ? 0 : -1);
                return Z3.includes(s.charAt(r))
            }
            function tj(s, e, t) {
                return e === (t ? s.offsetSize : 0)
            }
            class oj extends ye() {
                constructor() {
                    super(),
                    C(this, "markers"),
                    C(this, "document"),
                    C(this, "schema"),
                    C(this, "_pendingChanges"),
                    C(this, "_currentWriter"),
                    this.markers = new W3,
                    this.document = new H3(this),
                    this.schema = new f3,
                    this._pendingChanges = [],
                    this._currentWriter = null,
                    ["deleteContent", "modifySelection", "getSelectedContent", "applyOperation"].forEach(e => this.decorate(e)),
                    this.on("applyOperation", (e, t) => {
                        t[0]._validate()
                    }
                    , {
                        priority: "highest"
                    }),
                    this.schema.register("$root", {
                        isLimit: !0
                    }),
                    this.schema.register("$container", {
                        allowIn: ["$root", "$container"]
                    }),
                    this.schema.register("$block", {
                        allowIn: ["$root", "$container"],
                        isBlock: !0
                    }),
                    this.schema.register("$blockObject", {
                        allowWhere: "$block",
                        isBlock: !0,
                        isObject: !0
                    }),
                    this.schema.register("$inlineObject", {
                        allowWhere: "$text",
                        allowAttributesOf: "$text",
                        isInline: !0,
                        isObject: !0
                    }),
                    this.schema.register("$text", {
                        allowIn: "$block",
                        isInline: !0,
                        isContent: !0
                    }),
                    this.schema.register("$clipboardHolder", {
                        allowContentOf: "$root",
                        allowChildren: "$text",
                        isLimit: !0
                    }),
                    this.schema.register("$documentFragment", {
                        allowContentOf: "$root",
                        allowChildren: "$text",
                        isLimit: !0
                    }),
                    this.schema.register("$marker"),
                    this.schema.addChildCheck( (e, t) => {
                        if (t.name === "$marker")
                            return !0
                    }
                    ),
                    m3(this),
                    this.document.registerPostFixer(y_),
                    this.on("insertContent", (e, [t,r]) => {
                        e.return = function(i, l, d) {
                            return i.change(h => {
                                const m = d || i.document.selection;
                                m.isCollapsed || i.deleteContent(m, {
                                    doNotAutoparagraph: !0
                                });
                                const g = new Y3(i,h,m.anchor)
                                  , b = [];
                                let v;
                                if (l.is("documentFragment")) {
                                    if (l.markers.size) {
                                        const I = [];
                                        for (const [P,O] of l.markers) {
                                            const {start: F, end: q} = O
                                              , Q = F.isEqual(q);
                                            I.push({
                                                position: F,
                                                name: P,
                                                isCollapsed: Q
                                            }, {
                                                position: q,
                                                name: P,
                                                isCollapsed: Q
                                            })
                                        }
                                        I.sort( ({position: P}, {position: O}) => P.isBefore(O) ? 1 : -1);
                                        for (const {position: P, name: O, isCollapsed: F} of I) {
                                            let q = null
                                              , Q = null;
                                            const X = P.parent === l && P.isAtStart
                                              , le = P.parent === l && P.isAtEnd;
                                            X || le ? F && (Q = X ? "start" : "end") : (q = h.createElement("$marker"),
                                            h.insert(q, P)),
                                            b.push({
                                                name: O,
                                                element: q,
                                                collapsed: Q
                                            })
                                        }
                                    }
                                    v = l.getChildren()
                                } else
                                    v = [l];
                                g.handleNodes(v);
                                let x = g.getSelectionRange();
                                if (l.is("documentFragment") && b.length) {
                                    const I = x ? Io.fromRange(x) : null
                                      , P = {};
                                    for (let O = b.length - 1; O >= 0; O--) {
                                        const {name: F, element: q, collapsed: Q} = b[O]
                                          , X = !P[F];
                                        if (X && (P[F] = []),
                                        q) {
                                            const le = h.createPositionAt(q, "before");
                                            P[F].push(le),
                                            h.remove(q)
                                        } else {
                                            const le = g.getAffectedRange();
                                            if (!le) {
                                                Q && P[F].push(g.position);
                                                continue
                                            }
                                            Q ? P[F].push(le[Q]) : P[F].push(X ? le.start : le.end)
                                        }
                                    }
                                    for (const [O,[F,q]] of Object.entries(P))
                                        F && q && F.root === q.root && F.root.document && !h.model.markers.has(O) && h.addMarker(O, {
                                            usingOperation: !0,
                                            affectsData: !0,
                                            range: new J(F,q)
                                        });
                                    I && (x = I.toRange(),
                                    I.detach())
                                }
                                x && (m instanceof kr ? h.setSelection(x) : m.setTo(x));
                                const T = g.getAffectedRange() || i.createRange(m.anchor);
                                return g.destroy(),
                                T
                            }
                            )
                        }(this, t, r)
                    }
                    ),
                    this.on("insertObject", (e, [t,r,i]) => {
                        e.return = Q3(this, t, r, i)
                    }
                    ),
                    this.on("canEditAt", e => {
                        const t = !this.document.isReadOnly;
                        e.return = t,
                        t || e.stop()
                    }
                    )
                }
                change(e) {
                    try {
                        return this._pendingChanges.length === 0 ? (this._pendingChanges.push({
                            batch: new Ms,
                            callback: e
                        }),
                        this._runPendingChanges()[0]) : e(this._currentWriter)
                    } catch (t) {
                        U.rethrowUnexpectedError(t, this)
                    }
                }
                enqueueChange(e, t) {
                    try {
                        e ? typeof e == "function" ? (t = e,
                        e = new Ms) : e instanceof Ms || (e = new Ms(e)) : e = new Ms,
                        this._pendingChanges.push({
                            batch: e,
                            callback: t
                        }),
                        this._pendingChanges.length == 1 && this._runPendingChanges()
                    } catch (r) {
                        U.rethrowUnexpectedError(r, this)
                    }
                }
                applyOperation(e) {
                    e._execute()
                }
                insertContent(e, t, r, ...i) {
                    const l = Lp(t, r);
                    return this.fire("insertContent", [e, l, r, ...i])
                }
                insertObject(e, t, r, i, ...l) {
                    const d = Lp(t, r);
                    return this.fire("insertObject", [e, d, i, i, ...l])
                }
                deleteContent(e, t) {
                    K3(this, e, t)
                }
                modifySelection(e, t) {
                    (function(r, i, l={}) {
                        const d = r.schema
                          , h = l.direction != "backward"
                          , m = l.unit ? l.unit : "character"
                          , g = !!l.treatEmojiAsSingleUnit
                          , b = i.focus
                          , v = new Kr({
                            boundaries: X3(b, h),
                            singleCharacters: !0,
                            direction: h ? "forward" : "backward"
                        })
                          , x = {
                            walker: v,
                            schema: d,
                            isForward: h,
                            unit: m,
                            treatEmojiAsSingleUnit: g
                        };
                        let T;
                        for (; T = v.next(); ) {
                            if (T.done)
                                return;
                            const I = J3(x, T.value);
                            if (I)
                                return void (i instanceof kr ? r.change(P => {
                                    P.setSelectionFocus(I)
                                }
                                ) : i.setFocus(I))
                        }
                    }
                    )(this, e, t)
                }
                getSelectedContent(e) {
                    return function(t, r) {
                        return t.change(i => {
                            const l = i.createDocumentFragment()
                              , d = r.getFirstRange();
                            if (!d || d.isCollapsed)
                                return l;
                            const h = d.start.root
                              , m = d.start.getCommonPath(d.end)
                              , g = h.getNodeByPath(m);
                            let b;
                            b = d.start.parent == d.end.parent ? d : i.createRange(i.createPositionAt(g, d.start.path[m.length]), i.createPositionAt(g, d.end.path[m.length] + 1));
                            const v = b.end.offset - b.start.offset;
                            for (const x of b.getItems({
                                shallow: !0
                            }))
                                x.is("$textProxy") ? i.appendText(x.data, x.getAttributes(), l) : i.append(i.cloneElement(x, !0), l);
                            if (b != d) {
                                const x = d._getTransformedByMove(b.start, i.createPositionAt(l, 0), v)[0]
                                  , T = i.createRange(i.createPositionAt(l, 0), x.start);
                                oC(i.createRange(x.end, i.createPositionAt(l, "end")), i),
                                oC(T, i)
                            }
                            return l
                        }
                        )
                    }(this, e)
                }
                hasContent(e, t={}) {
                    const r = e instanceof J ? e : J._createIn(e);
                    if (r.isCollapsed)
                        return !1;
                    const {ignoreWhitespaces: i=!1, ignoreMarkers: l=!1} = t;
                    if (!l) {
                        for (const d of this.markers.getMarkersIntersectingRange(r))
                            if (d.affectsData)
                                return !0
                    }
                    for (const d of r.getItems())
                        if (this.schema.isContent(d) && (!d.is("$textProxy") || !i || d.data.search(/\S/) !== -1))
                            return !0;
                    return !1
                }
                canEditAt(e) {
                    const t = Lp(e);
                    return this.fire("canEditAt", [t])
                }
                createPositionFromPath(e, t, r) {
                    return new ne(e,t,r)
                }
                createPositionAt(e, t) {
                    return ne._createAt(e, t)
                }
                createPositionAfter(e) {
                    return ne._createAfter(e)
                }
                createPositionBefore(e) {
                    return ne._createBefore(e)
                }
                createRange(e, t) {
                    return new J(e,t)
                }
                createRangeIn(e) {
                    return J._createIn(e)
                }
                createRangeOn(e) {
                    return J._createOn(e)
                }
                createSelection(...e) {
                    return new To(...e)
                }
                createBatch(e) {
                    return new Ms(e)
                }
                createOperationFromJSON(e) {
                    return N3.fromJSON(e, this.document)
                }
                destroy() {
                    this.document.destroy(),
                    this.stopListening()
                }
                _runPendingChanges() {
                    const e = [];
                    this.fire("_beforeChanges");
                    try {
                        for (; this._pendingChanges.length; ) {
                            const t = this._pendingChanges[0].batch;
                            this._currentWriter = new q3(this,t);
                            const r = this._pendingChanges[0].callback(this._currentWriter);
                            e.push(r),
                            this.document._handleChangeBlock(this._currentWriter),
                            this._pendingChanges.shift(),
                            this._currentWriter = null
                        }
                    } finally {
                        this._pendingChanges.length = 0,
                        this._currentWriter = null,
                        this.fire("_afterChanges")
                    }
                    return e
                }
            }
            function Lp(s, e) {
                if (s)
                    return s instanceof To || s instanceof kr ? s : s instanceof Ii ? e || e === 0 ? new To(s,e) : s.is("rootElement") ? new To(s,"in") : new To(s,"on") : new To(s)
            }
            class rj extends Mn {
                constructor() {
                    super(...arguments),
                    C(this, "domEventType", "click")
                }
                onDomEvent(e) {
                    this.fire(e.type, e)
                }
            }
            class zp extends Mn {
                constructor() {
                    super(...arguments),
                    C(this, "domEventType", ["mousedown", "mouseup", "mouseover", "mouseout"])
                }
                onDomEvent(e) {
                    this.fire(e.type, e)
                }
            }
            class Zr {
                constructor(e) {
                    C(this, "document"),
                    this.document = e
                }
                createDocumentFragment(e) {
                    return new Ti(this.document,e)
                }
                createElement(e, t, r) {
                    return new So(this.document,e,t,r)
                }
                createText(e) {
                    return new We(this.document,e)
                }
                clone(e, t=!1) {
                    return e._clone(t)
                }
                appendChild(e, t) {
                    return t._appendChild(e)
                }
                insertChild(e, t, r) {
                    return r._insertChild(e, t)
                }
                removeChildren(e, t, r) {
                    return r._removeChildren(e, t)
                }
                remove(e) {
                    const t = e.parent;
                    return t ? this.removeChildren(t.getChildIndex(e), 1, t) : []
                }
                replace(e, t) {
                    const r = e.parent;
                    if (r) {
                        const i = r.getChildIndex(e);
                        return this.removeChildren(i, 1, r),
                        this.insertChild(i, t, r),
                        !0
                    }
                    return !1
                }
                unwrapElement(e) {
                    const t = e.parent;
                    if (t) {
                        const r = t.getChildIndex(e);
                        this.remove(e),
                        this.insertChild(r, e.getChildren(), t)
                    }
                }
                rename(e, t) {
                    const r = new So(this.document,e,t.getAttributes(),t.getChildren());
                    return this.replace(t, r) ? r : null
                }
                setAttribute(e, t, r) {
                    r._setAttribute(e, t)
                }
                removeAttribute(e, t) {
                    t._removeAttribute(e)
                }
                addClass(e, t) {
                    t._addClass(e)
                }
                removeClass(e, t) {
                    t._removeClass(e)
                }
                setStyle(e, t, r) {
                    Eo(e) && r === void 0 ? t._setStyle(e) : r._setStyle(e, t)
                }
                removeStyle(e, t) {
                    t._removeStyle(e)
                }
                setCustomProperty(e, t, r) {
                    r._setCustomProperty(e, t)
                }
                removeCustomProperty(e, t) {
                    return t._removeCustomProperty(e)
                }
                createPositionAt(e, t) {
                    return ae._createAt(e, t)
                }
                createPositionAfter(e) {
                    return ae._createAfter(e)
                }
                createPositionBefore(e) {
                    return ae._createBefore(e)
                }
                createRange(e, t) {
                    return new fe(e,t)
                }
                createRangeOn(e) {
                    return fe._createOn(e)
                }
                createRangeIn(e) {
                    return fe._createIn(e)
                }
                createSelection(...e) {
                    return new mr(...e)
                }
            }
            class rC {
                constructor(e) {
                    if (C(this, "crashes", []),
                    C(this, "state", "initializing"),
                    C(this, "_crashNumberLimit"),
                    C(this, "_now", Date.now),
                    C(this, "_minimumNonErrorTimePeriod"),
                    C(this, "_boundErrorHandler"),
                    C(this, "_listeners"),
                    this.crashes = [],
                    this._crashNumberLimit = typeof e.crashNumberLimit == "number" ? e.crashNumberLimit : 3,
                    this._minimumNonErrorTimePeriod = typeof e.minimumNonErrorTimePeriod == "number" ? e.minimumNonErrorTimePeriod : 5e3,
                    this._boundErrorHandler = t => {
                        const r = "error"in t ? t.error : t.reason;
                        r instanceof Error && this._handleError(r, t)
                    }
                    ,
                    this._listeners = {},
                    !this._restart)
                        throw new Error("The Watchdog class was split into the abstract `Watchdog` class and the `EditorWatchdog` class. Please, use `EditorWatchdog` if you have used the `Watchdog` class previously.")
                }
                destroy() {
                    this._stopErrorHandling(),
                    this._listeners = {}
                }
                on(e, t) {
                    this._listeners[e] || (this._listeners[e] = []),
                    this._listeners[e].push(t)
                }
                off(e, t) {
                    this._listeners[e] = this._listeners[e].filter(r => r !== t)
                }
                _fire(e, ...t) {
                    const r = this._listeners[e] || [];
                    for (const i of r)
                        i.apply(this, [null, ...t])
                }
                _startErrorHandling() {
                    window.addEventListener("error", this._boundErrorHandler),
                    window.addEventListener("unhandledrejection", this._boundErrorHandler)
                }
                _stopErrorHandling() {
                    window.removeEventListener("error", this._boundErrorHandler),
                    window.removeEventListener("unhandledrejection", this._boundErrorHandler)
                }
                _handleError(e, t) {
                    if (this._shouldReactToError(e)) {
                        this.crashes.push({
                            message: e.message,
                            stack: e.stack,
                            filename: t instanceof ErrorEvent ? t.filename : void 0,
                            lineno: t instanceof ErrorEvent ? t.lineno : void 0,
                            colno: t instanceof ErrorEvent ? t.colno : void 0,
                            date: this._now()
                        });
                        const r = this._shouldRestart();
                        this.state = "crashed",
                        this._fire("stateChange"),
                        this._fire("error", {
                            error: e,
                            causesRestart: r
                        }),
                        r ? this._restart() : (this.state = "crashedPermanently",
                        this._fire("stateChange"))
                    }
                }
                _shouldReactToError(e) {
                    return e.is && e.is("CKEditorError") && e.context !== void 0 && e.context !== null && this.state === "ready" && this._isErrorComingFromThisItem(e)
                }
                _shouldRestart() {
                    return this.crashes.length <= this._crashNumberLimit ? !0 : (this.crashes[this.crashes.length - 1].date - this.crashes[this.crashes.length - 1 - this._crashNumberLimit].date) / this._crashNumberLimit > this._minimumNonErrorTimePeriod
                }
            }
            function Op(s, e=new Set) {
                const t = [s]
                  , r = new Set;
                let i = 0;
                for (; t.length > i; ) {
                    const l = t[i++];
                    if (!r.has(l) && nj(l) && !e.has(l))
                        if (r.add(l),
                        Symbol.iterator in l)
                            try {
                                for (const d of l)
                                    t.push(d)
                            } catch {}
                        else
                            for (const d in l)
                                d !== "defaultValue" && t.push(l[d])
                }
                return r
            }
            function nj(s) {
                const e = Object.prototype.toString.call(s)
                  , t = typeof s;
                return !(t === "number" || t === "boolean" || t === "string" || t === "symbol" || t === "function" || e === "[object Date]" || e === "[object RegExp]" || e === "[object Module]" || s == null || s._watchdogExcluded || s instanceof EventTarget || s instanceof Event)
            }
            function nC(s, e, t=new Set) {
                if (s === e && typeof (r = s) == "object" && r !== null)
                    return !0;
                var r;
                const i = Op(s, t)
                  , l = Op(e, t);
                for (const d of i)
                    if (l.has(d))
                        return !0;
                return !1
            }
            const Yd = function(s, e, t) {
                var r = !0
                  , i = !0;
                if (typeof s != "function")
                    throw new TypeError("Expected a function");
                return Le(t) && (r = "leading"in t ? !!t.leading : r,
                i = "trailing"in t ? !!t.trailing : i),
                Ts(s, e, {
                    leading: r,
                    maxWait: e,
                    trailing: i
                })
            };
            class iC extends rC {
                constructor(e, t={}) {
                    super(t),
                    C(this, "_editor", null),
                    C(this, "_lifecyclePromise", null),
                    C(this, "_throttledSave"),
                    C(this, "_data"),
                    C(this, "_lastDocumentVersion"),
                    C(this, "_elementOrData"),
                    C(this, "_initUsingData", !0),
                    C(this, "_editables", {}),
                    C(this, "_config"),
                    C(this, "_excludedProps"),
                    this._throttledSave = Yd(this._save.bind(this), typeof t.saveInterval == "number" ? t.saveInterval : 5e3),
                    e && (this._creator = (r, i) => e.create(r, i)),
                    this._destructor = r => r.destroy()
                }
                get editor() {
                    return this._editor
                }
                get _item() {
                    return this._editor
                }
                setCreator(e) {
                    this._creator = e
                }
                setDestructor(e) {
                    this._destructor = e
                }
                _restart() {
                    return Promise.resolve().then( () => (this.state = "initializing",
                    this._fire("stateChange"),
                    this._destroy())).catch(e => {
                        console.error("An error happened during the editor destroying.", e)
                    }
                    ).then( () => {
                        const e = {}
                          , t = []
                          , r = this._config.rootsAttributes || {}
                          , i = {};
                        for (const [d,h] of Object.entries(this._data.roots))
                            h.isLoaded ? (e[d] = "",
                            i[d] = r[d] || {}) : t.push(d);
                        const l = {
                            ...this._config,
                            extraPlugins: this._config.extraPlugins || [],
                            lazyRoots: t,
                            rootsAttributes: i,
                            _watchdogInitialData: this._data
                        };
                        return delete l.initialData,
                        l.extraPlugins.push(ij),
                        this._initUsingData ? this.create(e, l, l.context) : Ci(this._elementOrData) ? this.create(this._elementOrData, l, l.context) : this.create(this._editables, l, l.context)
                    }
                    ).then( () => {
                        this._fire("restart")
                    }
                    )
                }
                create(e=this._elementOrData, t=this._config, r) {
                    return this._lifecyclePromise = Promise.resolve(this._lifecyclePromise).then( () => (super._startErrorHandling(),
                    this._elementOrData = e,
                    this._initUsingData = typeof e == "string" || Object.keys(e).length > 0 && typeof Object.values(e)[0] == "string",
                    this._config = this._cloneEditorConfiguration(t) || {},
                    this._config.context = r,
                    this._creator(e, this._config))).then(i => {
                        this._editor = i,
                        i.model.document.on("change:data", this._throttledSave),
                        this._lastDocumentVersion = i.model.document.version,
                        this._data = this._getData(),
                        this._initUsingData || (this._editables = this._getEditables()),
                        this.state = "ready",
                        this._fire("stateChange")
                    }
                    ).finally( () => {
                        this._lifecyclePromise = null
                    }
                    ),
                    this._lifecyclePromise
                }
                destroy() {
                    return this._lifecyclePromise = Promise.resolve(this._lifecyclePromise).then( () => (this.state = "destroyed",
                    this._fire("stateChange"),
                    super.destroy(),
                    this._destroy())).finally( () => {
                        this._lifecyclePromise = null
                    }
                    ),
                    this._lifecyclePromise
                }
                _destroy() {
                    return Promise.resolve().then( () => {
                        this._stopErrorHandling(),
                        this._throttledSave.cancel();
                        const e = this._editor;
                        return this._editor = null,
                        e.model.document.off("change:data", this._throttledSave),
                        this._destructor(e)
                    }
                    )
                }
                _save() {
                    const e = this._editor.model.document.version;
                    try {
                        this._data = this._getData(),
                        this._initUsingData || (this._editables = this._getEditables()),
                        this._lastDocumentVersion = e
                    } catch (t) {
                        console.error(t, "An error happened during restoring editor data. Editor will be restored from the previously saved data.")
                    }
                }
                _setExcludedProperties(e) {
                    this._excludedProps = e
                }
                _getData() {
                    const e = this._editor
                      , t = e.model.document.roots.filter(h => h.isAttached() && h.rootName != "$graveyard")
                      , {plugins: r} = e
                      , i = r.has("CommentsRepository") && r.get("CommentsRepository")
                      , l = r.has("TrackChanges") && r.get("TrackChanges")
                      , d = {
                        roots: {},
                        markers: {},
                        commentThreads: JSON.stringify([]),
                        suggestions: JSON.stringify([])
                    };
                    t.forEach(h => {
                        d.roots[h.rootName] = {
                            content: JSON.stringify(Array.from(h.getChildren())),
                            attributes: JSON.stringify(Array.from(h.getAttributes())),
                            isLoaded: h._isLoaded
                        }
                    }
                    );
                    for (const h of e.model.markers)
                        h._affectsData && (d.markers[h.name] = {
                            rangeJSON: h.getRange().toJSON(),
                            usingOperation: h._managedUsingOperations,
                            affectsData: h._affectsData
                        });
                    return i && (d.commentThreads = JSON.stringify(i.getCommentThreads({
                        toJSON: !0,
                        skipNotAttached: !0
                    }))),
                    l && (d.suggestions = JSON.stringify(l.getSuggestions({
                        toJSON: !0,
                        skipNotAttached: !0
                    }))),
                    d
                }
                _getEditables() {
                    const e = {};
                    for (const t of this.editor.model.document.getRootNames()) {
                        const r = this.editor.ui.getEditableElement(t);
                        r && (e[t] = r)
                    }
                    return e
                }
                _isErrorComingFromThisItem(e) {
                    return nC(this._editor, e.context, this._excludedProps)
                }
                _cloneEditorConfiguration(e) {
                    return Wm(e, (t, r) => Ci(t) || r === "context" ? t : void 0)
                }
            }
            class ij {
                constructor(e) {
                    C(this, "editor"),
                    C(this, "_data"),
                    this.editor = e,
                    this._data = e.config.get("_watchdogInitialData")
                }
                init() {
                    this.editor.data.on("init", e => {
                        e.stop(),
                        this.editor.model.enqueueChange({
                            isUndoable: !1
                        }, t => {
                            this._restoreCollaborationData(),
                            this._restoreEditorData(t)
                        }
                        ),
                        this.editor.data.fire("ready")
                    }
                    , {
                        priority: 999
                    })
                }
                _createNode(e, t) {
                    if ("name"in t) {
                        const r = e.createElement(t.name, t.attributes);
                        if (t.children)
                            for (const i of t.children)
                                r._appendChild(this._createNode(e, i));
                        return r
                    }
                    return e.createText(t.data, t.attributes)
                }
                _restoreEditorData(e) {
                    const t = this.editor;
                    Object.entries(this._data.roots).forEach( ([r,{content: i, attributes: l}]) => {
                        const d = JSON.parse(i)
                          , h = JSON.parse(l)
                          , m = t.model.document.getRoot(r);
                        for (const [g,b] of h)
                            e.setAttribute(g, b, m);
                        for (const g of d) {
                            const b = this._createNode(e, g);
                            e.insert(b, m, "end")
                        }
                    }
                    ),
                    Object.entries(this._data.markers).forEach( ([r,i]) => {
                        const {document: l} = t.model
                          , {rangeJSON: {start: d, end: h}, ...m} = i
                          , g = l.getRoot(d.root)
                          , b = e.createPositionFromPath(g, d.path, d.stickiness)
                          , v = e.createPositionFromPath(g, h.path, h.stickiness)
                          , x = e.createRange(b, v);
                        e.addMarker(r, {
                            range: x,
                            ...m
                        })
                    }
                    )
                }
                _restoreCollaborationData() {
                    const e = JSON.parse(this._data.commentThreads)
                      , t = JSON.parse(this._data.suggestions);
                    e.forEach(r => {
                        const i = this.editor.config.get("collaboration.channelId")
                          , l = this.editor.plugins.get("CommentsRepository");
                        l.hasCommentThread(r.threadId) && l.getCommentThread(r.threadId).remove(),
                        l.addCommentThread({
                            channelId: i,
                            ...r
                        })
                    }
                    ),
                    t.forEach(r => {
                        const i = this.editor.plugins.get("TrackChangesEditing");
                        i.hasSuggestion(r.id) ? i.getSuggestion(r.id).attributes = r.attributes : i.addSuggestionData(r)
                    }
                    )
                }
            }
            const Sl = Symbol("MainQueueId");
            class sj extends rC {
                constructor(e, t={}) {
                    super(t),
                    C(this, "_watchdogs", new Map),
                    C(this, "_watchdogConfig"),
                    C(this, "_context", null),
                    C(this, "_contextProps", new Set),
                    C(this, "_actionQueues", new aj),
                    C(this, "_contextConfig"),
                    C(this, "_item"),
                    this._watchdogConfig = t,
                    this._creator = r => e.create(r),
                    this._destructor = r => r.destroy(),
                    this._actionQueues.onEmpty( () => {
                        this.state === "initializing" && (this.state = "ready",
                        this._fire("stateChange"))
                    }
                    )
                }
                setCreator(e) {
                    this._creator = e
                }
                setDestructor(e) {
                    this._destructor = e
                }
                get context() {
                    return this._context
                }
                create(e={}) {
                    return this._actionQueues.enqueue(Sl, () => (this._contextConfig = e,
                    this._create()))
                }
                getItem(e) {
                    return this._getWatchdog(e)._item
                }
                getItemState(e) {
                    return this._getWatchdog(e).state
                }
                add(e) {
                    const t = sC(e);
                    return Promise.all(t.map(r => this._actionQueues.enqueue(r.id, () => {
                        if (this.state === "destroyed")
                            throw new Error("Cannot add items to destroyed watchdog.");
                        if (!this._context)
                            throw new Error("Context was not created yet. You should call the `ContextWatchdog#create()` method first.");
                        let i;
                        if (this._watchdogs.has(r.id))
                            throw new Error(`Item with the given id is already added: '${r.id}'.`);
                        if (r.type === "editor")
                            return i = new iC(null,this._watchdogConfig),
                            i.setCreator(r.creator),
                            i._setExcludedProperties(this._contextProps),
                            r.destructor && i.setDestructor(r.destructor),
                            this._watchdogs.set(r.id, i),
                            i.on("error", (l, {error: d, causesRestart: h}) => {
                                this._fire("itemError", {
                                    itemId: r.id,
                                    error: d
                                }),
                                h && this._actionQueues.enqueue(r.id, () => new Promise(m => {
                                    const g = () => {
                                        i.off("restart", g),
                                        this._fire("itemRestart", {
                                            itemId: r.id
                                        }),
                                        m()
                                    }
                                    ;
                                    i.on("restart", g)
                                }
                                ))
                            }
                            ),
                            i.create(r.sourceElementOrData, r.config, this._context);
                        throw new Error(`Not supported item type: '${r.type}'.`)
                    }
                    )))
                }
                remove(e) {
                    const t = sC(e);
                    return Promise.all(t.map(r => this._actionQueues.enqueue(r, () => {
                        const i = this._getWatchdog(r);
                        return this._watchdogs.delete(r),
                        i.destroy()
                    }
                    )))
                }
                destroy() {
                    return this._actionQueues.enqueue(Sl, () => (this.state = "destroyed",
                    this._fire("stateChange"),
                    super.destroy(),
                    this._destroy()))
                }
                _restart() {
                    return this._actionQueues.enqueue(Sl, () => (this.state = "initializing",
                    this._fire("stateChange"),
                    this._destroy().catch(e => {
                        console.error("An error happened during destroying the context or items.", e)
                    }
                    ).then( () => this._create()).then( () => this._fire("restart"))))
                }
                _create() {
                    return Promise.resolve().then( () => (this._startErrorHandling(),
                    this._creator(this._contextConfig))).then(e => (this._context = e,
                    this._contextProps = Op(this._context),
                    Promise.all(Array.from(this._watchdogs.values()).map(t => (t._setExcludedProperties(this._contextProps),
                    t.create(void 0, void 0, this._context))))))
                }
                _destroy() {
                    return Promise.resolve().then( () => {
                        this._stopErrorHandling();
                        const e = this._context;
                        return this._context = null,
                        this._contextProps = new Set,
                        Promise.all(Array.from(this._watchdogs.values()).map(t => t.destroy())).then( () => this._destructor(e))
                    }
                    )
                }
                _getWatchdog(e) {
                    const t = this._watchdogs.get(e);
                    if (!t)
                        throw new Error(`Item with the given id was not registered: ${e}.`);
                    return t
                }
                _isErrorComingFromThisItem(e) {
                    for (const t of this._watchdogs.values())
                        if (t._isErrorComingFromThisItem(e))
                            return !1;
                    return nC(this._context, e.context)
                }
            }
            class aj {
                constructor() {
                    C(this, "_onEmptyCallbacks", []),
                    C(this, "_queues", new Map),
                    C(this, "_activeActions", 0)
                }
                onEmpty(e) {
                    this._onEmptyCallbacks.push(e)
                }
                enqueue(e, t) {
                    const r = e === Sl;
                    this._activeActions++,
                    this._queues.get(e) || this._queues.set(e, Promise.resolve());
                    const i = (r ? Promise.all(this._queues.values()) : Promise.all([this._queues.get(Sl), this._queues.get(e)])).then(t)
                      , l = i.catch( () => {}
                    );
                    return this._queues.set(e, l),
                    i.finally( () => {
                        this._activeActions--,
                        this._queues.get(e) === l && this._activeActions === 0 && this._onEmptyCallbacks.forEach(d => d())
                    }
                    )
                }
            }
            function sC(s) {
                return Array.isArray(s) ? s : [s]
            }
            class lj {
                constructor() {
                    C(this, "_commands"),
                    this._commands = new Map
                }
                add(e, t) {
                    this._commands.set(e, t)
                }
                get(e) {
                    return this._commands.get(e)
                }
                execute(e, ...t) {
                    const r = this.get(e);
                    if (!r)
                        throw new U("commandcollection-command-not-found",this,{
                            commandName: e
                        });
                    return r.execute(...t)
                }
                *names() {
                    yield*this._commands.keys()
                }
                *commands() {
                    yield*this._commands.values()
                }
                [Symbol.iterator]() {
                    return this._commands[Symbol.iterator]()
                }
                destroy() {
                    for (const e of this.commands())
                        e.destroy()
                }
            }
            const Rp = "contentEditing"
              , aC = "common";
            class cj {
                constructor(e) {
                    C(this, "keystrokeInfos", new Map),
                    C(this, "_editor"),
                    this._editor = e;
                    const t = e.config.get("menuBar.isVisible")
                      , r = e.locale.t;
                    this.addKeystrokeInfoCategory({
                        id: Rp,
                        label: r("Content editing keystrokes"),
                        description: r("These keyboard shortcuts allow for quick access to content editing features.")
                    });
                    const i = [{
                        label: r("Close contextual balloons, dropdowns, and dialogs"),
                        keystroke: "Esc"
                    }, {
                        label: r("Open the accessibility help dialog"),
                        keystroke: "Alt+0"
                    }, {
                        label: r("Move focus between form fields (inputs, buttons, etc.)"),
                        keystroke: [["Tab"], ["Shift+Tab"]]
                    }, {
                        label: r("Move focus to the toolbar, navigate between toolbars"),
                        keystroke: "Alt+F10",
                        mayRequireFn: !0
                    }, {
                        label: r("Navigate through the toolbar or menu bar"),
                        keystroke: [["arrowup"], ["arrowright"], ["arrowdown"], ["arrowleft"]]
                    }, {
                        label: r("Execute the currently focused button. Executing buttons that interact with the editor content moves the focus back to the content."),
                        keystroke: [["Enter"], ["Space"]]
                    }];
                    t && i.push({
                        label: r("Move focus to the menu bar, navigate between menu bars"),
                        keystroke: "Alt+F9",
                        mayRequireFn: !0
                    }),
                    this.addKeystrokeInfoCategory({
                        id: "navigation",
                        label: r("User interface and content navigation keystrokes"),
                        description: r("Use the following keystrokes for more efficient navigation in the CKEditor 5 user interface."),
                        groups: [{
                            id: "common",
                            keystrokes: i
                        }]
                    })
                }
                addKeystrokeInfoCategory({id: e, label: t, description: r, groups: i}) {
                    this.keystrokeInfos.set(e, {
                        id: e,
                        label: t,
                        description: r,
                        groups: new Map
                    }),
                    this.addKeystrokeInfoGroup({
                        categoryId: e,
                        id: aC
                    }),
                    i && i.forEach(l => {
                        this.addKeystrokeInfoGroup({
                            categoryId: e,
                            ...l
                        })
                    }
                    )
                }
                addKeystrokeInfoGroup({categoryId: e=Rp, id: t, label: r, keystrokes: i}) {
                    const l = this.keystrokeInfos.get(e);
                    if (!l)
                        throw new U("accessibility-unknown-keystroke-info-category",this._editor,{
                            groupId: t,
                            categoryId: e
                        });
                    l.groups.set(t, {
                        id: t,
                        label: r,
                        keystrokes: i || []
                    })
                }
                addKeystrokeInfos({categoryId: e=Rp, groupId: t=aC, keystrokes: r}) {
                    if (!this.keystrokeInfos.has(e))
                        throw new U("accessibility-unknown-keystroke-info-category",this._editor,{
                            categoryId: e,
                            keystrokes: r
                        });
                    const i = this.keystrokeInfos.get(e);
                    if (!i.groups.has(t))
                        throw new U("accessibility-unknown-keystroke-info-group",this._editor,{
                            groupId: t,
                            categoryId: e,
                            keystrokes: r
                        });
                    i.groups.get(t).keystrokes.push(...r)
                }
            }
            class Ns extends ye() {
                constructor(e={}) {
                    super(),
                    C(this, "accessibility"),
                    C(this, "commands"),
                    C(this, "config"),
                    C(this, "conversion"),
                    C(this, "data"),
                    C(this, "editing"),
                    C(this, "locale"),
                    C(this, "model"),
                    C(this, "plugins"),
                    C(this, "keystrokes"),
                    C(this, "t"),
                    C(this, "_context"),
                    C(this, "_readOnlyLocks");
                    const t = this.constructor
                      , {translations: r, ...i} = t.defaultConfig || {}
                      , {translations: l=r, ...d} = e
                      , h = e.language || i.language;
                    this._context = e.context || new Id({
                        language: h,
                        translations: l
                    }),
                    this._context._addEditor(this, !e.context);
                    const m = Array.from(t.builtinPlugins || []);
                    this.config = new jA(d,i),
                    this.config.define("plugins", m),
                    this.config.define(this._context._getEditorConfig()),
                    this.plugins = new vv(this,m,this._context.plugins),
                    this.locale = this._context.locale,
                    this.t = this.locale.t,
                    this._readOnlyLocks = new Set,
                    this.commands = new lj,
                    this.set("state", "initializing"),
                    this.once("ready", () => this.state = "ready", {
                        priority: "high"
                    }),
                    this.once("destroy", () => this.state = "destroyed", {
                        priority: "high"
                    }),
                    this.model = new oj,
                    this.on("change:isReadOnly", () => {
                        this.model.document.isReadOnly = this.isReadOnly
                    }
                    );
                    const g = new rP;
                    this.data = new M3(this.model,g),
                    this.editing = new p3(this.model,g),
                    this.editing.view.document.bind("isReadOnly").to(this),
                    this.conversion = new B3([this.editing.downcastDispatcher, this.data.downcastDispatcher],this.data.upcastDispatcher),
                    this.conversion.addAlias("dataDowncast", this.data.downcastDispatcher),
                    this.conversion.addAlias("editingDowncast", this.editing.downcastDispatcher),
                    this.keystrokes = new z4(this),
                    this.keystrokes.listenTo(this.editing.view.document),
                    this.accessibility = new cj(this)
                }
                get isReadOnly() {
                    return this._readOnlyLocks.size > 0
                }
                set isReadOnly(e) {
                    throw new U("editor-isreadonly-has-no-setter")
                }
                enableReadOnlyMode(e) {
                    if (typeof e != "string" && typeof e != "symbol")
                        throw new U("editor-read-only-lock-id-invalid",null,{
                            lockId: e
                        });
                    this._readOnlyLocks.has(e) || (this._readOnlyLocks.add(e),
                    this._readOnlyLocks.size === 1 && this.fire("change:isReadOnly", "isReadOnly", !0, !1))
                }
                disableReadOnlyMode(e) {
                    if (typeof e != "string" && typeof e != "symbol")
                        throw new U("editor-read-only-lock-id-invalid",null,{
                            lockId: e
                        });
                    this._readOnlyLocks.has(e) && (this._readOnlyLocks.delete(e),
                    this._readOnlyLocks.size === 0 && this.fire("change:isReadOnly", "isReadOnly", !1, !0))
                }
                setData(e) {
                    this.data.set(e)
                }
                getData(e) {
                    return this.data.get(e)
                }
                initPlugins() {
                    const e = this.config
                      , t = e.get("plugins")
                      , r = e.get("removePlugins") || []
                      , i = e.get("extraPlugins") || []
                      , l = e.get("substitutePlugins") || [];
                    return this.plugins.init(t.concat(i), r, l)
                }
                destroy() {
                    let e = Promise.resolve();
                    return this.state == "initializing" && (e = new Promise(t => this.once("ready", t))),
                    e.then( () => {
                        this.fire("destroy"),
                        this.stopListening(),
                        this.commands.destroy()
                    }
                    ).then( () => this.plugins.destroy()).then( () => {
                        this.model.destroy(),
                        this.data.destroy(),
                        this.editing.destroy(),
                        this.keystrokes.destroy()
                    }
                    ).then( () => this._context._removeEditor(this))
                }
                execute(e, ...t) {
                    try {
                        return this.commands.execute(e, ...t)
                    } catch (r) {
                        U.rethrowUnexpectedError(r, this)
                    }
                }
                focus() {
                    this.editing.view.focus()
                }
                static create(...e) {
                    throw new Error("This is an abstract method.")
                }
            }
            C(Ns, "defaultConfig"),
            C(Ns, "builtinPlugins"),
            C(Ns, "Context", Id),
            C(Ns, "EditorWatchdog", iC),
            C(Ns, "ContextWatchdog", sj);
            function Fp(s) {
                return class extends s {
                    constructor() {
                        super(...arguments),
                        C(this, "sourceElement")
                    }
                    updateSourceElement(e) {
                        if (!this.sourceElement)
                            throw new U("editor-missing-sourceelement",this);
                        const t = this.config.get("updateSourceElementOnDestroy")
                          , r = this.sourceElement instanceof HTMLTextAreaElement;
                        if (!t && !r)
                            return void WA(this.sourceElement, "");
                        const i = typeof e == "string" ? e : this.data.get();
                        WA(this.sourceElement, i)
                    }
                }
            }
            Fp.updateSourceElement = Fp(Object).prototype.updateSourceElement;
            class lC extends Md {
                constructor() {
                    super(...arguments),
                    C(this, "_actions")
                }
                static get pluginName() {
                    return "PendingActions"
                }
                init() {
                    this.set("hasAny", !1),
                    this._actions = new dr({
                        idProperty: "_id"
                    }),
                    this._actions.delegate("add", "remove").to(this)
                }
                add(e) {
                    if (typeof e != "string")
                        throw new U("pendingactions-add-invalid-message",this);
                    const t = new (ye());
                    return t.set("message", e),
                    this._actions.add(t),
                    this.hasAny = !0,
                    t
                }
                remove(e) {
                    this._actions.remove(e),
                    this.hasAny = !!this._actions.length
                }
                get first() {
                    return this._actions.get(0)
                }
                [Symbol.iterator]() {
                    return this._actions[Symbol.iterator]()
                }
            }
            const he = {
                bold: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.187 17H5.773c-.637 0-1.092-.138-1.364-.415-.273-.277-.409-.718-.409-1.323V4.738c0-.617.14-1.062.419-1.332.279-.27.73-.406 1.354-.406h4.68c.69 0 1.288.041 1.793.124.506.083.96.242 1.36.478.341.197.644.447.906.75a3.262 3.262 0 0 1 .808 2.162c0 1.401-.722 2.426-2.167 3.075C15.05 10.175 16 11.315 16 13.01a3.756 3.756 0 0 1-2.296 3.504 6.1 6.1 0 0 1-1.517.377c-.571.073-1.238.11-2 .11zm-.217-6.217H7v4.087h3.069c1.977 0 2.965-.69 2.965-2.072 0-.707-.256-1.22-.768-1.537-.512-.319-1.277-.478-2.296-.478zM7 5.13v3.619h2.606c.729 0 1.292-.067 1.69-.2a1.6 1.6 0 0 0 .91-.765c.165-.267.247-.566.247-.897 0-.707-.26-1.176-.778-1.409-.519-.232-1.31-.348-2.375-.348H7z"/></svg>',
                cancel: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.591 10.177 4.243 4.242a1 1 0 0 1-1.415 1.415l-4.242-4.243-4.243 4.243a1 1 0 0 1-1.414-1.415l4.243-4.242L4.52 5.934A1 1 0 0 1 5.934 4.52l4.243 4.243 4.242-4.243a1 1 0 1 1 1.415 1.414l-4.243 4.243z"/></svg>',
                caption: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 16h9a1 1 0 0 1 0 2H2a1 1 0 0 1 0-2z"/><path d="M17 1a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h14zm0 1.5H3a.5.5 0 0 0-.492.41L2.5 3v9a.5.5 0 0 0 .41.492L3 12.5h14a.5.5 0 0 0 .492-.41L17.5 12V3a.5.5 0 0 0-.41-.492L17 2.5z" fill-opacity=".6"/></svg>',
                check: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.972 16.615a.997.997 0 0 1-.744-.292l-4.596-4.596a1 1 0 1 1 1.414-1.414l3.926 3.926 9.937-9.937a1 1 0 0 1 1.414 1.415L7.717 16.323a.997.997 0 0 1-.745.292z"/></svg>',
                image: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.66 9.118a.693.693 0 0 1 .956.032l3.65 3.411 2.422-2.238a.695.695 0 0 1 .945 0L17.5 13.6V2.5h-15v11.1l4.16-4.482ZM17.8 1c.652 0 1.2.47 1.2 1.1v14.362c0 .64-.532 1.038-1.184 1.038H2.184C1.532 17.5 1 17.103 1 16.462V2.1C1 1.47 1.537 1 2.2 1h15.6Zm-5.655 6a2.128 2.128 0 0 1 .157-2.364A2.133 2.133 0 1 1 12.145 7Z"/></svg>',
                imageUpload: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M1.201 1C.538 1 0 1.47 0 2.1v14.363c0 .64.534 1.037 1.186 1.037h9.494a2.97 2.97 0 0 1-.414-.287 2.998 2.998 0 0 1-1.055-2.03 3.003 3.003 0 0 1 .693-2.185l.383-.455-.02.018-3.65-3.41a.695.695 0 0 0-.957-.034L1.5 13.6V2.5h15v5.535a2.97 2.97 0 0 1 1.412.932l.088.105V2.1c0-.63-.547-1.1-1.2-1.1H1.202Zm11.713 2.803a2.146 2.146 0 0 0-2.049 1.992 2.14 2.14 0 0 0 1.28 2.096 2.13 2.13 0 0 0 2.644-3.11 2.134 2.134 0 0 0-1.875-.978Z"/><path d="M15.522 19.1a.79.79 0 0 0 .79-.79v-5.373l2.059 2.455a.79.79 0 1 0 1.211-1.015l-3.352-3.995a.79.79 0 0 0-.995-.179.784.784 0 0 0-.299.221l-3.35 3.99a.79.79 0 1 0 1.21 1.017l1.936-2.306v5.185c0 .436.353.79.79.79Z"/><path d="M15.522 19.1a.79.79 0 0 0 .79-.79v-5.373l2.059 2.455a.79.79 0 1 0 1.211-1.015l-3.352-3.995a.79.79 0 0 0-.995-.179.784.784 0 0 0-.299.221l-3.35 3.99a.79.79 0 1 0 1.21 1.017l1.936-2.306v5.185c0 .436.353.79.79.79Z"/></svg>',
                imageAssetManager: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M1.201 1c-.662 0-1.2.47-1.2 1.1v14.248c0 .64.533 1.152 1.185 1.152h6.623v-7.236L6.617 9.15a.694.694 0 0 0-.957-.033L1.602 13.55V2.553l14.798.003V9.7H18V2.1c0-.63-.547-1.1-1.2-1.1H1.202Zm11.723 2.805a2.094 2.094 0 0 0-1.621.832 2.127 2.127 0 0 0 1.136 3.357 2.13 2.13 0 0 0 2.611-1.506 2.133 2.133 0 0 0-.76-2.244 2.13 2.13 0 0 0-1.366-.44Z"/><path clip-rule="evenodd" d="M19.898 12.369v6.187a.844.844 0 0 1-.844.844h-8.719a.844.844 0 0 1-.843-.844v-7.312a.844.844 0 0 1 .843-.844h2.531a.843.843 0 0 1 .597.248l.838.852h4.75c.223 0 .441.114.6.272a.844.844 0 0 1 .247.597Zm-1.52.654-4.377.02-1.1-1.143H11v6h7.4l-.023-4.877Z"/></svg>',
                textAlternative: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3.035 1C2.446 1 2 1.54 2 2.098V10.5h1.5v-8h13v8H18V2.098C18 1.539 17.48 1 16.9 1H3.035Zm10.453 2.61a1.885 1.885 0 0 0-1.442.736 1.89 1.89 0 0 0 1.011 2.976 1.903 1.903 0 0 0 2.253-1.114 1.887 1.887 0 0 0-1.822-2.598ZM7.463 8.163a.611.611 0 0 0-.432.154L5.071 10.5h5.119L7.88 8.348a.628.628 0 0 0-.417-.185Zm6.236 1.059a.62.62 0 0 0-.42.164L12.07 10.5h2.969l-.92-1.113a.618.618 0 0 0-.42-.165ZM.91 11.5a.91.91 0 0 0-.91.912v6.877c0 .505.405.91.91.91h18.178a.91.91 0 0 0 .912-.91v-6.877a.908.908 0 0 0-.912-.912H.91ZM3.668 13h1.947l2.135 5.7H5.898l-.28-.946H3.601l-.278.945H1.516L3.668 13Zm4.947 0h1.801v4.3h2.7v1.4h-4.5V13h-.001Zm4.5 0h5.4v1.4h-1.798v4.3h-1.701v-4.3h-1.9V13h-.001Zm-8.517 1.457-.614 2.059h1.262l-.648-2.059Z"/></svg>',
                previousArrow: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.463 5.187a.888.888 0 1 1 1.254 1.255L9.16 10l3.557 3.557a.888.888 0 1 1-1.254 1.255L7.26 10.61a.888.888 0 0 1 .16-1.382l4.043-4.042z"/></svg>',
                nextArrow: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.537 14.813a.888.888 0 1 1-1.254-1.255L10.84 10 7.283 6.442a.888.888 0 1 1 1.254-1.255L12.74 9.39a.888.888 0 0 1-.16 1.382l-4.043 4.042z"/></svg>',
                importExport: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M19 4.5 14 0H3v12.673l.868-1.041c.185-.222.4-.402.632-.54V1.5h8v5h5v7.626a2.24 2.24 0 0 1 1.5.822V4.5ZM14 5V2l3.3 3H14Zm-3.692 12.5c.062.105.133.206.213.303L11.52 19H8v-.876a2.243 2.243 0 0 0 1.82-.624h.488Zm7.518-.657a.75.75 0 0 0-1.152-.96L15.5 17.29V12H14v5.29l-1.174-1.408a.75.75 0 0 0-1.152.96l2.346 2.816a.95.95 0 0 0 1.46 0l2.346-2.815Zm-15.056-.38a.75.75 0 0 1-.096-1.056l2.346-2.815a.95.95 0 0 1 1.46 0l2.346 2.815a.75.75 0 1 1-1.152.96L6.5 14.96V20H5v-5.04l-1.174 1.408a.75.75 0 0 1-1.056.096Z"/></svg>',
                paragraph: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.5 5.5H7v5h3.5a2.5 2.5 0 1 0 0-5zM5 3h6.5v.025a5 5 0 0 1 0 9.95V13H7v4a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1z"/></svg>',
                plus: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 2a1 1 0 0 0-1 1v6H3a1 1 0 1 0 0 2h6v6a1 1 0 1 0 2 0v-6h6a1 1 0 1 0 0-2h-6V3a1 1 0 0 0-1-1Z"/></svg>',
                text: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.816 11.5 7.038 4.785 4.261 11.5h5.555Zm.62 1.5H3.641l-1.666 4.028H.312l5.789-14h1.875l5.789 14h-1.663L10.436 13Z"/><path d="m12.09 17-.534-1.292.848-1.971.545 1.319L12.113 17h-.023Zm1.142-5.187.545 1.319L15.5 9.13l1.858 4.316h-3.45l.398.965h3.467L18.887 17H20l-3.873-9h-1.254l-1.641 3.813Z"/></svg>',
                alignLeft: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>',
                objectLeft: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zm0-3H18v1.5h-4.5zm0-3H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>',
                objectCenter: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M15.003 7v5.5a1 1 0 0 1-1 1H5.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H6.5V12h6.997V7.5z"/></svg>',
                objectRight: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2zm0-9h5v1.5H2zm0 3h5v1.5H2zm0 3h5v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>',
                objectFullWidth: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18 7v5.5a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1zm-1.505.5H3.504V12h12.991V7.5z"/></svg>',
                objectInline: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>',
                objectBlockLeft: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>',
                objectBlockRight: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>',
                pencil: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m7.3 17.37-.061.088a1.518 1.518 0 0 1-.934.535l-4.178.663-.806-4.153a1.495 1.495 0 0 1 .187-1.058l.056-.086L8.77 2.639c.958-1.351 2.803-1.076 4.296-.03 1.497 1.047 2.387 2.693 1.433 4.055L7.3 17.37zM9.14 4.728l-5.545 8.346 3.277 2.294 5.544-8.346L9.14 4.728zM6.07 16.512l-3.276-2.295.53 2.73 2.746-.435zM9.994 3.506 13.271 5.8c.316-.452-.16-1.333-1.065-1.966-.905-.634-1.895-.78-2.212-.328zM8 18.5 9.375 17H19v1.5H8z"/></svg>',
                pilcrow: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.999 2H15a1 1 0 0 1 0 2h-1.004v13a1 1 0 1 1-2 0V4H8.999v13a1 1 0 1 1-2 0v-7A4 4 0 0 1 3 6a4 4 0 0 1 3.999-4z"/></svg>',
                quote: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 10.423a6.5 6.5 0 0 1 6.056-6.408l.038.67C6.448 5.423 5.354 7.663 5.22 10H9c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574zm8 0a6.5 6.5 0 0 1 6.056-6.408l.038.67c-2.646.739-3.74 2.979-3.873 5.315H17c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574z"/></svg>',
                threeVerticalDots: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><circle cx="9.5" cy="4.5" r="1.5"/><circle cx="9.5" cy="10.5" r="1.5"/><circle cx="9.5" cy="16.5" r="1.5"/></svg>',
                dragIndicator: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M5 3.25a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M12 3.25a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M5 10a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M12 10a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M5 16.75a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M12 16.75a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/></svg>',
                redo: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m14.958 9.367-2.189 1.837a.75.75 0 0 0 .965 1.149l3.788-3.18a.747.747 0 0 0 .21-.284.75.75 0 0 0-.17-.945L13.77 4.762a.75.75 0 1 0-.964 1.15l2.331 1.955H6.22A.75.75 0 0 0 6 7.9a4 4 0 1 0 1.477 7.718l-.344-1.489A2.5 2.5 0 1 1 6.039 9.4l-.008-.032h8.927z"/></svg>',
                undo: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m5.042 9.367 2.189 1.837a.75.75 0 0 1-.965 1.149l-3.788-3.18a.747.747 0 0 1-.21-.284.75.75 0 0 1 .17-.945L6.23 4.762a.75.75 0 1 1 .964 1.15L4.863 7.866h8.917A.75.75 0 0 1 14 7.9a4 4 0 1 1-1.477 7.718l.344-1.489a2.5 2.5 0 1 0 1.094-4.73l.008-.032H5.042z"/></svg>',
                bulletedList: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0C1 4.784 1.777 4 2.75 4c.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75C1.784 7.5 1 6.723 1 5.75zm6 9c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0c0-.966.777-1.75 1.75-1.75.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75-.966 0-1.75-.777-1.75-1.75z"/></svg>',
                numberedList: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM3.5 3v5H2V3.7H1v-1h2.5V3zM.343 17.857l2.59-3.257H2.92a.6.6 0 1 0-1.04 0H.302a2 2 0 1 1 3.995 0h-.001c-.048.405-.16.734-.333.988-.175.254-.59.692-1.244 1.312H4.3v1h-4l.043-.043zM7 14.75a.75.75 0 0 1 .75-.75h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75z"/></svg>',
                browseFiles: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.627 16.5zm5.873-.196zm0-7.001V8h-13v8.5h4.341c.191.54.457 1.044.785 1.5H2a1.5 1.5 0 0 1-1.5-1.5v-13A1.5 1.5 0 0 1 2 2h4.5a1.5 1.5 0 0 1 1.06.44L9.122 4H16a1.5 1.5 0 0 1 1.5 1.5v1A1.5 1.5 0 0 1 19 8v2.531a6.027 6.027 0 0 0-1.5-1.228zM16 6.5v-1H8.5l-2-2H2v13h1V8a1.5 1.5 0 0 1 1.5-1.5H16z"/><path d="M14.5 19.5a5 5 0 1 1 0-10 5 5 0 0 1 0 10zM15 14v-2h-1v2h-2v1h2v2h1v-2h2v-1h-2z"/></svg>',
                indent: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zM1.632 6.95 5.02 9.358a.4.4 0 0 1-.013.661l-3.39 2.207A.4.4 0 0 1 1 11.892V7.275a.4.4 0 0 1 .632-.326z"/></svg>',
                outdent: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zm1.618-9.55L.98 9.358a.4.4 0 0 0 .013.661l3.39 2.207A.4.4 0 0 0 5 11.892V7.275a.4.4 0 0 0-.632-.326z"/></svg>',
                table: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 5.5v3h4v-3H3Zm0 4v3h4v-3H3Zm0 4v3h4v-3H3Zm5 3h4v-3H8v3Zm5 0h4v-3h-4v3Zm4-4v-3h-4v3h4Zm0-4v-3h-4v3h4Zm1.5 8A1.5 1.5 0 0 1 17 18H3a1.5 1.5 0 0 1-1.5-1.5V3c.222-.863 1.068-1.5 2-1.5h13c.932 0 1.778.637 2 1.5v13.5Zm-6.5-4v-3H8v3h4Zm0-4v-3H8v3h4Z"/></svg>'
            };
            var cC = u(7621)
              , dj = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(cC.A, dj),
            cC.A.locals;
            const dC = class _B extends pe {
                constructor() {
                    super();
                    const e = this.bindTemplate;
                    this.set("content", ""),
                    this.set("viewBox", "0 0 20 20"),
                    this.set("fillColor", ""),
                    this.set("isColorInherited", !0),
                    this.set("isVisible", !0),
                    this.setTemplate({
                        tag: "svg",
                        ns: "http://www.w3.org/2000/svg",
                        attributes: {
                            class: ["ck", "ck-icon", e.if("isVisible", "ck-hidden", t => !t), "ck-reset_all-excluded", e.if("isColorInherited", "ck-icon_inherit-color")],
                            viewBox: e.to("viewBox")
                        }
                    })
                }
                render() {
                    super.render(),
                    this._updateXMLContent(),
                    this._colorFillPaths(),
                    this.on("change:content", () => {
                        this._updateXMLContent(),
                        this._colorFillPaths()
                    }
                    ),
                    this.on("change:fillColor", () => {
                        this._colorFillPaths()
                    }
                    )
                }
                _updateXMLContent() {
                    if (this.content) {
                        const e = new DOMParser().parseFromString(this.content.trim(), "image/svg+xml").querySelector("svg")
                          , t = e.getAttribute("viewBox");
                        t && (this.viewBox = t);
                        for (const {name: r, value: i} of Array.from(e.attributes))
                            _B.presentationalAttributeNames.includes(r) && this.element.setAttribute(r, i);
                        for (; this.element.firstChild; )
                            this.element.removeChild(this.element.firstChild);
                        for (; e.childNodes.length > 0; )
                            this.element.appendChild(e.childNodes[0])
                    }
                }
                _colorFillPaths() {
                    this.fillColor && this.element.querySelectorAll(".ck-icon__fill").forEach(e => {
                        e.style.fill = this.fillColor
                    }
                    )
                }
            }
            ;
            C(dC, "presentationalAttributeNames", ["alignment-baseline", "baseline-shift", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-rendering", "cursor", "direction", "display", "dominant-baseline", "fill", "fill-opacity", "fill-rule", "filter", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "image-rendering", "letter-spacing", "lighting-color", "marker-end", "marker-mid", "marker-start", "mask", "opacity", "overflow", "paint-order", "pointer-events", "shape-rendering", "stop-color", "stop-opacity", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-anchor", "text-decoration", "text-overflow", "text-rendering", "transform", "unicode-bidi", "vector-effect", "visibility", "white-space", "word-spacing", "writing-mode"]);
            let Ni = dC;
            class uj extends pe {
                constructor() {
                    super(),
                    this.set({
                        style: void 0,
                        text: void 0,
                        id: void 0
                    });
                    const e = this.bindTemplate;
                    this.setTemplate({
                        tag: "span",
                        attributes: {
                            class: ["ck", "ck-button__label"],
                            style: e.to("style"),
                            id: e.to("id")
                        },
                        children: [{
                            text: e.to("text")
                        }]
                    })
                }
            }
            var uC = u(9715)
              , hj = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(uC.A, hj),
            uC.A.locals;
            class Te extends pe {
                constructor(e, t=new uj) {
                    super(e),
                    C(this, "children"),
                    C(this, "labelView"),
                    C(this, "iconView"),
                    C(this, "keystrokeView"),
                    C(this, "_focusDelayed", null);
                    const r = this.bindTemplate
                      , i = H();
                    this.set("ariaLabel", void 0),
                    this.set("ariaLabelledBy", `ck-editor__aria-label_${i}`),
                    this.set("class", void 0),
                    this.set("labelStyle", void 0),
                    this.set("icon", void 0),
                    this.set("isEnabled", !0),
                    this.set("isOn", !1),
                    this.set("isVisible", !0),
                    this.set("isToggleable", !1),
                    this.set("keystroke", void 0),
                    this.set("label", void 0),
                    this.set("role", void 0),
                    this.set("tabindex", -1),
                    this.set("tooltip", !1),
                    this.set("tooltipPosition", "s"),
                    this.set("type", "button"),
                    this.set("withText", !1),
                    this.set("withKeystroke", !1),
                    this.children = this.createCollection(),
                    this.labelView = this._setupLabelView(t),
                    this.iconView = new Ni,
                    this.iconView.extendTemplate({
                        attributes: {
                            class: "ck-button__icon"
                        }
                    }),
                    this.keystrokeView = this._createKeystrokeView(),
                    this.bind("_tooltipString").to(this, "tooltip", this, "label", this, "keystroke", this._getTooltipString.bind(this));
                    const l = {
                        tag: "button",
                        attributes: {
                            class: ["ck", "ck-button", r.to("class"), r.if("isEnabled", "ck-disabled", d => !d), r.if("isVisible", "ck-hidden", d => !d), r.to("isOn", d => d ? "ck-on" : "ck-off"), r.if("withText", "ck-button_with-text"), r.if("withKeystroke", "ck-button_with-keystroke")],
                            role: r.to("role"),
                            type: r.to("type", d => d || "button"),
                            tabindex: r.to("tabindex"),
                            "aria-checked": r.to("ariaChecked"),
                            "aria-label": r.to("ariaLabel"),
                            "aria-labelledby": r.to("ariaLabelledBy"),
                            "aria-disabled": r.if("isEnabled", !0, d => !d),
                            "aria-pressed": r.to("isOn", d => !!this.isToggleable && String(!!d)),
                            "data-cke-tooltip-text": r.to("_tooltipString"),
                            "data-cke-tooltip-position": r.to("tooltipPosition")
                        },
                        children: this.children,
                        on: {
                            click: r.to(d => {
                                this.isEnabled ? this.fire("execute") : d.preventDefault()
                            }
                            )
                        }
                    };
                    E.isSafari && (this._focusDelayed || (this._focusDelayed = ep( () => this.focus(), 0)),
                    l.on.mousedown = r.to( () => {
                        this._focusDelayed()
                    }
                    ),
                    l.on.mouseup = r.to( () => {
                        this._focusDelayed.cancel()
                    }
                    )),
                    this.setTemplate(l)
                }
                render() {
                    super.render(),
                    this.icon && (this.iconView.bind("content").to(this, "icon"),
                    this.children.add(this.iconView)),
                    this.children.add(this.labelView),
                    this.withKeystroke && this.keystroke && this.children.add(this.keystrokeView)
                }
                focus() {
                    this.element.focus()
                }
                destroy() {
                    this._focusDelayed && this._focusDelayed.cancel(),
                    super.destroy()
                }
                _setupLabelView(e) {
                    return e.bind("text", "style", "id").to(this, "label", "labelStyle", "ariaLabelledBy"),
                    e
                }
                _createKeystrokeView() {
                    const e = new pe;
                    return e.setTemplate({
                        tag: "span",
                        attributes: {
                            class: ["ck", "ck-button__keystroke"]
                        },
                        children: [{
                            text: this.bindTemplate.to("keystroke", t => xd(t))
                        }]
                    }),
                    e
                }
                _getTooltipString(e, t, r) {
                    return e ? typeof e == "string" ? e : (r && (r = xd(r)),
                    e instanceof Function ? e(t, r) : `${t}${r ? ` (${r})` : ""}`) : ""
                }
            }
            var hC = u(7913)
              , mj = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(hC.A, mj),
            hC.A.locals;
            class pj extends pe {
                constructor(e, t={}) {
                    super(e),
                    C(this, "children"),
                    C(this, "iconView");
                    const r = this.bindTemplate;
                    this.set("label", t.label || ""),
                    this.set("class", t.class || null),
                    this.children = this.createCollection(),
                    this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-form__header", r.to("class")]
                        },
                        children: this.children
                    }),
                    t.icon && (this.iconView = new Ni,
                    this.iconView.content = t.icon,
                    this.children.add(this.iconView));
                    const i = new pe(e);
                    i.setTemplate({
                        tag: "h2",
                        attributes: {
                            class: ["ck", "ck-form__header__label"],
                            role: "presentation"
                        },
                        children: [{
                            text: r.to("label")
                        }]
                    }),
                    this.children.add(i)
                }
            }
            class Jr extends Se() {
                constructor(e) {
                    if (super(),
                    C(this, "focusables"),
                    C(this, "focusTracker"),
                    C(this, "keystrokeHandler"),
                    C(this, "actions"),
                    this.focusables = e.focusables,
                    this.focusTracker = e.focusTracker,
                    this.keystrokeHandler = e.keystrokeHandler,
                    this.actions = e.actions,
                    e.actions && e.keystrokeHandler)
                        for (const t in e.actions) {
                            let r = e.actions[t];
                            typeof r == "string" && (r = [r]);
                            for (const i of r)
                                e.keystrokeHandler.set(i, (l, d) => {
                                    this[t](),
                                    d()
                                }
                                )
                        }
                    this.on("forwardCycle", () => this.focusFirst(), {
                        priority: "low"
                    }),
                    this.on("backwardCycle", () => this.focusLast(), {
                        priority: "low"
                    })
                }
                get first() {
                    return this.focusables.find(Vp) || null
                }
                get last() {
                    return this.focusables.filter(Vp).slice(-1)[0] || null
                }
                get next() {
                    return this._getDomFocusableItem(1)
                }
                get previous() {
                    return this._getDomFocusableItem(-1)
                }
                get current() {
                    let e = null;
                    return this.focusTracker.focusedElement === null ? null : (this.focusables.find( (t, r) => {
                        const i = t.element === this.focusTracker.focusedElement;
                        return i && (e = r),
                        i
                    }
                    ),
                    e)
                }
                focusFirst() {
                    this._focus(this.first, 1)
                }
                focusLast() {
                    this._focus(this.last, -1)
                }
                focusNext() {
                    const e = this.next;
                    e && this.focusables.getIndex(e) === this.current || e === this.first ? this.fire("forwardCycle") : this._focus(e, 1)
                }
                focusPrevious() {
                    const e = this.previous;
                    e && this.focusables.getIndex(e) === this.current || e === this.last ? this.fire("backwardCycle") : this._focus(e, -1)
                }
                _focus(e, t) {
                    e && this.focusTracker.focusedElement !== e.element && e.focus(t)
                }
                _getDomFocusableItem(e) {
                    const t = this.focusables.length;
                    if (!t)
                        return null;
                    const r = this.current;
                    if (r === null)
                        return this[e === 1 ? "first" : "last"];
                    let i = this.focusables.get(r)
                      , l = (r + t + e) % t;
                    do {
                        const d = this.focusables.get(l);
                        if (Vp(d)) {
                            i = d;
                            break
                        }
                        l = (l + t + e) % t
                    } while (l !== r);
                    return i
                }
            }
            function Vp(s) {
                return Dl(s) && yi(s.element)
            }
            function Dl(s) {
                return !(!("focus"in s) || typeof s.focus != "function")
            }
            function gj(s) {
                return class extends s {
                    constructor(...e) {
                        super(...e),
                        C(this, "_onDragBound", this._onDrag.bind(this)),
                        C(this, "_onDragEndBound", this._onDragEnd.bind(this)),
                        C(this, "_lastDraggingCoordinates", {
                            x: 0,
                            y: 0
                        }),
                        this.on("render", () => {
                            this._attachListeners()
                        }
                        ),
                        this.set("isDragging", !1)
                    }
                    _attachListeners() {
                        this.listenTo(this.element, "mousedown", this._onDragStart.bind(this)),
                        this.listenTo(this.element, "touchstart", this._onDragStart.bind(this))
                    }
                    _attachDragListeners() {
                        this.listenTo(w.document, "mouseup", this._onDragEndBound),
                        this.listenTo(w.document, "touchend", this._onDragEndBound),
                        this.listenTo(w.document, "mousemove", this._onDragBound),
                        this.listenTo(w.document, "touchmove", this._onDragBound)
                    }
                    _detachDragListeners() {
                        this.stopListening(w.document, "mouseup", this._onDragEndBound),
                        this.stopListening(w.document, "touchend", this._onDragEndBound),
                        this.stopListening(w.document, "mousemove", this._onDragBound),
                        this.stopListening(w.document, "touchmove", this._onDragBound)
                    }
                    _onDragStart(e, t) {
                        if (!this._isHandleElementPressed(t))
                            return;
                        this._attachDragListeners();
                        let r = 0
                          , i = 0;
                        t instanceof MouseEvent ? (r = t.clientX,
                        i = t.clientY) : (r = t.touches[0].clientX,
                        i = t.touches[0].clientY),
                        this._lastDraggingCoordinates = {
                            x: r,
                            y: i
                        },
                        this.isDragging = !0
                    }
                    _onDrag(e, t) {
                        if (!this.isDragging)
                            return void this._detachDragListeners();
                        let r = 0
                          , i = 0;
                        t instanceof MouseEvent ? (r = t.clientX,
                        i = t.clientY) : (r = t.touches[0].clientX,
                        i = t.touches[0].clientY),
                        t.preventDefault(),
                        this.fire("drag", {
                            deltaX: Math.round(r - this._lastDraggingCoordinates.x),
                            deltaY: Math.round(i - this._lastDraggingCoordinates.y)
                        }),
                        this._lastDraggingCoordinates = {
                            x: r,
                            y: i
                        }
                    }
                    _onDragEnd() {
                        this._detachDragListeners(),
                        this.isDragging = !1
                    }
                    _isHandleElementPressed(e) {
                        return !!this.dragHandleElement && (this.dragHandleElement === e.target || e.target instanceof HTMLElement && this.dragHandleElement.contains(e.target))
                    }
                }
            }
            var mC = u(9822)
              , fj = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(mC.A, fj),
            mC.A.locals;
            class kj extends pe {
                constructor(e) {
                    super(e),
                    C(this, "children"),
                    C(this, "keystrokes"),
                    C(this, "focusCycler"),
                    C(this, "_focusTracker"),
                    C(this, "_focusables"),
                    this.children = this.createCollection(),
                    this.keystrokes = new lo,
                    this._focusTracker = new Jt,
                    this._focusables = new ur,
                    this.focusCycler = new Jr({
                        focusables: this._focusables,
                        focusTracker: this._focusTracker,
                        keystrokeHandler: this.keystrokes,
                        actions: {
                            focusPrevious: "shift + tab",
                            focusNext: "tab"
                        }
                    }),
                    this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-dialog__actions"]
                        },
                        children: this.children
                    })
                }
                render() {
                    super.render(),
                    this.keystrokes.listenTo(this.element)
                }
                setButtons(e) {
                    for (const t of e) {
                        const r = new Te(this.locale);
                        let i;
                        for (i in r.on("execute", () => t.onExecute()),
                        t.onCreate && t.onCreate(r),
                        t)
                            i != "onExecute" && i != "onCreate" && r.set(i, t[i]);
                        this.children.add(r)
                    }
                    this._updateFocusCyclableItems()
                }
                focus(e) {
                    e === -1 ? this.focusCycler.focusLast() : this.focusCycler.focusFirst()
                }
                _updateFocusCyclableItems() {
                    Array.from(this.children).forEach(e => {
                        this._focusables.add(e),
                        this._focusTracker.add(e.element)
                    }
                    )
                }
            }
            class bj extends pe {
                constructor(e) {
                    super(e),
                    C(this, "children"),
                    this.children = this.createCollection(),
                    this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-dialog__content"]
                        },
                        children: this.children
                    })
                }
                reset() {
                    for (; this.children.length; )
                        this.children.remove(0)
                }
            }
            var pC = u(9819)
              , wj = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(pC.A, wj),
            pC.A.locals;
            const Qd = "screen-center"
              , gC = "editor-center"
              , Aj = "editor-top-side"
              , vj = "editor-top-center"
              , _j = "editor-bottom-center"
              , Cj = "editor-above-center"
              , yj = "editor-below-center"
              , fC = cl("px")
              , kC = class CB extends gj(pe) {
                constructor(e, {getCurrentDomRoot: t, getViewportOffset: r}) {
                    super(e),
                    C(this, "parts"),
                    C(this, "headerView"),
                    C(this, "closeButtonView"),
                    C(this, "actionsView"),
                    C(this, "contentView"),
                    C(this, "keystrokes"),
                    C(this, "focusTracker"),
                    C(this, "wasMoved", !1),
                    C(this, "_getCurrentDomRoot"),
                    C(this, "_getViewportOffset"),
                    C(this, "_focusables"),
                    C(this, "_focusCycler");
                    const i = this.bindTemplate
                      , l = e.t;
                    this.set("className", ""),
                    this.set("ariaLabel", l("Editor dialog")),
                    this.set("isModal", !1),
                    this.set("position", Qd),
                    this.set("_isVisible", !1),
                    this.set("_isTransparent", !1),
                    this.set("_top", 0),
                    this.set("_left", 0),
                    this._getCurrentDomRoot = t,
                    this._getViewportOffset = r,
                    this.decorate("moveTo"),
                    this.parts = this.createCollection(),
                    this.keystrokes = new lo,
                    this.focusTracker = new Jt,
                    this._focusables = new ur,
                    this._focusCycler = new Jr({
                        focusables: this._focusables,
                        focusTracker: this.focusTracker,
                        keystrokeHandler: this.keystrokes,
                        actions: {
                            focusPrevious: "shift + tab",
                            focusNext: "tab"
                        }
                    }),
                    this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-dialog-overlay", i.if("isModal", "ck-dialog-overlay__transparent", d => !d), i.if("_isVisible", "ck-hidden", d => !d)],
                            tabindex: "-1"
                        },
                        children: [{
                            tag: "div",
                            attributes: {
                                tabindex: "-1",
                                class: ["ck", "ck-dialog", i.to("className")],
                                role: "dialog",
                                "aria-label": i.to("ariaLabel"),
                                style: {
                                    top: i.to("_top", d => fC(d)),
                                    left: i.to("_left", d => fC(d)),
                                    visibility: i.if("_isTransparent", "hidden")
                                }
                            },
                            children: this.parts
                        }]
                    })
                }
                render() {
                    super.render(),
                    this.keystrokes.set("Esc", (e, t) => {
                        this.fire("close", {
                            source: "escKeyPress"
                        }),
                        t()
                    }
                    ),
                    this.on("drag", (e, {deltaX: t, deltaY: r}) => {
                        this.wasMoved = !0,
                        this.moveBy(t, r)
                    }
                    ),
                    this.listenTo(w.window, "resize", () => {
                        this._isVisible && !this.wasMoved && this.updatePosition()
                    }
                    ),
                    this.listenTo(w.document, "scroll", () => {
                        this._isVisible && !this.wasMoved && this.updatePosition()
                    }
                    ),
                    this.on("change:_isVisible", (e, t, r) => {
                        r && (this._isTransparent = !0,
                        setTimeout( () => {
                            this.updatePosition(),
                            this._isTransparent = !1,
                            this.focus()
                        }
                        , 10))
                    }
                    ),
                    this.keystrokes.listenTo(this.element)
                }
                get dragHandleElement() {
                    return this.headerView ? this.headerView.element : null
                }
                setupParts({icon: e, title: t, hasCloseButton: r=!0, content: i, actionButtons: l}) {
                    t && (this.headerView = new pj(this.locale,{
                        icon: e
                    }),
                    r && (this.closeButtonView = this._createCloseButton(),
                    this.headerView.children.add(this.closeButtonView)),
                    this.headerView.label = t,
                    this.ariaLabel = t,
                    this.parts.add(this.headerView, 0)),
                    i && (i instanceof pe && (i = [i]),
                    this.contentView = new bj(this.locale),
                    this.contentView.children.addMany(i),
                    this.parts.add(this.contentView)),
                    l && (this.actionsView = new kj(this.locale),
                    this.actionsView.setButtons(l),
                    this.parts.add(this.actionsView)),
                    this._updateFocusCyclableItems()
                }
                focus() {
                    this._focusCycler.focusFirst()
                }
                moveTo(e, t) {
                    const r = this._getViewportRect()
                      , i = this._getDialogRect();
                    e + i.width > r.right && (e = r.right - i.width),
                    e < r.left && (e = r.left),
                    t < r.top && (t = r.top),
                    this._moveTo(e, t)
                }
                _moveTo(e, t) {
                    this._left = e,
                    this._top = t
                }
                moveBy(e, t) {
                    this.moveTo(this._left + e, this._top + t)
                }
                _moveOffScreen() {
                    this._moveTo(-9999, -9999)
                }
                updatePosition() {
                    if (!this.element || !this.element.parentNode)
                        return;
                    const e = this._getViewportRect();
                    let t, r = this.position;
                    this._getCurrentDomRoot() ? t = this._getVisibleDomRootRect(e) : r = Qd;
                    const i = CB.defaultOffset
                      , l = this._getDialogRect();
                    switch (r) {
                    case Aj:
                        if (t) {
                            const d = this.locale.contentLanguageDirection === "ltr" ? t.right - l.width - i : t.left + i;
                            this.moveTo(d, t.top + i)
                        } else
                            this._moveOffScreen();
                        break;
                    case gC:
                        t ? this.moveTo(Math.round(t.left + t.width / 2 - l.width / 2), Math.round(t.top + t.height / 2 - l.height / 2)) : this._moveOffScreen();
                        break;
                    case Qd:
                        this.moveTo(Math.round((e.width - l.width) / 2), Math.round((e.height - l.height) / 2));
                        break;
                    case vj:
                        t ? this.moveTo(Math.round(t.left + t.width / 2 - l.width / 2), t.top + i) : this._moveOffScreen();
                        break;
                    case _j:
                        t ? this.moveTo(Math.round(t.left + t.width / 2 - l.width / 2), t.bottom - l.height - i) : this._moveOffScreen();
                        break;
                    case Cj:
                        t ? this.moveTo(Math.round(t.left + t.width / 2 - l.width / 2), t.top - l.height - i) : this._moveOffScreen();
                        break;
                    case yj:
                        t ? this.moveTo(Math.round(t.left + t.width / 2 - l.width / 2), t.bottom + i) : this._moveOffScreen()
                    }
                }
                _getVisibleDomRootRect(e) {
                    let t = new De(this._getCurrentDomRoot()).getVisible();
                    return t ? (t = e.getIntersection(t),
                    t || null) : null
                }
                _getDialogRect() {
                    return new De(this.element.firstElementChild)
                }
                _getViewportRect() {
                    return function(e) {
                        e = Object.assign({
                            top: 0,
                            bottom: 0,
                            left: 0,
                            right: 0
                        }, e);
                        const t = new De(w.window);
                        return t.top += e.top,
                        t.height -= e.top,
                        t.bottom -= e.bottom,
                        t.height -= e.bottom,
                        t.left += e.left,
                        t.right -= e.right,
                        t.width -= e.left + e.right,
                        t
                    }(this._getViewportOffset())
                }
                _updateFocusCyclableItems() {
                    const e = [];
                    if (this.contentView)
                        for (const t of this.contentView.children)
                            Dl(t) && e.push(t);
                    this.actionsView && e.push(this.actionsView),
                    this.closeButtonView && e.push(this.closeButtonView),
                    e.forEach(t => {
                        var r;
                        this._focusables.add(t),
                        this.focusTracker.add(t.element),
                        Dl(r = t) && "focusCycler"in r && r.focusCycler instanceof Jr && (this.listenTo(t.focusCycler, "forwardCycle", i => {
                            this._focusCycler.focusNext(),
                            this._focusCycler.next !== this._focusCycler.focusables.get(this._focusCycler.current) && i.stop()
                        }
                        ),
                        this.listenTo(t.focusCycler, "backwardCycle", i => {
                            this._focusCycler.focusPrevious(),
                            this._focusCycler.previous !== this._focusCycler.focusables.get(this._focusCycler.current) && i.stop()
                        }
                        ))
                    }
                    )
                }
                _createCloseButton() {
                    const e = new Te(this.locale)
                      , t = this.locale.t;
                    return e.set({
                        label: t("Close"),
                        tooltip: !0,
                        icon: he.cancel
                    }),
                    e.on("execute", () => this.fire("close", {
                        source: "closeButton"
                    })),
                    e
                }
            }
            ;
            C(kC, "defaultOffset", 15);
            let Up = kC;
            const bC = class Fn extends ie {
                constructor(e) {
                    super(e),
                    C(this, "view"),
                    C(this, "_onHide");
                    const t = e.t;
                    this._initShowHideListeners(),
                    this._initFocusToggler(),
                    this._initMultiRootIntegration(),
                    this.set("id", null),
                    e.accessibility.addKeystrokeInfos({
                        categoryId: "navigation",
                        keystrokes: [{
                            label: t("Move focus in and out of an active dialog window"),
                            keystroke: "Ctrl+F6",
                            mayRequireFn: !0
                        }]
                    })
                }
                static get pluginName() {
                    return "Dialog"
                }
                _initShowHideListeners() {
                    this.on("show", (e, t) => {
                        this._show(t)
                    }
                    ),
                    this.on("show", (e, t) => {
                        t.onShow && t.onShow(this)
                    }
                    , {
                        priority: "low"
                    }),
                    this.on("hide", () => {
                        Fn._visibleDialogPlugin && Fn._visibleDialogPlugin._hide()
                    }
                    ),
                    this.on("hide", () => {
                        this._onHide && (this._onHide(this),
                        this._onHide = void 0)
                    }
                    , {
                        priority: "low"
                    })
                }
                _initFocusToggler() {
                    const e = this.editor;
                    e.keystrokes.set("Ctrl+F6", (t, r) => {
                        this.isOpen && !this.view.isModal && (this.view.focusTracker.isFocused ? e.editing.view.focus() : this.view.focus(),
                        r())
                    }
                    )
                }
                _initMultiRootIntegration() {
                    const e = this.editor.model;
                    e.document.on("change:data", () => {
                        if (!this.view)
                            return;
                        const t = e.document.differ.getChangedRoots();
                        for (const r of t)
                            r.state && this.view.updatePosition()
                    }
                    )
                }
                show(e) {
                    this.hide(),
                    this.fire(`show:${e.id}`, e)
                }
                _show({id: e, icon: t, title: r, hasCloseButton: i=!0, content: l, actionButtons: d, className: h, isModal: m, position: g, onHide: b}) {
                    const v = this.editor;
                    this.view = new Up(v.locale,{
                        getCurrentDomRoot: () => v.editing.view.getDomRoot(v.model.document.selection.anchor.root.rootName),
                        getViewportOffset: () => v.ui.viewportOffset
                    });
                    const x = this.view;
                    x.on("close", () => {
                        this.hide()
                    }
                    ),
                    v.ui.view.body.add(x),
                    v.ui.focusTracker.add(x.element),
                    v.keystrokes.listenTo(x.element),
                    g || (g = m ? Qd : gC),
                    x.set({
                        position: g,
                        _isVisible: !0,
                        className: h,
                        isModal: m
                    }),
                    x.setupParts({
                        icon: t,
                        title: r,
                        hasCloseButton: i,
                        content: l,
                        actionButtons: d
                    }),
                    this.id = e,
                    b && (this._onHide = b),
                    this.isOpen = !0,
                    Fn._visibleDialogPlugin = this
                }
                hide() {
                    Fn._visibleDialogPlugin && Fn._visibleDialogPlugin.fire(`hide:${Fn._visibleDialogPlugin.id}`)
                }
                _hide() {
                    if (!this.view)
                        return;
                    const e = this.editor
                      , t = this.view;
                    t.contentView && t.contentView.reset(),
                    e.ui.view.body.remove(t),
                    e.ui.focusTracker.remove(t.element),
                    e.keystrokes.stopListening(t.element),
                    t.destroy(),
                    e.editing.view.focus(),
                    this.id = null,
                    this.isOpen = !1,
                    Fn._visibleDialogPlugin = null
                }
            }
            ;
            C(bC, "_visibleDialogPlugin");
            let wC = bC;
            var AC = u(977)
              , xj = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(AC.A, xj),
            AC.A.locals;
            class Xt extends Te {
                constructor(e) {
                    super(e),
                    this.set({
                        withText: !0,
                        withKeystroke: !0,
                        tooltip: !1,
                        role: "menuitem"
                    }),
                    this.extendTemplate({
                        attributes: {
                            class: ["ck-menu-bar__menu__item__button"]
                        }
                    })
                }
            }
            var vC = u(7801)
              , Ej = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(vC.A, Ej),
            vC.A.locals;
            class Zd extends pe {
                constructor(e) {
                    super(e),
                    C(this, "id"),
                    this.set("text", void 0),
                    this.set("for", void 0),
                    this.id = `ck-editor__label_${H()}`;
                    const t = this.bindTemplate;
                    this.setTemplate({
                        tag: "label",
                        attributes: {
                            class: ["ck", "ck-label"],
                            id: this.id,
                            for: t.to("for")
                        },
                        children: [{
                            text: t.to("text")
                        }]
                    })
                }
            }
            class Sj extends pe {
                constructor(e, t) {
                    super(e);
                    const r = e.t
                      , i = new Zd;
                    i.text = r("Help Contents. To close this dialog press ESC."),
                    this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-accessibility-help-dialog__content"],
                            "aria-labelledby": i.id,
                            role: "document",
                            tabindex: -1
                        },
                        children: [$o(document, "p", {}, r("Below, you can find a list of keyboard shortcuts that can be used in the editor.")), ...this._createCategories(Array.from(t.values())), i]
                    })
                }
                focus() {
                    this.element.focus()
                }
                _createCategories(e) {
                    return e.map(t => {
                        const r = [$o(document, "h3", {}, t.label), ...Array.from(t.groups.values()).map(i => this._createGroup(i)).flat()];
                        return t.description && r.splice(1, 0, $o(document, "p", {}, t.description)),
                        $o(document, "section", {}, r)
                    }
                    )
                }
                _createGroup(e) {
                    const t = e.keystrokes.sort( (i, l) => i.label.localeCompare(l.label)).map(i => this._createGroupRow(i)).flat()
                      , r = [$o(document, "dl", {}, t)];
                    return e.label && r.unshift($o(document, "h4", {}, e.label)),
                    r
                }
                _createGroupRow(e) {
                    const t = this.locale.t
                      , r = $o(document, "dt")
                      , i = $o(document, "dd")
                      , l = function(h) {
                        return typeof h == "string" ? [[h]] : typeof h[0] == "string" ? [h] : h
                    }(e.keystroke)
                      , d = [];
                    for (const h of l)
                        d.push(h.map(Dj).join(""));
                    return r.innerHTML = e.label,
                    i.innerHTML = d.join(", ") + (e.mayRequireFn && E.isMac ? ` ${t("(may require <kbd>Fn</kbd>)")}` : ""),
                    [r, i]
                }
            }
            function Dj(s) {
                return xd(s).split("+").map(e => `<kbd>${e}</kbd>`).join("+")
            }
            const _C = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 6.628a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3Z"/><path d="M8.5 9.125a.3.3 0 0 0-.253-.296L5.11 8.327a.75.75 0 1 1 .388-1.449l4.04.716c.267.072.624.08.893.009l4.066-.724a.75.75 0 1 1 .388 1.45l-3.132.5a.3.3 0 0 0-.253.296v1.357a.3.3 0 0 0 .018.102l1.615 4.438a.75.75 0 0 1-1.41.513l-1.35-3.71a.3.3 0 0 0-.281-.197h-.209a.3.3 0 0 0-.282.198l-1.35 3.711a.75.75 0 0 1-1.41-.513l1.64-4.509a.3.3 0 0 0 .019-.103V9.125Z"/><path clip-rule="evenodd" d="M10 18.5a8.5 8.5 0 1 1 0-17 8.5 8.5 0 0 1 0 17Zm0 1.5c5.523 0 10-4.477 10-10S15.523 0 10 0 0 4.477 0 10s4.477 10 10 10Z"/></svg>';
            var CC = u(8527)
              , Tj = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(CC.A, Tj),
            CC.A.locals;
            class Ij extends ie {
                constructor() {
                    super(...arguments),
                    C(this, "contentView", null)
                }
                static get requires() {
                    return [wC]
                }
                static get pluginName() {
                    return "AccessibilityHelp"
                }
                init() {
                    const e = this.editor
                      , t = e.locale.t;
                    e.ui.componentFactory.add("accessibilityHelp", () => {
                        const r = this._createButton(Te);
                        return r.set({
                            tooltip: !0,
                            withText: !1,
                            label: t("Accessibility help")
                        }),
                        r
                    }
                    ),
                    e.ui.componentFactory.add("menuBar:accessibilityHelp", () => {
                        const r = this._createButton(Xt);
                        return r.label = t("Accessibility"),
                        r
                    }
                    ),
                    e.keystrokes.set("Alt+0", (r, i) => {
                        this._showDialog(),
                        i()
                    }
                    ),
                    this._setupRootLabels()
                }
                _createButton(e) {
                    const t = new e(this.editor.locale);
                    return t.set({
                        keystroke: "Alt+0",
                        icon: _C
                    }),
                    t.on("execute", () => this._showDialog()),
                    t
                }
                _setupRootLabels() {
                    const e = this.editor
                      , t = e.editing.view
                      , r = e.t;
                    function i(l, d) {
                        const h = `${d.getAttribute("aria-label")}. ${r("Press %0 for help.", [xd("Alt+0")])}`;
                        l.setAttribute("aria-label", h, d)
                    }
                    e.ui.on("ready", () => {
                        t.change(l => {
                            for (const d of t.document.roots)
                                i(l, d)
                        }
                        ),
                        e.on("addRoot", (l, d) => {
                            const h = e.editing.view.document.getRoot(d.rootName);
                            t.change(m => i(m, h))
                        }
                        , {
                            priority: "low"
                        })
                    }
                    )
                }
                _showDialog() {
                    const e = this.editor
                      , t = e.plugins.get("Dialog")
                      , r = e.locale.t;
                    this.contentView || (this.contentView = new Sj(e.locale,e.accessibility.keystrokeInfos)),
                    t.show({
                        id: "accessibilityHelp",
                        className: "ck-accessibility-help-dialog",
                        title: r("Accessibility help"),
                        icon: _C,
                        hasCloseButton: !0,
                        content: this.contentView
                    })
                }
            }
            class Mj extends ur {
                constructor(e, t=[]) {
                    super(t),
                    C(this, "locale"),
                    C(this, "_bodyCollectionContainer"),
                    this.locale = e
                }
                get bodyCollectionContainer() {
                    return this._bodyCollectionContainer
                }
                attachToDom() {
                    this._bodyCollectionContainer = new hr({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-reset_all", "ck-body", "ck-rounded-corners"],
                            dir: this.locale.uiLanguageDirection
                        },
                        children: this
                    }).render();
                    let e = document.querySelector(".ck-body-wrapper");
                    e || (e = $o(document, "div", {
                        class: "ck-body-wrapper"
                    }),
                    document.body.appendChild(e)),
                    e.appendChild(this._bodyCollectionContainer)
                }
                detachFromDom() {
                    super.destroy(),
                    this._bodyCollectionContainer && this._bodyCollectionContainer.remove();
                    const e = document.querySelector(".ck-body-wrapper");
                    e && e.childElementCount == 0 && e.remove()
                }
            }
            var yC = u(4391)
              , Bj = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(yC.A, Bj),
            yC.A.locals;
            class Jd extends Te {
                constructor(e) {
                    super(e),
                    C(this, "toggleSwitchView"),
                    this.isToggleable = !0,
                    this.toggleSwitchView = this._createToggleView(),
                    this.extendTemplate({
                        attributes: {
                            class: "ck-switchbutton"
                        }
                    })
                }
                render() {
                    super.render(),
                    this.children.add(this.toggleSwitchView)
                }
                _createToggleView() {
                    const e = new pe;
                    return e.setTemplate({
                        tag: "span",
                        attributes: {
                            class: ["ck", "ck-button__toggle"]
                        },
                        children: [{
                            tag: "span",
                            attributes: {
                                class: ["ck", "ck-button__toggle__inner"]
                            }
                        }]
                    }),
                    e
                }
            }
            class Hp extends Te {
                constructor(e) {
                    super(e),
                    C(this, "buttonView"),
                    C(this, "_fileInputView"),
                    this.buttonView = this,
                    this._fileInputView = new Nj(e),
                    this._fileInputView.bind("acceptedType").to(this),
                    this._fileInputView.bind("allowMultipleFiles").to(this),
                    this._fileInputView.delegate("done").to(this),
                    this.on("execute", () => {
                        this._fileInputView.open()
                    }
                    ),
                    this.extendTemplate({
                        attributes: {
                            class: "ck-file-dialog-button"
                        }
                    })
                }
                render() {
                    super.render(),
                    this.children.add(this._fileInputView)
                }
            }
            class Nj extends pe {
                constructor(e) {
                    super(e),
                    this.set("acceptedType", void 0),
                    this.set("allowMultipleFiles", !1);
                    const t = this.bindTemplate;
                    this.setTemplate({
                        tag: "input",
                        attributes: {
                            class: ["ck-hidden"],
                            type: "file",
                            tabindex: "-1",
                            accept: t.to("acceptedType"),
                            multiple: t.to("allowMultipleFiles")
                        },
                        on: {
                            change: t.to( () => {
                                this.element && this.element.files && this.element.files.length && this.fire("done", this.element.files),
                                this.element.value = ""
                            }
                            )
                        }
                    })
                }
                open() {
                    this.element.click()
                }
            }
            const Xd = '<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><path d="M.941 4.523a.75.75 0 1 1 1.06-1.06l3.006 3.005 3.005-3.005a.75.75 0 1 1 1.06 1.06l-3.549 3.55a.75.75 0 0 1-1.168-.136L.941 4.523z"/></svg>';
            var xC = u(25)
              , Pj = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(xC.A, Pj),
            xC.A.locals;
            class jj extends pe {
                constructor(e, t) {
                    super(e),
                    C(this, "buttonView"),
                    C(this, "children");
                    const r = this.bindTemplate;
                    this.set("isCollapsed", !1),
                    this.set("label", ""),
                    this.buttonView = this._createButtonView(),
                    this.children = this.createCollection(),
                    this.set("_collapsibleAriaLabelUid", void 0),
                    t && this.children.addMany(t),
                    this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-collapsible", r.if("isCollapsed", "ck-collapsible_collapsed")]
                        },
                        children: [this.buttonView, {
                            tag: "div",
                            attributes: {
                                class: ["ck", "ck-collapsible__children"],
                                role: "region",
                                hidden: r.if("isCollapsed", "hidden"),
                                "aria-labelledby": r.to("_collapsibleAriaLabelUid")
                            },
                            children: this.children
                        }]
                    })
                }
                render() {
                    super.render(),
                    this._collapsibleAriaLabelUid = this.buttonView.labelView.element.id
                }
                focus() {
                    this.buttonView.focus()
                }
                _createButtonView() {
                    const e = new Te(this.locale)
                      , t = e.bindTemplate;
                    return e.set({
                        withText: !0,
                        icon: Xd
                    }),
                    e.extendTemplate({
                        attributes: {
                            "aria-expanded": t.to("isOn", r => String(r))
                        }
                    }),
                    e.bind("label").to(this),
                    e.bind("isOn").to(this, "isCollapsed", r => !r),
                    e.on("execute", () => {
                        this.isCollapsed = !this.isCollapsed
                    }
                    ),
                    e
                }
            }
            var EC = u(7317)
              , Lj = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(EC.A, Lj),
            EC.A.locals,
            u(6931),
            u(9047);
            var SC = u(4962)
              , zj = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(SC.A, zj),
            SC.A.locals;
            class Wp extends pe {
                constructor(e, t) {
                    super(e),
                    C(this, "fieldView"),
                    C(this, "labelView"),
                    C(this, "statusView"),
                    C(this, "fieldWrapperChildren");
                    const r = `ck-labeled-field-view-${H()}`
                      , i = `ck-labeled-field-view-status-${H()}`;
                    this.fieldView = t(this, r, i),
                    this.set("label", void 0),
                    this.set("isEnabled", !0),
                    this.set("isEmpty", !0),
                    this.set("isFocused", !1),
                    this.set("errorText", null),
                    this.set("infoText", null),
                    this.set("class", void 0),
                    this.set("placeholder", void 0),
                    this.labelView = this._createLabelView(r),
                    this.statusView = this._createStatusView(i),
                    this.fieldWrapperChildren = this.createCollection([this.fieldView, this.labelView]),
                    this.bind("_statusText").to(this, "errorText", this, "infoText", (d, h) => d || h);
                    const l = this.bindTemplate;
                    this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-labeled-field-view", l.to("class"), l.if("isEnabled", "ck-disabled", d => !d), l.if("isEmpty", "ck-labeled-field-view_empty"), l.if("isFocused", "ck-labeled-field-view_focused"), l.if("placeholder", "ck-labeled-field-view_placeholder"), l.if("errorText", "ck-error")]
                        },
                        children: [{
                            tag: "div",
                            attributes: {
                                class: ["ck", "ck-labeled-field-view__input-wrapper"]
                            },
                            children: this.fieldWrapperChildren
                        }, this.statusView]
                    })
                }
                _createLabelView(e) {
                    const t = new Zd(this.locale);
                    return t.for = e,
                    t.bind("text").to(this, "label"),
                    t
                }
                _createStatusView(e) {
                    const t = new pe(this.locale)
                      , r = this.bindTemplate;
                    return t.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-labeled-field-view__status", r.if("errorText", "ck-labeled-field-view__status_error"), r.if("_statusText", "ck-hidden", i => !i)],
                            id: e,
                            role: r.if("errorText", "alert")
                        },
                        children: [{
                            text: r.to("_statusText")
                        }]
                    }),
                    t
                }
                focus(e) {
                    this.fieldView.focus(e)
                }
            }
            class Oj extends pe {
                constructor(e) {
                    super(e),
                    C(this, "focusTracker"),
                    this.set("value", void 0),
                    this.set("id", void 0),
                    this.set("placeholder", void 0),
                    this.set("tabIndex", void 0),
                    this.set("isReadOnly", !1),
                    this.set("hasError", !1),
                    this.set("ariaDescribedById", void 0),
                    this.set("ariaLabel", void 0),
                    this.focusTracker = new Jt,
                    this.bind("isFocused").to(this.focusTracker),
                    this.set("isEmpty", !0);
                    const t = this.bindTemplate;
                    this.setTemplate({
                        tag: "input",
                        attributes: {
                            class: ["ck", "ck-input", t.if("isFocused", "ck-input_focused"), t.if("isEmpty", "ck-input-text_empty"), t.if("hasError", "ck-error")],
                            id: t.to("id"),
                            placeholder: t.to("placeholder"),
                            tabindex: t.to("tabIndex"),
                            readonly: t.to("isReadOnly"),
                            "aria-invalid": t.if("hasError", !0),
                            "aria-describedby": t.to("ariaDescribedById"),
                            "aria-label": t.to("ariaLabel")
                        },
                        on: {
                            input: t.to( (...r) => {
                                this.fire("input", ...r),
                                this._updateIsEmpty()
                            }
                            ),
                            change: t.to(this._updateIsEmpty.bind(this))
                        }
                    })
                }
                render() {
                    super.render(),
                    this.focusTracker.add(this.element),
                    this._setDomElementValue(this.value),
                    this._updateIsEmpty(),
                    this.on("change:value", (e, t, r) => {
                        this._setDomElementValue(r),
                        this._updateIsEmpty()
                    }
                    )
                }
                destroy() {
                    super.destroy(),
                    this.focusTracker.destroy()
                }
                select() {
                    this.element.select()
                }
                focus() {
                    this.element.focus()
                }
                reset() {
                    this.value = this.element.value = "",
                    this._updateIsEmpty()
                }
                _updateIsEmpty() {
                    this.isEmpty = !this.element.value
                }
                _setDomElementValue(e) {
                    this.element.value = e || e === 0 ? e : ""
                }
            }
            var DC = u(253)
              , Rj = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(DC.A, Rj),
            DC.A.locals;
            class Fj extends Oj {
                constructor(e) {
                    super(e),
                    this.set("inputMode", "text");
                    const t = this.bindTemplate;
                    this.extendTemplate({
                        attributes: {
                            inputmode: t.to("inputMode")
                        }
                    })
                }
            }
            class Vj extends Fj {
                constructor(e) {
                    super(e),
                    this.extendTemplate({
                        attributes: {
                            type: "text",
                            class: ["ck-input-text"]
                        }
                    })
                }
            }
            var TC = u(1671)
              , Uj = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(TC.A, Uj),
            TC.A.locals;
            class Hj extends pe {
                constructor(e) {
                    super(e),
                    C(this, "children");
                    const t = this.bindTemplate;
                    this.set("isVisible", !1),
                    this.set("position", "se"),
                    this.children = this.createCollection(),
                    this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-reset", "ck-dropdown__panel", t.to("position", r => `ck-dropdown__panel_${r}`), t.if("isVisible", "ck-dropdown__panel-visible")],
                            tabindex: "-1"
                        },
                        children: this.children,
                        on: {
                            selectstart: t.to(r => {
                                r.target.tagName.toLocaleLowerCase() !== "input" && r.preventDefault()
                            }
                            )
                        }
                    })
                }
                focus() {
                    if (this.children.length) {
                        const e = this.children.first;
                        typeof e.focus == "function" ? e.focus() : de("ui-dropdown-panel-focus-child-missing-focus", {
                            childView: this.children.first,
                            dropdownPanel: this
                        })
                    }
                }
                focusLast() {
                    if (this.children.length) {
                        const e = this.children.last;
                        typeof e.focusLast == "function" ? e.focusLast() : e.focus()
                    }
                }
            }
            var IC = u(8149)
              , Wj = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(IC.A, Wj),
            IC.A.locals;
            const $p = class rb extends pe {
                constructor(e, t, r) {
                    super(e),
                    C(this, "buttonView"),
                    C(this, "panelView"),
                    C(this, "focusTracker"),
                    C(this, "keystrokes"),
                    C(this, "listView"),
                    C(this, "toolbarView");
                    const i = this.bindTemplate;
                    this.buttonView = t,
                    this.panelView = r,
                    this.set("isOpen", !1),
                    this.set("isEnabled", !0),
                    this.set("class", void 0),
                    this.set("id", void 0),
                    this.set("panelPosition", "auto"),
                    this.panelView.bind("isVisible").to(this, "isOpen"),
                    this.keystrokes = new lo,
                    this.focusTracker = new Jt,
                    this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-dropdown", i.to("class"), i.if("isEnabled", "ck-disabled", l => !l)],
                            id: i.to("id"),
                            "aria-describedby": i.to("ariaDescribedById")
                        },
                        children: [t, r]
                    }),
                    t.extendTemplate({
                        attributes: {
                            class: ["ck-dropdown__button"],
                            "data-cke-tooltip-disabled": i.to("isOpen")
                        }
                    })
                }
                render() {
                    super.render(),
                    this.focusTracker.add(this.buttonView.element),
                    this.focusTracker.add(this.panelView.element),
                    this.listenTo(this.buttonView, "open", () => {
                        this.isOpen = !this.isOpen
                    }
                    ),
                    this.on("change:isOpen", (t, r, i) => {
                        if (i)
                            if (this.panelPosition === "auto") {
                                const l = rb._getOptimalPosition({
                                    element: this.panelView.element,
                                    target: this.buttonView.element,
                                    fitInViewport: !0,
                                    positions: this._panelPositions
                                });
                                this.panelView.position = l ? l.name : this._panelPositions[0].name
                            } else
                                this.panelView.position = this.panelPosition
                    }
                    ),
                    this.keystrokes.listenTo(this.element);
                    const e = (t, r) => {
                        this.isOpen && (this.isOpen = !1,
                        r())
                    }
                    ;
                    this.keystrokes.set("arrowdown", (t, r) => {
                        this.buttonView.isEnabled && !this.isOpen && (this.isOpen = !0,
                        r())
                    }
                    ),
                    this.keystrokes.set("arrowright", (t, r) => {
                        this.isOpen && r()
                    }
                    ),
                    this.keystrokes.set("arrowleft", e),
                    this.keystrokes.set("esc", e)
                }
                focus() {
                    this.buttonView.focus()
                }
                get _panelPositions() {
                    const {south: e, north: t, southEast: r, southWest: i, northEast: l, northWest: d, southMiddleEast: h, southMiddleWest: m, northMiddleEast: g, northMiddleWest: b} = rb.defaultPanelPositions;
                    return this.locale.uiLanguageDirection !== "rtl" ? [r, i, h, m, e, l, d, g, b, t] : [i, r, m, h, e, d, l, b, g, t]
                }
            }
            ;
            C($p, "defaultPanelPositions", {
                south: (s, e) => ({
                    top: s.bottom,
                    left: s.left - (e.width - s.width) / 2,
                    name: "s"
                }),
                southEast: s => ({
                    top: s.bottom,
                    left: s.left,
                    name: "se"
                }),
                southWest: (s, e) => ({
                    top: s.bottom,
                    left: s.left - e.width + s.width,
                    name: "sw"
                }),
                southMiddleEast: (s, e) => ({
                    top: s.bottom,
                    left: s.left - (e.width - s.width) / 4,
                    name: "sme"
                }),
                southMiddleWest: (s, e) => ({
                    top: s.bottom,
                    left: s.left - 3 * (e.width - s.width) / 4,
                    name: "smw"
                }),
                north: (s, e) => ({
                    top: s.top - e.height,
                    left: s.left - (e.width - s.width) / 2,
                    name: "n"
                }),
                northEast: (s, e) => ({
                    top: s.top - e.height,
                    left: s.left,
                    name: "ne"
                }),
                northWest: (s, e) => ({
                    top: s.top - e.height,
                    left: s.left - e.width + s.width,
                    name: "nw"
                }),
                northMiddleEast: (s, e) => ({
                    top: s.top - e.height,
                    left: s.left - (e.width - s.width) / 4,
                    name: "nme"
                }),
                northMiddleWest: (s, e) => ({
                    top: s.top - e.height,
                    left: s.left - 3 * (e.width - s.width) / 4,
                    name: "nmw"
                })
            }),
            C($p, "_getOptimalPosition", Km);
            let $j = $p;
            class qj extends Te {
                constructor(e) {
                    super(e),
                    C(this, "arrowView"),
                    this.arrowView = this._createArrowView(),
                    this.extendTemplate({
                        attributes: {
                            "aria-haspopup": !0,
                            "aria-expanded": this.bindTemplate.to("isOn", t => String(t))
                        }
                    }),
                    this.delegate("execute").to(this, "open")
                }
                render() {
                    super.render(),
                    this.children.add(this.arrowView)
                }
                _createArrowView() {
                    const e = new Ni;
                    return e.content = Xd,
                    e.extendTemplate({
                        attributes: {
                            class: "ck-dropdown__arrow"
                        }
                    }),
                    e
                }
            }
            class MC extends pe {
                constructor(e) {
                    super(e),
                    this.setTemplate({
                        tag: "span",
                        attributes: {
                            class: ["ck", "ck-toolbar__separator"]
                        }
                    })
                }
            }
            class Gj extends pe {
                constructor(e) {
                    super(e),
                    this.setTemplate({
                        tag: "span",
                        attributes: {
                            class: ["ck", "ck-toolbar__line-break"]
                        }
                    })
                }
            }
            function BC(s) {
                if (Array.isArray(s))
                    return {
                        items: s,
                        removeItems: []
                    };
                const e = {
                    items: [],
                    removeItems: []
                };
                return s ? {
                    ...e,
                    ...s
                } : e
            }
            var NC = u(9677)
              , Kj = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(NC.A, Kj),
            NC.A.locals;
            const Yj = {
                alignLeft: he.alignLeft,
                bold: he.bold,
                importExport: he.importExport,
                paragraph: he.paragraph,
                plus: he.plus,
                text: he.text,
                threeVerticalDots: he.threeVerticalDots,
                pilcrow: he.pilcrow,
                dragIndicator: he.dragIndicator
            };
            class qp extends pe {
                constructor(e, t) {
                    super(e),
                    C(this, "options"),
                    C(this, "items"),
                    C(this, "focusTracker"),
                    C(this, "keystrokes"),
                    C(this, "itemsView"),
                    C(this, "children"),
                    C(this, "focusables"),
                    C(this, "_focusCycler"),
                    C(this, "_behavior");
                    const r = this.bindTemplate
                      , i = this.t;
                    this.options = t || {},
                    this.set("ariaLabel", i("Editor toolbar")),
                    this.set("maxWidth", "auto"),
                    this.items = this.createCollection(),
                    this.focusTracker = new Jt,
                    this.keystrokes = new lo,
                    this.set("class", void 0),
                    this.set("isCompact", !1),
                    this.itemsView = new Qj(e),
                    this.children = this.createCollection(),
                    this.children.add(this.itemsView),
                    this.focusables = this.createCollection();
                    const l = e.uiLanguageDirection === "rtl";
                    this._focusCycler = new Jr({
                        focusables: this.focusables,
                        focusTracker: this.focusTracker,
                        keystrokeHandler: this.keystrokes,
                        actions: {
                            focusPrevious: [l ? "arrowright" : "arrowleft", "arrowup"],
                            focusNext: [l ? "arrowleft" : "arrowright", "arrowdown"]
                        }
                    });
                    const d = ["ck", "ck-toolbar", r.to("class"), r.if("isCompact", "ck-toolbar_compact")];
                    var h;
                    this.options.shouldGroupWhenFull && this.options.isFloating && d.push("ck-toolbar_floating"),
                    this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: d,
                            role: "toolbar",
                            "aria-label": r.to("ariaLabel"),
                            style: {
                                maxWidth: r.to("maxWidth")
                            },
                            tabindex: -1
                        },
                        children: this.children,
                        on: {
                            mousedown: (h = this,
                            h.bindTemplate.to(m => {
                                m.target === h.element && m.preventDefault()
                            }
                            ))
                        }
                    }),
                    this._behavior = this.options.shouldGroupWhenFull ? new Jj(this) : new Zj(this)
                }
                render() {
                    super.render(),
                    this.focusTracker.add(this.element);
                    for (const e of this.items)
                        this.focusTracker.add(e.element);
                    this.items.on("add", (e, t) => {
                        this.focusTracker.add(t.element)
                    }
                    ),
                    this.items.on("remove", (e, t) => {
                        this.focusTracker.remove(t.element)
                    }
                    ),
                    this.keystrokes.listenTo(this.element),
                    this._behavior.render(this)
                }
                destroy() {
                    return this._behavior.destroy(),
                    this.focusTracker.destroy(),
                    this.keystrokes.destroy(),
                    super.destroy()
                }
                focus() {
                    this._focusCycler.focusFirst()
                }
                focusLast() {
                    this._focusCycler.focusLast()
                }
                fillFromConfig(e, t, r) {
                    this.items.addMany(this._buildItemsFromConfig(e, t, r))
                }
                _buildItemsFromConfig(e, t, r) {
                    const i = BC(e)
                      , l = r || i.removeItems;
                    return this._cleanItemsConfiguration(i.items, t, l).map(d => Le(d) ? this._createNestedToolbarDropdown(d, t, l) : d === "|" ? new MC : d === "-" ? new Gj : t.create(d)).filter(d => !!d)
                }
                _cleanItemsConfiguration(e, t, r) {
                    const i = e.filter( (l, d, h) => l === "|" || r.indexOf(l) === -1 && (l === "-" ? !this.options.shouldGroupWhenFull || (de("toolbarview-line-break-ignored-when-grouping-items", h),
                    !1) : !(!Le(l) && !t.has(l)) || (de("toolbarview-item-unavailable", {
                        item: l
                    }),
                    !1)));
                    return this._cleanSeparatorsAndLineBreaks(i)
                }
                _cleanSeparatorsAndLineBreaks(e) {
                    const t = d => d !== "-" && d !== "|"
                      , r = e.length
                      , i = e.findIndex(t);
                    if (i === -1)
                        return [];
                    const l = r - e.slice().reverse().findIndex(t);
                    return e.slice(i, l).filter( (d, h, m) => t(d) ? !0 : !(h > 0 && m[h - 1] === d))
                }
                _createNestedToolbarDropdown(e, t, r) {
                    let {label: i, icon: l, items: d, tooltip: h=!0, withText: m=!1} = e;
                    if (d = this._cleanItemsConfiguration(d, t, r),
                    !d.length)
                        return null;
                    const g = Nn(this.locale);
                    return i || de("toolbarview-nested-toolbar-dropdown-missing-label", e),
                    g.class = "ck-toolbar__nested-toolbar-dropdown",
                    g.buttonView.set({
                        label: i,
                        tooltip: h,
                        withText: !!m
                    }),
                    l !== !1 ? g.buttonView.icon = Yj[l] || l || he.threeVerticalDots : g.buttonView.withText = !0,
                    Yp(g, () => g.toolbarView._buildItemsFromConfig(d, t, r)),
                    g
                }
            }
            class Qj extends pe {
                constructor(e) {
                    super(e),
                    C(this, "children"),
                    this.children = this.createCollection(),
                    this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-toolbar__items"]
                        },
                        children: this.children
                    })
                }
            }
            class Zj {
                constructor(e) {
                    const t = e.bindTemplate;
                    e.set("isVertical", !1),
                    e.itemsView.children.bindTo(e.items).using(r => r),
                    e.focusables.bindTo(e.items).using(r => Dl(r) ? r : null),
                    e.extendTemplate({
                        attributes: {
                            class: [t.if("isVertical", "ck-toolbar_vertical")]
                        }
                    })
                }
                render() {}
                destroy() {}
            }
            class Jj {
                constructor(e) {
                    C(this, "view"),
                    C(this, "viewChildren"),
                    C(this, "viewFocusables"),
                    C(this, "viewItemsView"),
                    C(this, "viewFocusTracker"),
                    C(this, "viewLocale"),
                    C(this, "ungroupedItems"),
                    C(this, "groupedItems"),
                    C(this, "groupedItemsDropdown"),
                    C(this, "resizeObserver", null),
                    C(this, "cachedPadding", null),
                    C(this, "shouldUpdateGroupingOnNextResize", !1),
                    C(this, "viewElement"),
                    this.view = e,
                    this.viewChildren = e.children,
                    this.viewFocusables = e.focusables,
                    this.viewItemsView = e.itemsView,
                    this.viewFocusTracker = e.focusTracker,
                    this.viewLocale = e.locale,
                    this.ungroupedItems = e.createCollection(),
                    this.groupedItems = e.createCollection(),
                    this.groupedItemsDropdown = this._createGroupedItemsDropdown(),
                    e.itemsView.children.bindTo(this.ungroupedItems).using(t => t),
                    this.ungroupedItems.on("change", this._updateFocusCyclableItems.bind(this)),
                    e.children.on("change", this._updateFocusCyclableItems.bind(this)),
                    e.items.on("change", (t, r) => {
                        const i = r.index
                          , l = Array.from(r.added);
                        for (const d of r.removed)
                            i >= this.ungroupedItems.length ? this.groupedItems.remove(d) : this.ungroupedItems.remove(d);
                        for (let d = i; d < i + l.length; d++) {
                            const h = l[d - i];
                            d > this.ungroupedItems.length ? this.groupedItems.add(h, d - this.ungroupedItems.length) : this.ungroupedItems.add(h, d)
                        }
                        this._updateGrouping()
                    }
                    ),
                    e.extendTemplate({
                        attributes: {
                            class: ["ck-toolbar_grouping"]
                        }
                    })
                }
                render(e) {
                    this.viewElement = e.element,
                    this._enableGroupingOnResize(),
                    this._enableGroupingOnMaxWidthChange(e)
                }
                destroy() {
                    this.groupedItemsDropdown.destroy(),
                    this.resizeObserver.destroy()
                }
                _updateGrouping() {
                    if (!this.viewElement.ownerDocument.body.contains(this.viewElement))
                        return;
                    if (!yi(this.viewElement))
                        return void (this.shouldUpdateGroupingOnNextResize = !0);
                    const e = this.groupedItems.length;
                    let t;
                    for (; this._areItemsOverflowing; )
                        this._groupLastItem(),
                        t = !0;
                    if (!t && this.groupedItems.length) {
                        for (; this.groupedItems.length && !this._areItemsOverflowing; )
                            this._ungroupFirstItem();
                        this._areItemsOverflowing && this._groupLastItem()
                    }
                    this.groupedItems.length !== e && this.view.fire("groupedItemsUpdate")
                }
                get _areItemsOverflowing() {
                    if (!this.ungroupedItems.length)
                        return !1;
                    const e = this.viewElement
                      , t = this.viewLocale.uiLanguageDirection
                      , r = new De(e.lastChild)
                      , i = new De(e);
                    if (!this.cachedPadding) {
                        const l = w.window.getComputedStyle(e)
                          , d = t === "ltr" ? "paddingRight" : "paddingLeft";
                        this.cachedPadding = Number.parseInt(l[d])
                    }
                    return t === "ltr" ? r.right > i.right - this.cachedPadding : r.left < i.left + this.cachedPadding
                }
                _enableGroupingOnResize() {
                    let e;
                    this.resizeObserver = new Gm(this.viewElement,t => {
                        e && e === t.contentRect.width && !this.shouldUpdateGroupingOnNextResize || (this.shouldUpdateGroupingOnNextResize = !1,
                        this._updateGrouping(),
                        e = t.contentRect.width)
                    }
                    ),
                    this._updateGrouping()
                }
                _enableGroupingOnMaxWidthChange(e) {
                    e.on("change:maxWidth", () => {
                        this._updateGrouping()
                    }
                    )
                }
                _groupLastItem() {
                    this.groupedItems.length || (this.viewChildren.add(new MC),
                    this.viewChildren.add(this.groupedItemsDropdown),
                    this.viewFocusTracker.add(this.groupedItemsDropdown.element)),
                    this.groupedItems.add(this.ungroupedItems.remove(this.ungroupedItems.last), 0)
                }
                _ungroupFirstItem() {
                    this.ungroupedItems.add(this.groupedItems.remove(this.groupedItems.first)),
                    this.groupedItems.length || (this.viewChildren.remove(this.groupedItemsDropdown),
                    this.viewChildren.remove(this.viewChildren.last),
                    this.viewFocusTracker.remove(this.groupedItemsDropdown.element))
                }
                _createGroupedItemsDropdown() {
                    const e = this.viewLocale
                      , t = e.t
                      , r = Nn(e);
                    return r.class = "ck-toolbar__grouped-dropdown",
                    r.panelPosition = e.uiLanguageDirection === "ltr" ? "sw" : "se",
                    Yp(r, this.groupedItems),
                    r.buttonView.set({
                        label: t("Show more items"),
                        tooltip: !0,
                        tooltipPosition: e.uiLanguageDirection === "rtl" ? "se" : "sw",
                        icon: he.threeVerticalDots
                    }),
                    r
                }
                _updateFocusCyclableItems() {
                    this.viewFocusables.clear(),
                    this.ungroupedItems.map(e => {
                        Dl(e) && this.viewFocusables.add(e)
                    }
                    ),
                    this.groupedItems.length && this.viewFocusables.add(this.groupedItemsDropdown)
                }
            }
            class Ps extends pe {
                constructor(e) {
                    super(e),
                    C(this, "children");
                    const t = this.bindTemplate;
                    this.set("isVisible", !0),
                    this.children = this.createCollection(),
                    this.setTemplate({
                        tag: "li",
                        attributes: {
                            class: ["ck", "ck-list__item", t.if("isVisible", "ck-hidden", r => !r)],
                            role: "presentation"
                        },
                        children: this.children
                    })
                }
                focus() {
                    this.children.first && this.children.first.focus()
                }
            }
            class Gp extends pe {
                constructor(e) {
                    super(e),
                    this.setTemplate({
                        tag: "li",
                        attributes: {
                            class: ["ck", "ck-list__separator"]
                        }
                    })
                }
            }
            class eu extends pe {
                constructor(e, t=new Zd) {
                    super(e),
                    C(this, "labelView"),
                    C(this, "items"),
                    C(this, "children");
                    const r = this.bindTemplate
                      , i = new Kp(e);
                    this.set({
                        label: "",
                        isVisible: !0
                    }),
                    this.labelView = t,
                    this.labelView.bind("text").to(this, "label"),
                    this.children = this.createCollection(),
                    this.children.addMany([this.labelView, i]),
                    i.set({
                        role: "group",
                        ariaLabelledBy: t.id
                    }),
                    i.focusTracker.destroy(),
                    i.keystrokes.destroy(),
                    this.items = i.items,
                    this.setTemplate({
                        tag: "li",
                        attributes: {
                            role: "presentation",
                            class: ["ck", "ck-list__group", r.if("isVisible", "ck-hidden", l => !l)]
                        },
                        children: this.children
                    })
                }
                focus() {
                    if (this.items) {
                        const e = this.items.find(t => !(t instanceof Gp));
                        e && e.focus()
                    }
                }
            }
            var PC = u(5199)
              , Xj = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(PC.A, Xj),
            PC.A.locals;
            class Kp extends pe {
                constructor(e) {
                    super(e),
                    C(this, "focusables"),
                    C(this, "items"),
                    C(this, "focusTracker"),
                    C(this, "keystrokes"),
                    C(this, "_focusCycler"),
                    C(this, "_listItemGroupToChangeListeners", new WeakMap);
                    const t = this.bindTemplate;
                    this.focusables = new ur,
                    this.items = this.createCollection(),
                    this.focusTracker = new Jt,
                    this.keystrokes = new lo,
                    this._focusCycler = new Jr({
                        focusables: this.focusables,
                        focusTracker: this.focusTracker,
                        keystrokeHandler: this.keystrokes,
                        actions: {
                            focusPrevious: "arrowup",
                            focusNext: "arrowdown"
                        }
                    }),
                    this.set("ariaLabel", void 0),
                    this.set("ariaLabelledBy", void 0),
                    this.set("role", void 0),
                    this.setTemplate({
                        tag: "ul",
                        attributes: {
                            class: ["ck", "ck-reset", "ck-list"],
                            role: t.to("role"),
                            "aria-label": t.to("ariaLabel"),
                            "aria-labelledby": t.to("ariaLabelledBy")
                        },
                        children: this.items
                    })
                }
                render() {
                    super.render();
                    for (const e of this.items)
                        e instanceof eu ? this._registerFocusableItemsGroup(e) : e instanceof Ps && this._registerFocusableListItem(e);
                    this.items.on("change", (e, t) => {
                        for (const r of t.removed)
                            r instanceof eu ? this._deregisterFocusableItemsGroup(r) : r instanceof Ps && this._deregisterFocusableListItem(r);
                        for (const r of Array.from(t.added).reverse())
                            r instanceof eu ? this._registerFocusableItemsGroup(r, t.index) : this._registerFocusableListItem(r, t.index)
                    }
                    ),
                    this.keystrokes.listenTo(this.element)
                }
                destroy() {
                    super.destroy(),
                    this.focusTracker.destroy(),
                    this.keystrokes.destroy()
                }
                focus() {
                    this._focusCycler.focusFirst()
                }
                focusFirst() {
                    this._focusCycler.focusFirst()
                }
                focusLast() {
                    this._focusCycler.focusLast()
                }
                _registerFocusableListItem(e, t) {
                    this.focusTracker.add(e.element),
                    this.focusables.add(e, t)
                }
                _deregisterFocusableListItem(e) {
                    this.focusTracker.remove(e.element),
                    this.focusables.remove(e)
                }
                _getOnGroupItemsChangeCallback(e) {
                    return (t, r) => {
                        for (const i of r.removed)
                            this._deregisterFocusableListItem(i);
                        for (const i of Array.from(r.added).reverse())
                            this._registerFocusableListItem(i, this.items.getIndex(e) + r.index)
                    }
                }
                _registerFocusableItemsGroup(e, t) {
                    Array.from(e.items).forEach( (i, l) => {
                        const d = t !== void 0 ? t + l : void 0;
                        this._registerFocusableListItem(i, d)
                    }
                    );
                    const r = this._getOnGroupItemsChangeCallback(e);
                    this._listItemGroupToChangeListeners.set(e, r),
                    e.items.on("change", r)
                }
                _deregisterFocusableItemsGroup(e) {
                    for (const t of e.items)
                        this._deregisterFocusableListItem(t);
                    e.items.off("change", this._listItemGroupToChangeListeners.get(e)),
                    this._listItemGroupToChangeListeners.delete(e)
                }
            }
            var jC = u(1792)
              , eL = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(jC.A, eL),
            jC.A.locals;
            class tu extends pe {
                constructor(e, t) {
                    super(e),
                    C(this, "children"),
                    C(this, "actionView"),
                    C(this, "arrowView"),
                    C(this, "keystrokes"),
                    C(this, "focusTracker");
                    const r = this.bindTemplate;
                    this.set("class", void 0),
                    this.set("labelStyle", void 0),
                    this.set("icon", void 0),
                    this.set("isEnabled", !0),
                    this.set("isOn", !1),
                    this.set("isToggleable", !1),
                    this.set("isVisible", !0),
                    this.set("keystroke", void 0),
                    this.set("withKeystroke", !1),
                    this.set("label", void 0),
                    this.set("tabindex", -1),
                    this.set("tooltip", !1),
                    this.set("tooltipPosition", "s"),
                    this.set("type", "button"),
                    this.set("withText", !1),
                    this.children = this.createCollection(),
                    this.actionView = this._createActionView(t),
                    this.arrowView = this._createArrowView(),
                    this.keystrokes = new lo,
                    this.focusTracker = new Jt,
                    this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-splitbutton", r.to("class"), r.if("isVisible", "ck-hidden", i => !i), this.arrowView.bindTemplate.if("isOn", "ck-splitbutton_open")]
                        },
                        children: this.children
                    })
                }
                render() {
                    super.render(),
                    this.children.add(this.actionView),
                    this.children.add(this.arrowView),
                    this.focusTracker.add(this.actionView.element),
                    this.focusTracker.add(this.arrowView.element),
                    this.keystrokes.listenTo(this.element),
                    this.keystrokes.set("arrowright", (e, t) => {
                        this.focusTracker.focusedElement === this.actionView.element && (this.arrowView.focus(),
                        t())
                    }
                    ),
                    this.keystrokes.set("arrowleft", (e, t) => {
                        this.focusTracker.focusedElement === this.arrowView.element && (this.actionView.focus(),
                        t())
                    }
                    )
                }
                destroy() {
                    super.destroy(),
                    this.focusTracker.destroy(),
                    this.keystrokes.destroy()
                }
                focus() {
                    this.actionView.focus()
                }
                _createActionView(e) {
                    const t = e || new Te;
                    return e || t.bind("icon", "isEnabled", "isOn", "isToggleable", "keystroke", "label", "tabindex", "tooltip", "tooltipPosition", "type", "withText").to(this),
                    t.extendTemplate({
                        attributes: {
                            class: "ck-splitbutton__action"
                        }
                    }),
                    t.delegate("execute").to(this),
                    t
                }
                _createArrowView() {
                    const e = new Te
                      , t = e.bindTemplate;
                    return e.icon = Xd,
                    e.extendTemplate({
                        attributes: {
                            class: ["ck-splitbutton__arrow"],
                            "data-cke-tooltip-disabled": t.to("isOn"),
                            "aria-haspopup": !0,
                            "aria-expanded": t.to("isOn", r => String(r))
                        }
                    }),
                    e.bind("isEnabled").to(this),
                    e.bind("label").to(this),
                    e.bind("tooltip").to(this),
                    e.delegate("execute").to(this, "open"),
                    e
                }
            }
            var LC = u(1666)
              , tL = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(LC.A, tL),
            LC.A.locals;
            var zC = u(3629)
              , oL = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(zC.A, oL),
            zC.A.locals;
            function Nn(s, e=qj) {
                const t = typeof e == "function" ? new e(s) : e
                  , r = new Hj(s)
                  , i = new $j(s,t,r);
                return t.bind("isEnabled").to(i),
                t instanceof tu ? t.arrowView.bind("isOn").to(i, "isOpen") : t.bind("isOn").to(i, "isOpen"),
                function(l) {
                    (function(d) {
                        d.on("render", () => {
                            Dd({
                                emitter: d,
                                activator: () => d.isOpen,
                                callback: () => {
                                    d.isOpen = !1
                                }
                                ,
                                contextElements: () => [d.element, ...d.focusTracker._elements]
                            })
                        }
                        )
                    }
                    )(l),
                    function(d) {
                        d.on("execute", h => {
                            h.source instanceof Jd || (d.isOpen = !1)
                        }
                        )
                    }(l),
                    function(d) {
                        d.focusTracker.on("change:isFocused", (h, m, g) => {
                            d.isOpen && !g && (d.isOpen = !1)
                        }
                        )
                    }(l),
                    function(d) {
                        d.keystrokes.set("arrowdown", (h, m) => {
                            d.isOpen && (d.panelView.focus(),
                            m())
                        }
                        ),
                        d.keystrokes.set("arrowup", (h, m) => {
                            d.isOpen && (d.panelView.focusLast(),
                            m())
                        }
                        )
                    }(l),
                    function(d) {
                        d.on("change:isOpen", (h, m, g) => {
                            if (g)
                                return;
                            const b = d.panelView.element;
                            b && b.contains(w.document.activeElement) && d.buttonView.focus()
                        }
                        )
                    }(l),
                    function(d) {
                        d.on("change:isOpen", (h, m, g) => {
                            g && d.panelView.focus()
                        }
                        , {
                            priority: "low"
                        })
                    }(l)
                }(i),
                i
            }
            function Yp(s, e, t={}) {
                s.extendTemplate({
                    attributes: {
                        class: ["ck-toolbar-dropdown"]
                    }
                }),
                s.isOpen ? OC(s, e, t) : s.once("change:isOpen", () => OC(s, e, t), {
                    priority: "highest"
                }),
                t.enableActiveItemFocusOnDropdownOpen && VC(s, () => s.toolbarView.items.find(r => r.isOn))
            }
            function OC(s, e, t) {
                const r = s.locale
                  , i = r.t
                  , l = s.toolbarView = new qp(r)
                  , d = typeof e == "function" ? e() : e;
                l.ariaLabel = t.ariaLabel || i("Dropdown toolbar"),
                t.maxWidth && (l.maxWidth = t.maxWidth),
                t.class && (l.class = t.class),
                t.isCompact && (l.isCompact = t.isCompact),
                t.isVertical && (l.isVertical = !0),
                d instanceof ur ? l.items.bindTo(d).using(h => h) : l.items.addMany(d),
                s.panelView.children.add(l),
                l.items.delegate("execute").to(s)
            }
            function RC(s, e, t={}) {
                s.isOpen ? FC(s, e, t) : s.once("change:isOpen", () => FC(s, e, t), {
                    priority: "highest"
                }),
                VC(s, () => s.listView.items.find(r => r instanceof Ps && r.children.first.isOn))
            }
            function FC(s, e, t) {
                const r = s.locale
                  , i = s.listView = new Kp(r)
                  , l = typeof e == "function" ? e() : e;
                i.ariaLabel = t.ariaLabel,
                i.role = t.role,
                UC(s, i.items, l, r),
                s.panelView.children.add(i),
                i.items.delegate("execute").to(s)
            }
            function VC(s, e) {
                s.on("change:isOpen", () => {
                    if (!s.isOpen)
                        return;
                    const t = e();
                    t && (typeof t.focus == "function" ? t.focus() : de("ui-dropdown-focus-child-on-open-child-missing-focus", {
                        view: t
                    }))
                }
                , {
                    priority: W.low - 10
                })
            }
            function UC(s, e, t, r) {
                e.bindTo(t).using(i => {
                    if (i.type === "separator")
                        return new Gp(r);
                    if (i.type === "group") {
                        const l = new eu(r);
                        return l.set({
                            label: i.label
                        }),
                        UC(s, l.items, i.items, r),
                        l.items.delegate("execute").to(s),
                        l
                    }
                    if (i.type === "button" || i.type === "switchbutton") {
                        const l = new Ps(r);
                        let d;
                        return i.type === "button" ? (d = new Te(r),
                        d.bind("ariaChecked").to(d, "isOn")) : d = new Jd(r),
                        d.bind(...Object.keys(i.model)).to(i.model),
                        d.delegate("execute").to(l),
                        l.children.add(d),
                        l
                    }
                    return null
                }
                )
            }
            const Qp = (s, e, t) => {
                const r = new Vj(s.locale);
                return r.set({
                    id: e,
                    ariaDescribedById: t
                }),
                r.bind("isReadOnly").to(s, "isEnabled", i => !i),
                r.bind("hasError").to(s, "errorText", i => !!i),
                r.on("input", () => {
                    s.errorText = null
                }
                ),
                s.bind("isEmpty", "isFocused", "placeholder").to(r),
                r
            }
            ;
            var HC = u(1905)
              , rL = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(HC.A, rL),
            HC.A.locals;
            var WC = u(6309)
              , nL = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(WC.A, nL),
            WC.A.locals;
            class iL {
                constructor(e) {
                    C(this, "editor"),
                    C(this, "_components", new Map),
                    this.editor = e
                }
                *names() {
                    for (const e of this._components.values())
                        yield e.originalName
                }
                add(e, t) {
                    this._components.set(Zp(e), {
                        callback: t,
                        originalName: e
                    })
                }
                create(e) {
                    if (!this.has(e))
                        throw new U("componentfactory-item-missing",this,{
                            name: e
                        });
                    return this._components.get(Zp(e)).callback(this.editor.locale)
                }
                has(e) {
                    return this._components.has(Zp(e))
                }
            }
            function Zp(s) {
                return String(s).toLowerCase()
            }
            var $C = u(3710)
              , sL = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()($C.A, sL),
            $C.A.locals;
            const qC = cl("px")
              , aL = {
                top: -99999,
                left: -99999,
                name: "arrowless",
                config: {
                    withArrow: !1
                }
            }
              , Pi = class Xs extends pe {
                constructor(e) {
                    super(e),
                    C(this, "content"),
                    C(this, "_pinWhenIsVisibleCallback");
                    const t = this.bindTemplate;
                    this.set("top", 0),
                    this.set("left", 0),
                    this.set("position", "arrow_nw"),
                    this.set("isVisible", !1),
                    this.set("withArrow", !0),
                    this.set("class", void 0),
                    this._pinWhenIsVisibleCallback = null,
                    this.content = this.createCollection(),
                    this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-balloon-panel", t.to("position", r => `ck-balloon-panel_${r}`), t.if("isVisible", "ck-balloon-panel_visible"), t.if("withArrow", "ck-balloon-panel_with-arrow"), t.to("class")],
                            style: {
                                top: t.to("top", qC),
                                left: t.to("left", qC)
                            }
                        },
                        children: this.content
                    })
                }
                show() {
                    this.isVisible = !0
                }
                hide() {
                    this.isVisible = !1
                }
                attachTo(e) {
                    this.show();
                    const t = Xs.defaultPositions
                      , r = Object.assign({}, {
                        element: this.element,
                        positions: [t.southArrowNorth, t.southArrowNorthMiddleWest, t.southArrowNorthMiddleEast, t.southArrowNorthWest, t.southArrowNorthEast, t.northArrowSouth, t.northArrowSouthMiddleWest, t.northArrowSouthMiddleEast, t.northArrowSouthWest, t.northArrowSouthEast, t.viewportStickyNorth],
                        limiter: w.document.body,
                        fitInViewport: !0
                    }, e)
                      , i = Xs._getOptimalPosition(r) || aL
                      , l = parseInt(i.left)
                      , d = parseInt(i.top)
                      , h = i.name
                      , m = i.config || {}
                      , {withArrow: g=!0} = m;
                    this.top = d,
                    this.left = l,
                    this.position = h,
                    this.withArrow = g
                }
                pin(e) {
                    this.unpin(),
                    this._pinWhenIsVisibleCallback = () => {
                        this.isVisible ? this._startPinning(e) : this._stopPinning()
                    }
                    ,
                    this._startPinning(e),
                    this.listenTo(this, "change:isVisible", this._pinWhenIsVisibleCallback)
                }
                unpin() {
                    this._pinWhenIsVisibleCallback && (this._stopPinning(),
                    this.stopListening(this, "change:isVisible", this._pinWhenIsVisibleCallback),
                    this._pinWhenIsVisibleCallback = null,
                    this.hide())
                }
                _startPinning(e) {
                    this.attachTo(e);
                    const t = Jp(e.target)
                      , r = e.limiter ? Jp(e.limiter) : w.document.body;
                    this.listenTo(w.document, "scroll", (i, l) => {
                        const d = l.target
                          , h = t && d.contains(t)
                          , m = r && d.contains(r);
                        !h && !m && t && r || this.attachTo(e)
                    }
                    , {
                        useCapture: !0
                    }),
                    this.listenTo(w.window, "resize", () => {
                        this.attachTo(e)
                    }
                    )
                }
                _stopPinning() {
                    this.stopListening(w.document, "scroll"),
                    this.stopListening(w.window, "resize")
                }
                static generatePositions(e={}) {
                    const {sideOffset: t=Xs.arrowSideOffset, heightOffset: r=Xs.arrowHeightOffset, stickyVerticalOffset: i=Xs.stickyVerticalOffset, config: l} = e;
                    return {
                        northWestArrowSouthWest: (m, g) => ({
                            top: d(m, g),
                            left: m.left - t,
                            name: "arrow_sw",
                            ...l && {
                                config: l
                            }
                        }),
                        northWestArrowSouthMiddleWest: (m, g) => ({
                            top: d(m, g),
                            left: m.left - .25 * g.width - t,
                            name: "arrow_smw",
                            ...l && {
                                config: l
                            }
                        }),
                        northWestArrowSouth: (m, g) => ({
                            top: d(m, g),
                            left: m.left - g.width / 2,
                            name: "arrow_s",
                            ...l && {
                                config: l
                            }
                        }),
                        northWestArrowSouthMiddleEast: (m, g) => ({
                            top: d(m, g),
                            left: m.left - .75 * g.width + t,
                            name: "arrow_sme",
                            ...l && {
                                config: l
                            }
                        }),
                        northWestArrowSouthEast: (m, g) => ({
                            top: d(m, g),
                            left: m.left - g.width + t,
                            name: "arrow_se",
                            ...l && {
                                config: l
                            }
                        }),
                        northArrowSouthWest: (m, g) => ({
                            top: d(m, g),
                            left: m.left + m.width / 2 - t,
                            name: "arrow_sw",
                            ...l && {
                                config: l
                            }
                        }),
                        northArrowSouthMiddleWest: (m, g) => ({
                            top: d(m, g),
                            left: m.left + m.width / 2 - .25 * g.width - t,
                            name: "arrow_smw",
                            ...l && {
                                config: l
                            }
                        }),
                        northArrowSouth: (m, g) => ({
                            top: d(m, g),
                            left: m.left + m.width / 2 - g.width / 2,
                            name: "arrow_s",
                            ...l && {
                                config: l
                            }
                        }),
                        northArrowSouthMiddleEast: (m, g) => ({
                            top: d(m, g),
                            left: m.left + m.width / 2 - .75 * g.width + t,
                            name: "arrow_sme",
                            ...l && {
                                config: l
                            }
                        }),
                        northArrowSouthEast: (m, g) => ({
                            top: d(m, g),
                            left: m.left + m.width / 2 - g.width + t,
                            name: "arrow_se",
                            ...l && {
                                config: l
                            }
                        }),
                        northEastArrowSouthWest: (m, g) => ({
                            top: d(m, g),
                            left: m.right - t,
                            name: "arrow_sw",
                            ...l && {
                                config: l
                            }
                        }),
                        northEastArrowSouthMiddleWest: (m, g) => ({
                            top: d(m, g),
                            left: m.right - .25 * g.width - t,
                            name: "arrow_smw",
                            ...l && {
                                config: l
                            }
                        }),
                        northEastArrowSouth: (m, g) => ({
                            top: d(m, g),
                            left: m.right - g.width / 2,
                            name: "arrow_s",
                            ...l && {
                                config: l
                            }
                        }),
                        northEastArrowSouthMiddleEast: (m, g) => ({
                            top: d(m, g),
                            left: m.right - .75 * g.width + t,
                            name: "arrow_sme",
                            ...l && {
                                config: l
                            }
                        }),
                        northEastArrowSouthEast: (m, g) => ({
                            top: d(m, g),
                            left: m.right - g.width + t,
                            name: "arrow_se",
                            ...l && {
                                config: l
                            }
                        }),
                        southWestArrowNorthWest: m => ({
                            top: h(m),
                            left: m.left - t,
                            name: "arrow_nw",
                            ...l && {
                                config: l
                            }
                        }),
                        southWestArrowNorthMiddleWest: (m, g) => ({
                            top: h(m),
                            left: m.left - .25 * g.width - t,
                            name: "arrow_nmw",
                            ...l && {
                                config: l
                            }
                        }),
                        southWestArrowNorth: (m, g) => ({
                            top: h(m),
                            left: m.left - g.width / 2,
                            name: "arrow_n",
                            ...l && {
                                config: l
                            }
                        }),
                        southWestArrowNorthMiddleEast: (m, g) => ({
                            top: h(m),
                            left: m.left - .75 * g.width + t,
                            name: "arrow_nme",
                            ...l && {
                                config: l
                            }
                        }),
                        southWestArrowNorthEast: (m, g) => ({
                            top: h(m),
                            left: m.left - g.width + t,
                            name: "arrow_ne",
                            ...l && {
                                config: l
                            }
                        }),
                        southArrowNorthWest: m => ({
                            top: h(m),
                            left: m.left + m.width / 2 - t,
                            name: "arrow_nw",
                            ...l && {
                                config: l
                            }
                        }),
                        southArrowNorthMiddleWest: (m, g) => ({
                            top: h(m),
                            left: m.left + m.width / 2 - .25 * g.width - t,
                            name: "arrow_nmw",
                            ...l && {
                                config: l
                            }
                        }),
                        southArrowNorth: (m, g) => ({
                            top: h(m),
                            left: m.left + m.width / 2 - g.width / 2,
                            name: "arrow_n",
                            ...l && {
                                config: l
                            }
                        }),
                        southArrowNorthMiddleEast: (m, g) => ({
                            top: h(m),
                            left: m.left + m.width / 2 - .75 * g.width + t,
                            name: "arrow_nme",
                            ...l && {
                                config: l
                            }
                        }),
                        southArrowNorthEast: (m, g) => ({
                            top: h(m),
                            left: m.left + m.width / 2 - g.width + t,
                            name: "arrow_ne",
                            ...l && {
                                config: l
                            }
                        }),
                        southEastArrowNorthWest: m => ({
                            top: h(m),
                            left: m.right - t,
                            name: "arrow_nw",
                            ...l && {
                                config: l
                            }
                        }),
                        southEastArrowNorthMiddleWest: (m, g) => ({
                            top: h(m),
                            left: m.right - .25 * g.width - t,
                            name: "arrow_nmw",
                            ...l && {
                                config: l
                            }
                        }),
                        southEastArrowNorth: (m, g) => ({
                            top: h(m),
                            left: m.right - g.width / 2,
                            name: "arrow_n",
                            ...l && {
                                config: l
                            }
                        }),
                        southEastArrowNorthMiddleEast: (m, g) => ({
                            top: h(m),
                            left: m.right - .75 * g.width + t,
                            name: "arrow_nme",
                            ...l && {
                                config: l
                            }
                        }),
                        southEastArrowNorthEast: (m, g) => ({
                            top: h(m),
                            left: m.right - g.width + t,
                            name: "arrow_ne",
                            ...l && {
                                config: l
                            }
                        }),
                        westArrowEast: (m, g) => ({
                            top: m.top + m.height / 2 - g.height / 2,
                            left: m.left - g.width - r,
                            name: "arrow_e",
                            ...l && {
                                config: l
                            }
                        }),
                        eastArrowWest: (m, g) => ({
                            top: m.top + m.height / 2 - g.height / 2,
                            left: m.right + r,
                            name: "arrow_w",
                            ...l && {
                                config: l
                            }
                        }),
                        viewportStickyNorth: (m, g, b, v) => {
                            const x = v || b;
                            return m.getIntersection(x) ? x.height - m.height > i ? null : {
                                top: x.top + i,
                                left: m.left + m.width / 2 - g.width / 2,
                                name: "arrowless",
                                config: {
                                    withArrow: !1,
                                    ...l
                                }
                            } : null
                        }
                    };
                    function d(m, g) {
                        return m.top - g.height - r
                    }
                    function h(m) {
                        return m.bottom + r
                    }
                }
            }
            ;
            C(Pi, "arrowSideOffset", 25),
            C(Pi, "arrowHeightOffset", 10),
            C(Pi, "stickyVerticalOffset", 20),
            C(Pi, "_getOptimalPosition", Km),
            C(Pi, "defaultPositions", Pi.generatePositions());
            let js = Pi;
            function Jp(s) {
                return Ci(s) ? s : Cd(s) ? s.commonAncestorContainer : typeof s == "function" ? Jp(s()) : null
            }
            var GC = u(9205)
              , lL = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(GC.A, lL),
            GC.A.locals;
            const KC = "ck-tooltip"
              , ou = class go extends qo() {
                constructor(e) {
                    if (super(),
                    C(this, "tooltipTextView"),
                    C(this, "balloonPanelView"),
                    C(this, "_currentElementWithTooltip", null),
                    C(this, "_currentTooltipPosition", null),
                    C(this, "_resizeObserver", null),
                    C(this, "_mutationObserver", null),
                    C(this, "_pinTooltipDebounced"),
                    C(this, "_unpinTooltipDebounced"),
                    C(this, "_watchdogExcluded"),
                    go._editors.add(e),
                    go._instance)
                        return go._instance;
                    go._instance = this,
                    this.tooltipTextView = new pe(e.locale),
                    this.tooltipTextView.set("text", ""),
                    this.tooltipTextView.setTemplate({
                        tag: "span",
                        attributes: {
                            class: ["ck", "ck-tooltip__text"]
                        },
                        children: [{
                            text: this.tooltipTextView.bindTemplate.to("text")
                        }]
                    }),
                    this.balloonPanelView = new js(e.locale),
                    this.balloonPanelView.class = KC,
                    this.balloonPanelView.content.add(this.tooltipTextView),
                    this._mutationObserver = function(t) {
                        const r = new MutationObserver( () => {
                            t()
                        }
                        );
                        return {
                            attach(i) {
                                r.observe(i, {
                                    attributes: !0,
                                    attributeFilter: ["data-cke-tooltip-text", "data-cke-tooltip-position"]
                                })
                            },
                            detach() {
                                r.disconnect()
                            }
                        }
                    }( () => {
                        this._updateTooltipPosition()
                    }
                    ),
                    this._pinTooltipDebounced = Ts(this._pinTooltip, 600),
                    this._unpinTooltipDebounced = Ts(this._unpinTooltip, 400),
                    this.listenTo(w.document, "keydown", this._onKeyDown.bind(this), {
                        useCapture: !0
                    }),
                    this.listenTo(w.document, "mouseenter", this._onEnterOrFocus.bind(this), {
                        useCapture: !0
                    }),
                    this.listenTo(w.document, "mouseleave", this._onLeaveOrBlur.bind(this), {
                        useCapture: !0
                    }),
                    this.listenTo(w.document, "focus", this._onEnterOrFocus.bind(this), {
                        useCapture: !0
                    }),
                    this.listenTo(w.document, "blur", this._onLeaveOrBlur.bind(this), {
                        useCapture: !0
                    }),
                    this.listenTo(w.document, "scroll", this._onScroll.bind(this), {
                        useCapture: !0
                    }),
                    this._watchdogExcluded = !0
                }
                destroy(e) {
                    const t = e.ui.view && e.ui.view.body;
                    go._editors.delete(e),
                    this.stopListening(e.ui),
                    t && t.has(this.balloonPanelView) && t.remove(this.balloonPanelView),
                    go._editors.size || (this._unpinTooltip(),
                    this.balloonPanelView.destroy(),
                    this.stopListening(),
                    go._instance = null)
                }
                static getPositioningFunctions(e) {
                    const t = go.defaultBalloonPositions;
                    return {
                        s: [t.southArrowNorth, t.southArrowNorthEast, t.southArrowNorthWest],
                        n: [t.northArrowSouth],
                        e: [t.eastArrowWest],
                        w: [t.westArrowEast],
                        sw: [t.southArrowNorthEast],
                        se: [t.southArrowNorthWest]
                    }[e]
                }
                _onKeyDown(e, t) {
                    t.key === "Escape" && this._currentElementWithTooltip && (this._unpinTooltip(),
                    t.stopPropagation())
                }
                _onEnterOrFocus(e, {target: t}) {
                    const r = Xp(t);
                    r ? r !== this._currentElementWithTooltip && (this._unpinTooltip(),
                    e.name !== "focus" || r.matches(":hover") ? this._pinTooltipDebounced(r, eg(r)) : this._pinTooltip(r, eg(r))) : e.name === "focus" && this._unpinTooltip()
                }
                _onLeaveOrBlur(e, {target: t, relatedTarget: r}) {
                    if (e.name === "mouseleave") {
                        if (!Ci(t))
                            return;
                        const i = this.balloonPanelView.element
                          , l = i && (i === r || i.contains(r))
                          , d = !l && t === i;
                        if (l)
                            return void this._unpinTooltipDebounced.cancel();
                        if (!d && this._currentElementWithTooltip && t !== this._currentElementWithTooltip)
                            return;
                        const h = Xp(t)
                          , m = Xp(r);
                        (d || h && h !== m) && this._unpinTooltipDebounced()
                    } else {
                        if (this._currentElementWithTooltip && t !== this._currentElementWithTooltip)
                            return;
                        this._unpinTooltipDebounced()
                    }
                }
                _onScroll(e, {target: t}) {
                    this._currentElementWithTooltip && (t.contains(this.balloonPanelView.element) && t.contains(this._currentElementWithTooltip) || this._unpinTooltip())
                }
                _pinTooltip(e, {text: t, position: r, cssClass: i}) {
                    this._unpinTooltip();
                    const l = zt(go._editors.values()).ui.view.body;
                    l.has(this.balloonPanelView) || l.add(this.balloonPanelView),
                    this.tooltipTextView.text = t,
                    this.balloonPanelView.class = [KC, i].filter(d => d).join(" "),
                    this.balloonPanelView.pin({
                        target: e,
                        positions: go.getPositioningFunctions(r)
                    }),
                    this._resizeObserver = new Gm(e, () => {
                        yi(e) || this._unpinTooltip()
                    }
                    ),
                    this._mutationObserver.attach(e);
                    for (const d of go._editors)
                        this.listenTo(d.ui, "update", this._updateTooltipPosition.bind(this), {
                            priority: "low"
                        });
                    this._currentElementWithTooltip = e,
                    this._currentTooltipPosition = r
                }
                _unpinTooltip() {
                    this._unpinTooltipDebounced.cancel(),
                    this._pinTooltipDebounced.cancel(),
                    this.balloonPanelView.unpin();
                    for (const e of go._editors)
                        this.stopListening(e.ui, "update");
                    this._currentElementWithTooltip = null,
                    this._currentTooltipPosition = null,
                    this.tooltipTextView.text = "",
                    this._resizeObserver && this._resizeObserver.destroy(),
                    this._mutationObserver.detach()
                }
                _updateTooltipPosition() {
                    if (!this._currentElementWithTooltip)
                        return;
                    const e = eg(this._currentElementWithTooltip);
                    yi(this._currentElementWithTooltip) && e.text ? this.balloonPanelView.pin({
                        target: this._currentElementWithTooltip,
                        positions: go.getPositioningFunctions(e.position)
                    }) : this._unpinTooltip()
                }
            }
            ;
            C(ou, "defaultBalloonPositions", js.generatePositions({
                heightOffset: 5,
                sideOffset: 13
            })),
            C(ou, "_editors", new Set),
            C(ou, "_instance", null);
            let cL = ou;
            function Xp(s) {
                return Ci(s) ? s.closest("[data-cke-tooltip-text]:not([data-cke-tooltip-disabled])") : null
            }
            function eg(s) {
                return {
                    text: s.dataset.ckeTooltipText,
                    position: s.dataset.ckeTooltipPosition || "s",
                    cssClass: s.dataset.ckeTooltipClass || ""
                }
            }
            const dL = 50
              , uL = 350
              , hL = "Powered by";
            class mL extends qo() {
                constructor(e) {
                    super(),
                    C(this, "editor"),
                    C(this, "_balloonView"),
                    C(this, "_showBalloonThrottled"),
                    C(this, "_lastFocusedEditableElement"),
                    this.editor = e,
                    this._balloonView = null,
                    this._lastFocusedEditableElement = null,
                    this._showBalloonThrottled = Yd(this._showBalloon.bind(this), 50, {
                        leading: !0
                    }),
                    e.on("ready", this._handleEditorReady.bind(this))
                }
                destroy() {
                    const e = this._balloonView;
                    e && (e.unpin(),
                    this._balloonView = null),
                    this._showBalloonThrottled.cancel(),
                    this.stopListening()
                }
                _handleEditorReady() {
                    const e = this.editor;
                    (e.config.get("ui.poweredBy.forceVisible") || function(t) {
                        function r(T) {
                            return T.length >= 40 && T.length <= 255 ? "VALID" : "INVALID"
                        }
                        if (!t)
                            return "INVALID";
                        let i = "";
                        try {
                            i = atob(t)
                        } catch {
                            return "INVALID"
                        }
                        const l = i.split("-")
                          , d = l[0]
                          , h = l[1];
                        if (!h)
                            return r(t);
                        try {
                            atob(h)
                        } catch {
                            try {
                                if (atob(d),
                                !atob(d).length)
                                    return r(t)
                            } catch {
                                return r(t)
                            }
                        }
                        if (d.length < 40 || d.length > 255)
                            return "INVALID";
                        let m = "";
                        try {
                            atob(d),
                            m = atob(h)
                        } catch {
                            return "INVALID"
                        }
                        if (m.length !== 8)
                            return "INVALID";
                        const g = Number(m.substring(0, 4))
                          , b = Number(m.substring(4, 6)) - 1
                          , v = Number(m.substring(6, 8))
                          , x = new Date(g,b,v);
                        return x < Ye || isNaN(Number(x)) ? "INVALID" : "VALID"
                    }(e.config.get("licenseKey")) !== "VALID") && e.ui.view && (e.ui.focusTracker.on("change:isFocused", (t, r, i) => {
                        this._updateLastFocusedEditableElement(),
                        i ? this._showBalloon() : this._hideBalloon()
                    }
                    ),
                    e.ui.focusTracker.on("change:focusedElement", (t, r, i) => {
                        this._updateLastFocusedEditableElement(),
                        i && this._showBalloon()
                    }
                    ),
                    e.ui.on("update", () => {
                        this._showBalloonThrottled()
                    }
                    ))
                }
                _createBalloonView() {
                    const e = this.editor
                      , t = this._balloonView = new js
                      , r = QC(e)
                      , i = new pL(e.locale,r.label);
                    t.content.add(i),
                    t.set({
                        class: "ck-powered-by-balloon"
                    }),
                    e.ui.view.body.add(t),
                    e.ui.focusTracker.add(t.element),
                    this._balloonView = t
                }
                _showBalloon() {
                    if (!this._lastFocusedEditableElement)
                        return;
                    const e = function(t, r) {
                        const i = QC(t)
                          , l = i.side === "right" ? function(d, h) {
                            return YC(d, h, (m, g) => m.left + m.width - g.width - h.horizontalOffset)
                        }(r, i) : function(d, h) {
                            return YC(d, h, m => m.left + h.horizontalOffset)
                        }(r, i);
                        return {
                            target: r,
                            positions: [l]
                        }
                    }(this.editor, this._lastFocusedEditableElement);
                    e && (this._balloonView || this._createBalloonView(),
                    this._balloonView.pin(e))
                }
                _hideBalloon() {
                    this._balloonView && this._balloonView.unpin()
                }
                _updateLastFocusedEditableElement() {
                    const e = this.editor
                      , t = e.ui.focusTracker.isFocused
                      , r = e.ui.focusTracker.focusedElement;
                    if (!t || !r)
                        return void (this._lastFocusedEditableElement = null);
                    const i = Array.from(e.ui.getEditableElementsNames()).map(l => e.ui.getEditableElement(l));
                    i.includes(r) ? this._lastFocusedEditableElement = r : this._lastFocusedEditableElement = i[0]
                }
            }
            class pL extends pe {
                constructor(e, t) {
                    super(e);
                    const r = new Ni
                      , i = this.bindTemplate;
                    r.set({
                        content: `<svg xmlns="http://www.w3.org/2000/svg" width="53" height="10" viewBox="0 0 53 10"><path fill="#1C2331" d="M31.724 1.492a15.139 15.139 0 0 0 .045 1.16 2.434 2.434 0 0 0-.687-.34 3.68 3.68 0 0 0-1.103-.166 2.332 2.332 0 0 0-1.14.255 1.549 1.549 0 0 0-.686.87c-.15.41-.225.98-.225 1.712 0 .939.148 1.659.444 2.161.297.503.792.754 1.487.754.452.015.9-.094 1.294-.316.296-.174.557-.4.771-.669l.14.852h1.282V.007h-1.623v1.485ZM31 6.496a1.77 1.77 0 0 1-.494.061.964.964 0 0 1-.521-.127.758.758 0 0 1-.296-.466 3.984 3.984 0 0 1-.093-.992 4.208 4.208 0 0 1 .098-1.052.753.753 0 0 1 .307-.477 1.08 1.08 0 0 1 .55-.122c.233-.004.466.026.69.089l.483.144v2.553c-.11.076-.213.143-.307.2a1.73 1.73 0 0 1-.417.189ZM35.68 0l-.702.004c-.322.002-.482.168-.48.497l.004.581c.002.33.164.493.486.49l.702-.004c.322-.002.481-.167.48-.496L36.165.49c-.002-.33-.164-.493-.486-.491ZM36.145 2.313l-1.612.01.034 5.482 1.613-.01-.035-5.482ZM39.623.79 37.989.8 38 2.306l-.946.056.006 1.009.949-.006.024 2.983c.003.476.143.844.419 1.106.275.26.658.39 1.148.387.132 0 .293-.01.483-.03.19-.02.38-.046.57-.08.163-.028.324-.068.482-.119l-.183-1.095-.702.004a.664.664 0 0 1-.456-.123.553.553 0 0 1-.14-.422l-.016-2.621 1.513-.01-.006-1.064-1.514.01-.01-1.503ZM46.226 2.388c-.41-.184-.956-.274-1.636-.27-.673.004-1.215.101-1.627.29-.402.179-.72.505-.888.91-.18.419-.268.979-.264 1.68.004.688.1 1.24.285 1.655.172.404.495.724.9.894.414.18.957.268 1.63.264.68-.004 1.224-.099 1.632-.284.4-.176.714-.501.878-.905.176-.418.263-.971.258-1.658-.004-.702-.097-1.261-.28-1.677a1.696 1.696 0 0 0-.888-.9Zm-.613 3.607a.77.77 0 0 1-.337.501 1.649 1.649 0 0 1-1.317.009.776.776 0 0 1-.343-.497 4.066 4.066 0 0 1-.105-1.02 4.136 4.136 0 0 1 .092-1.03.786.786 0 0 1 .337-.507 1.59 1.59 0 0 1 1.316-.008.79.79 0 0 1 .344.502c.078.337.113.683.105 1.03.012.343-.019.685-.092 1.02ZM52.114 2.07a2.67 2.67 0 0 0-1.128.278c-.39.191-.752.437-1.072.73l-.157-.846-1.273.008.036 5.572 1.623-.01-.024-3.78c.35-.124.646-.22.887-.286.26-.075.53-.114.8-.118l.45-.003.144-1.546-.286.001ZM22.083 7.426l-1.576-2.532a2.137 2.137 0 0 0-.172-.253 1.95 1.95 0 0 0-.304-.29.138.138 0 0 1 .042-.04 1.7 1.7 0 0 0 .328-.374l1.75-2.71c.01-.015.025-.028.024-.048-.01-.01-.021-.007-.031-.007L20.49 1.17a.078.078 0 0 0-.075.045l-.868 1.384c-.23.366-.46.732-.688 1.099a.108.108 0 0 1-.112.06c-.098-.005-.196-.001-.294-.002-.018 0-.038.006-.055-.007.002-.02.002-.039.005-.058a4.6 4.6 0 0 0 .046-.701V1.203c0-.02-.009-.032-.03-.03h-.033L16.93 1.17c-.084 0-.073-.01-.073.076v6.491c-.001.018.006.028.025.027h1.494c.083 0 .072.007.072-.071v-2.19c0-.055-.003-.11-.004-.166a3.366 3.366 0 0 0-.05-.417h.06c.104 0 .209.002.313-.002a.082.082 0 0 1 .084.05c.535.913 1.07 1.824 1.607 2.736a.104.104 0 0 0 .103.062c.554-.003 1.107-.002 1.66-.002l.069-.003-.019-.032-.188-.304ZM27.112 6.555c-.005-.08-.004-.08-.082-.08h-2.414c-.053 0-.106-.003-.159-.011a.279.279 0 0 1-.246-.209.558.558 0 0 1-.022-.15c0-.382 0-.762-.002-1.143 0-.032.007-.049.042-.044h2.504c.029.003.037-.012.034-.038V3.814c0-.089.013-.078-.076-.078h-2.44c-.07 0-.062.003-.062-.06v-.837c0-.047.004-.093.013-.14a.283.283 0 0 1 .241-.246.717.717 0 0 1 .146-.011h2.484c.024.002.035-.009.036-.033l.003-.038.03-.496c.01-.183.024-.365.034-.548.005-.085.003-.087-.082-.094-.218-.018-.437-.038-.655-.05a17.845 17.845 0 0 0-.657-.026 72.994 72.994 0 0 0-1.756-.016 1.7 1.7 0 0 0-.471.064 1.286 1.286 0 0 0-.817.655c-.099.196-.149.413-.145.633v3.875c0 .072.003.144.011.216a1.27 1.27 0 0 0 .711 1.029c.228.113.48.167.734.158.757-.005 1.515.002 2.272-.042.274-.016.548-.034.82-.053.03-.002.043-.008.04-.041-.008-.104-.012-.208-.019-.312a69.964 69.964 0 0 1-.05-.768ZM16.14 7.415l-.127-1.075c-.004-.03-.014-.04-.044-.037a13.125 13.125 0 0 1-.998.073c-.336.01-.672.02-1.008.016-.116-.001-.233-.014-.347-.039a.746.746 0 0 1-.45-.262c-.075-.1-.132-.211-.167-.33a3.324 3.324 0 0 1-.126-.773 9.113 9.113 0 0 1-.015-.749c0-.285.022-.57.065-.852.023-.158.066-.312.127-.46a.728.728 0 0 1 .518-.443 1.64 1.64 0 0 1 .397-.048c.628-.001 1.255.003 1.882.05.022.001.033-.006.036-.026l.003-.031.06-.55c.019-.177.036-.355.057-.532.004-.034-.005-.046-.04-.056a5.595 5.595 0 0 0-1.213-.21 10.783 10.783 0 0 0-.708-.02c-.24-.003-.48.01-.719.041a3.477 3.477 0 0 0-.625.14 1.912 1.912 0 0 0-.807.497c-.185.2-.33.433-.424.688a4.311 4.311 0 0 0-.24 1.096c-.031.286-.045.572-.042.86-.006.43.024.86.091 1.286.04.25.104.497.193.734.098.279.26.53.473.734.214.205.473.358.756.446.344.11.702.17 1.063.177a8.505 8.505 0 0 0 1.578-.083 6.11 6.11 0 0 0 .766-.18c.03-.008.047-.023.037-.057a.157.157 0 0 1-.003-.025Z"/><path fill="#AFE229" d="M6.016 6.69a1.592 1.592 0 0 0-.614.21c-.23.132-.422.32-.56.546-.044.072-.287.539-.287.539l-.836 1.528.009.006c.038.025.08.046.123.063.127.046.26.07.395.073.505.023 1.011-.007 1.517-.003.29.009.58.002.869-.022a.886.886 0 0 0 .395-.116.962.962 0 0 0 .312-.286c.056-.083.114-.163.164-.249.24-.408.48-.816.718-1.226.075-.128.148-.257.222-.386l.112-.192a1.07 1.07 0 0 0 .153-.518l-1.304.023s-1.258-.005-1.388.01Z"/><path fill="#771BFF" d="m2.848 9.044.76-1.39.184-.352c-.124-.067-.245-.14-.367-.21-.346-.204-.706-.384-1.045-.6a.984.984 0 0 1-.244-.207c-.108-.134-.136-.294-.144-.46-.021-.409-.002-.818-.009-1.227-.003-.195 0-.39.003-.585.004-.322.153-.553.427-.713l.833-.488c.22-.13.44-.257.662-.385.05-.029.105-.052.158-.077.272-.128.519-.047.76.085l.044.028c.123.06.242.125.358.196.318.178.635.357.952.537.095.056.187.117.275.184.194.144.254.35.266.578.016.284.007.569.006.853-.001.28.004.558 0 .838.592-.003 1.259 0 1.259 0l.723-.013c-.003-.292-.007-.584-.007-.876 0-.524.015-1.048-.016-1.571-.024-.42-.135-.8-.492-1.067a5.02 5.02 0 0 0-.506-.339A400.52 400.52 0 0 0 5.94.787C5.722.664 5.513.524 5.282.423 5.255.406 5.228.388 5.2.373 4.758.126 4.305-.026 3.807.21c-.097.046-.197.087-.29.14A699.896 699.896 0 0 0 .783 1.948c-.501.294-.773.717-.778 1.31-.004.36-.009.718-.001 1.077.016.754-.017 1.508.024 2.261.016.304.07.6.269.848.127.15.279.28.448.382.622.4 1.283.734 1.92 1.11l.183.109Z"/></svg>
`,
                        isColorInherited: !1
                    }),
                    r.extendTemplate({
                        attributes: {
                            style: {
                                width: "53px",
                                height: "10px"
                            }
                        }
                    }),
                    this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-powered-by"],
                            "aria-hidden": !0
                        },
                        children: [{
                            tag: "a",
                            attributes: {
                                href: "https://ckeditor.com/?utm_source=ckeditor&utm_medium=referral&utm_campaign=701Dn000000hVgmIAE_powered_by_ckeditor_logo",
                                target: "_blank",
                                tabindex: "-1"
                            },
                            children: [...t ? [{
                                tag: "span",
                                attributes: {
                                    class: ["ck", "ck-powered-by__label"]
                                },
                                children: [t]
                            }] : [], r],
                            on: {
                                dragstart: i.to(l => l.preventDefault())
                            }
                        }]
                    })
                }
            }
            function YC(s, e, t) {
                return (r, i) => {
                    const l = new De(s);
                    if (l.width < uL || l.height < dL)
                        return null;
                    let d;
                    d = e.position === "inside" ? l.bottom - i.height : l.bottom - i.height / 2,
                    d -= e.verticalOffset;
                    const h = t(l, i)
                      , m = r.clone().moveTo(h, d).getIntersection(i.clone().moveTo(h, d)).getVisible();
                    return !m || m.getArea() < i.getArea() ? null : {
                        top: d,
                        left: h,
                        name: `position_${e.position}-side_${e.side}`,
                        config: {
                            withArrow: !1
                        }
                    }
                }
            }
            function QC(s) {
                const e = s.config.get("ui.poweredBy")
                  , t = e && e.position || "border";
                return {
                    position: t,
                    label: hL,
                    verticalOffset: t === "inside" ? 5 : 0,
                    horizontalOffset: 5,
                    side: s.locale.contentLanguageDirection === "ltr" ? "right" : "left",
                    ...e
                }
            }
            var ZC = u(1801)
              , gL = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(ZC.A, gL),
            ZC.A.locals;
            const JC = {
                POLITE: "polite",
                ASSERTIVE: "assertive"
            };
            class fL {
                constructor(e) {
                    C(this, "editor"),
                    C(this, "view"),
                    this.editor = e,
                    e.once("ready", () => {
                        for (const t of Object.values(JC))
                            this.announce("", t)
                    }
                    )
                }
                announce(e, t=JC.POLITE) {
                    const r = this.editor;
                    if (!r.ui.view)
                        return;
                    this.view || (this.view = new kL(r.locale),
                    r.ui.view.body.add(this.view));
                    const {politeness: i, isUnsafeHTML: l} = typeof t == "string" ? {
                        politeness: t
                    } : t;
                    let d = this.view.regionViews.find(h => h.politeness === i);
                    d || (d = new bL(r,i),
                    this.view.regionViews.add(d)),
                    d.announce({
                        announcement: e,
                        isUnsafeHTML: l
                    })
                }
            }
            class kL extends pe {
                constructor(e) {
                    super(e),
                    C(this, "regionViews"),
                    this.regionViews = this.createCollection(),
                    this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-aria-live-announcer"]
                        },
                        children: this.regionViews
                    })
                }
            }
            class bL extends pe {
                constructor(e, t) {
                    super(e.locale),
                    C(this, "politeness"),
                    C(this, "_domConverter"),
                    C(this, "_pruneAnnouncementsInterval"),
                    this.setTemplate({
                        tag: "div",
                        attributes: {
                            role: "region",
                            "aria-live": t,
                            "aria-relevant": "additions"
                        },
                        children: [{
                            tag: "ul",
                            attributes: {
                                class: ["ck", "ck-aria-live-region-list"]
                            }
                        }]
                    }),
                    e.on("destroy", () => {
                        this._pruneAnnouncementsInterval !== null && (clearInterval(this._pruneAnnouncementsInterval),
                        this._pruneAnnouncementsInterval = null)
                    }
                    ),
                    this.politeness = t,
                    this._domConverter = e.data.htmlProcessor.domConverter,
                    this._pruneAnnouncementsInterval = setInterval( () => {
                        this.element && this._listElement.firstChild && this._listElement.firstChild.remove()
                    }
                    , 5e3)
                }
                announce({announcement: e, isUnsafeHTML: t}) {
                    if (!e.trim().length)
                        return;
                    const r = document.createElement("li");
                    t ? this._domConverter.setContentOf(r, e) : r.innerText = e,
                    this._listElement.appendChild(r)
                }
                get _listElement() {
                    return this.element.querySelector("ul")
                }
            }
            class wL extends ye() {
                constructor(e) {
                    super(),
                    C(this, "editor"),
                    C(this, "componentFactory"),
                    C(this, "focusTracker"),
                    C(this, "tooltipManager"),
                    C(this, "poweredBy"),
                    C(this, "ariaLiveAnnouncer"),
                    C(this, "isReady", !1),
                    C(this, "_editableElementsMap", new Map),
                    C(this, "_focusableToolbarDefinitions", []);
                    const t = e.editing.view;
                    this.editor = e,
                    this.componentFactory = new iL(e),
                    this.focusTracker = new Jt,
                    this.tooltipManager = new cL(e),
                    this.poweredBy = new mL(e),
                    this.ariaLiveAnnouncer = new fL(e),
                    this.set("viewportOffset", this._readViewportOffsetFromConfig()),
                    this.once("ready", () => {
                        this.isReady = !0
                    }
                    ),
                    this.listenTo(t.document, "layoutChanged", this.update.bind(this)),
                    this.listenTo(t, "scrollToTheSelection", this._handleScrollToTheSelection.bind(this)),
                    this._initFocusTracking()
                }
                get element() {
                    return null
                }
                update() {
                    this.fire("update")
                }
                destroy() {
                    this.stopListening(),
                    this.focusTracker.destroy(),
                    this.tooltipManager.destroy(this.editor),
                    this.poweredBy.destroy();
                    for (const e of this._editableElementsMap.values())
                        e.ckeditorInstance = null,
                        this.editor.keystrokes.stopListening(e);
                    this._editableElementsMap = new Map,
                    this._focusableToolbarDefinitions = []
                }
                setEditableElement(e, t) {
                    this._editableElementsMap.set(e, t),
                    t.ckeditorInstance || (t.ckeditorInstance = this.editor),
                    this.focusTracker.add(t);
                    const r = () => {
                        this.editor.editing.view.getDomRoot(e) || this.editor.keystrokes.listenTo(t)
                    }
                    ;
                    this.isReady ? r() : this.once("ready", r)
                }
                removeEditableElement(e) {
                    const t = this._editableElementsMap.get(e);
                    t && (this._editableElementsMap.delete(e),
                    this.editor.keystrokes.stopListening(t),
                    this.focusTracker.remove(t),
                    t.ckeditorInstance = null)
                }
                getEditableElement(e="main") {
                    return this._editableElementsMap.get(e)
                }
                getEditableElementsNames() {
                    return this._editableElementsMap.keys()
                }
                addToolbar(e, t={}) {
                    e.isRendered ? (this.focusTracker.add(e.element),
                    this.editor.keystrokes.listenTo(e.element)) : e.once("render", () => {
                        this.focusTracker.add(e.element),
                        this.editor.keystrokes.listenTo(e.element)
                    }
                    ),
                    this._focusableToolbarDefinitions.push({
                        toolbarView: e,
                        options: t
                    })
                }
                get _editableElements() {
                    return console.warn("editor-ui-deprecated-editable-elements: The EditorUI#_editableElements property has been deprecated and will be removed in the near future.", {
                        editorUI: this
                    }),
                    this._editableElementsMap
                }
                _readViewportOffsetFromConfig() {
                    const e = this.editor
                      , t = e.config.get("ui.viewportOffset");
                    if (t)
                        return t;
                    const r = e.config.get("toolbar.viewportTopOffset");
                    return r ? (console.warn("editor-ui-deprecated-viewport-offset-config: The `toolbar.vieportTopOffset` configuration option is deprecated. It will be removed from future CKEditor versions. Use `ui.viewportOffset.top` instead."),
                    {
                        top: r
                    }) : {
                        top: 0
                    }
                }
                _initFocusTracking() {
                    const e = this.editor
                      , t = e.editing.view;
                    let r, i;
                    e.keystrokes.set("Alt+F10", (l, d) => {
                        const h = this.focusTracker.focusedElement;
                        Array.from(this._editableElementsMap.values()).includes(h) && !Array.from(t.domRoots.values()).includes(h) && (r = h);
                        const m = this._getCurrentFocusedToolbarDefinition();
                        m && i || (i = this._getFocusableCandidateToolbarDefinitions());
                        for (let g = 0; g < i.length; g++) {
                            const b = i.shift();
                            if (i.push(b),
                            b !== m && this._focusFocusableCandidateToolbar(b)) {
                                m && m.options.afterBlur && m.options.afterBlur();
                                break
                            }
                        }
                        d()
                    }
                    ),
                    e.keystrokes.set("Esc", (l, d) => {
                        const h = this._getCurrentFocusedToolbarDefinition();
                        h && (r ? (r.focus(),
                        r = null) : e.editing.view.focus(),
                        h.options.afterBlur && h.options.afterBlur(),
                        d())
                    }
                    )
                }
                _getFocusableCandidateToolbarDefinitions() {
                    const e = [];
                    for (const t of this._focusableToolbarDefinitions) {
                        const {toolbarView: r, options: i} = t;
                        (yi(r.element) || i.beforeFocus) && e.push(t)
                    }
                    return e.sort( (t, r) => XC(t) - XC(r)),
                    e
                }
                _getCurrentFocusedToolbarDefinition() {
                    for (const e of this._focusableToolbarDefinitions)
                        if (e.toolbarView.element && e.toolbarView.element.contains(this.focusTracker.focusedElement))
                            return e;
                    return null
                }
                _focusFocusableCandidateToolbar(e) {
                    const {toolbarView: t, options: {beforeFocus: r}} = e;
                    return r && r(),
                    !!yi(t.element) && (t.focus(),
                    !0)
                }
                _handleScrollToTheSelection(e, t) {
                    const r = {
                        top: 0,
                        bottom: 0,
                        left: 0,
                        right: 0,
                        ...this.viewportOffset
                    };
                    t.viewportOffset.top += r.top,
                    t.viewportOffset.bottom += r.bottom,
                    t.viewportOffset.left += r.left,
                    t.viewportOffset.right += r.right
                }
            }
            function XC(s) {
                const {toolbarView: e, options: t} = s;
                let r = 10;
                return yi(e.element) && r--,
                t.isContextual && r--,
                r
            }
            var ey = u(1185)
              , AL = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(ey.A, AL),
            ey.A.locals;
            class vL extends pe {
                constructor(e) {
                    super(e),
                    C(this, "body"),
                    this.body = new Mj(e)
                }
                render() {
                    super.render(),
                    this.body.attachToDom()
                }
                destroy() {
                    return this.body.detachFromDom(),
                    super.destroy()
                }
            }
            class _L extends vL {
                constructor(e) {
                    super(e),
                    C(this, "top"),
                    C(this, "main"),
                    C(this, "_voiceLabelView"),
                    this.top = this.createCollection(),
                    this.main = this.createCollection(),
                    this._voiceLabelView = this._createVoiceLabel(),
                    this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-reset", "ck-editor", "ck-rounded-corners"],
                            role: "application",
                            dir: e.uiLanguageDirection,
                            lang: e.uiLanguage,
                            "aria-labelledby": this._voiceLabelView.id
                        },
                        children: [this._voiceLabelView, {
                            tag: "div",
                            attributes: {
                                class: ["ck", "ck-editor__top", "ck-reset_all"],
                                role: "presentation"
                            },
                            children: this.top
                        }, {
                            tag: "div",
                            attributes: {
                                class: ["ck", "ck-editor__main"],
                                role: "presentation"
                            },
                            children: this.main
                        }]
                    })
                }
                _createVoiceLabel() {
                    const e = this.t
                      , t = new Zd;
                    return t.text = e("Rich Text Editor"),
                    t.extendTemplate({
                        attributes: {
                            class: "ck-voice-label"
                        }
                    }),
                    t
                }
            }
            class CL extends pe {
                constructor(e, t, r) {
                    super(e),
                    C(this, "name", null),
                    C(this, "_editingView"),
                    C(this, "_editableElement"),
                    C(this, "_hasExternalElement"),
                    this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-content", "ck-editor__editable", "ck-rounded-corners"],
                            lang: e.contentLanguage,
                            dir: e.contentLanguageDirection
                        }
                    }),
                    this.set("isFocused", !1),
                    this._editableElement = r,
                    this._hasExternalElement = !!this._editableElement,
                    this._editingView = t
                }
                render() {
                    super.render(),
                    this._hasExternalElement ? this.template.apply(this.element = this._editableElement) : this._editableElement = this.element,
                    this.on("change:isFocused", () => this._updateIsFocusedClasses()),
                    this._updateIsFocusedClasses()
                }
                destroy() {
                    this._hasExternalElement && this.template.revert(this._editableElement),
                    super.destroy()
                }
                get hasExternalElement() {
                    return this._hasExternalElement
                }
                _updateIsFocusedClasses() {
                    const e = this._editingView;
                    function t(r) {
                        e.change(i => {
                            const l = e.document.getRoot(r.name);
                            i.addClass(r.isFocused ? "ck-focused" : "ck-blurred", l),
                            i.removeClass(r.isFocused ? "ck-blurred" : "ck-focused", l)
                        }
                        )
                    }
                    e.isRenderingInProgress ? function r(i) {
                        e.once("change:isRenderingInProgress", (l, d, h) => {
                            h ? r(i) : t(i)
                        }
                        )
                    }(this) : t(this)
                }
            }
            class yL extends CL {
                constructor(e, t, r, i={}) {
                    super(e, t, r),
                    C(this, "_generateLabel");
                    const l = e.t;
                    this.extendTemplate({
                        attributes: {
                            role: "textbox",
                            class: "ck-editor__editable_inline"
                        }
                    }),
                    this._generateLabel = i.label || ( () => l("Editor editing area: %0", this.name))
                }
                render() {
                    super.render();
                    const e = this._editingView;
                    e.change(t => {
                        const r = e.document.getRoot(this.name);
                        t.setAttribute("aria-label", this._generateLabel(this), r)
                    }
                    )
                }
            }
            class tg extends Md {
                static get pluginName() {
                    return "Notification"
                }
                init() {
                    this.on("show:warning", (e, t) => {
                        window.alert(t.message)
                    }
                    , {
                        priority: "lowest"
                    })
                }
                showSuccess(e, t={}) {
                    this._showNotification({
                        message: e,
                        type: "success",
                        namespace: t.namespace,
                        title: t.title
                    })
                }
                showInfo(e, t={}) {
                    this._showNotification({
                        message: e,
                        type: "info",
                        namespace: t.namespace,
                        title: t.title
                    })
                }
                showWarning(e, t={}) {
                    this._showNotification({
                        message: e,
                        type: "warning",
                        namespace: t.namespace,
                        title: t.title
                    })
                }
                _showNotification(e) {
                    const t = e.namespace ? `show:${e.type}:${e.namespace}` : `show:${e.type}`;
                    this.fire(t, {
                        message: e.message,
                        type: e.type,
                        title: e.title || ""
                    })
                }
            }
            class ty extends ye() {
                constructor(e, t) {
                    super(),
                    t && Zv(this, t),
                    e && this.set(e)
                }
            }
            var oy = u(991)
              , xL = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(oy.A, xL),
            oy.A.locals;
            var ry = u(5380)
              , EL = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(ry.A, EL),
            ry.A.locals;
            const ru = cl("px");
            class nu extends ie {
                constructor(e) {
                    super(e),
                    C(this, "positionLimiter"),
                    C(this, "visibleStack"),
                    C(this, "_viewToStack", new Map),
                    C(this, "_idToStack", new Map),
                    C(this, "_view", null),
                    C(this, "_rotatorView", null),
                    C(this, "_fakePanelsView", null),
                    this.positionLimiter = () => {
                        const t = this.editor.editing.view
                          , r = t.document.selection.editableElement;
                        return r ? t.domConverter.mapViewToDom(r.root) : null
                    }
                    ,
                    this.set("visibleView", null),
                    this.set("_numberOfStacks", 0),
                    this.set("_singleViewMode", !1)
                }
                static get pluginName() {
                    return "ContextualBalloon"
                }
                destroy() {
                    super.destroy(),
                    this._view && this._view.destroy(),
                    this._rotatorView && this._rotatorView.destroy(),
                    this._fakePanelsView && this._fakePanelsView.destroy()
                }
                get view() {
                    return this._view || this._createPanelView(),
                    this._view
                }
                hasView(e) {
                    return Array.from(this._viewToStack.keys()).includes(e)
                }
                add(e) {
                    if (this._view || this._createPanelView(),
                    this.hasView(e.view))
                        throw new U("contextualballoon-add-view-exist",[this, e]);
                    const t = e.stackId || "main";
                    if (!this._idToStack.has(t))
                        return this._idToStack.set(t, new Map([[e.view, e]])),
                        this._viewToStack.set(e.view, this._idToStack.get(t)),
                        this._numberOfStacks = this._idToStack.size,
                        void (this._visibleStack && !e.singleViewMode || this.showStack(t));
                    const r = this._idToStack.get(t);
                    e.singleViewMode && this.showStack(t),
                    r.set(e.view, e),
                    this._viewToStack.set(e.view, r),
                    r === this._visibleStack && this._showView(e)
                }
                remove(e) {
                    if (!this.hasView(e))
                        throw new U("contextualballoon-remove-view-not-exist",[this, e]);
                    const t = this._viewToStack.get(e);
                    this._singleViewMode && this.visibleView === e && (this._singleViewMode = !1),
                    this.visibleView === e && (t.size === 1 ? this._idToStack.size > 1 ? this._showNextStack() : (this.view.hide(),
                    this.visibleView = null,
                    this._rotatorView.hideView()) : this._showView(Array.from(t.values())[t.size - 2])),
                    t.size === 1 ? (this._idToStack.delete(this._getStackId(t)),
                    this._numberOfStacks = this._idToStack.size) : t.delete(e),
                    this._viewToStack.delete(e)
                }
                updatePosition(e) {
                    e && (this._visibleStack.get(this.visibleView).position = e),
                    this.view.pin(this._getBalloonPosition()),
                    this._fakePanelsView.updatePosition()
                }
                showStack(e) {
                    this.visibleStack = e;
                    const t = this._idToStack.get(e);
                    if (!t)
                        throw new U("contextualballoon-showstack-stack-not-exist",this);
                    this._visibleStack !== t && this._showView(Array.from(t.values()).pop())
                }
                _createPanelView() {
                    this._view = new js(this.editor.locale),
                    this.editor.ui.view.body.add(this._view),
                    this.editor.ui.focusTracker.add(this._view.element),
                    this._rotatorView = this._createRotatorView(),
                    this._fakePanelsView = this._createFakePanelsView()
                }
                get _visibleStack() {
                    return this._viewToStack.get(this.visibleView)
                }
                _getStackId(e) {
                    return Array.from(this._idToStack.entries()).find(t => t[1] === e)[0]
                }
                _showNextStack() {
                    const e = Array.from(this._idToStack.values());
                    let t = e.indexOf(this._visibleStack) + 1;
                    e[t] || (t = 0),
                    this.showStack(this._getStackId(e[t]))
                }
                _showPrevStack() {
                    const e = Array.from(this._idToStack.values());
                    let t = e.indexOf(this._visibleStack) - 1;
                    e[t] || (t = e.length - 1),
                    this.showStack(this._getStackId(e[t]))
                }
                _createRotatorView() {
                    const e = new SL(this.editor.locale)
                      , t = this.editor.locale.t;
                    return this.view.content.add(e),
                    e.bind("isNavigationVisible").to(this, "_numberOfStacks", this, "_singleViewMode", (r, i) => !i && r > 1),
                    e.on("change:isNavigationVisible", () => this.updatePosition(), {
                        priority: "low"
                    }),
                    e.bind("counter").to(this, "visibleView", this, "_numberOfStacks", (r, i) => {
                        if (i < 2)
                            return "";
                        const l = Array.from(this._idToStack.values()).indexOf(this._visibleStack) + 1;
                        return t("%0 of %1", [l, i])
                    }
                    ),
                    e.buttonNextView.on("execute", () => {
                        e.focusTracker.isFocused && this.editor.editing.view.focus(),
                        this._showNextStack()
                    }
                    ),
                    e.buttonPrevView.on("execute", () => {
                        e.focusTracker.isFocused && this.editor.editing.view.focus(),
                        this._showPrevStack()
                    }
                    ),
                    e
                }
                _createFakePanelsView() {
                    const e = new DL(this.editor.locale,this.view);
                    return e.bind("numberOfPanels").to(this, "_numberOfStacks", this, "_singleViewMode", (t, r) => !r && t >= 2 ? Math.min(t - 1, 2) : 0),
                    e.listenTo(this.view, "change:top", () => e.updatePosition()),
                    e.listenTo(this.view, "change:left", () => e.updatePosition()),
                    this.editor.ui.view.body.add(e),
                    e
                }
                _showView({view: e, balloonClassName: t="", withArrow: r=!0, singleViewMode: i=!1}) {
                    this.view.class = t,
                    this.view.withArrow = r,
                    this._rotatorView.showView(e),
                    this.visibleView = e,
                    this.view.pin(this._getBalloonPosition()),
                    this._fakePanelsView.updatePosition(),
                    i && (this._singleViewMode = !0)
                }
                _getBalloonPosition() {
                    let e = Array.from(this._visibleStack.values()).pop().position;
                    return e && (e.limiter || (e = Object.assign({}, e, {
                        limiter: this.positionLimiter
                    })),
                    e = Object.assign({}, e, {
                        viewportOffsetConfig: this.editor.ui.viewportOffset
                    })),
                    e
                }
            }
            class SL extends pe {
                constructor(e) {
                    super(e),
                    C(this, "focusTracker"),
                    C(this, "buttonPrevView"),
                    C(this, "buttonNextView"),
                    C(this, "content");
                    const t = e.t
                      , r = this.bindTemplate;
                    this.set("isNavigationVisible", !0),
                    this.focusTracker = new Jt,
                    this.buttonPrevView = this._createButtonView(t("Previous"), he.previousArrow),
                    this.buttonNextView = this._createButtonView(t("Next"), he.nextArrow),
                    this.content = this.createCollection(),
                    this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-balloon-rotator"],
                            "z-index": "-1"
                        },
                        children: [{
                            tag: "div",
                            attributes: {
                                class: ["ck-balloon-rotator__navigation", r.to("isNavigationVisible", i => i ? "" : "ck-hidden")]
                            },
                            children: [this.buttonPrevView, {
                                tag: "span",
                                attributes: {
                                    class: ["ck-balloon-rotator__counter"]
                                },
                                children: [{
                                    text: r.to("counter")
                                }]
                            }, this.buttonNextView]
                        }, {
                            tag: "div",
                            attributes: {
                                class: "ck-balloon-rotator__content"
                            },
                            children: this.content
                        }]
                    })
                }
                render() {
                    super.render(),
                    this.focusTracker.add(this.element)
                }
                destroy() {
                    super.destroy(),
                    this.focusTracker.destroy()
                }
                showView(e) {
                    this.hideView(),
                    this.content.add(e)
                }
                hideView() {
                    this.content.clear()
                }
                _createButtonView(e, t) {
                    const r = new Te(this.locale);
                    return r.set({
                        label: e,
                        icon: t,
                        tooltip: !0
                    }),
                    r
                }
            }
            class DL extends pe {
                constructor(e, t) {
                    super(e),
                    C(this, "content"),
                    C(this, "_balloonPanelView");
                    const r = this.bindTemplate;
                    this.set("top", 0),
                    this.set("left", 0),
                    this.set("height", 0),
                    this.set("width", 0),
                    this.set("numberOfPanels", 0),
                    this.content = this.createCollection(),
                    this._balloonPanelView = t,
                    this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck-fake-panel", r.to("numberOfPanels", i => i ? "" : "ck-hidden")],
                            style: {
                                top: r.to("top", ru),
                                left: r.to("left", ru),
                                width: r.to("width", ru),
                                height: r.to("height", ru)
                            }
                        },
                        children: this.content
                    }),
                    this.on("change:numberOfPanels", (i, l, d, h) => {
                        d > h ? this._addPanels(d - h) : this._removePanels(h - d),
                        this.updatePosition()
                    }
                    )
                }
                _addPanels(e) {
                    for (; e--; ) {
                        const t = new pe;
                        t.setTemplate({
                            tag: "div"
                        }),
                        this.content.add(t),
                        this.registerChild(t)
                    }
                }
                _removePanels(e) {
                    for (; e--; ) {
                        const t = this.content.last;
                        this.content.remove(t),
                        this.deregisterChild(t),
                        t.destroy()
                    }
                }
                updatePosition() {
                    if (this.numberOfPanels) {
                        const {top: e, left: t} = this._balloonPanelView
                          , {width: r, height: i} = new De(this._balloonPanelView.element);
                        Object.assign(this, {
                            top: e,
                            left: t,
                            width: r,
                            height: i
                        })
                    }
                }
            }
            var ny = u(8298)
              , TL = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(ny.A, TL),
            ny.A.locals;
            const Ls = cl("px");
            class IL extends pe {
                constructor(e) {
                    super(e),
                    C(this, "content"),
                    C(this, "contentPanelElement"),
                    C(this, "_contentPanelPlaceholder");
                    const t = this.bindTemplate;
                    this.set("isActive", !1),
                    this.set("isSticky", !1),
                    this.set("limiterElement", null),
                    this.set("limiterBottomOffset", 50),
                    this.set("viewportTopOffset", 0),
                    this.set("_marginLeft", null),
                    this.set("_isStickyToTheBottomOfLimiter", !1),
                    this.set("_stickyTopOffset", null),
                    this.set("_stickyBottomOffset", null),
                    this.content = this.createCollection(),
                    this._contentPanelPlaceholder = new hr({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-sticky-panel__placeholder"],
                            style: {
                                display: t.to("isSticky", r => r ? "block" : "none"),
                                height: t.to("isSticky", r => r ? Ls(this._contentPanelRect.height) : null)
                            }
                        }
                    }).render(),
                    this.contentPanelElement = new hr({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-sticky-panel__content", t.if("isSticky", "ck-sticky-panel__content_sticky"), t.if("_isStickyToTheBottomOfLimiter", "ck-sticky-panel__content_sticky_bottom-limit")],
                            style: {
                                width: t.to("isSticky", r => r ? Ls(this._contentPanelPlaceholder.getBoundingClientRect().width) : null),
                                top: t.to("_stickyTopOffset", r => r && Ls(r)),
                                bottom: t.to("_stickyBottomOffset", r => r && Ls(r)),
                                marginLeft: t.to("_marginLeft")
                            }
                        },
                        children: this.content
                    }).render(),
                    this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-sticky-panel"]
                        },
                        children: [this._contentPanelPlaceholder, this.contentPanelElement]
                    })
                }
                render() {
                    super.render(),
                    this.checkIfShouldBeSticky(),
                    this.listenTo(w.document, "scroll", () => {
                        this.checkIfShouldBeSticky()
                    }
                    , {
                        useCapture: !0
                    }),
                    this.listenTo(this, "change:isActive", () => {
                        this.checkIfShouldBeSticky()
                    }
                    )
                }
                checkIfShouldBeSticky() {
                    if (!this.limiterElement || !this.isActive)
                        return void this._unstick();
                    const e = new De(this.limiterElement);
                    let t = e.getVisible();
                    if (t) {
                        const r = new De(w.window);
                        r.top += this.viewportTopOffset,
                        r.height -= this.viewportTopOffset,
                        t = t.getIntersection(r)
                    }
                    if (t && e.top < t.top) {
                        const r = t.top;
                        if (r + this._contentPanelRect.height + this.limiterBottomOffset > t.bottom) {
                            const i = Math.max(e.bottom - t.bottom, 0) + this.limiterBottomOffset;
                            e.bottom - i > e.top + this._contentPanelRect.height ? this._stickToBottomOfLimiter(i) : this._unstick()
                        } else
                            this._contentPanelRect.height + this.limiterBottomOffset < e.height ? this._stickToTopOfAncestors(r) : this._unstick()
                    } else
                        this._unstick()
                }
                _stickToTopOfAncestors(e) {
                    this.isSticky = !0,
                    this._isStickyToTheBottomOfLimiter = !1,
                    this._stickyTopOffset = e,
                    this._stickyBottomOffset = null,
                    this._marginLeft = Ls(-w.window.scrollX)
                }
                _stickToBottomOfLimiter(e) {
                    this.isSticky = !0,
                    this._isStickyToTheBottomOfLimiter = !0,
                    this._stickyTopOffset = null,
                    this._stickyBottomOffset = e,
                    this._marginLeft = Ls(-w.window.scrollX)
                }
                _unstick() {
                    this.isSticky = !1,
                    this._isStickyToTheBottomOfLimiter = !1,
                    this._stickyTopOffset = null,
                    this._stickyBottomOffset = null,
                    this._marginLeft = null
                }
                get _contentPanelRect() {
                    return new De(this.contentPanelElement)
                }
            }
            var iy = /[\\^$.*+?()[\]{}|]/g
              , ML = RegExp(iy.source);
            const BL = function(s) {
                return (s = dp(s)) && ML.test(s) ? s.replace(iy, "\\$&") : s
            };
            var sy = u(8107)
              , NL = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(sy.A, NL),
            sy.A.locals;
            var ay = u(5727)
              , PL = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(ay.A, PL),
            ay.A.locals;
            var ly = u(9529)
              , jL = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(ly.A, jL),
            ly.A.locals;
            var cy = u(109)
              , LL = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(cy.A, LL),
            cy.A.locals;
            var dy = u(2710)
              , zL = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(dy.A, zL),
            dy.A.locals;
            var uy = u(3344)
              , OL = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(uy.A, OL),
            uy.A.locals;
            class RL extends Te {
                constructor(e) {
                    super(e),
                    C(this, "arrowView");
                    const t = this.bindTemplate;
                    this.set({
                        withText: !0,
                        role: "menuitem"
                    }),
                    this.arrowView = this._createArrowView(),
                    this.extendTemplate({
                        attributes: {
                            class: ["ck-menu-bar__menu__button"],
                            "aria-haspopup": !0,
                            "aria-expanded": this.bindTemplate.to("isOn", r => String(r)),
                            "data-cke-tooltip-disabled": t.to("isOn")
                        },
                        on: {
                            mouseenter: t.to("mouseenter")
                        }
                    })
                }
                render() {
                    super.render(),
                    this.children.add(this.arrowView)
                }
                _createArrowView() {
                    const e = new Ni;
                    return e.content = Xd,
                    e.extendTemplate({
                        attributes: {
                            class: "ck-menu-bar__menu__button__arrow"
                        }
                    }),
                    e
                }
            }
            var hy = u(9481)
              , FL = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(hy.A, FL),
            hy.A.locals;
            class iu extends Ps {
                constructor(e, t) {
                    super(e);
                    const r = this.bindTemplate;
                    this.extendTemplate({
                        attributes: {
                            class: ["ck-menu-bar__menu__item"]
                        },
                        on: {
                            mouseenter: r.to("mouseenter")
                        }
                    }),
                    this.delegate("mouseenter").to(t)
                }
            }
            const Tl = {
                toggleMenusAndFocusItemsOnHover(s) {
                    s.on("menu:mouseenter", e => {
                        if (s.isOpen) {
                            for (const t of s.menus) {
                                const r = e.path[0]
                                  , i = r instanceof iu && r.children.first === t;
                                t.isOpen = (e.path.includes(t) || i) && t.isEnabled
                            }
                            e.source.focus()
                        }
                    }
                    )
                },
                focusCycleMenusOnArrows(s) {
                    const e = s.locale.uiLanguageDirection === "rtl";
                    function t(r, i) {
                        const l = s.children.getIndex(r)
                          , d = r.isOpen
                          , h = s.children.length
                          , m = s.children.get((l + h + i) % h);
                        r.isOpen = !1,
                        d && (m.isOpen = !0),
                        m.buttonView.focus()
                    }
                    s.on("menu:arrowright", r => {
                        t(r.source, e ? -1 : 1)
                    }
                    ),
                    s.on("menu:arrowleft", r => {
                        t(r.source, e ? 1 : -1)
                    }
                    )
                },
                closeMenusWhenTheBarCloses(s) {
                    s.on("change:isOpen", () => {
                        s.isOpen || s.menus.forEach(e => {
                            e.isOpen = !1
                        }
                        )
                    }
                    )
                },
                closeMenuWhenAnotherOnTheSameLevelOpens(s) {
                    s.on("menu:change:isOpen", (e, t, r) => {
                        r && s.menus.filter(i => e.source.parentMenuView === i.parentMenuView && e.source !== i && i.isOpen).forEach(i => {
                            i.isOpen = !1
                        }
                        )
                    }
                    )
                },
                closeOnClickOutside(s) {
                    Dd({
                        emitter: s,
                        activator: () => s.isOpen,
                        callback: () => s.close(),
                        contextElements: () => s.children.map(e => e.element)
                    })
                }
            }
              , ji = {
                openAndFocusPanelOnArrowDownKey(s) {
                    s.keystrokes.set("arrowdown", (e, t) => {
                        s.focusTracker.focusedElement === s.buttonView.element && (s.isOpen || (s.isOpen = !0),
                        s.panelView.focus(),
                        t())
                    }
                    )
                },
                openOnArrowRightKey(s) {
                    const e = s.locale.uiLanguageDirection === "rtl" ? "arrowleft" : "arrowright";
                    s.keystrokes.set(e, (t, r) => {
                        s.focusTracker.focusedElement === s.buttonView.element && s.isEnabled && (s.isOpen || (s.isOpen = !0),
                        s.panelView.focus(),
                        r())
                    }
                    )
                },
                openOnButtonClick(s) {
                    s.buttonView.on("execute", () => {
                        s.isOpen = !0,
                        s.panelView.focus()
                    }
                    )
                },
                toggleOnButtonClick(s) {
                    s.buttonView.on("execute", () => {
                        s.isOpen = !s.isOpen,
                        s.isOpen && s.panelView.focus()
                    }
                    )
                },
                closeOnArrowLeftKey(s) {
                    const e = s.locale.uiLanguageDirection === "rtl" ? "arrowright" : "arrowleft";
                    s.keystrokes.set(e, (t, r) => {
                        s.isOpen && (s.isOpen = !1,
                        s.focus(),
                        r())
                    }
                    )
                },
                closeOnEscKey(s) {
                    s.keystrokes.set("esc", (e, t) => {
                        s.isOpen && (s.isOpen = !1,
                        s.focus(),
                        t())
                    }
                    )
                },
                closeOnParentClose(s) {
                    s.parentMenuView.on("change:isOpen", (e, t, r) => {
                        r || e.source !== s.parentMenuView || (s.isOpen = !1)
                    }
                    )
                }
            }
              , VL = {
                southEast: s => ({
                    top: s.bottom,
                    left: s.left,
                    name: "se"
                }),
                southWest: (s, e) => ({
                    top: s.bottom,
                    left: s.left - e.width + s.width,
                    name: "sw"
                }),
                northEast: (s, e) => ({
                    top: s.top - e.height,
                    left: s.left,
                    name: "ne"
                }),
                northWest: (s, e) => ({
                    top: s.top - e.height,
                    left: s.left - e.width + s.width,
                    name: "nw"
                }),
                eastSouth: s => ({
                    top: s.top,
                    left: s.right - 5,
                    name: "es"
                }),
                eastNorth: (s, e) => ({
                    top: s.top - e.height,
                    left: s.right - 5,
                    name: "en"
                }),
                westSouth: (s, e) => ({
                    top: s.top,
                    left: s.left - e.width + 5,
                    name: "ws"
                }),
                westNorth: (s, e) => ({
                    top: s.top - e.height,
                    left: s.left - e.width + 5,
                    name: "wn"
                })
            }
              , UL = [{
                menuId: "file",
                label: "File",
                groups: [{
                    groupId: "export",
                    items: ["menuBar:exportPdf", "menuBar:exportWord"]
                }, {
                    groupId: "import",
                    items: ["menuBar:importWord"]
                }, {
                    groupId: "revisionHistory",
                    items: ["menuBar:revisionHistory"]
                }]
            }, {
                menuId: "edit",
                label: "Edit",
                groups: [{
                    groupId: "undo",
                    items: ["menuBar:undo", "menuBar:redo"]
                }, {
                    groupId: "selectAll",
                    items: ["menuBar:selectAll"]
                }, {
                    groupId: "findAndReplace",
                    items: ["menuBar:findAndReplace"]
                }]
            }, {
                menuId: "view",
                label: "View",
                groups: [{
                    groupId: "sourceEditing",
                    items: ["menuBar:sourceEditing"]
                }, {
                    groupId: "showBlocks",
                    items: ["menuBar:showBlocks"]
                }, {
                    groupId: "restrictedEditingException",
                    items: ["menuBar:restrictedEditingException"]
                }]
            }, {
                menuId: "insert",
                label: "Insert",
                groups: [{
                    groupId: "insertMainWidgets",
                    items: ["menuBar:insertImage", "menuBar:ckbox", "menuBar:ckfinder", "menuBar:insertTable"]
                }, {
                    groupId: "insertInline",
                    items: ["menuBar:link", "menuBar:comment"]
                }, {
                    groupId: "insertMinorWidgets",
                    items: ["menuBar:mediaEmbed", "menuBar:insertTemplate", "menuBar:blockQuote", "menuBar:codeBlock", "menuBar:htmlEmbed"]
                }, {
                    groupId: "insertStructureWidgets",
                    items: ["menuBar:horizontalLine", "menuBar:pageBreak", "menuBar:tableOfContents"]
                }, {
                    groupId: "restrictedEditing",
                    items: ["menuBar:restrictedEditing"]
                }]
            }, {
                menuId: "format",
                label: "Format",
                groups: [{
                    groupId: "textAndFont",
                    items: [{
                        menuId: "text",
                        label: "Text",
                        groups: [{
                            groupId: "basicStyles",
                            items: ["menuBar:bold", "menuBar:italic", "menuBar:underline", "menuBar:strikethrough", "menuBar:superscript", "menuBar:subscript", "menuBar:code"]
                        }, {
                            groupId: "textPartLanguage",
                            items: ["menuBar:textPartLanguage"]
                        }]
                    }, {
                        menuId: "font",
                        label: "Font",
                        groups: [{
                            groupId: "fontProperties",
                            items: ["menuBar:fontSize", "menuBar:fontFamily"]
                        }, {
                            groupId: "fontColors",
                            items: ["menuBar:fontColor", "menuBar:fontBackgroundColor"]
                        }, {
                            groupId: "highlight",
                            items: ["menuBar:highlight"]
                        }]
                    }, "menuBar:heading"]
                }, {
                    groupId: "list",
                    items: ["menuBar:bulletedList", "menuBar:numberedList", "menuBar:multiLevelList", "menuBar:todoList"]
                }, {
                    groupId: "indent",
                    items: ["menuBar:alignment", "menuBar:indent", "menuBar:outdent"]
                }, {
                    groupId: "caseChange",
                    items: ["menuBar:caseChange"]
                }, {
                    groupId: "removeFormat",
                    items: ["menuBar:removeFormat"]
                }]
            }, {
                menuId: "tools",
                label: "Tools",
                groups: [{
                    groupId: "aiTools",
                    items: ["menuBar:aiAssistant", "menuBar:aiCommands"]
                }, {
                    groupId: "tools",
                    items: ["menuBar:trackChanges", "menuBar:commentsArchive"]
                }]
            }, {
                menuId: "help",
                label: "Help",
                groups: [{
                    groupId: "help",
                    items: ["menuBar:accessibilityHelp"]
                }]
            }];
            function HL({normalizedConfig: s, locale: e, componentFactory: t}) {
                const r = gr(s);
                return function(i, l) {
                    const d = l.removeItems
                      , h = [];
                    l.items = l.items.filter( ({menuId: m}) => !d.includes(m) || (h.push(m),
                    !1)),
                    zs(l.items, m => {
                        m.groups = m.groups.filter( ({groupId: g}) => !d.includes(g) || (h.push(g),
                        !1));
                        for (const g of m.groups)
                            g.items = g.items.filter(b => {
                                const v = gy(b);
                                return !d.includes(v) || (h.push(v),
                                !1)
                            }
                            )
                    }
                    );
                    for (const m of d)
                        h.includes(m) || de("menu-bar-item-could-not-be-removed", {
                            menuBarConfig: i,
                            itemName: m
                        })
                }(s, r),
                function(i, l) {
                    const d = l.addItems
                      , h = [];
                    for (const m of d) {
                        const g = qL(m.position)
                          , b = GL(m.position);
                        if (WL(m))
                            if (b) {
                                const v = l.items.findIndex(x => x.menuId === b);
                                v != -1 ? g === "before" ? (l.items.splice(v, 0, m.menu),
                                h.push(m)) : g === "after" && (l.items.splice(v + 1, 0, m.menu),
                                h.push(m)) : my(l, m.menu, b, g) && h.push(m)
                            } else
                                g === "start" ? (l.items.unshift(m.menu),
                                h.push(m)) : g === "end" && (l.items.push(m.menu),
                                h.push(m));
                        else
                            $L(m) ? zs(l.items, v => {
                                if (v.menuId === b)
                                    g === "start" ? (v.groups.unshift(m.group),
                                    h.push(m)) : g === "end" && (v.groups.push(m.group),
                                    h.push(m));
                                else {
                                    const x = v.groups.findIndex(T => T.groupId === b);
                                    x !== -1 && (g === "before" ? (v.groups.splice(x, 0, m.group),
                                    h.push(m)) : g === "after" && (v.groups.splice(x + 1, 0, m.group),
                                    h.push(m)))
                                }
                            }
                            ) : my(l, m.item, b, g) && h.push(m)
                    }
                    for (const m of d)
                        h.includes(m) || de("menu-bar-item-could-not-be-added", {
                            menuBarConfig: i,
                            addedItemConfig: m
                        })
                }(s, r),
                function(i, l, d) {
                    zs(l.items, h => {
                        for (const m of h.groups)
                            m.items = m.items.filter(g => {
                                const b = typeof g == "string" && !d.has(g);
                                return b && !l.isUsingDefaultConfig && de("menu-bar-item-unavailable", {
                                    menuBarConfig: i,
                                    parentMenuConfig: gr(h),
                                    componentName: g
                                }),
                                !b
                            }
                            )
                    }
                    )
                }(s, r, t),
                py(s, r),
                function(i, l) {
                    const d = l.t
                      , h = {
                        File: d({
                            string: "File",
                            id: "MENU_BAR_MENU_FILE"
                        }),
                        Edit: d({
                            string: "Edit",
                            id: "MENU_BAR_MENU_EDIT"
                        }),
                        View: d({
                            string: "View",
                            id: "MENU_BAR_MENU_VIEW"
                        }),
                        Insert: d({
                            string: "Insert",
                            id: "MENU_BAR_MENU_INSERT"
                        }),
                        Format: d({
                            string: "Format",
                            id: "MENU_BAR_MENU_FORMAT"
                        }),
                        Tools: d({
                            string: "Tools",
                            id: "MENU_BAR_MENU_TOOLS"
                        }),
                        Help: d({
                            string: "Help",
                            id: "MENU_BAR_MENU_HELP"
                        }),
                        Text: d({
                            string: "Text",
                            id: "MENU_BAR_MENU_TEXT"
                        }),
                        Font: d({
                            string: "Font",
                            id: "MENU_BAR_MENU_FONT"
                        })
                    };
                    zs(i.items, m => {
                        m.label in h && (m.label = h[m.label])
                    }
                    )
                }(r, e),
                r
            }
            function my(s, e, t, r) {
                let i = !1;
                return zs(s.items, l => {
                    for (const {groupId: d, items: h} of l.groups) {
                        if (i)
                            return;
                        if (d === t)
                            r === "start" ? (h.unshift(e),
                            i = !0) : r === "end" && (h.push(e),
                            i = !0);
                        else {
                            const m = h.findIndex(g => gy(g) === t);
                            m !== -1 && (r === "before" ? (h.splice(m, 0, e),
                            i = !0) : r === "after" && (h.splice(m + 1, 0, e),
                            i = !0))
                        }
                    }
                }
                ),
                i
            }
            function py(s, e) {
                const t = e.isUsingDefaultConfig;
                let r = !1;
                e.items = e.items.filter(i => !!i.groups.length || (og(s, i, t),
                !1)),
                e.items.length ? (zs(e.items, i => {
                    i.groups = i.groups.filter(l => !!l.items.length || (r = !0,
                    !1));
                    for (const l of i.groups)
                        l.items = l.items.filter(d => !(fy(d) && !d.groups.length) || (og(s, d, t),
                        r = !0,
                        !1))
                }
                ),
                r && py(s, e)) : og(s, s, t)
            }
            function og(s, e, t) {
                t || de("menu-bar-menu-empty", {
                    menuBarConfig: s,
                    emptyMenuConfig: e
                })
            }
            function zs(s, e) {
                if (Array.isArray(s))
                    for (const r of s)
                        t(r);
                function t(r) {
                    e(r);
                    for (const i of r.groups)
                        for (const l of i.items)
                            fy(l) && t(l)
                }
            }
            function WL(s) {
                return typeof s == "object" && "menu"in s
            }
            function $L(s) {
                return typeof s == "object" && "group"in s
            }
            function qL(s) {
                return s.startsWith("start") ? "start" : s.startsWith("end") ? "end" : s.startsWith("after") ? "after" : "before"
            }
            function GL(s) {
                const e = s.match(/^[^:]+:(.+)/);
                return e ? e[1] : null
            }
            function gy(s) {
                return typeof s == "string" ? s : s.menuId
            }
            function fy(s) {
                return typeof s == "object" && "menuId"in s
            }
            function KL(s, e) {
                const t = e.element;
                s.ui.focusTracker.add(t),
                s.keystrokes.listenTo(t);
                const r = function(i) {
                    let l;
                    return l = "items"in i && i.items ? {
                        items: i.items,
                        removeItems: [],
                        addItems: [],
                        isVisible: !0,
                        isUsingDefaultConfig: !1,
                        ...i
                    } : {
                        items: gr(UL),
                        addItems: [],
                        removeItems: [],
                        isVisible: !0,
                        isUsingDefaultConfig: !0,
                        ...i
                    },
                    l
                }(s.config.get("menuBar") || {});
                e.fillFromConfig(r, s.ui.componentFactory),
                s.keystrokes.set("Esc", (i, l) => {
                    t.contains(s.ui.focusTracker.focusedElement) && (s.editing.view.focus(),
                    l())
                }
                ),
                s.keystrokes.set("Alt+F9", (i, l) => {
                    t.contains(s.ui.focusTracker.focusedElement) || (e.focus(),
                    l())
                }
                )
            }
            var ky = u(9108)
              , YL = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(ky.A, YL),
            ky.A.locals;
            class QL extends pe {
                constructor(e) {
                    super(e),
                    C(this, "children");
                    const t = this.bindTemplate;
                    this.set("isVisible", !1),
                    this.set("position", "se"),
                    this.children = this.createCollection(),
                    this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-reset", "ck-menu-bar__menu__panel", t.to("position", r => `ck-menu-bar__menu__panel_position_${r}`), t.if("isVisible", "ck-hidden", r => !r)],
                            tabindex: "-1"
                        },
                        children: this.children,
                        on: {
                            selectstart: t.to(r => {
                                r.target.tagName.toLocaleLowerCase() !== "input" && r.preventDefault()
                            }
                            )
                        }
                    })
                }
                focus(e=1) {
                    this.children.length && (e === 1 ? this.children.first.focus() : this.children.last.focus())
                }
            }
            var by = u(4)
              , ZL = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(by.A, ZL),
            by.A.locals;
            const wy = class yB extends pe {
                constructor(e) {
                    super(e),
                    C(this, "buttonView"),
                    C(this, "panelView"),
                    C(this, "focusTracker"),
                    C(this, "keystrokes");
                    const t = this.bindTemplate;
                    this.buttonView = new RL(e),
                    this.buttonView.delegate("mouseenter").to(this),
                    this.buttonView.bind("isOn", "isEnabled").to(this, "isOpen", "isEnabled"),
                    this.panelView = new QL(e),
                    this.panelView.bind("isVisible").to(this, "isOpen"),
                    this.keystrokes = new lo,
                    this.focusTracker = new Jt,
                    this.set("isOpen", !1),
                    this.set("isEnabled", !0),
                    this.set("panelPosition", "w"),
                    this.set("class", void 0),
                    this.set("parentMenuView", null),
                    this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-menu-bar__menu", t.to("class"), t.if("isEnabled", "ck-disabled", r => !r), t.if("parentMenuView", "ck-menu-bar__menu_top-level", r => !r)]
                        },
                        children: [this.buttonView, this.panelView]
                    })
                }
                render() {
                    super.render(),
                    this.focusTracker.add(this.buttonView.element),
                    this.focusTracker.add(this.panelView.element),
                    this.keystrokes.listenTo(this.element),
                    ji.closeOnEscKey(this),
                    this._repositionPanelOnOpen()
                }
                _attachBehaviors() {
                    this.parentMenuView ? (ji.openOnButtonClick(this),
                    ji.openOnArrowRightKey(this),
                    ji.closeOnArrowLeftKey(this),
                    ji.closeOnParentClose(this)) : (this._propagateArrowKeystrokeEvents(),
                    ji.openAndFocusPanelOnArrowDownKey(this),
                    ji.toggleOnButtonClick(this))
                }
                _propagateArrowKeystrokeEvents() {
                    this.keystrokes.set("arrowright", (e, t) => {
                        this.fire("arrowright"),
                        t()
                    }
                    ),
                    this.keystrokes.set("arrowleft", (e, t) => {
                        this.fire("arrowleft"),
                        t()
                    }
                    )
                }
                _repositionPanelOnOpen() {
                    this.on("change:isOpen", (e, t, r) => {
                        if (!r)
                            return;
                        const i = yB._getOptimalPosition({
                            element: this.panelView.element,
                            target: this.buttonView.element,
                            fitInViewport: !0,
                            positions: this._panelPositions
                        });
                        this.panelView.position = i ? i.name : this._panelPositions[0].name
                    }
                    )
                }
                focus() {
                    this.buttonView.focus()
                }
                get _panelPositions() {
                    const {southEast: e, southWest: t, northEast: r, northWest: i, westSouth: l, eastSouth: d, westNorth: h, eastNorth: m} = VL;
                    return this.locale.uiLanguageDirection === "ltr" ? this.parentMenuView ? [d, m, l, h] : [e, t, r, i] : this.parentMenuView ? [l, h, d, m] : [t, e, i, r]
                }
            }
            ;
            C(wy, "_getOptimalPosition", Km);
            let Os = wy;
            class su extends Kp {
                constructor(e) {
                    super(e),
                    this.role = "menu"
                }
            }
            class Ay extends Hp {
                constructor(e) {
                    super(e),
                    this.set({
                        withText: !0,
                        withKeystroke: !0,
                        tooltip: !1,
                        role: "menuitem"
                    }),
                    this.extendTemplate({
                        attributes: {
                            class: ["ck-menu-bar__menu__item__button"]
                        }
                    })
                }
            }
            var vy = u(497)
              , JL = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(vy.A, JL),
            vy.A.locals;
            const _y = ["mouseenter", "arrowleft", "arrowright", "change:isOpen"];
            class XL extends pe {
                constructor(e) {
                    super(e),
                    C(this, "children"),
                    C(this, "menus", []);
                    const t = e.t;
                    this.set("isOpen", !1),
                    this._setupIsOpenUpdater(),
                    this.children = this.createCollection(),
                    this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-menu-bar"],
                            "aria-label": t("Editor menu bar"),
                            role: "menubar"
                        },
                        children: this.children
                    })
                }
                fillFromConfig(e, t) {
                    const r = HL({
                        normalizedConfig: e,
                        locale: this.locale,
                        componentFactory: t
                    }).items.map(i => this._createMenu({
                        componentFactory: t,
                        menuDefinition: i
                    }));
                    this.children.addMany(r)
                }
                render() {
                    super.render(),
                    Tl.toggleMenusAndFocusItemsOnHover(this),
                    Tl.closeMenusWhenTheBarCloses(this),
                    Tl.closeMenuWhenAnotherOnTheSameLevelOpens(this),
                    Tl.focusCycleMenusOnArrows(this),
                    Tl.closeOnClickOutside(this)
                }
                focus() {
                    this.children.first && this.children.first.focus()
                }
                close() {
                    for (const e of this.children)
                        e.isOpen = !1
                }
                registerMenu(e, t=null) {
                    t ? (e.delegate(..._y).to(t),
                    e.parentMenuView = t) : e.delegate(..._y).to(this, r => "menu:" + r),
                    e._attachBehaviors(),
                    this.menus.push(e)
                }
                _createMenu({componentFactory: e, menuDefinition: t, parentMenuView: r}) {
                    const i = this.locale
                      , l = new Os(i);
                    return this.registerMenu(l, r),
                    l.buttonView.set({
                        label: t.label
                    }),
                    l.once("change:isOpen", () => {
                        const d = new su(i);
                        d.ariaLabel = t.label,
                        l.panelView.children.add(d),
                        d.items.addMany(this._createMenuItems({
                            menuDefinition: t,
                            parentMenuView: l,
                            componentFactory: e
                        }))
                    }
                    ),
                    l
                }
                _createMenuItems({menuDefinition: e, parentMenuView: t, componentFactory: r}) {
                    const i = this.locale
                      , l = [];
                    for (const d of e.groups) {
                        for (const h of d.items) {
                            const m = new iu(i,t);
                            if (Le(h))
                                m.children.add(this._createMenu({
                                    componentFactory: r,
                                    menuDefinition: h,
                                    parentMenuView: t
                                }));
                            else {
                                const g = this._createMenuItemContentFromFactory({
                                    componentName: h,
                                    componentFactory: r,
                                    parentMenuView: t
                                });
                                if (!g)
                                    continue;
                                m.children.add(g)
                            }
                            l.push(m)
                        }
                        d !== e.groups[e.groups.length - 1] && l.push(new Gp(i))
                    }
                    return l
                }
                _createMenuItemContentFromFactory({componentName: e, parentMenuView: t, componentFactory: r}) {
                    const i = r.create(e);
                    return i instanceof Os || i instanceof Xt || i instanceof Ay ? (this._registerMenuTree(i, t),
                    i.on("execute", () => {
                        this.close()
                    }
                    ),
                    i) : (de("menu-bar-component-unsupported", {
                        componentName: e,
                        componentView: i
                    }),
                    null)
                }
                _registerMenuTree(e, t) {
                    if (!(e instanceof Os))
                        return void e.delegate("mouseenter").to(t);
                    this.registerMenu(e, t);
                    const r = e.panelView.children.filter(l => l instanceof su)[0];
                    if (!r)
                        return void e.delegate("mouseenter").to(t);
                    const i = r.items.filter(l => l instanceof Ps);
                    for (const l of i)
                        this._registerMenuTree(l.children.get(0), e)
                }
                _setupIsOpenUpdater() {
                    let e;
                    this.on("menu:change:isOpen", (t, r, i) => {
                        clearTimeout(e),
                        i ? this.isOpen = !0 : e = setTimeout( () => {
                            this.isOpen = Array.from(this.children).some(l => l.isOpen)
                        }
                        , 0)
                    }
                    )
                }
            }
            class ez extends wL {
                constructor(e, t) {
                    super(e),
                    C(this, "view"),
                    C(this, "_toolbarConfig"),
                    C(this, "_elementReplacer"),
                    this.view = t,
                    this._toolbarConfig = BC(e.config.get("toolbar")),
                    this._elementReplacer = new SB,
                    this.listenTo(e.editing.view, "scrollToTheSelection", this._handleScrollToTheSelectionWithStickyPanel.bind(this))
                }
                get element() {
                    return this.view.element
                }
                init(e) {
                    const t = this.editor
                      , r = this.view
                      , i = t.editing.view
                      , l = r.editable
                      , d = i.document.getRoot();
                    l.name = d.rootName,
                    r.render();
                    const h = l.element;
                    this.setEditableElement(l.name, h),
                    r.editable.bind("isFocused").to(this.focusTracker),
                    i.attachDomRoot(h),
                    e && this._elementReplacer.replace(e, this.element),
                    this._initPlaceholder(),
                    this._initToolbar(),
                    r.menuBarView && KL(t, r.menuBarView),
                    this._initDialogPluginIntegration(),
                    this.fire("ready")
                }
                destroy() {
                    super.destroy();
                    const e = this.view
                      , t = this.editor.editing.view;
                    this._elementReplacer.restore(),
                    t.detachDomRoot(e.editable.name),
                    e.destroy()
                }
                _initToolbar() {
                    const e = this.view;
                    e.stickyPanel.bind("isActive").to(this.focusTracker, "isFocused"),
                    e.stickyPanel.limiterElement = e.element,
                    e.stickyPanel.bind("viewportTopOffset").to(this, "viewportOffset", ({top: t}) => t || 0),
                    e.toolbar.fillFromConfig(this._toolbarConfig, this.componentFactory),
                    this.addToolbar(e.toolbar)
                }
                _initPlaceholder() {
                    const e = this.editor
                      , t = e.editing.view
                      , r = t.document.getRoot()
                      , i = e.sourceElement;
                    let l;
                    const d = e.config.get("placeholder");
                    d && (l = typeof d == "string" ? d : d[this.view.editable.name]),
                    !l && i && i.tagName.toLowerCase() === "textarea" && (l = i.getAttribute("placeholder")),
                    l && (r.placeholder = l),
                    yv({
                        view: t,
                        element: r,
                        isDirectHost: !1,
                        keepOnFocus: !0
                    })
                }
                _handleScrollToTheSelectionWithStickyPanel(e, t, r) {
                    const i = this.view.stickyPanel;
                    if (i.isSticky) {
                        const l = new De(i.element).height;
                        t.viewportOffset.top += l
                    } else {
                        const l = () => {
                            this.editor.editing.view.scrollToTheSelection(r)
                        }
                        ;
                        this.listenTo(i, "change:isSticky", l),
                        setTimeout( () => {
                            this.stopListening(i, "change:isSticky", l)
                        }
                        , 20)
                    }
                }
                _initDialogPluginIntegration() {
                    if (!this.editor.plugins.has("Dialog"))
                        return;
                    const e = this.view.stickyPanel
                      , t = this.editor.plugins.get("Dialog");
                    t.on("show", () => {
                        const r = t.view;
                        r.on("moveTo", (i, l) => {
                            if (!e.isSticky || r.wasMoved)
                                return;
                            const d = new De(e.contentPanelElement);
                            l[1] < d.bottom + Up.defaultOffset && (l[1] = d.bottom + Up.defaultOffset)
                        }
                        , {
                            priority: "high"
                        })
                    }
                    , {
                        priority: "low"
                    })
                }
            }
            var Cy = u(7388)
              , tz = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(Cy.A, tz),
            Cy.A.locals;
            class oz extends _L {
                constructor(e, t, r={}) {
                    super(e),
                    C(this, "stickyPanel"),
                    C(this, "toolbar"),
                    C(this, "menuBarView"),
                    C(this, "editable"),
                    this.stickyPanel = new IL(e),
                    this.toolbar = new qp(e,{
                        shouldGroupWhenFull: r.shouldToolbarGroupWhenFull
                    }),
                    r.useMenuBar && (this.menuBarView = new XL(e)),
                    this.editable = new yL(e,t)
                }
                render() {
                    super.render(),
                    this.menuBarView ? this.stickyPanel.content.addMany([this.menuBarView, this.toolbar]) : this.stickyPanel.content.add(this.toolbar),
                    this.top.add(this.stickyPanel),
                    this.main.add(this.editable)
                }
            }
            class rz extends Fp(Ns) {
                constructor(e, t={}) {
                    if (!au(e) && t.initialData !== void 0)
                        throw new U("editor-create-initial-data",null);
                    super(t),
                    C(this, "ui"),
                    this.config.define("menuBar.isVisible", !1),
                    this.config.get("initialData") === void 0 && this.config.set("initialData", function(d) {
                        return au(d) ? (h = d,
                        h instanceof HTMLTextAreaElement ? h.value : h.innerHTML) : d;
                        var h
                    }(e)),
                    au(e) && (this.sourceElement = e),
                    this.model.document.createRoot();
                    const r = !this.config.get("toolbar.shouldNotGroupWhenFull")
                      , i = this.config.get("menuBar")
                      , l = new oz(this.locale,this.editing.view,{
                        shouldToolbarGroupWhenFull: r,
                        useMenuBar: i.isVisible
                    });
                    this.ui = new ez(this,l),
                    function(d) {
                        if (!wi(d.updateSourceElement))
                            throw new U("attachtoform-missing-elementapi-interface",d);
                        const h = d.sourceElement;
                        if (function(m) {
                            return !!m && m.tagName.toLowerCase() === "textarea"
                        }(h) && h.form) {
                            let m;
                            const g = h.form
                              , b = () => d.updateSourceElement();
                            wi(g.submit) && (m = g.submit,
                            g.submit = () => {
                                b(),
                                m.apply(g)
                            }
                            ),
                            g.addEventListener("submit", b),
                            d.on("destroy", () => {
                                g.removeEventListener("submit", b),
                                m && (g.submit = m)
                            }
                            )
                        }
                    }(this)
                }
                destroy() {
                    return this.sourceElement && this.updateSourceElement(),
                    this.ui.destroy(),
                    super.destroy()
                }
                static create(e, t={}) {
                    return new Promise(r => {
                        const i = new this(e,t);
                        r(i.initPlugins().then( () => i.ui.init(au(e) ? e : null)).then( () => i.data.init(i.config.get("initialData"))).then( () => i.fire("ready")).then( () => i))
                    }
                    )
                }
            }
            function au(s) {
                return Ci(s)
            }
            class Il extends Mn {
                constructor(e) {
                    super(e),
                    C(this, "domEventType", ["paste", "copy", "cut", "drop", "dragover", "dragstart", "dragend", "dragenter", "dragleave"]);
                    const t = this.document;
                    function r(i) {
                        return (l, d) => {
                            d.preventDefault();
                            const h = d.dropRange ? [d.dropRange] : null
                              , m = new K(t,i);
                            t.fire(m, {
                                dataTransfer: d.dataTransfer,
                                method: l.name,
                                targetRanges: h,
                                target: d.target,
                                domEvent: d.domEvent
                            }),
                            m.stop.called && d.stopPropagation()
                        }
                    }
                    this.listenTo(t, "paste", r("clipboardInput"), {
                        priority: "low"
                    }),
                    this.listenTo(t, "drop", r("clipboardInput"), {
                        priority: "low"
                    }),
                    this.listenTo(t, "dragover", r("dragging"), {
                        priority: "low"
                    })
                }
                onDomEvent(e) {
                    const t = "clipboardData"in e ? e.clipboardData : e.dataTransfer
                      , r = e.type == "drop" || e.type == "paste"
                      , i = {
                        dataTransfer: new i_(t,{
                            cacheFiles: r
                        })
                    };
                    e.type != "drop" && e.type != "dragover" || (i.dropRange = function(l, d) {
                        const h = d.target.ownerDocument
                          , m = d.clientX
                          , g = d.clientY;
                        let b;
                        return h.caretRangeFromPoint && h.caretRangeFromPoint(m, g) ? b = h.caretRangeFromPoint(m, g) : d.rangeParent && (b = h.createRange(),
                        b.setStart(d.rangeParent, d.rangeOffset),
                        b.collapse(!0)),
                        b ? l.domConverter.domRangeToView(b) : null
                    }(this.view, e)),
                    this.fire(e.type, e, i)
                }
            }
            const yy = ["figcaption", "li"]
              , xy = ["ol", "ul"];
            function Ey(s) {
                if (s.is("$text") || s.is("$textProxy"))
                    return s.data;
                if (s.is("element", "img") && s.hasAttribute("alt"))
                    return s.getAttribute("alt");
                if (s.is("element", "br"))
                    return `
`;
                let e = ""
                  , t = null;
                for (const r of s.getChildren())
                    e += nz(r, t) + Ey(r),
                    t = r;
                return e
            }
            function nz(s, e) {
                return e ? s.is("element", "li") && !s.isEmpty && s.getChild(0).is("containerElement") || xy.includes(s.name) && xy.includes(e.name) ? `

` : s.is("containerElement") || e.is("containerElement") ? yy.includes(s.name) || yy.includes(e.name) ? `
` : `

` : "" : ""
            }
            const iz = function(s, e) {
                return s && tv(s, e, al)
            }
              , sz = function(s, e, t, r) {
                var i = t.length
                  , l = i;
                if (s == null)
                    return !l;
                for (s = Object(s); i--; ) {
                    var d = t[i];
                    if (d[2] ? d[1] !== s[d[0]] : !(d[0]in s))
                        return !1
                }
                for (; ++i < l; ) {
                    var h = (d = t[i])[0]
                      , m = s[h]
                      , g = d[1];
                    if (d[2]) {
                        if (m === void 0 && !(h in s))
                            return !1
                    } else {
                        var b = new bs, v;
                        if (!(v === void 0 ? Hd(g, m, 3, r, b) : v))
                            return !1
                    }
                }
                return !0
            }
              , Sy = function(s) {
                return s == s && !Le(s)
            }
              , az = function(s) {
                for (var e = al(s), t = e.length; t--; ) {
                    var r = e[t]
                      , i = s[r];
                    e[t] = [r, i, Sy(i)]
                }
                return e
            }
              , Dy = function(s, e) {
                return function(t) {
                    return t != null && t[s] === e && (e !== void 0 || s in Object(t))
                }
            }
              , lz = function(s) {
                var e = az(s);
                return e.length == 1 && e[0][2] ? Dy(e[0][0], e[0][1]) : function(t) {
                    return t === s || sz(t, s, e)
                }
            }
              , cz = function(s, e) {
                return s != null && e in Object(s)
            }
              , dz = function(s, e, t) {
                for (var r = -1, i = (e = Pd(e, s)).length, l = !1; ++r < i; ) {
                    var d = ys(e[r]);
                    if (!(l = s != null && t(s, d)))
                        break;
                    s = s[d]
                }
                return l || ++r != i ? l : !!(i = s == null ? 0 : s.length) && Mm(i) && wd(d, i) && (xo(s) || bd(s))
            }
              , uz = function(s, e) {
                return s != null && dz(s, e, cz)
            }
              , hz = function(s, e) {
                return lp(s) && Sy(e) ? Dy(ys(s), e) : function(t) {
                    var r = ml(t, s);
                    return r === void 0 && r === e ? uz(t, s) : Hd(e, r, 3)
                }
            }
              , mz = function(s) {
                return function(e) {
                    return e == null ? void 0 : e[s]
                }
            }
              , pz = function(s) {
                return function(e) {
                    return up(e, s)
                }
            }
              , gz = function(s) {
                return lp(s) ? mz(ys(s)) : pz(s)
            }
              , fz = function(s) {
                return typeof s == "function" ? s : s == null ? In : typeof s == "object" ? xo(s) ? hz(s[0], s[1]) : lz(s) : gz(s)
            }
              , kz = function(s, e) {
                var t = {};
                return e = fz(e),
                iz(s, function(r, i, l) {
                    kd(t, i, e(r, i, l))
                }),
                t
            };
            class Ml extends ie {
                constructor() {
                    super(...arguments),
                    C(this, "_markersToCopy", new Map)
                }
                static get pluginName() {
                    return "ClipboardMarkersUtils"
                }
                _registerMarkerToCopy(e, t) {
                    this._markersToCopy.set(e, t)
                }
                _copySelectedFragmentWithMarkers(e, t, r=i => i.model.getSelectedContent(i.model.document.selection)) {
                    return this.editor.model.change(i => {
                        const l = i.model.document.selection;
                        i.setSelection(t);
                        const d = this._insertFakeMarkersIntoSelection(i, i.model.document.selection, e)
                          , h = r(i)
                          , m = this._removeFakeMarkersInsideElement(i, h);
                        for (const [g,b] of Object.entries(d)) {
                            m[g] || (m[g] = i.createRangeIn(h));
                            for (const v of b)
                                i.remove(v)
                        }
                        h.markers.clear();
                        for (const [g,b] of Object.entries(m))
                            h.markers.set(g, b);
                        return i.setSelection(l),
                        h
                    }
                    )
                }
                _pasteMarkersIntoTransformedElement(e, t) {
                    const r = this._getPasteMarkersFromRangeMap(e);
                    return this.editor.model.change(i => {
                        const l = this._insertFakeMarkersElements(i, r)
                          , d = t(i)
                          , h = this._removeFakeMarkersInsideElement(i, d);
                        for (const m of Object.values(l).flat())
                            i.remove(m);
                        for (const [m,g] of Object.entries(h))
                            i.model.markers.has(m) || i.addMarker(m, {
                                usingOperation: !0,
                                affectsData: !0,
                                range: g
                            });
                        return d
                    }
                    )
                }
                _pasteFragmentWithMarkers(e) {
                    const t = this._getPasteMarkersFromRangeMap(e.markers);
                    e.markers.clear();
                    for (const r of t)
                        e.markers.set(r.name, r.range);
                    return this.editor.model.insertContent(e)
                }
                _forceMarkersCopy(e, t, r={
                    allowedActions: "all",
                    copyPartiallySelected: !0,
                    duplicateOnPaste: !0
                }) {
                    const i = this._markersToCopy.get(e);
                    this._markersToCopy.set(e, r),
                    t(),
                    i ? this._markersToCopy.set(e, i) : this._markersToCopy.delete(e)
                }
                _isMarkerCopyable(e, t) {
                    const r = this._getMarkerClipboardConfig(e);
                    if (!r)
                        return !1;
                    if (!t)
                        return !0;
                    const {allowedActions: i} = r;
                    return i === "all" || i.includes(t)
                }
                _hasMarkerConfiguration(e) {
                    return !!this._getMarkerClipboardConfig(e)
                }
                _getMarkerClipboardConfig(e) {
                    const [t] = e.split(":");
                    return this._markersToCopy.get(t) || null
                }
                _insertFakeMarkersIntoSelection(e, t, r) {
                    const i = this._getCopyableMarkersFromSelection(e, t, r);
                    return this._insertFakeMarkersElements(e, i)
                }
                _getCopyableMarkersFromSelection(e, t, r) {
                    const i = Array.from(t.getRanges())
                      , l = new Set(i.flatMap(d => Array.from(e.model.markers.getMarkersIntersectingRange(d))));
                    return Array.from(l).filter(d => {
                        if (!this._isMarkerCopyable(d.name, r))
                            return !1;
                        const {copyPartiallySelected: h} = this._getMarkerClipboardConfig(d.name);
                        if (!h) {
                            const m = d.getRange();
                            return i.some(g => g.containsRange(m, !0))
                        }
                        return !0
                    }
                    ).map(d => ({
                        name: r === "dragstart" ? this._getUniqueMarkerName(d.name) : d.name,
                        range: d.getRange()
                    }))
                }
                _getPasteMarkersFromRangeMap(e, t=null) {
                    const {model: r} = this.editor;
                    return (e instanceof Map ? Array.from(e.entries()) : Object.entries(e)).flatMap( ([i,l]) => {
                        if (!this._hasMarkerConfiguration(i))
                            return [{
                                name: i,
                                range: l
                            }];
                        if (this._isMarkerCopyable(i, t)) {
                            const d = this._getMarkerClipboardConfig(i)
                              , h = r.markers.has(i) && r.markers.get(i).getRange().root.rootName === "$graveyard";
                            return (d.duplicateOnPaste || h) && (i = this._getUniqueMarkerName(i)),
                            [{
                                name: i,
                                range: l
                            }]
                        }
                        return []
                    }
                    )
                }
                _insertFakeMarkersElements(e, t) {
                    const r = {}
                      , i = t.flatMap(l => {
                        const {start: d, end: h} = l.range;
                        return [{
                            position: d,
                            marker: l,
                            type: "start"
                        }, {
                            position: h,
                            marker: l,
                            type: "end"
                        }]
                    }
                    ).sort( ({position: l}, {position: d}) => l.isBefore(d) ? 1 : -1);
                    for (const {position: l, marker: d, type: h} of i) {
                        const m = e.createElement("$marker", {
                            "data-name": d.name,
                            "data-type": h
                        });
                        r[d.name] || (r[d.name] = []),
                        r[d.name].push(m),
                        e.insert(m, l)
                    }
                    return r
                }
                _removeFakeMarkersInsideElement(e, t) {
                    const r = this._getAllFakeMarkersFromElement(e, t).reduce( (i, l) => {
                        const d = l.markerElement && e.createPositionBefore(l.markerElement);
                        let h = i[l.name]
                          , m = !1;
                        return h && h.start && h.end && (this._getMarkerClipboardConfig(l.name).duplicateOnPaste ? i[this._getUniqueMarkerName(l.name)] = i[l.name] : m = !0,
                        h = null),
                        m || (i[l.name] = {
                            ...h,
                            [l.type]: d
                        }),
                        l.markerElement && e.remove(l.markerElement),
                        i
                    }
                    , {});
                    return kz(r, i => new J(i.start || e.createPositionFromPath(t, [0]),i.end || e.createPositionAt(t, "end")))
                }
                _getAllFakeMarkersFromElement(e, t) {
                    const r = Array.from(e.createRangeIn(t)).flatMap( ({item: d}) => {
                        if (!d.is("element", "$marker"))
                            return [];
                        const h = d.getAttribute("data-name")
                          , m = d.getAttribute("data-type");
                        return [{
                            markerElement: d,
                            name: h,
                            type: m
                        }]
                    }
                    )
                      , i = []
                      , l = [];
                    for (const d of r)
                        d.type === "end" && (r.some(h => h.name === d.name && h.type === "start") || i.push({
                            markerElement: null,
                            name: d.name,
                            type: "start"
                        })),
                        d.type === "start" && (r.some(h => h.name === d.name && h.type === "end") || l.unshift({
                            markerElement: null,
                            name: d.name,
                            type: "end"
                        }));
                    return [...i, ...r, ...l]
                }
                _getUniqueMarkerName(e) {
                    const t = e.split(":")
                      , r = H().substring(1, 6);
                    return t.length === 3 ? `${t.slice(0, 2).join(":")}:${r}` : `${t.join(":")}:${r}`
                }
            }
            class Ko extends ie {
                static get pluginName() {
                    return "ClipboardPipeline"
                }
                static get requires() {
                    return [Ml]
                }
                init() {
                    this.editor.editing.view.addObserver(Il),
                    this._setupPasteDrop(),
                    this._setupCopyCut()
                }
                _fireOutputTransformationEvent(e, t, r) {
                    const i = this.editor.plugins.get("ClipboardMarkersUtils");
                    this.editor.model.enqueueChange({
                        isUndoable: r === "cut"
                    }, () => {
                        const l = i._copySelectedFragmentWithMarkers(r, t);
                        this.fire("outputTransformation", {
                            dataTransfer: e,
                            content: l,
                            method: r
                        })
                    }
                    )
                }
                _setupPasteDrop() {
                    const e = this.editor
                      , t = e.model
                      , r = e.editing.view
                      , i = r.document
                      , l = this.editor.plugins.get("ClipboardMarkersUtils");
                    this.listenTo(i, "clipboardInput", (d, h) => {
                        h.method != "paste" || e.model.canEditAt(e.model.document.selection) || d.stop()
                    }
                    , {
                        priority: "highest"
                    }),
                    this.listenTo(i, "clipboardInput", (d, h) => {
                        const m = h.dataTransfer;
                        let g;
                        if (h.content)
                            g = h.content;
                        else {
                            let x = "";
                            m.getData("text/html") ? x = function(T) {
                                return T.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, (I, P) => P.length == 1 ? " " : P).replace(/<!--[\s\S]*?-->/g, "")
                            }(m.getData("text/html")) : m.getData("text/plain") && (((b = (b = m.getData("text/plain")).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r?\n\r?\n/g, "</p><p>").replace(/\r?\n/g, "<br>").replace(/\t/g, "&nbsp;&nbsp;&nbsp;&nbsp;").replace(/^\s/, "&nbsp;").replace(/\s$/, "&nbsp;").replace(/\s\s/g, " &nbsp;")).includes("</p><p>") || b.includes("<br>")) && (b = `<p>${b}</p>`),
                            x = b),
                            g = this.editor.data.htmlProcessor.toView(x)
                        }
                        var b;
                        const v = new K(this,"inputTransformation");
                        this.fire(v, {
                            content: g,
                            dataTransfer: m,
                            targetRanges: h.targetRanges,
                            method: h.method
                        }),
                        v.stop.called && d.stop(),
                        r.scrollToTheSelection()
                    }
                    , {
                        priority: "low"
                    }),
                    this.listenTo(this, "inputTransformation", (d, h) => {
                        if (h.content.isEmpty)
                            return;
                        const m = this.editor.data.toModel(h.content, "$clipboardHolder");
                        m.childCount != 0 && (d.stop(),
                        t.change( () => {
                            this.fire("contentInsertion", {
                                content: m,
                                method: h.method,
                                dataTransfer: h.dataTransfer,
                                targetRanges: h.targetRanges
                            })
                        }
                        ))
                    }
                    , {
                        priority: "low"
                    }),
                    this.listenTo(this, "contentInsertion", (d, h) => {
                        h.resultRange = l._pasteFragmentWithMarkers(h.content)
                    }
                    , {
                        priority: "low"
                    })
                }
                _setupCopyCut() {
                    const e = this.editor
                      , t = e.model.document
                      , r = e.editing.view.document
                      , i = (l, d) => {
                        const h = d.dataTransfer;
                        d.preventDefault(),
                        this._fireOutputTransformationEvent(h, t.selection, l.name)
                    }
                    ;
                    this.listenTo(r, "copy", i, {
                        priority: "low"
                    }),
                    this.listenTo(r, "cut", (l, d) => {
                        e.model.canEditAt(e.model.document.selection) ? i(l, d) : d.preventDefault()
                    }
                    , {
                        priority: "low"
                    }),
                    this.listenTo(this, "outputTransformation", (l, d) => {
                        const h = e.data.toView(d.content);
                        r.fire("clipboardOutput", {
                            dataTransfer: d.dataTransfer,
                            content: h,
                            method: d.method
                        })
                    }
                    , {
                        priority: "low"
                    }),
                    this.listenTo(r, "clipboardOutput", (l, d) => {
                        d.content.isEmpty || (d.dataTransfer.setData("text/html", this.editor.data.htmlProcessor.toData(d.content)),
                        d.dataTransfer.setData("text/plain", Ey(d.content))),
                        d.method == "cut" && e.model.deleteContent(t.selection)
                    }
                    , {
                        priority: "low"
                    })
                }
            }
            class Ty {
                constructor(e, t=20) {
                    C(this, "model"),
                    C(this, "limit"),
                    C(this, "_isLocked"),
                    C(this, "_size"),
                    C(this, "_batch", null),
                    C(this, "_changeCallback"),
                    C(this, "_selectionChangeCallback"),
                    this.model = e,
                    this._size = 0,
                    this.limit = t,
                    this._isLocked = !1,
                    this._changeCallback = (r, i) => {
                        i.isLocal && i.isUndoable && i !== this._batch && this._reset(!0)
                    }
                    ,
                    this._selectionChangeCallback = () => {
                        this._reset()
                    }
                    ,
                    this.model.document.on("change", this._changeCallback),
                    this.model.document.selection.on("change:range", this._selectionChangeCallback),
                    this.model.document.selection.on("change:attribute", this._selectionChangeCallback)
                }
                get batch() {
                    return this._batch || (this._batch = this.model.createBatch({
                        isTyping: !0
                    })),
                    this._batch
                }
                get size() {
                    return this._size
                }
                input(e) {
                    this._size += e,
                    this._size >= this.limit && this._reset(!0)
                }
                get isLocked() {
                    return this._isLocked
                }
                lock() {
                    this._isLocked = !0
                }
                unlock() {
                    this._isLocked = !1
                }
                destroy() {
                    this.model.document.off("change", this._changeCallback),
                    this.model.document.selection.off("change:range", this._selectionChangeCallback),
                    this.model.document.selection.off("change:attribute", this._selectionChangeCallback)
                }
                _reset(e=!1) {
                    this.isLocked && !e || (this._batch = null,
                    this._size = 0)
                }
            }
            class bz extends _e {
                constructor(e, t) {
                    super(e),
                    C(this, "_buffer"),
                    this._buffer = new Ty(e.model,t),
                    this._isEnabledBasedOnSelection = !1
                }
                get buffer() {
                    return this._buffer
                }
                destroy() {
                    super.destroy(),
                    this._buffer.destroy()
                }
                execute(e={}) {
                    const t = this.editor.model
                      , r = t.document
                      , i = e.text || ""
                      , l = i.length;
                    let d = r.selection;
                    if (e.selection ? d = e.selection : e.range && (d = t.createSelection(e.range)),
                    !t.canEditAt(d))
                        return;
                    const h = e.resultRange;
                    t.enqueueChange(this._buffer.batch, m => {
                        this._buffer.lock();
                        const g = Array.from(r.selection.getAttributes());
                        t.deleteContent(d),
                        i && t.insertContent(m.createText(i, g), d),
                        h ? m.setSelection(h) : d.is("documentSelection") || m.setSelection(d),
                        this._buffer.unlock(),
                        this._buffer.input(l)
                    }
                    )
                }
            }
            const Iy = ["insertText", "insertReplacementText"];
            class wz extends Nr {
                constructor(e) {
                    super(e),
                    C(this, "focusObserver"),
                    this.focusObserver = e.getObserver(Wd),
                    E.isAndroid && Iy.push("insertCompositionText");
                    const t = e.document;
                    t.on("beforeinput", (r, i) => {
                        if (!this.isEnabled)
                            return;
                        const {data: l, targetRanges: d, inputType: h, domEvent: m} = i;
                        if (!Iy.includes(h))
                            return;
                        this.focusObserver.flush();
                        const g = new K(t,"insertText");
                        t.fire(g, new Ds(e,m,{
                            text: l,
                            selection: e.createSelection(d)
                        })),
                        g.stop.called && r.stop()
                    }
                    ),
                    t.on("compositionend", (r, {data: i, domEvent: l}) => {
                        this.isEnabled && !E.isAndroid && i && t.fire("insertText", new Ds(e,l,{
                            text: i,
                            selection: t.selection
                        }))
                    }
                    , {
                        priority: "lowest"
                    })
                }
                observe() {}
                stopObserving() {}
            }
            class My extends ie {
                static get pluginName() {
                    return "Input"
                }
                init() {
                    const e = this.editor
                      , t = e.model
                      , r = e.editing.view
                      , i = t.document.selection;
                    r.addObserver(wz);
                    const l = new bz(e,e.config.get("typing.undoStep") || 20);
                    e.commands.add("insertText", l),
                    e.commands.add("input", l),
                    this.listenTo(r.document, "insertText", (d, h) => {
                        r.document.isComposing || h.preventDefault();
                        const {text: m, selection: g, resultRange: b} = h
                          , v = Array.from(g.getRanges()).map(I => e.editing.mapper.toModelRange(I));
                        let x = m;
                        if (E.isAndroid) {
                            const I = Array.from(v[0].getItems()).reduce( (P, O) => P + (O.is("$textProxy") ? O.data : ""), "");
                            I && (I.length <= x.length ? x.startsWith(I) && (x = x.substring(I.length),
                            v[0].start = v[0].start.getShiftedBy(I.length)) : I.startsWith(x) && (v[0].start = v[0].start.getShiftedBy(x.length),
                            x = ""))
                        }
                        const T = {
                            text: x,
                            selection: t.createSelection(v)
                        };
                        b && (T.resultRange = e.editing.mapper.toModelRange(b)),
                        e.execute("insertText", T),
                        r.scrollToTheSelection()
                    }
                    ),
                    E.isAndroid ? this.listenTo(r.document, "keydown", (d, h) => {
                        !i.isCollapsed && h.keyCode == 229 && r.document.isComposing && By(t, l)
                    }
                    ) : this.listenTo(r.document, "compositionstart", () => {
                        i.isCollapsed || By(t, l)
                    }
                    )
                }
            }
            function By(s, e) {
                if (!e.isEnabled)
                    return;
                const t = e.buffer;
                t.lock(),
                s.enqueueChange(t.batch, () => {
                    s.deleteContent(s.document.selection)
                }
                ),
                t.unlock()
            }
            class Ny extends _e {
                constructor(e, t) {
                    super(e),
                    C(this, "direction"),
                    C(this, "_buffer"),
                    this.direction = t,
                    this._buffer = new Ty(e.model,e.config.get("typing.undoStep")),
                    this._isEnabledBasedOnSelection = !1
                }
                get buffer() {
                    return this._buffer
                }
                execute(e={}) {
                    const t = this.editor.model
                      , r = t.document;
                    t.enqueueChange(this._buffer.batch, i => {
                        this._buffer.lock();
                        const l = i.createSelection(e.selection || r.selection);
                        if (!t.canEditAt(l))
                            return;
                        const d = e.sequence || 1
                          , h = l.isCollapsed;
                        if (l.isCollapsed && t.modifySelection(l, {
                            direction: this.direction,
                            unit: e.unit,
                            treatEmojiAsSingleUnit: !0
                        }),
                        this._shouldEntireContentBeReplacedWithParagraph(d))
                            return void this._replaceEntireContentWithParagraph(i);
                        if (this._shouldReplaceFirstBlockWithParagraph(l, d))
                            return void this.editor.execute("paragraph", {
                                selection: l
                            });
                        if (l.isCollapsed)
                            return;
                        let m = 0;
                        l.getFirstRange().getMinimalFlatRanges().forEach(g => {
                            m += Sm(g.getWalker({
                                singleCharacters: !0,
                                ignoreElementEnd: !0,
                                shallow: !0
                            }))
                        }
                        ),
                        t.deleteContent(l, {
                            doNotResetEntireContent: h,
                            direction: this.direction
                        }),
                        this._buffer.input(m),
                        i.setSelection(l),
                        this._buffer.unlock()
                    }
                    )
                }
                _shouldEntireContentBeReplacedWithParagraph(e) {
                    if (e > 1)
                        return !1;
                    const t = this.editor.model
                      , r = t.document.selection
                      , i = t.schema.getLimitElement(r);
                    if (!(r.isCollapsed && r.containsEntireContent(i)) || !t.schema.checkChild(i, "paragraph"))
                        return !1;
                    const l = i.getChild(0);
                    return !l || !l.is("element", "paragraph")
                }
                _replaceEntireContentWithParagraph(e) {
                    const t = this.editor.model
                      , r = t.document.selection
                      , i = t.schema.getLimitElement(r)
                      , l = e.createElement("paragraph");
                    e.remove(e.createRangeIn(i)),
                    e.insert(l, i),
                    e.setSelection(l, 0)
                }
                _shouldReplaceFirstBlockWithParagraph(e, t) {
                    const r = this.editor.model;
                    if (t > 1 || this.direction != "backward" || !e.isCollapsed)
                        return !1;
                    const i = e.getFirstPosition()
                      , l = r.schema.getLimitElement(i)
                      , d = l.getChild(0);
                    return i.parent == d && !!e.containsEntireContent(d) && !!r.schema.checkChild(l, "paragraph") && d.name != "paragraph"
                }
            }
            const Py = "word"
              , Pn = "selection"
              , Rs = "backward"
              , Bl = "forward"
              , jy = {
                deleteContent: {
                    unit: Pn,
                    direction: Rs
                },
                deleteContentBackward: {
                    unit: "codePoint",
                    direction: Rs
                },
                deleteWordBackward: {
                    unit: Py,
                    direction: Rs
                },
                deleteHardLineBackward: {
                    unit: Pn,
                    direction: Rs
                },
                deleteSoftLineBackward: {
                    unit: Pn,
                    direction: Rs
                },
                deleteContentForward: {
                    unit: "character",
                    direction: Bl
                },
                deleteWordForward: {
                    unit: Py,
                    direction: Bl
                },
                deleteHardLineForward: {
                    unit: Pn,
                    direction: Bl
                },
                deleteSoftLineForward: {
                    unit: Pn,
                    direction: Bl
                }
            };
            class Az extends Nr {
                constructor(e) {
                    super(e);
                    const t = e.document;
                    let r = 0;
                    t.on("keydown", () => {
                        r++
                    }
                    ),
                    t.on("keyup", () => {
                        r = 0
                    }
                    ),
                    t.on("beforeinput", (i, l) => {
                        if (!this.isEnabled)
                            return;
                        const {targetRanges: d, domEvent: h, inputType: m} = l
                          , g = jy[m];
                        if (!g)
                            return;
                        const b = {
                            direction: g.direction,
                            unit: g.unit,
                            sequence: r
                        };
                        b.unit == Pn && (b.selectionToRemove = e.createSelection(d[0])),
                        m === "deleteContentBackward" && (E.isAndroid && (b.sequence = 1),
                        function(x) {
                            if (x.length != 1 || x[0].isCollapsed)
                                return !1;
                            const T = x[0].getWalker({
                                direction: "backward",
                                singleCharacters: !0,
                                ignoreElementEnd: !0
                            });
                            let I = 0;
                            for (const {nextPosition: P, item: O} of T) {
                                if (P.parent.is("$text")) {
                                    const F = P.parent.data
                                      , q = P.offset;
                                    if (tp(F, q) || op(F, q) || sv(F, q))
                                        continue;
                                    I++
                                } else
                                    (O.is("containerElement") || O.is("emptyElement")) && I++;
                                if (I > 1)
                                    return !0
                            }
                            return !1
                        }(d) && (b.unit = Pn,
                        b.selectionToRemove = e.createSelection(d)));
                        const v = new xs(t,"delete",d[0]);
                        t.fire(v, new Ds(e,h,b)),
                        v.stop.called && i.stop()
                    }
                    ),
                    E.isBlink && function(i) {
                        const l = i.view
                          , d = l.document;
                        let h = null
                          , m = !1;
                        function g(v) {
                            return v == Me.backspace || v == Me.delete
                        }
                        function b(v) {
                            return v == Me.backspace ? Rs : Bl
                        }
                        d.on("keydown", (v, {keyCode: x}) => {
                            h = x,
                            m = !1
                        }
                        ),
                        d.on("keyup", (v, {keyCode: x, domEvent: T}) => {
                            const I = d.selection
                              , P = i.isEnabled && x == h && g(x) && !I.isCollapsed && !m;
                            if (h = null,
                            P) {
                                const O = I.getFirstRange()
                                  , F = new xs(d,"delete",O)
                                  , q = {
                                    unit: Pn,
                                    direction: b(x),
                                    selectionToRemove: I
                                };
                                d.fire(F, new Ds(l,T,q))
                            }
                        }
                        ),
                        d.on("beforeinput", (v, {inputType: x}) => {
                            const T = jy[x];
                            g(h) && T && T.direction == b(h) && (m = !0)
                        }
                        , {
                            priority: "high"
                        }),
                        d.on("beforeinput", (v, {inputType: x, data: T}) => {
                            h == Me.delete && x == "insertText" && T == "" && v.stop()
                        }
                        , {
                            priority: "high"
                        })
                    }(this)
                }
                observe() {}
                stopObserving() {}
            }
            class Xr extends ie {
                constructor() {
                    super(...arguments),
                    C(this, "_undoOnBackspace")
                }
                static get pluginName() {
                    return "Delete"
                }
                init() {
                    const e = this.editor
                      , t = e.editing.view
                      , r = t.document
                      , i = e.model.document;
                    t.addObserver(Az),
                    this._undoOnBackspace = !1;
                    const l = new Ny(e,"forward");
                    e.commands.add("deleteForward", l),
                    e.commands.add("forwardDelete", l),
                    e.commands.add("delete", new Ny(e,"backward")),
                    this.listenTo(r, "delete", (d, h) => {
                        r.isComposing || h.preventDefault();
                        const {direction: m, sequence: g, selectionToRemove: b, unit: v} = h
                          , x = m === "forward" ? "deleteForward" : "delete"
                          , T = {
                            sequence: g
                        };
                        if (v == "selection") {
                            const I = Array.from(b.getRanges()).map(P => e.editing.mapper.toModelRange(P));
                            T.selection = e.model.createSelection(I)
                        } else
                            T.unit = v;
                        e.execute(x, T),
                        t.scrollToTheSelection()
                    }
                    , {
                        priority: "low"
                    }),
                    this.editor.plugins.has("UndoEditing") && (this.listenTo(r, "delete", (d, h) => {
                        this._undoOnBackspace && h.direction == "backward" && h.sequence == 1 && h.unit == "codePoint" && (this._undoOnBackspace = !1,
                        e.execute("undo"),
                        h.preventDefault(),
                        d.stop())
                    }
                    , {
                        context: "$capture"
                    }),
                    this.listenTo(i, "change", () => {
                        this._undoOnBackspace = !1
                    }
                    ))
                }
                requestUndoOnBackspace() {
                    this.editor.plugins.has("UndoEditing") && (this._undoOnBackspace = !0)
                }
            }
            class vz extends ie {
                static get requires() {
                    return [My, Xr]
                }
                static get pluginName() {
                    return "Typing"
                }
            }
            function Ly(s, e) {
                let t = s.start;
                return {
                    text: Array.from(s.getWalker({
                        ignoreElementEnd: !1
                    })).reduce( (r, {item: i}) => i.is("$text") || i.is("$textProxy") ? r + i.data : (t = e.createPositionAfter(i),
                    ""), ""),
                    range: e.createRange(t, s.end)
                }
            }
            class zy extends ye() {
                constructor(e, t) {
                    super(),
                    C(this, "model"),
                    C(this, "testCallback"),
                    C(this, "_hasMatch"),
                    this.model = e,
                    this.testCallback = t,
                    this._hasMatch = !1,
                    this.set("isEnabled", !0),
                    this.on("change:isEnabled", () => {
                        this.isEnabled ? this._startListening() : (this.stopListening(e.document.selection),
                        this.stopListening(e.document))
                    }
                    ),
                    this._startListening()
                }
                get hasMatch() {
                    return this._hasMatch
                }
                _startListening() {
                    const e = this.model.document;
                    this.listenTo(e.selection, "change:range", (t, {directChange: r}) => {
                        r && (e.selection.isCollapsed ? this._evaluateTextBeforeSelection("selection") : this.hasMatch && (this.fire("unmatched"),
                        this._hasMatch = !1))
                    }
                    ),
                    this.listenTo(e, "change:data", (t, r) => {
                        !r.isUndo && r.isLocal && this._evaluateTextBeforeSelection("data", {
                            batch: r
                        })
                    }
                    )
                }
                _evaluateTextBeforeSelection(e, t={}) {
                    const r = this.model
                      , i = r.document.selection
                      , l = r.createRange(r.createPositionAt(i.focus.parent, 0), i.focus)
                      , {text: d, range: h} = Ly(l, r)
                      , m = this.testCallback(d);
                    if (!m && this.hasMatch && this.fire("unmatched"),
                    this._hasMatch = !!m,
                    m) {
                        const g = Object.assign(t, {
                            text: d,
                            range: h
                        });
                        typeof m == "object" && Object.assign(g, m),
                        this.fire(`matched:${e}`, g)
                    }
                }
            }
            class Oy extends ie {
                constructor(e) {
                    super(e),
                    C(this, "attributes"),
                    C(this, "_overrideUid"),
                    C(this, "_isNextGravityRestorationSkipped", !1),
                    this.attributes = new Set,
                    this._overrideUid = null
                }
                static get pluginName() {
                    return "TwoStepCaretMovement"
                }
                init() {
                    const e = this.editor
                      , t = e.model
                      , r = e.editing.view
                      , i = e.locale
                      , l = t.document.selection;
                    this.listenTo(r.document, "arrowKey", (d, h) => {
                        if (!l.isCollapsed || h.shiftKey || h.altKey || h.ctrlKey)
                            return;
                        const m = h.keyCode == Me.arrowright
                          , g = h.keyCode == Me.arrowleft;
                        if (!m && !g)
                            return;
                        const b = i.contentLanguageDirection;
                        let v = !1;
                        v = b === "ltr" && m || b === "rtl" && g ? this._handleForwardMovement(h) : this._handleBackwardMovement(h),
                        v === !0 && d.stop()
                    }
                    , {
                        context: "$text",
                        priority: "highest"
                    }),
                    this.listenTo(l, "change:range", (d, h) => {
                        this._isNextGravityRestorationSkipped ? this._isNextGravityRestorationSkipped = !1 : this._isGravityOverridden && (!h.directChange && Yo(l.getFirstPosition(), this.attributes) || this._restoreGravity())
                    }
                    ),
                    this._enableClickingAfterNode(),
                    this._enableInsertContentSelectionAttributesFixer(),
                    this._handleDeleteContentAfterNode()
                }
                registerAttribute(e) {
                    this.attributes.add(e)
                }
                _handleForwardMovement(e) {
                    const t = this.attributes
                      , r = this.editor.model
                      , i = r.document.selection
                      , l = i.getFirstPosition();
                    return !this._isGravityOverridden && (!l.isAtStart || !en(i, t)) && !!Yo(l, t) && (Pl(e),
                    en(i, t) && Yo(l, t, !0) ? Nl(r, t) : this._overrideGravity(),
                    !0)
                }
                _handleBackwardMovement(e) {
                    const t = this.attributes
                      , r = this.editor.model
                      , i = r.document.selection
                      , l = i.getFirstPosition();
                    return this._isGravityOverridden ? (Pl(e),
                    this._restoreGravity(),
                    Yo(l, t, !0) ? Nl(r, t) : lu(r, t, l),
                    !0) : l.isAtStart ? !!en(i, t) && (Pl(e),
                    lu(r, t, l),
                    !0) : !en(i, t) && Yo(l, t, !0) ? (Pl(e),
                    lu(r, t, l),
                    !0) : !!Ry(l, t) && (l.isAtEnd && !en(i, t) && Yo(l, t) ? (Pl(e),
                    lu(r, t, l),
                    !0) : (this._isNextGravityRestorationSkipped = !0,
                    this._overrideGravity(),
                    !1))
                }
                _enableClickingAfterNode() {
                    const e = this.editor
                      , t = e.model
                      , r = t.document.selection
                      , i = e.editing.view.document;
                    e.editing.view.addObserver(zp);
                    let l = !1;
                    this.listenTo(i, "mousedown", () => {
                        l = !0
                    }
                    ),
                    this.listenTo(i, "selectionChange", () => {
                        const d = this.attributes;
                        if (!l || (l = !1,
                        !r.isCollapsed) || !en(r, d))
                            return;
                        const h = r.getFirstPosition();
                        Yo(h, d) && (h.isAtStart || Yo(h, d, !0) ? Nl(t, d) : this._isGravityOverridden || this._overrideGravity())
                    }
                    )
                }
                _enableInsertContentSelectionAttributesFixer() {
                    const e = this.editor.model
                      , t = e.document.selection
                      , r = this.attributes;
                    this.listenTo(e, "insertContent", () => {
                        const i = t.getFirstPosition();
                        en(t, r) && Yo(i, r) && Nl(e, r)
                    }
                    , {
                        priority: "low"
                    })
                }
                _handleDeleteContentAfterNode() {
                    const e = this.editor
                      , t = e.model
                      , r = t.document.selection
                      , i = e.editing.view;
                    let l = !1
                      , d = !1;
                    this.listenTo(i.document, "delete", (h, m) => {
                        l = m.direction === "backward"
                    }
                    , {
                        priority: "high"
                    }),
                    this.listenTo(t, "deleteContent", () => {
                        if (!l)
                            return;
                        const h = r.getFirstPosition();
                        d = en(r, this.attributes) && !Ry(h, this.attributes)
                    }
                    , {
                        priority: "high"
                    }),
                    this.listenTo(t, "deleteContent", () => {
                        l && (l = !1,
                        d || e.model.enqueueChange( () => {
                            const h = r.getFirstPosition();
                            en(r, this.attributes) && Yo(h, this.attributes) && (h.isAtStart || Yo(h, this.attributes, !0) ? Nl(t, this.attributes) : this._isGravityOverridden || this._overrideGravity())
                        }
                        ))
                    }
                    , {
                        priority: "low"
                    })
                }
                get _isGravityOverridden() {
                    return !!this._overrideUid
                }
                _overrideGravity() {
                    this._overrideUid = this.editor.model.change(e => e.overrideSelectionGravity())
                }
                _restoreGravity() {
                    this.editor.model.change(e => {
                        e.restoreSelectionGravity(this._overrideUid),
                        this._overrideUid = null
                    }
                    )
                }
            }
            function en(s, e) {
                for (const t of e)
                    if (s.hasAttribute(t))
                        return !0;
                return !1
            }
            function lu(s, e, t) {
                const r = t.nodeBefore;
                s.change(i => {
                    if (r) {
                        const l = []
                          , d = s.schema.isObject(r) && s.schema.isInline(r);
                        for (const [h,m] of r.getAttributes())
                            !s.schema.checkAttribute("$text", h) || d && s.schema.getAttributeProperties(h).copyFromObject === !1 || l.push([h, m]);
                        i.setSelectionAttribute(l)
                    } else
                        i.removeSelectionAttribute(e)
                }
                )
            }
            function Nl(s, e) {
                s.change(t => {
                    t.removeSelectionAttribute(e)
                }
                )
            }
            function Pl(s) {
                s.preventDefault()
            }
            function Ry(s, e) {
                return Yo(s.getShiftedBy(-1), e)
            }
            function Yo(s, e, t=!1) {
                const {nodeBefore: r, nodeAfter: i} = s;
                for (const l of e) {
                    const d = r ? r.getAttribute(l) : void 0
                      , h = i ? i.getAttribute(l) : void 0;
                    if ((!t || d !== void 0 && h !== void 0) && h !== d)
                        return !0
                }
                return !1
            }
            const Fy = {
                copyright: {
                    from: "(c)",
                    to: "©"
                },
                registeredTrademark: {
                    from: "(r)",
                    to: "®"
                },
                trademark: {
                    from: "(tm)",
                    to: "™"
                },
                oneHalf: {
                    from: /(^|[^/a-z0-9])(1\/2)([^/a-z0-9])$/i,
                    to: [null, "½", null]
                },
                oneThird: {
                    from: /(^|[^/a-z0-9])(1\/3)([^/a-z0-9])$/i,
                    to: [null, "⅓", null]
                },
                twoThirds: {
                    from: /(^|[^/a-z0-9])(2\/3)([^/a-z0-9])$/i,
                    to: [null, "⅔", null]
                },
                oneForth: {
                    from: /(^|[^/a-z0-9])(1\/4)([^/a-z0-9])$/i,
                    to: [null, "¼", null]
                },
                threeQuarters: {
                    from: /(^|[^/a-z0-9])(3\/4)([^/a-z0-9])$/i,
                    to: [null, "¾", null]
                },
                lessThanOrEqual: {
                    from: "<=",
                    to: "≤"
                },
                greaterThanOrEqual: {
                    from: ">=",
                    to: "≥"
                },
                notEqual: {
                    from: "!=",
                    to: "≠"
                },
                arrowLeft: {
                    from: "<-",
                    to: "←"
                },
                arrowRight: {
                    from: "->",
                    to: "→"
                },
                horizontalEllipsis: {
                    from: "...",
                    to: "…"
                },
                enDash: {
                    from: /(^| )(--)( )$/,
                    to: [null, "–", null]
                },
                emDash: {
                    from: /(^| )(---)( )$/,
                    to: [null, "—", null]
                },
                quotesPrimary: {
                    from: Fs('"'),
                    to: [null, "“", null, "”"]
                },
                quotesSecondary: {
                    from: Fs("'"),
                    to: [null, "‘", null, "’"]
                },
                quotesPrimaryEnGb: {
                    from: Fs("'"),
                    to: [null, "‘", null, "’"]
                },
                quotesSecondaryEnGb: {
                    from: Fs('"'),
                    to: [null, "“", null, "”"]
                },
                quotesPrimaryPl: {
                    from: Fs('"'),
                    to: [null, "„", null, "”"]
                },
                quotesSecondaryPl: {
                    from: Fs("'"),
                    to: [null, "‚", null, "’"]
                }
            }
              , Vy = {
                symbols: ["copyright", "registeredTrademark", "trademark"],
                mathematical: ["oneHalf", "oneThird", "twoThirds", "oneForth", "threeQuarters", "lessThanOrEqual", "greaterThanOrEqual", "notEqual", "arrowLeft", "arrowRight"],
                typography: ["horizontalEllipsis", "enDash", "emDash"],
                quotes: ["quotesPrimary", "quotesSecondary"]
            }
              , _z = ["symbols", "mathematical", "typography", "quotes"];
            class Cz extends ie {
                static get requires() {
                    return ["Delete", "Input"]
                }
                static get pluginName() {
                    return "TextTransformation"
                }
                constructor(e) {
                    super(e),
                    e.config.define("typing", {
                        transformations: {
                            include: _z
                        }
                    })
                }
                init() {
                    const e = this.editor.model.document.selection;
                    e.on("change:range", () => {
                        this.isEnabled = !e.anchor.parent.is("element", "codeBlock")
                    }
                    ),
                    this._enableTransformationWatchers()
                }
                _enableTransformationWatchers() {
                    const e = this.editor
                      , t = e.model
                      , r = e.plugins.get("Delete")
                      , i = function(d) {
                        const h = d.extra || []
                          , m = d.remove || []
                          , g = b => !m.includes(b);
                        return function(b) {
                            const v = new Set;
                            for (const x of b)
                                if (typeof x == "string" && Vy[x])
                                    for (const T of Vy[x])
                                        v.add(T);
                                else
                                    v.add(x);
                            return Array.from(v)
                        }(d.include.concat(h).filter(g)).filter(g).map(b => typeof b == "string" && Fy[b] ? Fy[b] : b).filter(b => typeof b == "object").map(b => ({
                            from: yz(b.from),
                            to: xz(b.to)
                        }))
                    }(e.config.get("typing.transformations"))
                      , l = new zy(e.model,d => {
                        for (const h of i)
                            if (h.from.test(d))
                                return {
                                    normalizedTransformation: h
                                }
                    }
                    );
                    l.on("matched:data", (d, h) => {
                        if (!h.batch.isTyping)
                            return;
                        const {from: m, to: g} = h.normalizedTransformation
                          , b = m.exec(h.text)
                          , v = g(b.slice(1))
                          , x = h.range;
                        let T = b.index;
                        t.enqueueChange(I => {
                            for (let P = 1; P < b.length; P++) {
                                const O = b[P]
                                  , F = v[P - 1];
                                if (F == null) {
                                    T += O.length;
                                    continue
                                }
                                const q = x.start.getShiftedBy(T)
                                  , Q = t.createRange(q, q.getShiftedBy(O.length))
                                  , X = Ez(q);
                                t.insertContent(I.createText(F, X), Q),
                                T += F.length
                            }
                            t.enqueueChange( () => {
                                r.requestUndoOnBackspace()
                            }
                            )
                        }
                        )
                    }
                    ),
                    l.bind("isEnabled").to(this)
                }
            }
            function yz(s) {
                return typeof s == "string" ? new RegExp(`(${BL(s)})$`) : s
            }
            function xz(s) {
                return typeof s == "string" ? () => [s] : s instanceof Array ? () => s : s
            }
            function Ez(s) {
                return (s.textNode ? s.textNode : s.nodeAfter).getAttributes()
            }
            function Fs(s) {
                return new RegExp(`(^|\\s)(${s})([^${s}]*)(${s})$`)
            }
            function cu(s, e, t, r) {
                return r.createRange(Uy(s, e, t, !0, r), Uy(s, e, t, !1, r))
            }
            function Uy(s, e, t, r, i) {
                let l = s.textNode || (r ? s.nodeBefore : s.nodeAfter)
                  , d = null;
                for (; l && l.getAttribute(e) == t; )
                    d = l,
                    l = r ? l.previousSibling : l.nextSibling;
                return d ? i.createPositionAt(d, r ? "before" : "after") : s
            }
            function *Hy(s, e) {
                for (const t of e)
                    t && s.getAttributeProperties(t[0]).copyOnEnter && (yield t)
            }
            class Sz extends _e {
                execute() {
                    this.editor.model.change(e => {
                        this.enterBlock(e),
                        this.fire("afterExecute", {
                            writer: e
                        })
                    }
                    )
                }
                enterBlock(e) {
                    const t = this.editor.model
                      , r = t.document.selection
                      , i = t.schema
                      , l = r.isCollapsed
                      , d = r.getFirstRange()
                      , h = d.start.parent
                      , m = d.end.parent;
                    if (i.isLimit(h) || i.isLimit(m))
                        return l || h != m || t.deleteContent(r),
                        !1;
                    if (l) {
                        const g = Hy(e.model.schema, r.getAttributes());
                        return Wy(e, d.start),
                        e.setSelectionAttribute(g),
                        !0
                    }
                    {
                        const g = !(d.start.isAtStart && d.end.isAtEnd)
                          , b = h == m;
                        if (t.deleteContent(r, {
                            leaveUnmerged: g
                        }),
                        g) {
                            if (b)
                                return Wy(e, r.focus),
                                !0;
                            e.setSelection(m, 0)
                        }
                    }
                    return !1
                }
            }
            function Wy(s, e) {
                s.split(e),
                s.setSelection(e.parent.nextSibling, 0)
            }
            const Dz = {
                insertParagraph: {
                    isSoft: !1
                },
                insertLineBreak: {
                    isSoft: !0
                }
            };
            class $y extends Nr {
                constructor(e) {
                    super(e);
                    const t = this.document;
                    let r = !1;
                    t.on("keydown", (i, l) => {
                        r = l.shiftKey
                    }
                    ),
                    t.on("beforeinput", (i, l) => {
                        if (!this.isEnabled)
                            return;
                        let d = l.inputType;
                        E.isSafari && r && d == "insertParagraph" && (d = "insertLineBreak");
                        const h = l.domEvent
                          , m = Dz[d];
                        if (!m)
                            return;
                        const g = new xs(t,"enter",l.targetRanges[0]);
                        t.fire(g, new Ds(e,h,{
                            isSoft: m.isSoft
                        })),
                        g.stop.called && i.stop()
                    }
                    )
                }
                observe() {}
                stopObserving() {}
            }
            class du extends ie {
                static get pluginName() {
                    return "Enter"
                }
                init() {
                    const e = this.editor
                      , t = e.editing.view
                      , r = t.document
                      , i = this.editor.t;
                    t.addObserver($y),
                    e.commands.add("enter", new Sz(e)),
                    this.listenTo(r, "enter", (l, d) => {
                        r.isComposing || d.preventDefault(),
                        d.isSoft || (e.execute("enter"),
                        t.scrollToTheSelection())
                    }
                    , {
                        priority: "low"
                    }),
                    e.accessibility.addKeystrokeInfos({
                        keystrokes: [{
                            label: i("Insert a hard break (a new paragraph)"),
                            keystroke: "Enter"
                        }]
                    })
                }
            }
            class Tz extends _e {
                execute() {
                    const e = this.editor.model
                      , t = e.document;
                    e.change(r => {
                        (function(i, l, d) {
                            const h = d.isCollapsed
                              , m = d.getFirstRange()
                              , g = m.start.parent
                              , b = m.end.parent
                              , v = g == b;
                            if (h) {
                                const x = Hy(i.schema, d.getAttributes());
                                qy(i, l, m.end),
                                l.removeSelectionAttribute(d.getAttributeKeys()),
                                l.setSelectionAttribute(x)
                            } else {
                                const x = !(m.start.isAtStart && m.end.isAtEnd);
                                i.deleteContent(d, {
                                    leaveUnmerged: x
                                }),
                                v ? qy(i, l, d.focus) : x && l.setSelection(b, 0)
                            }
                        }
                        )(e, r, t.selection),
                        this.fire("afterExecute", {
                            writer: r
                        })
                    }
                    )
                }
                refresh() {
                    const e = this.editor.model
                      , t = e.document;
                    this.isEnabled = function(r, i) {
                        if (i.rangeCount > 1)
                            return !1;
                        const l = i.anchor;
                        if (!l || !r.checkChild(l, "softBreak"))
                            return !1;
                        const d = i.getFirstRange()
                          , h = d.start.parent
                          , m = d.end.parent;
                        return !((rg(h, r) || rg(m, r)) && h !== m)
                    }(e.schema, t.selection)
                }
            }
            function qy(s, e, t) {
                const r = e.createElement("softBreak");
                s.insertContent(r, t),
                e.setSelection(r, "after")
            }
            function rg(s, e) {
                return !s.is("rootElement") && (e.isLimit(s) || rg(s.parent, e))
            }
            class Iz extends ie {
                static get pluginName() {
                    return "ShiftEnter"
                }
                init() {
                    const e = this.editor
                      , t = e.model.schema
                      , r = e.conversion
                      , i = e.editing.view
                      , l = i.document
                      , d = this.editor.t;
                    t.register("softBreak", {
                        allowWhere: "$text",
                        isInline: !0
                    }),
                    r.for("upcast").elementToElement({
                        model: "softBreak",
                        view: "br"
                    }),
                    r.for("downcast").elementToElement({
                        model: "softBreak",
                        view: (h, {writer: m}) => m.createEmptyElement("br")
                    }),
                    i.addObserver($y),
                    e.commands.add("shiftEnter", new Tz(e)),
                    this.listenTo(l, "enter", (h, m) => {
                        l.isComposing || m.preventDefault(),
                        m.isSoft && (e.execute("shiftEnter"),
                        i.scrollToTheSelection())
                    }
                    , {
                        priority: "low"
                    }),
                    e.accessibility.addKeystrokeInfos({
                        keystrokes: [{
                            label: d("Insert a soft break (a <code>&lt;br&gt;</code> element)"),
                            keystroke: "Shift+Enter"
                        }]
                    })
                }
            }
            class Mz extends Se() {
                constructor() {
                    super(...arguments),
                    C(this, "_stack", [])
                }
                add(e, t) {
                    const r = this._stack
                      , i = r[0];
                    this._insertDescriptor(e);
                    const l = r[0];
                    i === l || ng(i, l) || this.fire("change:top", {
                        oldDescriptor: i,
                        newDescriptor: l,
                        writer: t
                    })
                }
                remove(e, t) {
                    const r = this._stack
                      , i = r[0];
                    this._removeDescriptor(e);
                    const l = r[0];
                    i === l || ng(i, l) || this.fire("change:top", {
                        oldDescriptor: i,
                        newDescriptor: l,
                        writer: t
                    })
                }
                _insertDescriptor(e) {
                    const t = this._stack
                      , r = t.findIndex(l => l.id === e.id);
                    if (ng(e, t[r]))
                        return;
                    r > -1 && t.splice(r, 1);
                    let i = 0;
                    for (; t[i] && Bz(t[i], e); )
                        i++;
                    t.splice(i, 0, e)
                }
                _removeDescriptor(e) {
                    const t = this._stack
                      , r = t.findIndex(i => i.id === e);
                    r > -1 && t.splice(r, 1)
                }
            }
            function ng(s, e) {
                return s && e && s.priority == e.priority && uu(s.classes) == uu(e.classes)
            }
            function Bz(s, e) {
                return s.priority > e.priority || !(s.priority < e.priority) && uu(s.classes) > uu(e.classes)
            }
            function uu(s) {
                return Array.isArray(s) ? s.sort().join(",") : s
            }
            const Nz = '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M4 0v1H1v3H0V.5A.5.5 0 0 1 .5 0H4zm8 0h3.5a.5.5 0 0 1 .5.5V4h-1V1h-3V0zM4 16H.5a.5.5 0 0 1-.5-.5V12h1v3h3v1zm8 0v-1h3v-3h1v3.5a.5.5 0 0 1-.5.5H12z"/><path fill-opacity=".256" d="M1 1h14v14H1z"/><g class="ck-icon__selected-indicator"><path d="M7 0h2v1H7V0zM0 7h1v2H0V7zm15 0h1v2h-1V7zm-8 8h2v1H7v-1z"/><path fill-opacity=".254" d="M1 1h14v14H1z"/></g></svg>'
              , Pz = "ck-widget"
              , Gy = "ck-widget_selected";
            function At(s) {
                return !!s.is("element") && !!s.getCustomProperty("widget")
            }
            function ig(s, e, t={}) {
                if (!s.is("containerElement"))
                    throw new U("widget-to-widget-wrong-element-type",null,{
                        element: s
                    });
                return e.setAttribute("contenteditable", "false", s),
                e.addClass(Pz, s),
                e.setCustomProperty("widget", !0, s),
                s.getFillerOffset = zz,
                e.setCustomProperty("widgetLabel", [], s),
                t.label && function(r, i) {
                    r.getCustomProperty("widgetLabel").push(i)
                }(s, t.label),
                t.hasSelectionHandle && function(r, i) {
                    const l = i.createUIElement("div", {
                        class: "ck ck-widget__selection-handle"
                    }, function(d) {
                        const h = this.toDomElement(d)
                          , m = new Ni;
                        return m.set("content", Nz),
                        m.render(),
                        h.appendChild(m.element),
                        h
                    });
                    i.insert(i.createPositionAt(r, 0), l),
                    i.addClass(["ck-widget_with-selection-handle"], r)
                }(s, e),
                Ky(s, e),
                s
            }
            function jz(s, e, t) {
                if (e.classes && t.addClass(Ze(e.classes), s),
                e.attributes)
                    for (const r in e.attributes)
                        t.setAttribute(r, e.attributes[r], s)
            }
            function Lz(s, e, t) {
                if (e.classes && t.removeClass(Ze(e.classes), s),
                e.attributes)
                    for (const r in e.attributes)
                        t.removeAttribute(r, s)
            }
            function Ky(s, e, t=jz, r=Lz) {
                const i = new Mz;
                i.on("change:top", (l, d) => {
                    d.oldDescriptor && r(s, d.oldDescriptor, d.writer),
                    d.newDescriptor && t(s, d.newDescriptor, d.writer)
                }
                ),
                e.setCustomProperty("addHighlight", (l, d, h) => i.add(d, h), s),
                e.setCustomProperty("removeHighlight", (l, d, h) => i.remove(d, h), s)
            }
            function Yy(s, e, t={}) {
                return e.addClass(["ck-editor__editable", "ck-editor__nested-editable"], s),
                e.setAttribute("role", "textbox", s),
                e.setAttribute("tabindex", "-1", s),
                t.label && e.setAttribute("aria-label", t.label, s),
                e.setAttribute("contenteditable", s.isReadOnly ? "false" : "true", s),
                s.on("change:isReadOnly", (r, i, l) => {
                    e.setAttribute("contenteditable", l ? "false" : "true", s)
                }
                ),
                s.on("change:isFocused", (r, i, l) => {
                    l ? e.addClass("ck-editor__nested-editable_focused", s) : e.removeClass("ck-editor__nested-editable_focused", s)
                }
                ),
                Ky(s, e),
                s
            }
            function Qy(s, e) {
                const t = s.getSelectedElement();
                if (t) {
                    const r = jn(s);
                    if (r)
                        return e.createRange(e.createPositionAt(t, r))
                }
                return e.schema.findOptimalInsertionRange(s)
            }
            function zz() {
                return null
            }
            const tn = "widget-type-around";
            function Li(s, e, t) {
                return !!s && At(s) && !t.isInline(e)
            }
            function jn(s) {
                return s.getAttribute(tn)
            }
            var Zy = u(8508)
              , Oz = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(Zy.A, Oz),
            Zy.A.locals;
            const Jy = ["before", "after"]
              , Rz = new DOMParser().parseFromString('<svg viewBox="0 0 10 8" xmlns="http://www.w3.org/2000/svg"><path d="M9.055.263v3.972h-6.77M1 4.216l2-2.038m-2 2 2 2.038"/></svg>', "image/svg+xml").firstChild
              , Xy = "ck-widget__type-around_disabled";
            class Fz extends ie {
                constructor() {
                    super(...arguments),
                    C(this, "_currentFakeCaretModelElement", null)
                }
                static get pluginName() {
                    return "WidgetTypeAround"
                }
                static get requires() {
                    return [du, Xr]
                }
                init() {
                    const e = this.editor
                      , t = e.editing.view;
                    this.on("change:isEnabled", (r, i, l) => {
                        t.change(d => {
                            for (const h of t.document.roots)
                                l ? d.removeClass(Xy, h) : d.addClass(Xy, h)
                        }
                        ),
                        l || e.model.change(d => {
                            d.removeSelectionAttribute(tn)
                        }
                        )
                    }
                    ),
                    this._enableTypeAroundUIInjection(),
                    this._enableInsertingParagraphsOnButtonClick(),
                    this._enableInsertingParagraphsOnEnterKeypress(),
                    this._enableInsertingParagraphsOnTypingKeystroke(),
                    this._enableTypeAroundFakeCaretActivationUsingKeyboardArrows(),
                    this._enableDeleteIntegration(),
                    this._enableInsertContentIntegration(),
                    this._enableInsertObjectIntegration(),
                    this._enableDeleteContentIntegration()
                }
                destroy() {
                    super.destroy(),
                    this._currentFakeCaretModelElement = null
                }
                _insertParagraph(e, t) {
                    const r = this.editor
                      , i = r.editing.view
                      , l = r.model.schema.getAttributesWithProperty(e, "copyOnReplace", !0);
                    r.execute("insertParagraph", {
                        position: r.model.createPositionAt(e, t),
                        attributes: l
                    }),
                    i.focus(),
                    i.scrollToTheSelection()
                }
                _listenToIfEnabled(e, t, r, i) {
                    this.listenTo(e, t, (...l) => {
                        this.isEnabled && r(...l)
                    }
                    , i)
                }
                _insertParagraphAccordingToFakeCaretPosition() {
                    const e = this.editor.model.document.selection
                      , t = jn(e);
                    if (!t)
                        return !1;
                    const r = e.getSelectedElement();
                    return this._insertParagraph(r, t),
                    !0
                }
                _enableTypeAroundUIInjection() {
                    const e = this.editor
                      , t = e.model.schema
                      , r = e.locale.t
                      , i = {
                        before: r("Insert paragraph before block"),
                        after: r("Insert paragraph after block")
                    };
                    e.editing.downcastDispatcher.on("insert", (l, d, h) => {
                        const m = h.mapper.toViewElement(d.item);
                        m && Li(m, d.item, t) && (function(g, b, v) {
                            const x = g.createUIElement("div", {
                                class: "ck ck-reset_all ck-widget__type-around"
                            }, function(T) {
                                const I = this.toDomElement(T);
                                return function(P, O) {
                                    for (const F of Jy) {
                                        const q = new hr({
                                            tag: "div",
                                            attributes: {
                                                class: ["ck", "ck-widget__type-around__button", `ck-widget__type-around__button_${F}`],
                                                title: O[F],
                                                "aria-hidden": "true"
                                            },
                                            children: [P.ownerDocument.importNode(Rz, !0)]
                                        });
                                        P.appendChild(q.render())
                                    }
                                }(I, b),
                                function(P) {
                                    const O = new hr({
                                        tag: "div",
                                        attributes: {
                                            class: ["ck", "ck-widget__type-around__fake-caret"]
                                        }
                                    });
                                    P.appendChild(O.render())
                                }(I),
                                I
                            });
                            g.insert(g.createPositionAt(v, "end"), x)
                        }(h.writer, i, m),
                        m.getCustomProperty("widgetLabel").push( () => this.isEnabled ? r("Press Enter to type after or press Shift + Enter to type before the widget") : ""))
                    }
                    , {
                        priority: "low"
                    })
                }
                _enableTypeAroundFakeCaretActivationUsingKeyboardArrows() {
                    const e = this.editor
                      , t = e.model
                      , r = t.document.selection
                      , i = t.schema
                      , l = e.editing.view;
                    function d(h) {
                        return `ck-widget_type-around_show-fake-caret_${h}`
                    }
                    this._listenToIfEnabled(l.document, "arrowKey", (h, m) => {
                        this._handleArrowKeyPress(h, m)
                    }
                    , {
                        context: [At, "$text"],
                        priority: "high"
                    }),
                    this._listenToIfEnabled(r, "change:range", (h, m) => {
                        m.directChange && e.model.change(g => {
                            g.removeSelectionAttribute(tn)
                        }
                        )
                    }
                    ),
                    this._listenToIfEnabled(t.document, "change:data", () => {
                        const h = r.getSelectedElement();
                        h && Li(e.editing.mapper.toViewElement(h), h, i) || e.model.change(m => {
                            m.removeSelectionAttribute(tn)
                        }
                        )
                    }
                    ),
                    this._listenToIfEnabled(e.editing.downcastDispatcher, "selection", (h, m, g) => {
                        const b = g.writer;
                        if (this._currentFakeCaretModelElement) {
                            const I = g.mapper.toViewElement(this._currentFakeCaretModelElement);
                            I && (b.removeClass(Jy.map(d), I),
                            this._currentFakeCaretModelElement = null)
                        }
                        const v = m.selection.getSelectedElement();
                        if (!v)
                            return;
                        const x = g.mapper.toViewElement(v);
                        if (!Li(x, v, i))
                            return;
                        const T = jn(m.selection);
                        T && (b.addClass(d(T), x),
                        this._currentFakeCaretModelElement = v)
                    }
                    ),
                    this._listenToIfEnabled(e.ui.focusTracker, "change:isFocused", (h, m, g) => {
                        g || e.model.change(b => {
                            b.removeSelectionAttribute(tn)
                        }
                        )
                    }
                    )
                }
                _handleArrowKeyPress(e, t) {
                    const r = this.editor
                      , i = r.model
                      , l = i.document.selection
                      , d = i.schema
                      , h = r.editing.view
                      , m = function(v, x) {
                        const T = Zm(v, x);
                        return T === "down" || T === "right"
                    }(t.keyCode, r.locale.contentLanguageDirection)
                      , g = h.document.selection.getSelectedElement();
                    let b;
                    Li(g, r.editing.mapper.toModelElement(g), d) ? b = this._handleArrowKeyPressOnSelectedWidget(m) : l.isCollapsed ? b = this._handleArrowKeyPressWhenSelectionNextToAWidget(m) : t.shiftKey || (b = this._handleArrowKeyPressWhenNonCollapsedSelection(m)),
                    b && (t.preventDefault(),
                    e.stop())
                }
                _handleArrowKeyPressOnSelectedWidget(e) {
                    const t = this.editor.model
                      , r = jn(t.document.selection);
                    return t.change(i => r ? r !== (e ? "after" : "before") ? (i.removeSelectionAttribute(tn),
                    !0) : !1 : (i.setSelectionAttribute(tn, e ? "after" : "before"),
                    !0))
                }
                _handleArrowKeyPressWhenSelectionNextToAWidget(e) {
                    const t = this.editor
                      , r = t.model
                      , i = r.schema
                      , l = t.plugins.get("Widget")
                      , d = l._getObjectElementNextToSelection(e);
                    return !!Li(t.editing.mapper.toViewElement(d), d, i) && (r.change(h => {
                        l._setSelectionOverElement(d),
                        h.setSelectionAttribute(tn, e ? "before" : "after")
                    }
                    ),
                    !0)
                }
                _handleArrowKeyPressWhenNonCollapsedSelection(e) {
                    const t = this.editor
                      , r = t.model
                      , i = r.schema
                      , l = t.editing.mapper
                      , d = r.document.selection
                      , h = e ? d.getLastPosition().nodeBefore : d.getFirstPosition().nodeAfter;
                    return !!Li(l.toViewElement(h), h, i) && (r.change(m => {
                        m.setSelection(h, "on"),
                        m.setSelectionAttribute(tn, e ? "after" : "before")
                    }
                    ),
                    !0)
                }
                _enableInsertingParagraphsOnButtonClick() {
                    const e = this.editor
                      , t = e.editing.view;
                    this._listenToIfEnabled(t.document, "mousedown", (r, i) => {
                        const l = i.domTarget.closest(".ck-widget__type-around__button");
                        if (!l)
                            return;
                        const d = function(g) {
                            return g.classList.contains("ck-widget__type-around__button_before") ? "before" : "after"
                        }(l)
                          , h = function(g, b) {
                            const v = g.closest(".ck-widget");
                            return b.mapDomToView(v)
                        }(l, t.domConverter)
                          , m = e.editing.mapper.toModelElement(h);
                        this._insertParagraph(m, d),
                        i.preventDefault(),
                        r.stop()
                    }
                    )
                }
                _enableInsertingParagraphsOnEnterKeypress() {
                    const e = this.editor
                      , t = e.model.document.selection
                      , r = e.editing.view;
                    this._listenToIfEnabled(r.document, "enter", (i, l) => {
                        if (i.eventPhase != "atTarget")
                            return;
                        const d = t.getSelectedElement()
                          , h = e.editing.mapper.toViewElement(d)
                          , m = e.model.schema;
                        let g;
                        this._insertParagraphAccordingToFakeCaretPosition() ? g = !0 : Li(h, d, m) && (this._insertParagraph(d, l.isSoft ? "before" : "after"),
                        g = !0),
                        g && (l.preventDefault(),
                        i.stop())
                    }
                    , {
                        context: At
                    })
                }
                _enableInsertingParagraphsOnTypingKeystroke() {
                    const e = this.editor.editing.view.document;
                    this._listenToIfEnabled(e, "insertText", (t, r) => {
                        this._insertParagraphAccordingToFakeCaretPosition() && (r.selection = e.selection)
                    }
                    , {
                        priority: "high"
                    }),
                    E.isAndroid ? this._listenToIfEnabled(e, "keydown", (t, r) => {
                        r.keyCode == 229 && this._insertParagraphAccordingToFakeCaretPosition()
                    }
                    ) : this._listenToIfEnabled(e, "compositionstart", () => {
                        this._insertParagraphAccordingToFakeCaretPosition()
                    }
                    , {
                        priority: "high"
                    })
                }
                _enableDeleteIntegration() {
                    const e = this.editor
                      , t = e.editing.view
                      , r = e.model
                      , i = r.schema;
                    this._listenToIfEnabled(t.document, "delete", (l, d) => {
                        if (l.eventPhase != "atTarget")
                            return;
                        const h = jn(r.document.selection);
                        if (!h)
                            return;
                        const m = d.direction
                          , g = r.document.selection.getSelectedElement()
                          , b = m == "forward";
                        if (h === "before" === b)
                            e.execute("delete", {
                                selection: r.createSelection(g, "on")
                            });
                        else {
                            const v = i.getNearestSelectionRange(r.createPositionAt(g, h), m);
                            if (v)
                                if (v.isCollapsed) {
                                    const x = r.createSelection(v.start);
                                    if (r.modifySelection(x, {
                                        direction: m
                                    }),
                                    x.focus.isEqual(v.start)) {
                                        const T = function(I, P) {
                                            let O = P;
                                            for (const F of P.getAncestors({
                                                parentFirst: !0
                                            })) {
                                                if (F.childCount > 1 || I.isLimit(F))
                                                    break;
                                                O = F
                                            }
                                            return O
                                        }(i, v.start.parent);
                                        r.deleteContent(r.createSelection(T, "on"), {
                                            doNotAutoparagraph: !0
                                        })
                                    } else
                                        r.change(T => {
                                            T.setSelection(v),
                                            e.execute(b ? "deleteForward" : "delete")
                                        }
                                        )
                                } else
                                    r.change(x => {
                                        x.setSelection(v),
                                        e.execute(b ? "deleteForward" : "delete")
                                    }
                                    )
                        }
                        d.preventDefault(),
                        l.stop()
                    }
                    , {
                        context: At
                    })
                }
                _enableInsertContentIntegration() {
                    const e = this.editor
                      , t = this.editor.model
                      , r = t.document.selection;
                    this._listenToIfEnabled(e.model, "insertContent", (i, [l,d]) => {
                        if (d && !d.is("documentSelection"))
                            return;
                        const h = jn(r);
                        return h ? (i.stop(),
                        t.change(m => {
                            const g = r.getSelectedElement()
                              , b = t.createPositionAt(g, h)
                              , v = m.createSelection(b)
                              , x = t.insertContent(l, v);
                            return m.setSelection(v),
                            x
                        }
                        )) : void 0
                    }
                    , {
                        priority: "high"
                    })
                }
                _enableInsertObjectIntegration() {
                    const e = this.editor
                      , t = this.editor.model.document.selection;
                    this._listenToIfEnabled(e.model, "insertObject", (r, i) => {
                        const [,l,d={}] = i;
                        if (l && !l.is("documentSelection"))
                            return;
                        const h = jn(t);
                        h && (d.findOptimalPosition = h,
                        i[3] = d)
                    }
                    , {
                        priority: "high"
                    })
                }
                _enableDeleteContentIntegration() {
                    const e = this.editor
                      , t = this.editor.model.document.selection;
                    this._listenToIfEnabled(e.model, "deleteContent", (r, [i]) => {
                        i && !i.is("documentSelection") || jn(t) && r.stop()
                    }
                    , {
                        priority: "high"
                    })
                }
            }
            function Vz(s) {
                const e = s.model;
                return (t, r) => {
                    const i = r.keyCode == Me.arrowup
                      , l = r.keyCode == Me.arrowdown
                      , d = r.shiftKey
                      , h = e.document.selection;
                    if (!i && !l)
                        return;
                    const m = l;
                    if (d && function(b, v) {
                        return !b.isCollapsed && b.isBackward == v
                    }(h, m))
                        return;
                    const g = function(b, v, x) {
                        const T = b.model;
                        if (x) {
                            const I = v.isCollapsed ? v.focus : v.getLastPosition()
                              , P = e0(T, I, "forward");
                            if (!P)
                                return null;
                            const O = T.createRange(I, P)
                              , F = t0(T.schema, O, "backward");
                            return F ? T.createRange(I, F) : null
                        }
                        {
                            const I = v.isCollapsed ? v.focus : v.getFirstPosition()
                              , P = e0(T, I, "backward");
                            if (!P)
                                return null;
                            const O = T.createRange(P, I)
                              , F = t0(T.schema, O, "forward");
                            return F ? T.createRange(F, I) : null
                        }
                    }(s, h, m);
                    if (g) {
                        if (g.isCollapsed && (h.isCollapsed || d))
                            return;
                        (g.isCollapsed || function(b, v, x) {
                            const T = b.model
                              , I = b.view.domConverter;
                            if (x) {
                                const Q = T.createSelection(v.start);
                                T.modifySelection(Q),
                                Q.focus.isAtEnd || v.start.isEqual(Q.focus) || (v = T.createRange(Q.focus, v.end))
                            }
                            const P = b.mapper.toViewRange(v)
                              , O = I.viewRangeToDom(P)
                              , F = De.getDomRangeRects(O);
                            let q;
                            for (const Q of F)
                                if (q !== void 0) {
                                    if (Math.round(Q.top) >= q)
                                        return !1;
                                    q = Math.max(q, Math.round(Q.bottom))
                                } else
                                    q = Math.round(Q.bottom);
                            return !0
                        }(s, g, m)) && (e.change(b => {
                            const v = m ? g.end : g.start;
                            if (d) {
                                const x = e.createSelection(h.anchor);
                                x.setFocus(v),
                                b.setSelection(x)
                            } else
                                b.setSelection(v)
                        }
                        ),
                        t.stop(),
                        r.preventDefault(),
                        r.stopPropagation())
                    }
                }
            }
            function e0(s, e, t) {
                const r = s.schema
                  , i = s.createRangeIn(e.root)
                  , l = t == "forward" ? "elementStart" : "elementEnd";
                for (const {previousPosition: d, item: h, type: m} of i.getWalker({
                    startPosition: e,
                    direction: t
                })) {
                    if (r.isLimit(h) && !r.isInline(h))
                        return d;
                    if (m == l && r.isBlock(h))
                        return null
                }
                return null
            }
            function t0(s, e, t) {
                const r = t == "backward" ? e.end : e.start;
                if (s.checkChild(r, "$text"))
                    return r;
                for (const {nextPosition: i} of e.getWalker({
                    direction: t
                }))
                    if (s.checkChild(i, "$text"))
                        return i;
                return null
            }
            var o0 = u(695)
              , Uz = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(o0.A, Uz),
            o0.A.locals;
            class jl extends ie {
                constructor() {
                    super(...arguments),
                    C(this, "_previouslySelected", new Set)
                }
                static get pluginName() {
                    return "Widget"
                }
                static get requires() {
                    return [Fz, Xr]
                }
                init() {
                    const e = this.editor
                      , t = e.editing.view
                      , r = t.document
                      , i = e.t;
                    this.editor.editing.downcastDispatcher.on("selection", (l, d, h) => {
                        const m = h.writer
                          , g = d.selection;
                        if (g.isCollapsed)
                            return;
                        const b = g.getSelectedElement();
                        if (!b)
                            return;
                        const v = e.editing.mapper.toViewElement(b);
                        var x;
                        At(v) && h.consumable.consume(g, "selection") && m.setSelection(m.createRangeOn(v), {
                            fake: !0,
                            label: (x = v,
                            x.getCustomProperty("widgetLabel").reduce( (T, I) => typeof I == "function" ? T ? T + ". " + I() : I() : T ? T + ". " + I : I, ""))
                        })
                    }
                    ),
                    this.editor.editing.downcastDispatcher.on("selection", (l, d, h) => {
                        this._clearPreviouslySelectedWidgets(h.writer);
                        const m = h.writer
                          , g = m.document.selection;
                        let b = null;
                        for (const v of g.getRanges())
                            for (const x of v) {
                                const T = x.item;
                                At(T) && !Hz(T, b) && (m.addClass(Gy, T),
                                this._previouslySelected.add(T),
                                b = T)
                            }
                    }
                    , {
                        priority: "low"
                    }),
                    t.addObserver(zp),
                    this.listenTo(r, "mousedown", (...l) => this._onMousedown(...l)),
                    this.listenTo(r, "arrowKey", (...l) => {
                        this._handleSelectionChangeOnArrowKeyPress(...l)
                    }
                    , {
                        context: [At, "$text"]
                    }),
                    this.listenTo(r, "arrowKey", (...l) => {
                        this._preventDefaultOnArrowKeyPress(...l)
                    }
                    , {
                        context: "$root"
                    }),
                    this.listenTo(r, "arrowKey", Vz(this.editor.editing), {
                        context: "$text"
                    }),
                    this.listenTo(r, "delete", (l, d) => {
                        this._handleDelete(d.direction == "forward") && (d.preventDefault(),
                        l.stop())
                    }
                    , {
                        context: "$root"
                    }),
                    this.listenTo(r, "tab", (l, d) => {
                        l.eventPhase == "atTarget" && (d.shiftKey || this._selectFirstNestedEditable() && (d.preventDefault(),
                        l.stop()))
                    }
                    , {
                        context: At,
                        priority: "low"
                    }),
                    this.listenTo(r, "tab", (l, d) => {
                        d.shiftKey && this._selectAncestorWidget() && (d.preventDefault(),
                        l.stop())
                    }
                    , {
                        priority: "low"
                    }),
                    this.listenTo(r, "keydown", (l, d) => {
                        d.keystroke == Me.esc && this._selectAncestorWidget() && (d.preventDefault(),
                        l.stop())
                    }
                    , {
                        priority: "low"
                    }),
                    e.accessibility.addKeystrokeInfoGroup({
                        id: "widget",
                        label: i("Keystrokes that can be used when a widget is selected (for example: image, table, etc.)"),
                        keystrokes: [{
                            label: i("Move focus from an editable area back to the parent widget"),
                            keystroke: "Esc"
                        }, {
                            label: i("Insert a new paragraph directly after a widget"),
                            keystroke: "Enter"
                        }, {
                            label: i("Insert a new paragraph directly before a widget"),
                            keystroke: "Shift+Enter"
                        }, {
                            label: i("Move the caret to allow typing directly before a widget"),
                            keystroke: [["arrowup"], ["arrowleft"]]
                        }, {
                            label: i("Move the caret to allow typing directly after a widget"),
                            keystroke: [["arrowdown"], ["arrowright"]]
                        }]
                    })
                }
                _onMousedown(e, t) {
                    const r = this.editor
                      , i = r.editing.view
                      , l = i.document;
                    let d = t.target;
                    if (t.domEvent.detail >= 3)
                        return void (this._selectBlockContent(d) && t.preventDefault());
                    if (function(m) {
                        let g = m;
                        for (; g; ) {
                            if (g.is("editableElement") && !g.is("rootElement"))
                                return !0;
                            if (At(g))
                                return !1;
                            g = g.parent
                        }
                        return !1
                    }(d) || !At(d) && (d = d.findAncestor(At),
                    !d))
                        return;
                    E.isAndroid && t.preventDefault(),
                    l.isFocused || i.focus();
                    const h = r.editing.mapper.toModelElement(d);
                    this._setSelectionOverElement(h)
                }
                _selectBlockContent(e) {
                    const t = this.editor
                      , r = t.model
                      , i = t.editing.mapper
                      , l = r.schema
                      , d = i.findMappedViewAncestor(this.editor.editing.view.createPositionAt(e, 0))
                      , h = function(m, g) {
                        for (const b of m.getAncestors({
                            includeSelf: !0,
                            parentFirst: !0
                        })) {
                            if (g.checkChild(b, "$text"))
                                return b;
                            if (g.isLimit(b) && !g.isObject(b))
                                break
                        }
                        return null
                    }(i.toModelElement(d), r.schema);
                    return !!h && (r.change(m => {
                        const g = l.isLimit(h) ? null : function(x, T) {
                            const I = new Kr({
                                startPosition: x
                            });
                            for (const {item: P} of I) {
                                if (T.isLimit(P) || !P.is("element"))
                                    return null;
                                if (T.checkChild(P, "$text"))
                                    return P
                            }
                            return null
                        }(m.createPositionAfter(h), l)
                          , b = m.createPositionAt(h, 0)
                          , v = g ? m.createPositionAt(g, 0) : m.createPositionAt(h, "end");
                        m.setSelection(m.createRange(b, v))
                    }
                    ),
                    !0)
                }
                _handleSelectionChangeOnArrowKeyPress(e, t) {
                    const r = t.keyCode
                      , i = this.editor.model
                      , l = i.schema
                      , d = i.document.selection
                      , h = d.getSelectedElement()
                      , m = Zm(r, this.editor.locale.contentLanguageDirection)
                      , g = m == "down" || m == "right"
                      , b = m == "up" || m == "down";
                    if (h && l.isObject(h)) {
                        const x = g ? d.getLastPosition() : d.getFirstPosition()
                          , T = l.getNearestSelectionRange(x, g ? "forward" : "backward");
                        return void (T && (i.change(I => {
                            I.setSelection(T)
                        }
                        ),
                        t.preventDefault(),
                        e.stop()))
                    }
                    if (!d.isCollapsed && !t.shiftKey) {
                        const x = d.getFirstPosition()
                          , T = d.getLastPosition()
                          , I = x.nodeAfter
                          , P = T.nodeBefore;
                        return void ((I && l.isObject(I) || P && l.isObject(P)) && (i.change(O => {
                            O.setSelection(g ? T : x)
                        }
                        ),
                        t.preventDefault(),
                        e.stop()))
                    }
                    if (!d.isCollapsed)
                        return;
                    const v = this._getObjectElementNextToSelection(g);
                    if (v && l.isObject(v)) {
                        if (l.isInline(v) && b)
                            return;
                        this._setSelectionOverElement(v),
                        t.preventDefault(),
                        e.stop()
                    }
                }
                _preventDefaultOnArrowKeyPress(e, t) {
                    const r = this.editor.model
                      , i = r.schema
                      , l = r.document.selection.getSelectedElement();
                    l && i.isObject(l) && (t.preventDefault(),
                    e.stop())
                }
                _handleDelete(e) {
                    const t = this.editor.model.document.selection;
                    if (!this.editor.model.canEditAt(t) || !t.isCollapsed)
                        return;
                    const r = this._getObjectElementNextToSelection(e);
                    return r ? (this.editor.model.change(i => {
                        let l = t.anchor.parent;
                        for (; l.isEmpty; ) {
                            const d = l;
                            l = d.parent,
                            i.remove(d)
                        }
                        this._setSelectionOverElement(r)
                    }
                    ),
                    !0) : void 0
                }
                _setSelectionOverElement(e) {
                    this.editor.model.change(t => {
                        t.setSelection(t.createRangeOn(e))
                    }
                    )
                }
                _getObjectElementNextToSelection(e) {
                    const t = this.editor.model
                      , r = t.schema
                      , i = t.document.selection
                      , l = t.createSelection(i);
                    if (t.modifySelection(l, {
                        direction: e ? "forward" : "backward"
                    }),
                    l.isEqual(i))
                        return null;
                    const d = e ? l.focus.nodeBefore : l.focus.nodeAfter;
                    return d && r.isObject(d) ? d : null
                }
                _clearPreviouslySelectedWidgets(e) {
                    for (const t of this._previouslySelected)
                        e.removeClass(Gy, t);
                    this._previouslySelected.clear()
                }
                _selectFirstNestedEditable() {
                    const e = this.editor
                      , t = this.editor.editing.view.document;
                    for (const r of t.selection.getFirstRange().getItems())
                        if (r.is("editableElement")) {
                            const i = e.editing.mapper.toModelElement(r);
                            if (!i)
                                continue;
                            const l = e.model.createPositionAt(i, 0)
                              , d = e.model.schema.getNearestSelectionRange(l, "forward");
                            return e.model.change(h => {
                                h.setSelection(d)
                            }
                            ),
                            !0
                        }
                    return !1
                }
                _selectAncestorWidget() {
                    const e = this.editor
                      , t = e.editing.mapper
                      , r = e.editing.view.document.selection.getFirstPosition().parent
                      , i = (r.is("$text") ? r.parent : r).findAncestor(At);
                    if (!i)
                        return !1;
                    const l = t.toModelElement(i);
                    return !!l && (e.model.change(d => {
                        d.setSelection(l, "on")
                    }
                    ),
                    !0)
                }
            }
            function Hz(s, e) {
                return !!e && Array.from(s.getAncestors()).includes(e)
            }
            class hu extends ie {
                constructor() {
                    super(...arguments),
                    C(this, "_toolbarDefinitions", new Map),
                    C(this, "_balloon")
                }
                static get requires() {
                    return [nu]
                }
                static get pluginName() {
                    return "WidgetToolbarRepository"
                }
                init() {
                    const e = this.editor;
                    if (e.plugins.has("BalloonToolbar")) {
                        const t = e.plugins.get("BalloonToolbar");
                        this.listenTo(t, "show", r => {
                            (function(i) {
                                const l = i.getSelectedElement();
                                return !(!l || !At(l))
                            }
                            )(e.editing.view.document.selection) && r.stop()
                        }
                        , {
                            priority: "high"
                        })
                    }
                    this._balloon = this.editor.plugins.get("ContextualBalloon"),
                    this.on("change:isEnabled", () => {
                        this._updateToolbarsVisibility()
                    }
                    ),
                    this.listenTo(e.ui, "update", () => {
                        this._updateToolbarsVisibility()
                    }
                    ),
                    this.listenTo(e.ui.focusTracker, "change:isFocused", () => {
                        this._updateToolbarsVisibility()
                    }
                    , {
                        priority: "low"
                    })
                }
                destroy() {
                    super.destroy();
                    for (const e of this._toolbarDefinitions.values())
                        e.view.destroy()
                }
                register(e, {ariaLabel: t, items: r, getRelatedElement: i, balloonClassName: l="ck-toolbar-container"}) {
                    if (!r.length)
                        return void de("widget-toolbar-no-items", {
                            toolbarId: e
                        });
                    const d = this.editor
                      , h = d.t
                      , m = new qp(d.locale);
                    if (m.ariaLabel = t || h("Widget toolbar"),
                    this._toolbarDefinitions.has(e))
                        throw new U("widget-toolbar-duplicated",this,{
                            toolbarId: e
                        });
                    const g = {
                        view: m,
                        getRelatedElement: i,
                        balloonClassName: l,
                        itemsConfig: r,
                        initialized: !1
                    };
                    d.ui.addToolbar(m, {
                        isContextual: !0,
                        beforeFocus: () => {
                            const b = i(d.editing.view.document.selection);
                            b && this._showToolbar(g, b)
                        }
                        ,
                        afterBlur: () => {
                            this._hideToolbar(g)
                        }
                    }),
                    this._toolbarDefinitions.set(e, g)
                }
                _updateToolbarsVisibility() {
                    let e = 0
                      , t = null
                      , r = null;
                    for (const i of this._toolbarDefinitions.values()) {
                        const l = i.getRelatedElement(this.editor.editing.view.document.selection);
                        if (this.isEnabled && l)
                            if (this.editor.ui.focusTracker.isFocused) {
                                const d = l.getAncestors().length;
                                d > e && (e = d,
                                t = l,
                                r = i)
                            } else
                                this._isToolbarVisible(i) && this._hideToolbar(i);
                        else
                            this._isToolbarInBalloon(i) && this._hideToolbar(i)
                    }
                    r && this._showToolbar(r, t)
                }
                _hideToolbar(e) {
                    this._balloon.remove(e.view),
                    this.stopListening(this._balloon, "change:visibleView")
                }
                _showToolbar(e, t) {
                    this._isToolbarVisible(e) ? r0(this.editor, t) : this._isToolbarInBalloon(e) || (e.initialized || (e.initialized = !0,
                    e.view.fillFromConfig(e.itemsConfig, this.editor.ui.componentFactory)),
                    this._balloon.add({
                        view: e.view,
                        position: n0(this.editor, t),
                        balloonClassName: e.balloonClassName
                    }),
                    this.listenTo(this._balloon, "change:visibleView", () => {
                        for (const r of this._toolbarDefinitions.values())
                            if (this._isToolbarVisible(r)) {
                                const i = r.getRelatedElement(this.editor.editing.view.document.selection);
                                r0(this.editor, i)
                            }
                    }
                    ))
                }
                _isToolbarVisible(e) {
                    return this._balloon.visibleView === e.view
                }
                _isToolbarInBalloon(e) {
                    return this._balloon.hasView(e.view)
                }
            }
            function r0(s, e) {
                const t = s.plugins.get("ContextualBalloon")
                  , r = n0(s, e);
                t.updatePosition(r)
            }
            function n0(s, e) {
                const t = s.editing.view
                  , r = js.defaultPositions;
                return {
                    target: t.domConverter.mapViewToDom(e),
                    positions: [r.northArrowSouth, r.northArrowSouthWest, r.northArrowSouthEast, r.southArrowNorth, r.southArrowNorthWest, r.southArrowNorthEast, r.viewportStickyNorth]
                }
            }
            var i0 = u(4095)
              , Wz = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(i0.A, Wz),
            i0.A.locals;
            const sg = cl("px");
            class $z extends pe {
                constructor() {
                    super();
                    const e = this.bindTemplate;
                    this.set({
                        isVisible: !1,
                        left: null,
                        top: null,
                        width: null
                    }),
                    this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-clipboard-drop-target-line", e.if("isVisible", "ck-hidden", t => !t)],
                            style: {
                                left: e.to("left", t => sg(t)),
                                top: e.to("top", t => sg(t)),
                                width: e.to("width", t => sg(t))
                            }
                        }
                    })
                }
            }
            class mu extends ie {
                constructor() {
                    super(...arguments),
                    C(this, "removeDropMarkerDelayed", ep( () => this.removeDropMarker(), 40)),
                    C(this, "_updateDropMarkerThrottled", Yd(e => this._updateDropMarker(e), 40)),
                    C(this, "_reconvertMarkerThrottled", Yd( () => {
                        this.editor.model.markers.has("drop-target") && this.editor.editing.reconvertMarker("drop-target")
                    }
                    , 0)),
                    C(this, "_dropTargetLineView", new $z),
                    C(this, "_domEmitter", new (qo())),
                    C(this, "_scrollables", new Map)
                }
                static get pluginName() {
                    return "DragDropTarget"
                }
                init() {
                    this._setupDropMarker()
                }
                destroy() {
                    this._domEmitter.stopListening();
                    for (const {resizeObserver: e} of this._scrollables.values())
                        e.destroy();
                    return this._updateDropMarkerThrottled.cancel(),
                    this.removeDropMarkerDelayed.cancel(),
                    this._reconvertMarkerThrottled.cancel(),
                    super.destroy()
                }
                updateDropMarker(e, t, r, i, l, d) {
                    this.removeDropMarkerDelayed.cancel();
                    const h = s0(this.editor, e, t, r, i, l, d);
                    if (h)
                        return d && d.containsRange(h) ? this.removeDropMarker() : void this._updateDropMarkerThrottled(h)
                }
                getFinalDropRange(e, t, r, i, l, d) {
                    const h = s0(this.editor, e, t, r, i, l, d);
                    return this.removeDropMarker(),
                    h
                }
                removeDropMarker() {
                    const e = this.editor.model;
                    this.removeDropMarkerDelayed.cancel(),
                    this._updateDropMarkerThrottled.cancel(),
                    this._dropTargetLineView.isVisible = !1,
                    e.markers.has("drop-target") && e.change(t => {
                        t.removeMarker("drop-target")
                    }
                    )
                }
                _setupDropMarker() {
                    const e = this.editor;
                    e.ui.view.body.add(this._dropTargetLineView),
                    e.conversion.for("editingDowncast").markerToHighlight({
                        model: "drop-target",
                        view: {
                            classes: ["ck-clipboard-drop-target-range"]
                        }
                    }),
                    e.conversion.for("editingDowncast").markerToElement({
                        model: "drop-target",
                        view: (t, {writer: r}) => {
                            if (e.model.schema.checkChild(t.markerRange.start, "$text"))
                                return this._dropTargetLineView.isVisible = !1,
                                this._createDropTargetPosition(r);
                            t.markerRange.isCollapsed ? this._updateDropTargetLine(t.markerRange) : this._dropTargetLineView.isVisible = !1
                        }
                    })
                }
                _updateDropMarker(e) {
                    const t = this.editor
                      , r = t.model.markers;
                    t.model.change(i => {
                        r.has("drop-target") ? r.get("drop-target").getRange().isEqual(e) || i.updateMarker("drop-target", {
                            range: e
                        }) : i.addMarker("drop-target", {
                            range: e,
                            usingOperation: !1,
                            affectsData: !1
                        })
                    }
                    )
                }
                _createDropTargetPosition(e) {
                    return e.createUIElement("span", {
                        class: "ck ck-clipboard-drop-target-position"
                    }, function(t) {
                        const r = this.toDomElement(t);
                        return r.append("⁠", t.createElement("span"), "⁠"),
                        r
                    })
                }
                _updateDropTargetLine(e) {
                    const t = this.editor.editing
                      , r = e.start.nodeBefore
                      , i = e.start.nodeAfter
                      , l = e.start.parent
                      , d = r ? t.mapper.toViewElement(r) : null
                      , h = d ? t.view.domConverter.mapViewToDom(d) : null
                      , m = i ? t.mapper.toViewElement(i) : null
                      , g = m ? t.view.domConverter.mapViewToDom(m) : null
                      , b = t.mapper.toViewElement(l);
                    if (!b)
                        return;
                    const v = t.view.domConverter.mapViewToDom(b)
                      , x = this._getScrollableRect(b)
                      , {scrollX: T, scrollY: I} = w.window
                      , P = h ? new De(h) : null
                      , O = g ? new De(g) : null
                      , F = new De(v).excludeScrollbarsAndBorders()
                      , q = P ? P.bottom : F.top
                      , Q = O ? O.top : F.bottom
                      , X = w.window.getComputedStyle(v)
                      , le = q <= Q ? (q + Q) / 2 : Q;
                    if (x.top < le && le < x.bottom) {
                        const ge = F.left + parseFloat(X.paddingLeft)
                          , ke = F.right - parseFloat(X.paddingRight)
                          , vt = Math.max(ge + T, x.left)
                          , Nt = Math.min(ke + T, x.right);
                        this._dropTargetLineView.set({
                            isVisible: !0,
                            left: vt,
                            top: le + I,
                            width: Nt - vt
                        })
                    } else
                        this._dropTargetLineView.isVisible = !1
                }
                _getScrollableRect(e) {
                    const t = e.root.rootName;
                    let r;
                    if (this._scrollables.has(t))
                        r = this._scrollables.get(t).domElement;
                    else {
                        r = function(l) {
                            let d = l;
                            do {
                                d = d.parentElement;
                                const h = w.window.getComputedStyle(d).overflowY;
                                if (h == "auto" || h == "scroll")
                                    break
                            } while (d.tagName != "BODY");
                            return d
                        }(this.editor.editing.view.domConverter.mapViewToDom(e)),
                        this._domEmitter.listenTo(r, "scroll", this._reconvertMarkerThrottled, {
                            usePassive: !0
                        });
                        const i = new Gm(r,this._reconvertMarkerThrottled);
                        this._scrollables.set(t, {
                            domElement: r,
                            resizeObserver: i
                        })
                    }
                    return new De(r).excludeScrollbarsAndBorders()
                }
            }
            function s0(s, e, t, r, i, l, d) {
                const h = s.model
                  , m = s.editing.mapper;
                let g = l0(s, e);
                for (; g; ) {
                    if (!l) {
                        if (h.schema.checkChild(g, "$text")) {
                            if (t) {
                                const b = t[0].start
                                  , v = m.toModelPosition(b);
                                if (!d || Array.from(d.getItems()).every(x => h.schema.checkChild(v, x))) {
                                    if (h.schema.checkChild(v, "$text"))
                                        return h.createRange(v);
                                    if (b)
                                        return pu(s, l0(s, b.parent), r, i)
                                }
                            }
                        } else if (h.schema.isInline(g))
                            return pu(s, g, r, i)
                    }
                    if (h.schema.isBlock(g))
                        return pu(s, g, r, i);
                    if (h.schema.checkChild(g, "$block")) {
                        const b = Array.from(g.getChildren()).filter(T => T.is("element") && !qz(s, T));
                        let v = 0
                          , x = b.length;
                        if (x == 0)
                            return h.createRange(h.createPositionAt(g, "end"));
                        for (; v < x - 1; ) {
                            const T = Math.floor((v + x) / 2);
                            a0(s, b[T], r, i) == "before" ? x = T : v = T
                        }
                        return pu(s, b[v], r, i)
                    }
                    g = g.parent
                }
                return null
            }
            function qz(s, e) {
                const t = s.editing.mapper
                  , r = s.editing.view.domConverter
                  , i = t.toViewElement(e);
                if (!i)
                    return !0;
                const l = r.mapViewToDom(i);
                return w.window.getComputedStyle(l).float != "none"
            }
            function pu(s, e, t, r) {
                const i = s.model;
                return i.createRange(i.createPositionAt(e, a0(s, e, t, r)))
            }
            function a0(s, e, t, r) {
                const i = s.editing.mapper
                  , l = s.editing.view.domConverter
                  , d = i.toViewElement(e)
                  , h = l.mapViewToDom(d)
                  , m = new De(h);
                return s.model.schema.isInline(e) ? t < (m.left + m.right) / 2 ? "before" : "after" : r < (m.top + m.bottom) / 2 ? "before" : "after"
            }
            function l0(s, e) {
                const t = s.editing.mapper
                  , r = s.editing.view
                  , i = t.toModelElement(e);
                if (i)
                    return i;
                const l = r.createPositionBefore(e)
                  , d = t.findMappedViewAncestor(l);
                return t.toModelElement(d)
            }
            class Gz extends ie {
                constructor() {
                    super(...arguments),
                    C(this, "_isBlockDragging", !1),
                    C(this, "_domEmitter", new (qo()))
                }
                static get pluginName() {
                    return "DragDropBlockToolbar"
                }
                init() {
                    const e = this.editor;
                    if (this.listenTo(e, "change:isReadOnly", (t, r, i) => {
                        i ? (this.forceDisabled("readOnlyMode"),
                        this._isBlockDragging = !1) : this.clearForceDisabled("readOnlyMode")
                    }
                    ),
                    E.isAndroid && this.forceDisabled("noAndroidSupport"),
                    e.plugins.has("BlockToolbar")) {
                        const t = e.plugins.get("BlockToolbar").buttonView.element;
                        this._domEmitter.listenTo(t, "dragstart", (r, i) => this._handleBlockDragStart(i)),
                        this._domEmitter.listenTo(w.document, "dragover", (r, i) => this._handleBlockDragging(i)),
                        this._domEmitter.listenTo(w.document, "drop", (r, i) => this._handleBlockDragging(i)),
                        this._domEmitter.listenTo(w.document, "dragend", () => this._handleBlockDragEnd(), {
                            useCapture: !0
                        }),
                        this.isEnabled && t.setAttribute("draggable", "true"),
                        this.on("change:isEnabled", (r, i, l) => {
                            t.setAttribute("draggable", l ? "true" : "false")
                        }
                        )
                    }
                }
                destroy() {
                    return this._domEmitter.stopListening(),
                    super.destroy()
                }
                _handleBlockDragStart(e) {
                    if (!this.isEnabled)
                        return;
                    const t = this.editor.model
                      , r = t.document.selection
                      , i = this.editor.editing.view
                      , l = Array.from(r.getSelectedBlocks())
                      , d = t.createRange(t.createPositionBefore(l[0]), t.createPositionAfter(l[l.length - 1]));
                    t.change(h => h.setSelection(d)),
                    this._isBlockDragging = !0,
                    i.focus(),
                    i.getObserver(Il).onDomEvent(e)
                }
                _handleBlockDragging(e) {
                    if (!this.isEnabled || !this._isBlockDragging)
                        return;
                    const t = e.clientX + (this.editor.locale.contentLanguageDirection == "ltr" ? 100 : -100)
                      , r = e.clientY
                      , i = document.elementFromPoint(t, r)
                      , l = this.editor.editing.view;
                    i && i.closest(".ck-editor__editable") && l.getObserver(Il).onDomEvent({
                        ...e,
                        type: e.type,
                        dataTransfer: e.dataTransfer,
                        target: i,
                        clientX: t,
                        clientY: r,
                        preventDefault: () => e.preventDefault(),
                        stopPropagation: () => e.stopPropagation()
                    })
                }
                _handleBlockDragEnd() {
                    this._isBlockDragging = !1
                }
            }
            var c0 = u(7793)
              , Kz = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(c0.A, Kz),
            c0.A.locals;
            class Yz extends ie {
                constructor() {
                    super(...arguments),
                    C(this, "_draggedRange"),
                    C(this, "_draggingUid"),
                    C(this, "_draggableElement"),
                    C(this, "_clearDraggableAttributesDelayed", ep( () => this._clearDraggableAttributes(), 40)),
                    C(this, "_blockMode", !1),
                    C(this, "_domEmitter", new (qo())),
                    C(this, "_previewContainer")
                }
                static get pluginName() {
                    return "DragDrop"
                }
                static get requires() {
                    return [Ko, jl, mu, Gz]
                }
                init() {
                    const e = this.editor
                      , t = e.editing.view;
                    this._draggedRange = null,
                    this._draggingUid = "",
                    this._draggableElement = null,
                    t.addObserver(Il),
                    t.addObserver(zp),
                    this._setupDragging(),
                    this._setupContentInsertionIntegration(),
                    this._setupClipboardInputIntegration(),
                    this._setupDraggableAttributeHandling(),
                    this.listenTo(e, "change:isReadOnly", (r, i, l) => {
                        l ? this.forceDisabled("readOnlyMode") : this.clearForceDisabled("readOnlyMode")
                    }
                    ),
                    this.on("change:isEnabled", (r, i, l) => {
                        l || this._finalizeDragging(!1)
                    }
                    ),
                    E.isAndroid && this.forceDisabled("noAndroidSupport")
                }
                destroy() {
                    return this._draggedRange && (this._draggedRange.detach(),
                    this._draggedRange = null),
                    this._previewContainer && this._previewContainer.remove(),
                    this._domEmitter.stopListening(),
                    this._clearDraggableAttributesDelayed.cancel(),
                    super.destroy()
                }
                _setupDragging() {
                    const e = this.editor
                      , t = e.model
                      , r = e.editing.view
                      , i = r.document
                      , l = e.plugins.get(mu);
                    this.listenTo(i, "dragstart", (d, h) => {
                        if (h.target && h.target.is("editableElement") || (this._prepareDraggedRange(h.target),
                        !this._draggedRange))
                            return void h.preventDefault();
                        this._draggingUid = H(),
                        h.dataTransfer.effectAllowed = this.isEnabled ? "copyMove" : "copy",
                        h.dataTransfer.setData("application/ckeditor5-dragging-uid", this._draggingUid);
                        const m = t.createSelection(this._draggedRange.toRange());
                        this.editor.plugins.get("ClipboardPipeline")._fireOutputTransformationEvent(h.dataTransfer, m, "dragstart");
                        const {dataTransfer: g, domTarget: b, domEvent: v} = h
                          , {clientX: x} = v;
                        this._updatePreview({
                            dataTransfer: g,
                            domTarget: b,
                            clientX: x
                        }),
                        h.stopPropagation(),
                        this.isEnabled || (this._draggedRange.detach(),
                        this._draggedRange = null,
                        this._draggingUid = "")
                    }
                    , {
                        priority: "low"
                    }),
                    this.listenTo(i, "dragend", (d, h) => {
                        this._finalizeDragging(!h.dataTransfer.isCanceled && h.dataTransfer.dropEffect == "move")
                    }
                    , {
                        priority: "low"
                    }),
                    this._domEmitter.listenTo(w.document, "dragend", () => {
                        this._blockMode = !1
                    }
                    , {
                        useCapture: !0
                    }),
                    this.listenTo(i, "dragenter", () => {
                        this.isEnabled && r.focus()
                    }
                    ),
                    this.listenTo(i, "dragleave", () => {
                        l.removeDropMarkerDelayed()
                    }
                    ),
                    this.listenTo(i, "dragging", (d, h) => {
                        if (!this.isEnabled)
                            return void (h.dataTransfer.dropEffect = "none");
                        const {clientX: m, clientY: g} = h.domEvent;
                        l.updateDropMarker(h.target, h.targetRanges, m, g, this._blockMode, this._draggedRange),
                        this._draggedRange || (h.dataTransfer.dropEffect = "copy"),
                        E.isGecko || (h.dataTransfer.effectAllowed == "copy" ? h.dataTransfer.dropEffect = "copy" : ["all", "copyMove"].includes(h.dataTransfer.effectAllowed) && (h.dataTransfer.dropEffect = "move")),
                        d.stop()
                    }
                    , {
                        priority: "low"
                    })
                }
                _setupClipboardInputIntegration() {
                    const e = this.editor
                      , t = e.editing.view.document
                      , r = e.plugins.get(mu);
                    this.listenTo(t, "clipboardInput", (i, l) => {
                        if (l.method != "drop")
                            return;
                        const {clientX: d, clientY: h} = l.domEvent
                          , m = r.getFinalDropRange(l.target, l.targetRanges, d, h, this._blockMode, this._draggedRange);
                        if (!m)
                            return this._finalizeDragging(!1),
                            void i.stop();
                        if (this._draggedRange && this._draggingUid != l.dataTransfer.getData("application/ckeditor5-dragging-uid") && (this._draggedRange.detach(),
                        this._draggedRange = null,
                        this._draggingUid = ""),
                        d0(l.dataTransfer) == "move" && this._draggedRange && this._draggedRange.containsRange(m, !0))
                            return this._finalizeDragging(!1),
                            void i.stop();
                        l.targetRanges = [e.editing.mapper.toViewRange(m)]
                    }
                    , {
                        priority: "high"
                    })
                }
                _setupContentInsertionIntegration() {
                    const e = this.editor.plugins.get(Ko);
                    e.on("contentInsertion", (t, r) => {
                        if (!this.isEnabled || r.method !== "drop")
                            return;
                        const i = r.targetRanges.map(l => this.editor.editing.mapper.toModelRange(l));
                        this.editor.model.change(l => l.setSelection(i))
                    }
                    , {
                        priority: "high"
                    }),
                    e.on("contentInsertion", (t, r) => {
                        if (!this.isEnabled || r.method !== "drop")
                            return;
                        const i = d0(r.dataTransfer) == "move"
                          , l = !r.resultRange || !r.resultRange.isCollapsed;
                        this._finalizeDragging(l && i)
                    }
                    , {
                        priority: "lowest"
                    })
                }
                _setupDraggableAttributeHandling() {
                    const e = this.editor
                      , t = e.editing.view
                      , r = t.document;
                    this.listenTo(r, "mousedown", (i, l) => {
                        if (E.isAndroid || !l)
                            return;
                        this._clearDraggableAttributesDelayed.cancel();
                        let d = u0(l.target);
                        if (E.isBlink && !e.isReadOnly && !d && !r.selection.isCollapsed) {
                            const h = r.selection.getSelectedElement();
                            h && At(h) || (d = r.selection.editableElement)
                        }
                        d && (t.change(h => {
                            h.setAttribute("draggable", "true", d)
                        }
                        ),
                        this._draggableElement = e.editing.mapper.toModelElement(d))
                    }
                    ),
                    this.listenTo(r, "mouseup", () => {
                        E.isAndroid || this._clearDraggableAttributesDelayed()
                    }
                    )
                }
                _clearDraggableAttributes() {
                    const e = this.editor.editing;
                    e.view.change(t => {
                        this._draggableElement && this._draggableElement.root.rootName != "$graveyard" && t.removeAttribute("draggable", e.mapper.toViewElement(this._draggableElement)),
                        this._draggableElement = null
                    }
                    )
                }
                _finalizeDragging(e) {
                    const t = this.editor
                      , r = t.model;
                    t.plugins.get(mu).removeDropMarker(),
                    this._clearDraggableAttributes(),
                    t.plugins.has("WidgetToolbarRepository") && t.plugins.get("WidgetToolbarRepository").clearForceDisabled("dragDrop"),
                    this._draggingUid = "",
                    this._previewContainer && (this._previewContainer.remove(),
                    this._previewContainer = void 0),
                    this._draggedRange && (e && this.isEnabled && r.change(i => {
                        const l = r.createSelection(this._draggedRange);
                        r.deleteContent(l, {
                            doNotAutoparagraph: !0
                        });
                        const d = l.getFirstPosition().parent;
                        d.isEmpty && !r.schema.checkChild(d, "$text") && r.schema.checkChild(d, "paragraph") && i.insertElement("paragraph", d, 0)
                    }
                    ),
                    this._draggedRange.detach(),
                    this._draggedRange = null)
                }
                _prepareDraggedRange(e) {
                    const t = this.editor
                      , r = t.model
                      , i = r.document.selection
                      , l = e ? u0(e) : null;
                    if (l) {
                        const g = t.editing.mapper.toModelElement(l);
                        this._draggedRange = Io.fromRange(r.createRangeOn(g)),
                        this._blockMode = r.schema.isBlock(g),
                        t.plugins.has("WidgetToolbarRepository") && t.plugins.get("WidgetToolbarRepository").forceDisabled("dragDrop");
                        return
                    }
                    if (i.isCollapsed && !i.getFirstPosition().parent.isEmpty)
                        return;
                    const d = Array.from(i.getSelectedBlocks())
                      , h = i.getFirstRange();
                    if (d.length == 0)
                        return void (this._draggedRange = Io.fromRange(h));
                    const m = h0(r, d);
                    if (d.length > 1)
                        this._draggedRange = Io.fromRange(m),
                        this._blockMode = !0;
                    else if (d.length == 1) {
                        const g = h.start.isTouching(m.start) && h.end.isTouching(m.end);
                        this._draggedRange = Io.fromRange(g ? m : h),
                        this._blockMode = g
                    }
                    r.change(g => g.setSelection(this._draggedRange.toRange()))
                }
                _updatePreview({dataTransfer: e, domTarget: t, clientX: r}) {
                    const i = this.editor.editing.view
                      , l = i.document.selection.editableElement
                      , d = i.domConverter.mapViewToDom(l)
                      , h = w.window.getComputedStyle(d);
                    this._previewContainer ? this._previewContainer.firstElementChild && this._previewContainer.removeChild(this._previewContainer.firstElementChild) : (this._previewContainer = $o(w.document, "div", {
                        style: "position: fixed; left: -999999px;"
                    }),
                    w.document.body.appendChild(this._previewContainer));
                    const m = new De(d);
                    if (d.contains(t))
                        return;
                    const g = parseFloat(h.paddingLeft)
                      , b = $o(w.document, "div");
                    b.className = "ck ck-content",
                    b.style.width = h.width,
                    b.style.paddingLeft = `${m.left - r + g}px`,
                    E.isiOS && (b.style.backgroundColor = "white"),
                    b.innerHTML = e.getData("text/html"),
                    e.setDragImage(b, 0, 0),
                    this._previewContainer.appendChild(b)
                }
            }
            function d0(s) {
                return E.isGecko ? s.dropEffect : ["all", "copyMove"].includes(s.effectAllowed) ? "move" : "copy"
            }
            function u0(s) {
                if (s.is("editableElement"))
                    return null;
                if (s.hasClass("ck-widget__selection-handle"))
                    return s.findAncestor(At);
                if (At(s))
                    return s;
                const e = s.findAncestor(t => At(t) || t.is("editableElement"));
                return At(e) ? e : null
            }
            function h0(s, e) {
                const t = e[0]
                  , r = e[e.length - 1]
                  , i = t.getCommonAncestor(r)
                  , l = s.createPositionBefore(t)
                  , d = s.createPositionAfter(r);
                if (i && i.is("element") && !s.schema.isLimit(i)) {
                    const h = s.createRangeOn(i)
                      , m = l.isTouching(h.start)
                      , g = d.isTouching(h.end);
                    if (m && g)
                        return h0(s, [i])
                }
                return s.createRange(l, d)
            }
            class Qz extends ie {
                static get pluginName() {
                    return "PastePlainText"
                }
                static get requires() {
                    return [Ko]
                }
                init() {
                    const e = this.editor
                      , t = e.model
                      , r = e.editing.view
                      , i = r.document
                      , l = t.document.selection;
                    let d = !1;
                    r.addObserver(Il),
                    this.listenTo(i, "keydown", (h, m) => {
                        d = m.shiftKey
                    }
                    ),
                    e.plugins.get(Ko).on("contentInsertion", (h, m) => {
                        (d || function(g, b) {
                            if (g.childCount > 1)
                                return !1;
                            const v = g.getChild(0);
                            return b.isObject(v) ? !1 : Array.from(v.getAttributeKeys()).length == 0
                        }(m.content, t.schema)) && t.change(g => {
                            const b = Array.from(l.getAttributes()).filter( ([x]) => t.schema.getAttributeProperties(x).isFormatting);
                            l.isCollapsed || t.deleteContent(l, {
                                doNotAutoparagraph: !0
                            }),
                            b.push(...l.getAttributes());
                            const v = g.createRangeIn(m.content);
                            for (const x of v.getItems())
                                x.is("$textProxy") && g.setAttributes(b, x)
                        }
                        )
                    }
                    )
                }
            }
            class m0 extends ie {
                static get pluginName() {
                    return "Clipboard"
                }
                static get requires() {
                    return [Ml, Ko, Yz, Qz]
                }
                init() {
                    const e = this.editor
                      , t = this.editor.t;
                    e.accessibility.addKeystrokeInfos({
                        keystrokes: [{
                            label: t("Copy selected content"),
                            keystroke: "CTRL+C"
                        }, {
                            label: t("Paste content"),
                            keystroke: "CTRL+V"
                        }, {
                            label: t("Paste content as plain text"),
                            keystroke: "CTRL+SHIFT+V"
                        }]
                    })
                }
            }
            class Zz extends _e {
                constructor(e) {
                    super(e),
                    this.affectsData = !1
                }
                execute() {
                    const e = this.editor.model
                      , t = e.document.selection;
                    let r = e.schema.getLimitElement(t);
                    if (t.containsEntireContent(r) || !p0(e.schema, r))
                        do
                            if (r = r.parent,
                            !r)
                                return;
                        while (!p0(e.schema, r));
                    e.change(i => {
                        i.setSelection(r, "in")
                    }
                    )
                }
            }
            function p0(s, e) {
                return s.isLimit(e) && (s.checkChild(e, "$text") || s.checkChild(e, "paragraph"))
            }
            const Jz = Qm("Ctrl+A");
            class Xz extends ie {
                static get pluginName() {
                    return "SelectAllEditing"
                }
                init() {
                    const e = this.editor
                      , t = e.t
                      , r = e.editing.view.document;
                    e.commands.add("selectAll", new Zz(e)),
                    this.listenTo(r, "keydown", (i, l) => {
                        _s(l) === Jz && (e.execute("selectAll"),
                        l.preventDefault())
                    }
                    ),
                    e.accessibility.addKeystrokeInfos({
                        keystrokes: [{
                            label: t("Select all"),
                            keystroke: "CTRL+A"
                        }]
                    })
                }
            }
            class eO extends ie {
                static get pluginName() {
                    return "SelectAllUI"
                }
                init() {
                    const e = this.editor;
                    e.ui.componentFactory.add("selectAll", () => {
                        const t = this._createButton(Te);
                        return t.set({
                            tooltip: !0
                        }),
                        t
                    }
                    ),
                    e.ui.componentFactory.add("menuBar:selectAll", () => this._createButton(Xt))
                }
                _createButton(e) {
                    const t = this.editor
                      , r = t.locale
                      , i = t.commands.get("selectAll")
                      , l = new e(t.locale)
                      , d = r.t;
                    return l.set({
                        label: d("Select all"),
                        icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M.75 15.5a.75.75 0 0 1 .75.75V18l.008.09A.5.5 0 0 0 2 18.5h1.75a.75.75 0 1 1 0 1.5H1.5l-.144-.007a1.5 1.5 0 0 1-1.35-1.349L0 18.5v-2.25a.75.75 0 0 1 .75-.75zm18.5 0a.75.75 0 0 1 .75.75v2.25l-.007.144a1.5 1.5 0 0 1-1.349 1.35L18.5 20h-2.25a.75.75 0 1 1 0-1.5H18a.5.5 0 0 0 .492-.41L18.5 18v-1.75a.75.75 0 0 1 .75-.75zm-10.45 3c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm.45-5.5a.75.75 0 1 1 0 1.5h-8.5a.75.75 0 1 1 0-1.5h8.5zM1.3 11c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM1.3 7c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5h-2.5a.75.75 0 1 1 0-1.5h2.5zm-5 0a.75.75 0 1 1 0 1.5h-5.5a.75.75 0 0 1 0-1.5h5.5zm-6.5-5a.75.75 0 0 1 0 1.5H2a.5.5 0 0 0-.492.41L1.5 2v1.75a.75.75 0 0 1-1.5 0V1.5l.007-.144A1.5 1.5 0 0 1 1.356.006L1.5 0h2.25zM18.5 0l.144.007a1.5 1.5 0 0 1 1.35 1.349L20 1.5v2.25a.75.75 0 1 1-1.5 0V2l-.008-.09A.5.5 0 0 0 18 1.5h-1.75a.75.75 0 1 1 0-1.5h2.25zM8.8 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6z"/></svg>',
                        keystroke: "Ctrl+A"
                    }),
                    l.bind("isEnabled").to(i, "isEnabled"),
                    this.listenTo(l, "execute", () => {
                        t.execute("selectAll"),
                        t.editing.view.focus()
                    }
                    ),
                    l
                }
            }
            class tO extends ie {
                static get requires() {
                    return [Xz, eO]
                }
                static get pluginName() {
                    return "SelectAll"
                }
            }
            class g0 extends _e {
                constructor(e) {
                    super(e),
                    C(this, "_stack", []),
                    C(this, "_createdBatches", new WeakSet),
                    this.refresh(),
                    this._isEnabledBasedOnSelection = !1,
                    this.listenTo(e.data, "set", (t, r) => {
                        r[1] = {
                            ...r[1]
                        };
                        const i = r[1];
                        i.batchType || (i.batchType = {
                            isUndoable: !1
                        })
                    }
                    , {
                        priority: "high"
                    }),
                    this.listenTo(e.data, "set", (t, r) => {
                        r[1].batchType.isUndoable || this.clearStack()
                    }
                    )
                }
                refresh() {
                    this.isEnabled = this._stack.length > 0
                }
                get createdBatches() {
                    return this._createdBatches
                }
                addBatch(e) {
                    const t = this.editor.model.document.selection
                      , r = {
                        ranges: t.hasOwnRange ? Array.from(t.getRanges()) : [],
                        isBackward: t.isBackward
                    };
                    this._stack.push({
                        batch: e,
                        selection: r
                    }),
                    this.refresh()
                }
                clearStack() {
                    this._stack = [],
                    this.refresh()
                }
                _restoreSelection(e, t, r) {
                    const i = this.editor.model
                      , l = i.document
                      , d = []
                      , h = e.map(g => g.getTransformedByOperations(r))
                      , m = h.flat();
                    for (const g of h) {
                        const b = g.filter(v => v.root != l.graveyard).filter(v => !rO(v, m));
                        b.length && (oO(b),
                        d.push(b[0]))
                    }
                    d.length && i.change(g => {
                        g.setSelection(d, {
                            backward: t
                        })
                    }
                    )
                }
                _undo(e, t) {
                    const r = this.editor.model
                      , i = r.document;
                    this._createdBatches.add(t);
                    const l = e.operations.slice().filter(d => d.isDocumentOperation);
                    l.reverse();
                    for (const d of l) {
                        const h = d.baseVersion + 1
                          , m = Array.from(i.history.getOperations(h))
                          , g = j3([d.getReversed()], m, {
                            useRelations: !0,
                            document: this.editor.model.document,
                            forceWeakRemove: !0
                        }).operationsA;
                        for (let b of g) {
                            const v = b.affectedSelectable;
                            v && !r.canEditAt(v) && (b = new Mt(b.baseVersion)),
                            t.addOperation(b),
                            r.applyOperation(b),
                            i.history.setOperationAsUndone(d, b)
                        }
                    }
                }
            }
            function oO(s) {
                s.sort( (e, t) => e.start.isBefore(t.start) ? -1 : 1);
                for (let e = 1; e < s.length; e++) {
                    const t = s[e - 1].getJoined(s[e], !0);
                    t && (e--,
                    s.splice(e, 2, t))
                }
            }
            function rO(s, e) {
                return e.some(t => t !== s && t.containsRange(s, !0))
            }
            class nO extends g0 {
                execute(e=null) {
                    const t = e ? this._stack.findIndex(l => l.batch == e) : this._stack.length - 1
                      , r = this._stack.splice(t, 1)[0]
                      , i = this.editor.model.createBatch({
                        isUndo: !0
                    });
                    this.editor.model.enqueueChange(i, () => {
                        this._undo(r.batch, i);
                        const l = this.editor.model.document.history.getOperations(r.batch.baseVersion);
                        this._restoreSelection(r.selection.ranges, r.selection.isBackward, l)
                    }
                    ),
                    this.fire("revert", r.batch, i),
                    this.refresh()
                }
            }
            class iO extends g0 {
                execute() {
                    const e = this._stack.pop()
                      , t = this.editor.model.createBatch({
                        isUndo: !0
                    });
                    this.editor.model.enqueueChange(t, () => {
                        const r = e.batch.operations[e.batch.operations.length - 1].baseVersion + 1
                          , i = this.editor.model.document.history.getOperations(r);
                        this._restoreSelection(e.selection.ranges, e.selection.isBackward, i),
                        this._undo(e.batch, t)
                    }
                    ),
                    this.refresh()
                }
            }
            class sO extends ie {
                constructor() {
                    super(...arguments),
                    C(this, "_undoCommand"),
                    C(this, "_redoCommand"),
                    C(this, "_batchRegistry", new WeakSet)
                }
                static get pluginName() {
                    return "UndoEditing"
                }
                init() {
                    const e = this.editor
                      , t = e.t;
                    this._undoCommand = new nO(e),
                    this._redoCommand = new iO(e),
                    e.commands.add("undo", this._undoCommand),
                    e.commands.add("redo", this._redoCommand),
                    this.listenTo(e.model, "applyOperation", (r, i) => {
                        const l = i[0];
                        if (!l.isDocumentOperation)
                            return;
                        const d = l.batch
                          , h = this._redoCommand.createdBatches.has(d)
                          , m = this._undoCommand.createdBatches.has(d);
                        this._batchRegistry.has(d) || (this._batchRegistry.add(d),
                        d.isUndoable && (h ? this._undoCommand.addBatch(d) : m || (this._undoCommand.addBatch(d),
                        this._redoCommand.clearStack())))
                    }
                    , {
                        priority: "highest"
                    }),
                    this.listenTo(this._undoCommand, "revert", (r, i, l) => {
                        this._redoCommand.addBatch(l)
                    }
                    ),
                    e.keystrokes.set("CTRL+Z", "undo"),
                    e.keystrokes.set("CTRL+Y", "redo"),
                    e.keystrokes.set("CTRL+SHIFT+Z", "redo"),
                    e.accessibility.addKeystrokeInfos({
                        keystrokes: [{
                            label: t("Undo"),
                            keystroke: "CTRL+Z"
                        }, {
                            label: t("Redo"),
                            keystroke: [["CTRL+Y"], ["CTRL+SHIFT+Z"]]
                        }]
                    })
                }
            }
            class aO extends ie {
                static get pluginName() {
                    return "UndoUI"
                }
                init() {
                    const e = this.editor
                      , t = e.locale
                      , r = e.t
                      , i = t.uiLanguageDirection == "ltr" ? he.undo : he.redo
                      , l = t.uiLanguageDirection == "ltr" ? he.redo : he.undo;
                    this._addButtonsToFactory("undo", r("Undo"), "CTRL+Z", i),
                    this._addButtonsToFactory("redo", r("Redo"), "CTRL+Y", l)
                }
                _addButtonsToFactory(e, t, r, i) {
                    const l = this.editor;
                    l.ui.componentFactory.add(e, () => {
                        const d = this._createButton(Te, e, t, r, i);
                        return d.set({
                            tooltip: !0
                        }),
                        d
                    }
                    ),
                    l.ui.componentFactory.add("menuBar:" + e, () => this._createButton(Xt, e, t, r, i))
                }
                _createButton(e, t, r, i, l) {
                    const d = this.editor
                      , h = d.locale
                      , m = d.commands.get(t)
                      , g = new e(h);
                    return g.set({
                        label: r,
                        icon: l,
                        keystroke: i
                    }),
                    g.bind("isEnabled").to(m, "isEnabled"),
                    this.listenTo(g, "execute", () => {
                        d.execute(t),
                        d.editing.view.focus()
                    }
                    ),
                    g
                }
            }
            class f0 extends ie {
                static get requires() {
                    return [sO, aO]
                }
                static get pluginName() {
                    return "Undo"
                }
            }
            class lO extends ie {
                static get requires() {
                    return [Ij, m0, du, tO, Iz, vz, f0]
                }
                static get pluginName() {
                    return "Essentials"
                }
            }
            class cO extends ye() {
                constructor() {
                    super(),
                    C(this, "total"),
                    C(this, "_reader"),
                    C(this, "_data");
                    const e = new window.FileReader;
                    this._reader = e,
                    this._data = void 0,
                    this.set("loaded", 0),
                    e.onprogress = t => {
                        this.loaded = t.loaded
                    }
                }
                get error() {
                    return this._reader.error
                }
                get data() {
                    return this._data
                }
                read(e) {
                    const t = this._reader;
                    return this.total = e.size,
                    new Promise( (r, i) => {
                        t.onload = () => {
                            const l = t.result;
                            this._data = l,
                            r(l)
                        }
                        ,
                        t.onerror = () => {
                            i("error")
                        }
                        ,
                        t.onabort = () => {
                            i("aborted")
                        }
                        ,
                        this._reader.readAsDataURL(e)
                    }
                    )
                }
                abort() {
                    this._reader.abort()
                }
            }
            class br extends ie {
                constructor() {
                    super(...arguments),
                    C(this, "loaders", new dr),
                    C(this, "_loadersMap", new Map),
                    C(this, "_pendingAction", null)
                }
                static get pluginName() {
                    return "FileRepository"
                }
                static get requires() {
                    return [lC]
                }
                init() {
                    this.loaders.on("change", () => this._updatePendingAction()),
                    this.set("uploaded", 0),
                    this.set("uploadTotal", null),
                    this.bind("uploadedPercent").to(this, "uploaded", this, "uploadTotal", (e, t) => t ? e / t * 100 : 0)
                }
                getLoader(e) {
                    return this._loadersMap.get(e) || null
                }
                createLoader(e) {
                    if (!this.createUploadAdapter)
                        return de("filerepository-no-upload-adapter"),
                        null;
                    const t = new k0(Promise.resolve(e),this.createUploadAdapter);
                    return this.loaders.add(t),
                    this._loadersMap.set(e, t),
                    e instanceof Promise && t.file.then(r => {
                        this._loadersMap.set(r, t)
                    }
                    ).catch( () => {}
                    ),
                    t.on("change:uploaded", () => {
                        let r = 0;
                        for (const i of this.loaders)
                            r += i.uploaded;
                        this.uploaded = r
                    }
                    ),
                    t.on("change:uploadTotal", () => {
                        let r = 0;
                        for (const i of this.loaders)
                            i.uploadTotal && (r += i.uploadTotal);
                        this.uploadTotal = r
                    }
                    ),
                    t
                }
                destroyLoader(e) {
                    const t = e instanceof k0 ? e : this.getLoader(e);
                    t._destroy(),
                    this.loaders.remove(t),
                    this._loadersMap.forEach( (r, i) => {
                        r === t && this._loadersMap.delete(i)
                    }
                    )
                }
                _updatePendingAction() {
                    const e = this.editor.plugins.get(lC);
                    if (this.loaders.length) {
                        if (!this._pendingAction) {
                            const t = this.editor.t
                              , r = i => `${t("Upload in progress")} ${parseInt(i)}%.`;
                            this._pendingAction = e.add(r(this.uploadedPercent)),
                            this._pendingAction.bind("message").to(this, "uploadedPercent", r)
                        }
                    } else
                        e.remove(this._pendingAction),
                        this._pendingAction = null
                }
            }
            class k0 extends ye() {
                constructor(e, t) {
                    super(),
                    C(this, "id"),
                    C(this, "_filePromiseWrapper"),
                    C(this, "_adapter"),
                    C(this, "_reader"),
                    this.id = H(),
                    this._filePromiseWrapper = this._createFilePromiseWrapper(e),
                    this._adapter = t(this),
                    this._reader = new cO,
                    this.set("status", "idle"),
                    this.set("uploaded", 0),
                    this.set("uploadTotal", null),
                    this.bind("uploadedPercent").to(this, "uploaded", this, "uploadTotal", (r, i) => i ? r / i * 100 : 0),
                    this.set("uploadResponse", null)
                }
                get file() {
                    return this._filePromiseWrapper ? this._filePromiseWrapper.promise.then(e => this._filePromiseWrapper ? e : null) : Promise.resolve(null)
                }
                get data() {
                    return this._reader.data
                }
                read() {
                    if (this.status != "idle")
                        throw new U("filerepository-read-wrong-status",this);
                    return this.status = "reading",
                    this.file.then(e => this._reader.read(e)).then(e => {
                        if (this.status !== "reading")
                            throw this.status;
                        return this.status = "idle",
                        e
                    }
                    ).catch(e => {
                        throw e === "aborted" ? (this.status = "aborted",
                        "aborted") : (this.status = "error",
                        this._reader.error ? this._reader.error : e)
                    }
                    )
                }
                upload() {
                    if (this.status != "idle")
                        throw new U("filerepository-upload-wrong-status",this);
                    return this.status = "uploading",
                    this.file.then( () => this._adapter.upload()).then(e => (this.uploadResponse = e,
                    this.status = "idle",
                    e)).catch(e => {
                        throw this.status === "aborted" ? "aborted" : (this.status = "error",
                        e)
                    }
                    )
                }
                abort() {
                    const e = this.status;
                    this.status = "aborted",
                    this._filePromiseWrapper.isFulfilled ? e == "reading" ? this._reader.abort() : e == "uploading" && this._adapter.abort && this._adapter.abort() : (this._filePromiseWrapper.promise.catch( () => {}
                    ),
                    this._filePromiseWrapper.rejecter("aborted")),
                    this._destroy()
                }
                _destroy() {
                    this._filePromiseWrapper = void 0,
                    this._reader = void 0,
                    this._adapter = void 0,
                    this.uploadResponse = void 0
                }
                _createFilePromiseWrapper(e) {
                    const t = {};
                    return t.promise = new Promise( (r, i) => {
                        t.rejecter = i,
                        t.isFulfilled = !1,
                        e.then(l => {
                            t.isFulfilled = !0,
                            r(l)
                        }
                        ).catch(l => {
                            t.isFulfilled = !0,
                            i(l)
                        }
                        )
                    }
                    ),
                    t
                }
            }
            const b0 = "ckCsrfToken"
              , w0 = "abcdefghijklmnopqrstuvwxyz0123456789";
            function dO() {
                let s = function(r) {
                    r = r.toLowerCase();
                    const i = document.cookie.split(";");
                    for (const l of i) {
                        const d = l.split("=");
                        if (decodeURIComponent(d[0].trim().toLowerCase()) === r)
                            return decodeURIComponent(d[1])
                    }
                    return null
                }(b0);
                var e, t;
                return s && s.length == 40 || (s = function(r) {
                    let i = "";
                    const l = new Uint8Array(r);
                    window.crypto.getRandomValues(l);
                    for (let d = 0; d < l.length; d++) {
                        const h = w0.charAt(l[d] % w0.length);
                        i += Math.random() > .5 ? h.toUpperCase() : h
                    }
                    return i
                }(40),
                e = b0,
                t = s,
                document.cookie = encodeURIComponent(e) + "=" + encodeURIComponent(t) + ";path=/"),
                s
            }
            class uO extends ie {
                static get requires() {
                    return [br]
                }
                static get pluginName() {
                    return "CKFinderUploadAdapter"
                }
                init() {
                    const e = this.editor.config.get("ckfinder.uploadUrl");
                    e && (this.editor.plugins.get(br).createUploadAdapter = t => new hO(t,e,this.editor.t))
                }
            }
            class hO {
                constructor(e, t, r) {
                    C(this, "loader"),
                    C(this, "url"),
                    C(this, "t"),
                    C(this, "xhr"),
                    this.loader = e,
                    this.url = t,
                    this.t = r
                }
                upload() {
                    return this.loader.file.then(e => new Promise( (t, r) => {
                        this._initRequest(),
                        this._initListeners(t, r, e),
                        this._sendRequest(e)
                    }
                    ))
                }
                abort() {
                    this.xhr && this.xhr.abort()
                }
                _initRequest() {
                    const e = this.xhr = new XMLHttpRequest;
                    e.open("POST", this.url, !0),
                    e.responseType = "json"
                }
                _initListeners(e, t, r) {
                    const i = this.xhr
                      , l = this.loader
                      , d = (0,
                    this.t)("Cannot upload file:") + ` ${r.name}.`;
                    i.addEventListener("error", () => t(d)),
                    i.addEventListener("abort", () => t()),
                    i.addEventListener("load", () => {
                        const h = i.response;
                        if (!h || !h.uploaded)
                            return t(h && h.error && h.error.message ? h.error.message : d);
                        e({
                            default: h.url
                        })
                    }
                    ),
                    i.upload && i.upload.addEventListener("progress", h => {
                        h.lengthComputable && (l.uploadTotal = h.total,
                        l.uploaded = h.loaded)
                    }
                    )
                }
                _sendRequest(e) {
                    const t = new FormData;
                    t.append("upload", e),
                    t.append("ckCsrfToken", dO()),
                    this.xhr.send(t)
                }
            }
            function Ln(s, e, t, r) {
                let i, l = null;
                typeof r == "function" ? i = r : (l = s.commands.get(r),
                i = () => {
                    s.execute(r)
                }
                ),
                s.model.document.on("change:data", (d, h) => {
                    if (l && !l.isEnabled || !e.isEnabled)
                        return;
                    const m = zt(s.model.document.selection.getRanges());
                    if (!m.isCollapsed || h.isUndo || !h.isLocal)
                        return;
                    const g = Array.from(s.model.document.differ.getChanges())
                      , b = g[0];
                    if (g.length != 1 || b.type !== "insert" || b.name != "$text" || b.length != 1)
                        return;
                    const v = b.position.parent;
                    if (v.is("element", "codeBlock") || v.is("element", "listItem") && typeof r != "function" && !["numberedList", "bulletedList", "todoList"].includes(r) || l && l.value === !0)
                        return;
                    const x = v.getChild(0)
                      , T = s.model.createRangeOn(x);
                    if (!T.containsRange(m) && !m.end.isEqual(T.end))
                        return;
                    const I = t.exec(x.data.substr(0, m.end.offset));
                    I && s.model.enqueueChange(P => {
                        const O = P.createPositionAt(v, 0)
                          , F = P.createPositionAt(v, I[0].length)
                          , q = new Io(O,F);
                        if (i({
                            match: I
                        }) !== !1) {
                            P.remove(q);
                            const Q = s.model.document.selection.getFirstRange()
                              , X = P.createRangeIn(v);
                            !v.isEmpty || X.isEqual(Q) || X.containsRange(Q, !0) || P.remove(v)
                        }
                        q.detach(),
                        s.model.enqueueChange( () => {
                            s.plugins.get("Delete").requestUndoOnBackspace()
                        }
                        )
                    }
                    )
                }
                )
            }
            function Vs(s, e, t, r) {
                let i, l;
                t instanceof RegExp ? i = t : l = t,
                l = l || (d => {
                    let h;
                    const m = []
                      , g = [];
                    for (; (h = i.exec(d)) !== null && !(h && h.length < 4); ) {
                        let {index: b, 1: v, 2: x, 3: T} = h;
                        const I = v + x + T;
                        b += h[0].length - I.length;
                        const P = [b, b + v.length]
                          , O = [b + v.length + x.length, b + v.length + x.length + T.length];
                        m.push(P),
                        m.push(O),
                        g.push([b + v.length, b + v.length + x.length])
                    }
                    return {
                        remove: m,
                        format: g
                    }
                }
                ),
                s.model.document.on("change:data", (d, h) => {
                    if (h.isUndo || !h.isLocal || !e.isEnabled)
                        return;
                    const m = s.model
                      , g = m.document.selection;
                    if (!g.isCollapsed)
                        return;
                    const b = Array.from(m.document.differ.getChanges())
                      , v = b[0];
                    if (b.length != 1 || v.type !== "insert" || v.name != "$text" || v.length != 1)
                        return;
                    const x = g.focus
                      , T = x.parent
                      , {text: I, range: P} = function(Q, X) {
                        let le = Q.start;
                        return {
                            text: Array.from(Q.getItems()).reduce( (ge, ke) => !ke.is("$text") && !ke.is("$textProxy") || ke.getAttribute("code") ? (le = X.createPositionAfter(ke),
                            "") : ge + ke.data, ""),
                            range: X.createRange(le, Q.end)
                        }
                    }(m.createRange(m.createPositionAt(T, 0), x), m)
                      , O = l(I)
                      , F = A0(P.start, O.format, m)
                      , q = A0(P.start, O.remove, m);
                    F.length && q.length && m.enqueueChange(Q => {
                        if (r(Q, F) !== !1) {
                            for (const X of q.reverse())
                                Q.remove(X);
                            m.enqueueChange( () => {
                                s.plugins.get("Delete").requestUndoOnBackspace()
                            }
                            )
                        }
                    }
                    )
                }
                )
            }
            function A0(s, e, t) {
                return e.filter(r => r[0] !== void 0 && r[1] !== void 0).map(r => t.createRange(s.getShiftedBy(r[0]), s.getShiftedBy(r[1])))
            }
            class mO extends ie {
                static get requires() {
                    return [Xr]
                }
                static get pluginName() {
                    return "Autoformat"
                }
                afterInit() {
                    const e = this.editor
                      , t = this.editor.t;
                    this._addListAutoformats(),
                    this._addBasicStylesAutoformats(),
                    this._addHeadingAutoformats(),
                    this._addBlockQuoteAutoformats(),
                    this._addCodeBlockAutoformats(),
                    this._addHorizontalLineAutoformats(),
                    e.accessibility.addKeystrokeInfos({
                        keystrokes: [{
                            label: t("Revert autoformatting action"),
                            keystroke: "Backspace"
                        }]
                    })
                }
                _addListAutoformats() {
                    const e = this.editor.commands;
                    e.get("bulletedList") && Ln(this.editor, this, /^[*-]\s$/, "bulletedList"),
                    e.get("numberedList") && Ln(this.editor, this, /^1[.|)]\s$/, "numberedList"),
                    e.get("todoList") && Ln(this.editor, this, /^\[\s?\]\s$/, "todoList"),
                    e.get("checkTodoList") && Ln(this.editor, this, /^\[\s?x\s?\]\s$/, () => {
                        this.editor.execute("todoList"),
                        this.editor.execute("checkTodoList")
                    }
                    )
                }
                _addBasicStylesAutoformats() {
                    const e = this.editor.commands;
                    if (e.get("bold")) {
                        const t = gu(this.editor, "bold");
                        Vs(this.editor, this, /(?:^|\s)(\*\*)([^*]+)(\*\*)$/g, t),
                        Vs(this.editor, this, /(?:^|\s)(__)([^_]+)(__)$/g, t)
                    }
                    if (e.get("italic")) {
                        const t = gu(this.editor, "italic");
                        Vs(this.editor, this, /(?:^|\s)(\*)([^*_]+)(\*)$/g, t),
                        Vs(this.editor, this, /(?:^|\s)(_)([^_]+)(_)$/g, t)
                    }
                    if (e.get("code")) {
                        const t = gu(this.editor, "code");
                        Vs(this.editor, this, /(`)([^`]+)(`)$/g, t)
                    }
                    if (e.get("strikethrough")) {
                        const t = gu(this.editor, "strikethrough");
                        Vs(this.editor, this, /(~~)([^~]+)(~~)$/g, t)
                    }
                }
                _addHeadingAutoformats() {
                    const e = this.editor.commands.get("heading");
                    e && e.modelElements.filter(t => t.match(/^heading[1-6]$/)).forEach(t => {
                        const r = t[7]
                          , i = new RegExp(`^(#{${r}})\\s$`);
                        Ln(this.editor, this, i, () => {
                            if (!e.isEnabled || e.value === t)
                                return !1;
                            this.editor.execute("heading", {
                                value: t
                            })
                        }
                        )
                    }
                    )
                }
                _addBlockQuoteAutoformats() {
                    this.editor.commands.get("blockQuote") && Ln(this.editor, this, /^>\s$/, "blockQuote")
                }
                _addCodeBlockAutoformats() {
                    const e = this.editor
                      , t = e.model.document.selection;
                    e.commands.get("codeBlock") && Ln(e, this, /^```$/, () => {
                        if (t.getFirstPosition().parent.is("element", "listItem"))
                            return !1;
                        this.editor.execute("codeBlock", {
                            usePreviousLanguageChoice: !0
                        })
                    }
                    )
                }
                _addHorizontalLineAutoformats() {
                    this.editor.commands.get("horizontalLine") && Ln(this.editor, this, /^---$/, "horizontalLine")
                }
            }
            function gu(s, e) {
                return (t, r) => {
                    if (!s.commands.get(e).isEnabled)
                        return !1;
                    const i = s.model.schema.getValidRanges(r, e);
                    for (const l of i)
                        t.setAttribute(e, !0, l);
                    t.removeSelectionAttribute(e)
                }
            }
            class v0 extends _e {
                constructor(e, t) {
                    super(e),
                    C(this, "attributeKey"),
                    this.attributeKey = t
                }
                refresh() {
                    const e = this.editor.model
                      , t = e.document;
                    this.value = this._getValueFromFirstAllowedNode(),
                    this.isEnabled = e.schema.checkAttributeInSelection(t.selection, this.attributeKey)
                }
                execute(e={}) {
                    const t = this.editor.model
                      , r = t.document.selection
                      , i = e.forceValue === void 0 ? !this.value : e.forceValue;
                    t.change(l => {
                        if (r.isCollapsed)
                            i ? l.setSelectionAttribute(this.attributeKey, !0) : l.removeSelectionAttribute(this.attributeKey);
                        else {
                            const d = t.schema.getValidRanges(r.getRanges(), this.attributeKey);
                            for (const h of d)
                                i ? l.setAttribute(this.attributeKey, i, h) : l.removeAttribute(this.attributeKey, h)
                        }
                    }
                    )
                }
                _getValueFromFirstAllowedNode() {
                    const e = this.editor.model
                      , t = e.schema
                      , r = e.document.selection;
                    if (r.isCollapsed)
                        return r.hasAttribute(this.attributeKey);
                    for (const i of r.getRanges())
                        for (const l of i.getItems())
                            if (t.checkAttribute(l, this.attributeKey))
                                return l.hasAttribute(this.attributeKey);
                    return !1
                }
            }
            const Us = "bold";
            class pO extends ie {
                static get pluginName() {
                    return "BoldEditing"
                }
                init() {
                    const e = this.editor
                      , t = this.editor.t;
                    e.model.schema.extend("$text", {
                        allowAttributes: Us
                    }),
                    e.model.schema.setAttributeProperties(Us, {
                        isFormatting: !0,
                        copyOnEnter: !0
                    }),
                    e.conversion.attributeToElement({
                        model: Us,
                        view: "strong",
                        upcastAlso: ["b", r => {
                            const i = r.getStyle("font-weight");
                            return i && (i == "bold" || Number(i) >= 600) ? {
                                name: !0,
                                styles: ["font-weight"]
                            } : null
                        }
                        ]
                    }),
                    e.commands.add(Us, new v0(e,Us)),
                    e.keystrokes.set("CTRL+B", Us),
                    e.accessibility.addKeystrokeInfos({
                        keystrokes: [{
                            label: t("Bold text"),
                            keystroke: "CTRL+B"
                        }]
                    })
                }
            }
            function _0({editor: s, commandName: e, plugin: t, icon: r, label: i, keystroke: l}) {
                return d => {
                    const h = s.commands.get(e)
                      , m = new d(s.locale);
                    return m.set({
                        label: i,
                        icon: r,
                        keystroke: l,
                        isToggleable: !0
                    }),
                    m.bind("isEnabled").to(h, "isEnabled"),
                    t.listenTo(m, "execute", () => {
                        s.execute(e),
                        s.editing.view.focus()
                    }
                    ),
                    m
                }
            }
            const fu = "bold";
            class gO extends ie {
                static get pluginName() {
                    return "BoldUI"
                }
                init() {
                    const e = this.editor
                      , t = e.locale.t
                      , r = e.commands.get(fu)
                      , i = _0({
                        editor: e,
                        commandName: fu,
                        plugin: this,
                        icon: he.bold,
                        label: t("Bold"),
                        keystroke: "CTRL+B"
                    });
                    e.ui.componentFactory.add(fu, () => {
                        const l = i(Te);
                        return l.set({
                            tooltip: !0
                        }),
                        l.bind("isOn").to(r, "value"),
                        l
                    }
                    ),
                    e.ui.componentFactory.add("menuBar:" + fu, () => i(Xt))
                }
            }
            class fO extends ie {
                static get requires() {
                    return [pO, gO]
                }
                static get pluginName() {
                    return "Bold"
                }
            }
            var C0 = u(4199)
              , kO = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(C0.A, kO),
            C0.A.locals;
            const Hs = "italic";
            class bO extends ie {
                static get pluginName() {
                    return "ItalicEditing"
                }
                init() {
                    const e = this.editor
                      , t = this.editor.t;
                    e.model.schema.extend("$text", {
                        allowAttributes: Hs
                    }),
                    e.model.schema.setAttributeProperties(Hs, {
                        isFormatting: !0,
                        copyOnEnter: !0
                    }),
                    e.conversion.attributeToElement({
                        model: Hs,
                        view: "i",
                        upcastAlso: ["em", {
                            styles: {
                                "font-style": "italic"
                            }
                        }]
                    }),
                    e.commands.add(Hs, new v0(e,Hs)),
                    e.keystrokes.set("CTRL+I", Hs),
                    e.accessibility.addKeystrokeInfos({
                        keystrokes: [{
                            label: t("Italic text"),
                            keystroke: "CTRL+I"
                        }]
                    })
                }
            }
            const ku = "italic";
            class wO extends ie {
                static get pluginName() {
                    return "ItalicUI"
                }
                init() {
                    const e = this.editor
                      , t = e.commands.get(ku)
                      , r = e.locale.t
                      , i = _0({
                        editor: e,
                        commandName: ku,
                        plugin: this,
                        icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.586 14.633.021.004c-.036.335.095.655.393.962.082.083.173.15.274.201h1.474a.6.6 0 1 1 0 1.2H5.304a.6.6 0 0 1 0-1.2h1.15c.474-.07.809-.182 1.005-.334.157-.122.291-.32.404-.597l2.416-9.55a1.053 1.053 0 0 0-.281-.823 1.12 1.12 0 0 0-.442-.296H8.15a.6.6 0 0 1 0-1.2h6.443a.6.6 0 1 1 0 1.2h-1.195c-.376.056-.65.155-.823.296-.215.175-.423.439-.623.79l-2.366 9.347z"/></svg>',
                        keystroke: "CTRL+I",
                        label: r("Italic")
                    });
                    e.ui.componentFactory.add(ku, () => {
                        const l = i(Te);
                        return l.set({
                            tooltip: !0
                        }),
                        l.bind("isOn").to(t, "value"),
                        l
                    }
                    ),
                    e.ui.componentFactory.add("menuBar:" + ku, () => i(Xt))
                }
            }
            class AO extends ie {
                static get requires() {
                    return [bO, wO]
                }
                static get pluginName() {
                    return "Italic"
                }
            }
            class vO extends _e {
                refresh() {
                    this.value = this._getValue(),
                    this.isEnabled = this._checkEnabled()
                }
                execute(e={}) {
                    const t = this.editor.model
                      , r = t.schema
                      , i = t.document.selection
                      , l = Array.from(i.getSelectedBlocks())
                      , d = e.forceValue === void 0 ? !this.value : e.forceValue;
                    t.change(h => {
                        if (d) {
                            const m = l.filter(g => bu(g) || x0(r, g));
                            this._applyQuote(h, m)
                        } else
                            this._removeQuote(h, l.filter(bu))
                    }
                    )
                }
                _getValue() {
                    const e = zt(this.editor.model.document.selection.getSelectedBlocks());
                    return !(!e || !bu(e))
                }
                _checkEnabled() {
                    if (this.value)
                        return !0;
                    const e = this.editor.model.document.selection
                      , t = this.editor.model.schema
                      , r = zt(e.getSelectedBlocks());
                    return !!r && x0(t, r)
                }
                _removeQuote(e, t) {
                    y0(e, t).reverse().forEach(r => {
                        if (r.start.isAtStart && r.end.isAtEnd)
                            return void e.unwrap(r.start.parent);
                        if (r.start.isAtStart) {
                            const l = e.createPositionBefore(r.start.parent);
                            return void e.move(r, l)
                        }
                        r.end.isAtEnd || e.split(r.end);
                        const i = e.createPositionAfter(r.end.parent);
                        e.move(r, i)
                    }
                    )
                }
                _applyQuote(e, t) {
                    const r = [];
                    y0(e, t).reverse().forEach(i => {
                        let l = bu(i.start);
                        l || (l = e.createElement("blockQuote"),
                        e.wrap(i, l)),
                        r.push(l)
                    }
                    ),
                    r.reverse().reduce( (i, l) => i.nextSibling == l ? (e.merge(e.createPositionAfter(i)),
                    i) : l)
                }
            }
            function bu(s) {
                return s.parent.name == "blockQuote" ? s.parent : null
            }
            function y0(s, e) {
                let t, r = 0;
                const i = [];
                for (; r < e.length; ) {
                    const l = e[r]
                      , d = e[r + 1];
                    t || (t = s.createPositionBefore(l)),
                    d && l.nextSibling == d || (i.push(s.createRange(t, s.createPositionAfter(l))),
                    t = null),
                    r++
                }
                return i
            }
            function x0(s, e) {
                const t = s.checkChild(e.parent, "blockQuote")
                  , r = s.checkChild(["$root", "blockQuote"], e);
                return t && r
            }
            class _O extends ie {
                static get pluginName() {
                    return "BlockQuoteEditing"
                }
                static get requires() {
                    return [du, Xr]
                }
                init() {
                    const e = this.editor
                      , t = e.model.schema;
                    e.commands.add("blockQuote", new vO(e)),
                    t.register("blockQuote", {
                        inheritAllFrom: "$container"
                    }),
                    e.conversion.elementToElement({
                        model: "blockQuote",
                        view: "blockquote"
                    }),
                    e.model.document.registerPostFixer(d => {
                        const h = e.model.document.differ.getChanges();
                        for (const m of h)
                            if (m.type == "insert") {
                                const g = m.position.nodeAfter;
                                if (!g)
                                    continue;
                                if (g.is("element", "blockQuote") && g.isEmpty)
                                    return d.remove(g),
                                    !0;
                                if (g.is("element", "blockQuote") && !t.checkChild(m.position, g))
                                    return d.unwrap(g),
                                    !0;
                                if (g.is("element")) {
                                    const b = d.createRangeIn(g);
                                    for (const v of b.getItems())
                                        if (v.is("element", "blockQuote") && !t.checkChild(d.createPositionBefore(v), v))
                                            return d.unwrap(v),
                                            !0
                                }
                            } else if (m.type == "remove") {
                                const g = m.position.parent;
                                if (g.is("element", "blockQuote") && g.isEmpty)
                                    return d.remove(g),
                                    !0
                            }
                        return !1
                    }
                    );
                    const r = this.editor.editing.view.document
                      , i = e.model.document.selection
                      , l = e.commands.get("blockQuote");
                    this.listenTo(r, "enter", (d, h) => {
                        !i.isCollapsed || !l.value || i.getLastPosition().parent.isEmpty && (e.execute("blockQuote"),
                        e.editing.view.scrollToTheSelection(),
                        h.preventDefault(),
                        d.stop())
                    }
                    , {
                        context: "blockquote"
                    }),
                    this.listenTo(r, "delete", (d, h) => {
                        if (h.direction != "backward" || !i.isCollapsed || !l.value)
                            return;
                        const m = i.getLastPosition().parent;
                        m.isEmpty && !m.previousSibling && (e.execute("blockQuote"),
                        e.editing.view.scrollToTheSelection(),
                        h.preventDefault(),
                        d.stop())
                    }
                    , {
                        context: "blockquote"
                    })
                }
            }
            var E0 = u(8708)
              , CO = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(E0.A, CO),
            E0.A.locals;
            class yO extends ie {
                static get pluginName() {
                    return "BlockQuoteUI"
                }
                init() {
                    const e = this.editor
                      , t = e.commands.get("blockQuote");
                    e.ui.componentFactory.add("blockQuote", () => {
                        const r = this._createButton(Te);
                        return r.set({
                            tooltip: !0
                        }),
                        r.bind("isOn").to(t, "value"),
                        r
                    }
                    ),
                    e.ui.componentFactory.add("menuBar:blockQuote", () => this._createButton(Xt))
                }
                _createButton(e) {
                    const t = this.editor
                      , r = t.locale
                      , i = t.commands.get("blockQuote")
                      , l = new e(t.locale)
                      , d = r.t;
                    return l.set({
                        label: d("Block quote"),
                        icon: he.quote,
                        isToggleable: !0
                    }),
                    l.bind("isEnabled").to(i, "isEnabled"),
                    this.listenTo(l, "execute", () => {
                        t.execute("blockQuote"),
                        t.editing.view.focus()
                    }
                    ),
                    l
                }
            }
            class xO extends ie {
                static get requires() {
                    return [_O, yO]
                }
                static get pluginName() {
                    return "BlockQuote"
                }
            }
            class EO extends ie {
                static get pluginName() {
                    return "CKBoxUI"
                }
                afterInit() {
                    const e = this.editor;
                    e.commands.get("ckbox") && (e.ui.componentFactory.add("ckbox", () => this._createFileToolbarButton()),
                    e.ui.componentFactory.add("menuBar:ckbox", () => this._createFileMenuBarButton()),
                    e.plugins.has("ImageInsertUI") && e.plugins.get("ImageInsertUI").registerIntegration({
                        name: "assetManager",
                        observable: () => e.commands.get("ckbox"),
                        buttonViewCreator: () => this._createImageToolbarButton(),
                        formViewCreator: () => this._createImageDropdownButton(),
                        menuBarButtonViewCreator: t => this._createImageMenuBarButton(t ? "insertOnly" : "insertNested")
                    }))
                }
                _createButton(e) {
                    const t = this.editor
                      , r = t.locale
                      , i = new e(r)
                      , l = t.commands.get("ckbox");
                    return r.t,
                    i.bind("isOn", "isEnabled").to(l, "value", "isEnabled"),
                    i.on("execute", () => {
                        t.execute("ckbox")
                    }
                    ),
                    i
                }
                _createFileToolbarButton() {
                    const e = this.editor.locale.t
                      , t = this._createButton(Te);
                    return t.icon = he.browseFiles,
                    t.label = e("Open file manager"),
                    t.tooltip = !0,
                    t
                }
                _createImageToolbarButton() {
                    const e = this.editor.locale.t
                      , t = this.editor.plugins.get("ImageInsertUI")
                      , r = this._createButton(Te);
                    return r.icon = he.imageAssetManager,
                    r.bind("label").to(t, "isImageSelected", i => e(i ? "Replace image with file manager" : "Insert image with file manager")),
                    r.tooltip = !0,
                    r
                }
                _createImageDropdownButton() {
                    const e = this.editor.locale.t
                      , t = this.editor.plugins.get("ImageInsertUI")
                      , r = this._createButton(Te);
                    return r.icon = he.imageAssetManager,
                    r.withText = !0,
                    r.bind("label").to(t, "isImageSelected", i => e(i ? "Replace with file manager" : "Insert with file manager")),
                    r.on("execute", () => {
                        t.dropdownView.isOpen = !1
                    }
                    ),
                    r
                }
                _createFileMenuBarButton() {
                    const e = this.editor.locale.t
                      , t = this._createButton(Xt);
                    return t.icon = he.browseFiles,
                    t.withText = !0,
                    t.label = e("File"),
                    t
                }
                _createImageMenuBarButton(e) {
                    const t = this.editor.locale.t
                      , r = this._createButton(Xt);
                    switch (r.icon = he.imageAssetManager,
                    r.withText = !0,
                    e) {
                    case "insertOnly":
                        r.label = t("Image");
                        break;
                    case "insertNested":
                        r.label = t("With file manager")
                    }
                    return r
                }
            }
            var SO = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "#", "$", "%", "*", "+", ",", "-", ".", ":", ";", "=", "?", "@", "[", "]", "^", "_", "{", "|", "}", "~"]
              , Ll = s => {
                let e = 0;
                for (let t = 0; t < s.length; t++) {
                    let r = s[t];
                    e = 83 * e + SO.indexOf(r)
                }
                return e
            }
              , ag = s => {
                let e = s / 255;
                return e <= .04045 ? e / 12.92 : Math.pow((e + .055) / 1.055, 2.4)
            }
              , lg = s => {
                let e = Math.max(0, Math.min(1, s));
                return e <= .0031308 ? Math.trunc(12.92 * e * 255 + .5) : Math.trunc(255 * (1.055 * Math.pow(e, .4166666666666667) - .055) + .5)
            }
              , cg = (s, e) => (t => t < 0 ? -1 : 1)(s) * Math.pow(Math.abs(s), e)
              , S0 = class extends Error {
                constructor(s) {
                    super(s),
                    this.name = "ValidationError",
                    this.message = s
                }
            }
              , DO = s => {
                if (!s || s.length < 6)
                    throw new S0("The blurhash string must be at least 6 characters");
                let e = Ll(s[0])
                  , t = Math.floor(e / 9) + 1
                  , r = e % 9 + 1;
                if (s.length !== 4 + 2 * r * t)
                    throw new S0(`blurhash length mismatch: length is ${s.length} but it should be ${4 + 2 * r * t}`)
            }
              , TO = s => {
                let e = s >> 8 & 255
                  , t = 255 & s;
                return [ag(s >> 16), ag(e), ag(t)]
            }
              , IO = (s, e) => {
                let t = Math.floor(s / 361)
                  , r = Math.floor(s / 19) % 19
                  , i = s % 19;
                return [cg((t - 9) / 9, 2) * e, cg((r - 9) / 9, 2) * e, cg((i - 9) / 9, 2) * e]
            }
              , MO = (s, e, t, r) => {
                DO(s),
                r |= 1;
                let i = Ll(s[0])
                  , l = Math.floor(i / 9) + 1
                  , d = i % 9 + 1
                  , h = (Ll(s[1]) + 1) / 166
                  , m = new Array(d * l);
                for (let v = 0; v < m.length; v++)
                    if (v === 0) {
                        let x = Ll(s.substring(2, 6));
                        m[v] = TO(x)
                    } else {
                        let x = Ll(s.substring(4 + 2 * v, 6 + 2 * v));
                        m[v] = IO(x, h * r)
                    }
                let g = 4 * e
                  , b = new Uint8ClampedArray(g * t);
                for (let v = 0; v < t; v++)
                    for (let x = 0; x < e; x++) {
                        let T = 0
                          , I = 0
                          , P = 0;
                        for (let Q = 0; Q < l; Q++)
                            for (let X = 0; X < d; X++) {
                                let le = Math.cos(Math.PI * x * X / e) * Math.cos(Math.PI * v * Q / t)
                                  , ge = m[X + Q * d];
                                T += ge[0] * le,
                                I += ge[1] * le,
                                P += ge[2] * le
                            }
                        let O = lg(T)
                          , F = lg(I)
                          , q = lg(P);
                        b[4 * x + 0 + v * g] = O,
                        b[4 * x + 1 + v * g] = F,
                        b[4 * x + 2 + v * g] = q,
                        b[4 * x + 3 + v * g] = 255
                    }
                return b
            }
            ;
            function D0(s) {
                const e = [];
                let t = 0;
                for (const i in s) {
                    const l = parseInt(i, 10);
                    isNaN(l) || (l > t && (t = l),
                    e.push(`${s[i]} ${i}w`))
                }
                const r = [{
                    srcset: e.join(","),
                    sizes: `(max-width: ${t}px) 100vw, ${t}px`,
                    type: "image/webp"
                }];
                return {
                    imageFallbackUrl: s.default,
                    imageSources: r
                }
            }
            const zl = 32;
            function T0({url: s, method: e="GET", data: t, onUploadProgress: r, signal: i, authorization: l}) {
                const d = new XMLHttpRequest;
                d.open(e, s.toString()),
                d.setRequestHeader("Authorization", l),
                d.setRequestHeader("CKBox-Version", "CKEditor 5"),
                d.responseType = "json";
                const h = () => {
                    d.abort()
                }
                ;
                return new Promise( (m, g) => {
                    i.throwIfAborted(),
                    i.addEventListener("abort", h),
                    d.addEventListener("loadstart", () => {
                        i.addEventListener("abort", h)
                    }
                    ),
                    d.addEventListener("loadend", () => {
                        i.removeEventListener("abort", h)
                    }
                    ),
                    d.addEventListener("error", () => {
                        g()
                    }
                    ),
                    d.addEventListener("abort", () => {
                        g()
                    }
                    ),
                    d.addEventListener("load", () => {
                        const b = d.response;
                        if (!b || b.statusCode >= 400)
                            return g(b && b.message);
                        m(b)
                    }
                    ),
                    r && d.upload.addEventListener("progress", b => {
                        r(b)
                    }
                    ),
                    d.send(t)
                }
                )
            }
            const BO = {
                "image/gif": "gif",
                "image/jpeg": "jpg",
                "image/png": "png",
                "image/webp": "webp",
                "image/bmp": "bmp",
                "image/tiff": "tiff"
            };
            class NO extends _e {
                constructor(e) {
                    super(e),
                    C(this, "_chosenAssets", new Set),
                    C(this, "_wrapper", null),
                    this._initListeners()
                }
                refresh() {
                    this.value = this._getValue(),
                    this.isEnabled = this._checkEnabled()
                }
                execute() {
                    this.fire("ckbox:open")
                }
                _getValue() {
                    return this._wrapper !== null
                }
                _checkEnabled() {
                    const e = this.editor.commands.get("insertImage")
                      , t = this.editor.commands.get("link");
                    return !(!e.isEnabled && !t.isEnabled)
                }
                _prepareOptions() {
                    const e = this.editor.config.get("ckbox");
                    return {
                        theme: e.theme,
                        language: e.language,
                        tokenUrl: e.tokenUrl,
                        serviceOrigin: e.serviceOrigin,
                        forceDemoLabel: e.forceDemoLabel,
                        dialog: {
                            onClose: () => this.fire("ckbox:close")
                        },
                        assets: {
                            onChoose: t => this.fire("ckbox:choose", t)
                        }
                    }
                }
                _initListeners() {
                    const e = this.editor
                      , t = e.model
                      , r = !e.config.get("ckbox.ignoreDataId");
                    this.on("ckbox", () => {
                        this.refresh()
                    }
                    , {
                        priority: "low"
                    }),
                    this.on("ckbox:open", () => {
                        this.isEnabled && !this.value && (this._wrapper = $o(document, "div", {
                            class: "ck ckbox-wrapper"
                        }),
                        document.body.appendChild(this._wrapper),
                        window.CKBox.mount(this._wrapper, this._prepareOptions()))
                    }
                    ),
                    this.on("ckbox:close", () => {
                        this.value && (this._wrapper.remove(),
                        this._wrapper = null,
                        e.editing.view.focus())
                    }
                    ),
                    this.on("ckbox:choose", (i, l) => {
                        if (!this.isEnabled)
                            return;
                        const d = e.commands.get("insertImage")
                          , h = e.commands.get("link")
                          , m = function({assets: b, isImageAllowed: v, isLinkAllowed: x}) {
                            return b.map(T => function(I) {
                                const P = I.data.metadata;
                                return P ? P.width && P.height : !1
                            }(T) ? {
                                id: T.data.id,
                                type: "image",
                                attributes: PO(T)
                            } : {
                                id: T.data.id,
                                type: "link",
                                attributes: jO(T)
                            }).filter(T => T.type === "image" ? v : x)
                        }({
                            assets: l,
                            isImageAllowed: d.isEnabled,
                            isLinkAllowed: h.isEnabled
                        })
                          , g = m.length;
                        g !== 0 && (t.change(b => {
                            for (const v of m) {
                                const x = v === m[g - 1]
                                  , T = g === 1;
                                this._insertAsset(v, x, b, T),
                                r && (setTimeout( () => this._chosenAssets.delete(v), 1e3),
                                this._chosenAssets.add(v))
                            }
                        }
                        ),
                        e.editing.view.focus())
                    }
                    ),
                    this.listenTo(e, "destroy", () => {
                        this.fire("ckbox:close"),
                        this._chosenAssets.clear()
                    }
                    )
                }
                _insertAsset(e, t, r, i) {
                    const l = this.editor.model.document.selection;
                    r.removeSelectionAttribute("linkHref"),
                    e.type === "image" ? this._insertImage(e) : this._insertLink(e, r, i),
                    t || r.setSelection(l.getLastPosition())
                }
                _insertImage(e) {
                    const t = this.editor
                      , {imageFallbackUrl: r, imageSources: i, imageTextAlternative: l, imageWidth: d, imageHeight: h, imagePlaceholder: m} = e.attributes;
                    t.execute("insertImage", {
                        source: {
                            src: r,
                            sources: i,
                            alt: l,
                            width: d,
                            height: h,
                            ...m ? {
                                placeholder: m
                            } : null
                        }
                    })
                }
                _insertLink(e, t, r) {
                    const i = this.editor
                      , l = i.model
                      , d = l.document.selection
                      , {linkName: h, linkHref: m} = e.attributes;
                    if (d.isCollapsed) {
                        const g = Ir(d.getAttributes())
                          , b = t.createText(h, g);
                        if (!r) {
                            const x = d.getLastPosition()
                              , T = x.parent;
                            T.name === "paragraph" && T.isEmpty || i.execute("insertParagraph", {
                                position: x
                            });
                            const I = l.insertContent(b);
                            return t.setSelection(I),
                            void i.execute("link", m)
                        }
                        const v = l.insertContent(b);
                        t.setSelection(v)
                    }
                    i.execute("link", m)
                }
            }
            function PO(s) {
                const {imageFallbackUrl: e, imageSources: t} = D0(s.data.imageUrls)
                  , {description: r, width: i, height: l, blurHash: d} = s.data.metadata
                  , h = function(m) {
                    if (m)
                        try {
                            const g = `${zl}px`
                              , b = document.createElement("canvas");
                            b.setAttribute("width", g),
                            b.setAttribute("height", g);
                            const v = b.getContext("2d");
                            if (!v)
                                return;
                            const x = v.createImageData(zl, zl)
                              , T = MO(m, zl, zl);
                            return x.data.set(T),
                            v.putImageData(x, 0, 0),
                            b.toDataURL()
                        } catch {
                            return
                        }
                }(d);
                return {
                    imageFallbackUrl: e,
                    imageSources: t,
                    imageTextAlternative: r || "",
                    imageWidth: i,
                    imageHeight: l,
                    ...h ? {
                        imagePlaceholder: h
                    } : null
                }
            }
            function jO(s) {
                return {
                    linkName: s.data.name,
                    linkHref: LO(s)
                }
            }
            function LO(s) {
                const e = new URL(s.data.url);
                return e.searchParams.set("download", "true"),
                e.toString()
            }
            class I0 extends ie {
                constructor() {
                    super(...arguments),
                    C(this, "_token")
                }
                static get pluginName() {
                    return "CKBoxUtils"
                }
                static get requires() {
                    return ["CloudServices"]
                }
                async init() {
                    const e = this.editor
                      , t = !!e.config.get("ckbox")
                      , r = !!window.CKBox;
                    if (!t && !r)
                        return;
                    e.config.define("ckbox", {
                        serviceOrigin: "https://api.ckbox.io",
                        defaultUploadCategories: null,
                        ignoreDataId: !1,
                        language: e.locale.uiLanguage,
                        theme: "lark",
                        tokenUrl: e.config.get("cloudServices.tokenUrl")
                    });
                    const i = e.plugins.get("CloudServices")
                      , l = e.config.get("cloudServices.tokenUrl")
                      , d = e.config.get("ckbox.tokenUrl");
                    if (!d)
                        throw new U("ckbox-plugin-missing-token-url",this);
                    this._token = d == l ? i.token : await i.registerTokenUrl(d)
                }
                getToken() {
                    return this._token
                }
                getWorkspaceId() {
                    const e = (0,
                    this.editor.t)("Cannot access default workspace.")
                      , t = this.editor.config.get("ckbox.defaultUploadWorkspaceId")
                      , r = function(i, l) {
                        const [,d] = i.value.split(".")
                          , h = JSON.parse(atob(d))
                          , m = h.auth && h.auth.ckbox && h.auth.ckbox.workspaces || [h.aud];
                        return l ? (h.auth && h.auth.ckbox && h.auth.ckbox.role) == "superadmin" || m.includes(l) ? l : null : m[0]
                    }(this._token, t);
                    if (r == null)
                        throw te("ckbox-access-default-workspace-error"),
                        e;
                    return r
                }
                async getCategoryIdForFile(e, t) {
                    const r = (0,
                    this.editor.t)("Cannot determine a category for the uploaded file.")
                      , i = this.editor.config.get("ckbox.defaultUploadCategories")
                      , l = this._getAvailableCategories(t)
                      , d = typeof e == "string" ? (h = await async function(b, v) {
                        try {
                            const x = await fetch(b, {
                                method: "HEAD",
                                cache: "force-cache",
                                ...v
                            });
                            return x.ok && x.headers.get("content-type") || ""
                        } catch {
                            return ""
                        }
                    }(e, t),
                    BO[h]) : e.name.match(/\.(?<ext>[^.]+)$/).groups.ext.toLowerCase();
                    var h;
                    const m = await l;
                    if (!m)
                        throw r;
                    if (i) {
                        const b = Object.keys(i).find(v => i[v].find(x => x.toLowerCase() == d));
                        if (b) {
                            const v = m.find(x => x.id === b || x.name === b);
                            if (!v)
                                throw r;
                            return v.id
                        }
                    }
                    const g = m.find(b => b.extensions.find(v => v.toLowerCase() == d));
                    if (!g)
                        throw r;
                    return g.id
                }
                async _getAvailableCategories(e) {
                    const t = this.editor
                      , r = this._token
                      , {signal: i} = e
                      , l = t.config.get("ckbox.serviceOrigin")
                      , d = this.getWorkspaceId();
                    try {
                        const m = [];
                        let g, b = 0;
                        do {
                            const v = await h(b);
                            m.push(...v.items),
                            g = v.totalCount - (b + 50),
                            b += 50
                        } while (g > 0);
                        return m
                    } catch {
                        return i.throwIfAborted(),
                        void te("ckbox-fetch-category-http-error")
                    }
                    function h(m) {
                        const g = new URL("categories",l);
                        return g.searchParams.set("limit", "50"),
                        g.searchParams.set("offset", m.toString()),
                        g.searchParams.set("workspaceId", d),
                        T0({
                            url: g,
                            signal: i,
                            authorization: r.value
                        })
                    }
                }
            }
            class zO extends ie {
                static get requires() {
                    return ["ImageUploadEditing", "ImageUploadProgress", br, M0]
                }
                static get pluginName() {
                    return "CKBoxUploadAdapter"
                }
                async afterInit() {
                    const e = this.editor
                      , t = !!e.config.get("ckbox")
                      , r = !!window.CKBox;
                    if (!t && !r)
                        return;
                    const i = e.plugins.get(br)
                      , l = e.plugins.get(I0);
                    i.createUploadAdapter = m => new OO(m,e,l);
                    const d = !e.config.get("ckbox.ignoreDataId")
                      , h = e.plugins.get("ImageUploadEditing");
                    d && h.on("uploadComplete", (m, {imageElement: g, data: b}) => {
                        e.model.change(v => {
                            v.setAttribute("ckboxImageId", b.ckboxImageId, g)
                        }
                        )
                    }
                    )
                }
            }
            class OO {
                constructor(e, t, r) {
                    C(this, "loader"),
                    C(this, "token"),
                    C(this, "editor"),
                    C(this, "controller"),
                    C(this, "serviceOrigin"),
                    C(this, "ckboxUtils"),
                    this.loader = e,
                    this.token = r.getToken(),
                    this.ckboxUtils = r,
                    this.editor = t,
                    this.controller = new AbortController,
                    this.serviceOrigin = t.config.get("ckbox.serviceOrigin")
                }
                async upload() {
                    const e = this.ckboxUtils
                      , t = this.editor.t
                      , r = await this.loader.file
                      , i = await e.getCategoryIdForFile(r, {
                        signal: this.controller.signal
                    })
                      , l = new URL("assets",this.serviceOrigin)
                      , d = new FormData;
                    return l.searchParams.set("workspaceId", e.getWorkspaceId()),
                    d.append("categoryId", i),
                    d.append("file", r),
                    T0({
                        method: "POST",
                        url: l,
                        data: d,
                        onUploadProgress: h => {
                            h.lengthComputable && (this.loader.uploadTotal = h.total,
                            this.loader.uploaded = h.loaded)
                        }
                        ,
                        signal: this.controller.signal,
                        authorization: this.token.value
                    }).then(async h => {
                        const m = D0(h.imageUrls);
                        return {
                            ckboxImageId: h.id,
                            default: m.imageFallbackUrl,
                            sources: m.imageSources
                        }
                    }
                    ).catch( () => {
                        const h = t("Cannot upload file:") + ` ${r.name}.`;
                        return Promise.reject(h)
                    }
                    )
                }
                abort() {
                    this.controller.abort()
                }
            }
            class M0 extends ie {
                constructor() {
                    super(...arguments),
                    C(this, "_token")
                }
                static get pluginName() {
                    return "CKBoxEditing"
                }
                static get requires() {
                    return ["LinkEditing", "PictureEditing", zO, I0]
                }
                init() {
                    const e = this.editor;
                    this._shouldBeInitialised() && (this._checkImagePlugins(),
                    N0() && e.commands.add("ckbox", new NO(e)))
                }
                afterInit() {
                    const e = this.editor;
                    this._shouldBeInitialised() && (e.config.get("ckbox.ignoreDataId") || (this._initSchema(),
                    this._initConversion(),
                    this._initFixers()))
                }
                _shouldBeInitialised() {
                    return !!this.editor.config.get("ckbox") || N0()
                }
                _checkImagePlugins() {
                    const e = this.editor;
                    e.plugins.has("ImageBlockEditing") || e.plugins.has("ImageInlineEditing") || te("ckbox-plugin-image-feature-missing", e)
                }
                _initSchema() {
                    const e = this.editor.model.schema;
                    e.extend("$text", {
                        allowAttributes: "ckboxLinkId"
                    }),
                    e.isRegistered("imageBlock") && e.extend("imageBlock", {
                        allowAttributes: ["ckboxImageId", "ckboxLinkId"]
                    }),
                    e.isRegistered("imageInline") && e.extend("imageInline", {
                        allowAttributes: ["ckboxImageId", "ckboxLinkId"]
                    }),
                    e.addAttributeCheck( (t, r) => {
                        if (!t.last.getAttribute("linkHref") && r === "ckboxLinkId")
                            return !1
                    }
                    )
                }
                _initConversion() {
                    const e = this.editor;
                    e.conversion.for("downcast").add(r => {
                        r.on("attribute:ckboxLinkId:imageBlock", (i, l, d) => {
                            const {writer: h, mapper: m, consumable: g} = d;
                            if (!g.consume(l.item, i.name))
                                return;
                            const b = [...m.toViewElement(l.item).getChildren()].find(v => v.name === "a");
                            b && (l.item.hasAttribute("ckboxLinkId") ? h.setAttribute("data-ckbox-resource-id", l.item.getAttribute("ckboxLinkId"), b) : h.removeAttribute("data-ckbox-resource-id", b))
                        }
                        , {
                            priority: "low"
                        }),
                        r.on("attribute:ckboxLinkId", (i, l, d) => {
                            const {writer: h, mapper: m, consumable: g} = d;
                            if (g.consume(l.item, i.name)) {
                                if (l.attributeOldValue) {
                                    const b = B0(h, l.attributeOldValue);
                                    h.unwrap(m.toViewRange(l.range), b)
                                }
                                if (l.attributeNewValue) {
                                    const b = B0(h, l.attributeNewValue);
                                    if (l.item.is("selection")) {
                                        const v = h.document.selection;
                                        h.wrap(v.getFirstRange(), b)
                                    } else
                                        h.wrap(m.toViewRange(l.range), b)
                                }
                            }
                        }
                        , {
                            priority: "low"
                        })
                    }
                    ),
                    e.conversion.for("upcast").add(r => {
                        r.on("element:a", (i, l, d) => {
                            const {writer: h, consumable: m} = d;
                            if (!l.viewItem.getAttribute("href") || !m.consume(l.viewItem, {
                                attributes: ["data-ckbox-resource-id"]
                            }))
                                return;
                            const g = l.viewItem.getAttribute("data-ckbox-resource-id");
                            if (g)
                                if (l.modelRange)
                                    for (let b of l.modelRange.getItems())
                                        b.is("$textProxy") && (b = b.textNode),
                                        FO(b) && h.setAttribute("ckboxLinkId", g, b);
                                else {
                                    const b = l.modelCursor.nodeBefore || l.modelCursor.parent;
                                    h.setAttribute("ckboxLinkId", g, b)
                                }
                        }
                        , {
                            priority: "low"
                        })
                    }
                    ),
                    e.conversion.for("downcast").attributeToAttribute({
                        model: "ckboxImageId",
                        view: "data-ckbox-resource-id"
                    }),
                    e.conversion.for("upcast").elementToAttribute({
                        model: {
                            key: "ckboxImageId",
                            value: r => r.getAttribute("data-ckbox-resource-id")
                        },
                        view: {
                            attributes: {
                                "data-ckbox-resource-id": /[\s\S]+/
                            }
                        }
                    });
                    const t = e.commands.get("replaceImageSource");
                    t && this.listenTo(t, "cleanupImage", (r, [i,l]) => {
                        i.removeAttribute("ckboxImageId", l)
                    }
                    )
                }
                _initFixers() {
                    const e = this.editor
                      , t = e.model
                      , r = t.document.selection;
                    t.document.registerPostFixer(function(i) {
                        return l => {
                            let d = !1;
                            const h = i.model
                              , m = i.commands.get("ckbox");
                            if (!m)
                                return d;
                            for (const g of h.document.differ.getChanges()) {
                                if (g.type !== "insert" && g.type !== "attribute")
                                    continue;
                                const b = g.type === "insert" ? new J(g.position,g.position.getShiftedBy(g.length)) : g.range
                                  , v = g.type === "attribute" && g.attributeKey === "linkHref" && g.attributeNewValue === null;
                                for (const x of b.getItems()) {
                                    if (v && x.hasAttribute("ckboxLinkId")) {
                                        l.removeAttribute("ckboxLinkId", x),
                                        d = !0;
                                        continue
                                    }
                                    const T = RO(x, m._chosenAssets);
                                    for (const I of T) {
                                        const P = I.type === "image" ? "ckboxImageId" : "ckboxLinkId";
                                        I.id !== x.getAttribute(P) && (l.setAttribute(P, I.id, x),
                                        d = !0)
                                    }
                                }
                            }
                            return d
                        }
                    }(e)),
                    t.document.registerPostFixer(function(i) {
                        return l => !(i.hasAttribute("linkHref") || !i.hasAttribute("ckboxLinkId")) && (l.removeSelectionAttribute("ckboxLinkId"),
                        !0)
                    }(r))
                }
            }
            function RO(s, e) {
                const t = s.is("element", "imageInline") || s.is("element", "imageBlock")
                  , r = s.hasAttribute("linkHref");
                return [...e].filter(i => i.type === "image" && t ? i.attributes.imageFallbackUrl === s.getAttribute("src") : i.type === "link" && r ? i.attributes.linkHref === s.getAttribute("linkHref") : void 0)
            }
            function B0(s, e) {
                const t = s.createAttributeElement("a", {
                    "data-ckbox-resource-id": e
                }, {
                    priority: 5
                });
                return s.setCustomProperty("link", !0, t),
                t
            }
            function FO(s) {
                return !!s.is("$text") || !(!s.is("element", "imageInline") && !s.is("element", "imageBlock"))
            }
            function N0() {
                return !!window.CKBox
            }
            class VO extends ie {
                static get pluginName() {
                    return "CKBox"
                }
                static get requires() {
                    return [M0, EO]
                }
            }
            var P0 = u(1866)
              , UO = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(P0.A, UO),
            P0.A.locals;
            class HO extends ie {
                static get pluginName() {
                    return "CKFinderUI"
                }
                init() {
                    const e = this.editor;
                    e.ui.componentFactory.add("ckfinder", () => this._createFileToolbarButton()),
                    e.ui.componentFactory.add("menuBar:ckfinder", () => this._createFileMenuBarButton()),
                    e.plugins.has("ImageInsertUI") && e.plugins.get("ImageInsertUI").registerIntegration({
                        name: "assetManager",
                        observable: () => e.commands.get("ckfinder"),
                        buttonViewCreator: () => this._createImageToolbarButton(),
                        formViewCreator: () => this._createImageDropdownButton(),
                        menuBarButtonViewCreator: t => this._createImageMenuBarButton(t ? "insertOnly" : "insertNested")
                    })
                }
                _createButton(e) {
                    const t = this.editor
                      , r = new e(t.locale)
                      , i = t.commands.get("ckfinder");
                    return r.bind("isEnabled").to(i),
                    r.on("execute", () => {
                        t.execute("ckfinder"),
                        t.editing.view.focus()
                    }
                    ),
                    r
                }
                _createFileToolbarButton() {
                    const e = this.editor.locale.t
                      , t = this._createButton(Te);
                    return t.icon = he.browseFiles,
                    t.label = e("Insert image or file"),
                    t.tooltip = !0,
                    t
                }
                _createImageToolbarButton() {
                    const e = this.editor.locale.t
                      , t = this.editor.plugins.get("ImageInsertUI")
                      , r = this._createButton(Te);
                    return r.icon = he.imageAssetManager,
                    r.bind("label").to(t, "isImageSelected", i => e(i ? "Replace image with file manager" : "Insert image with file manager")),
                    r.tooltip = !0,
                    r
                }
                _createImageDropdownButton() {
                    const e = this.editor.locale.t
                      , t = this.editor.plugins.get("ImageInsertUI")
                      , r = this._createButton(Te);
                    return r.icon = he.imageAssetManager,
                    r.withText = !0,
                    r.bind("label").to(t, "isImageSelected", i => e(i ? "Replace with file manager" : "Insert with file manager")),
                    r.on("execute", () => {
                        t.dropdownView.isOpen = !1
                    }
                    ),
                    r
                }
                _createFileMenuBarButton() {
                    const e = this.editor.locale.t
                      , t = this._createButton(Xt);
                    return t.icon = he.browseFiles,
                    t.withText = !0,
                    t.label = e("File"),
                    t
                }
                _createImageMenuBarButton(e) {
                    const t = this.editor.locale.t
                      , r = this._createButton(Xt);
                    switch (r.icon = he.imageAssetManager,
                    r.withText = !0,
                    e) {
                    case "insertOnly":
                        r.label = t("Image");
                        break;
                    case "insertNested":
                        r.label = t("With file manager")
                    }
                    return r
                }
            }
            class WO extends _e {
                constructor(e) {
                    super(e),
                    this.affectsData = !1,
                    this.stopListening(this.editor.model.document, "change"),
                    this.listenTo(this.editor.model.document, "change", () => this.refresh(), {
                        priority: "low"
                    })
                }
                refresh() {
                    const e = this.editor.commands.get("insertImage")
                      , t = this.editor.commands.get("link");
                    this.isEnabled = e.isEnabled || t.isEnabled
                }
                execute() {
                    const e = this.editor
                      , t = this.editor.config.get("ckfinder.openerMethod") || "modal";
                    if (t != "popup" && t != "modal")
                        throw new U("ckfinder-unknown-openermethod",e);
                    const r = this.editor.config.get("ckfinder.options") || {};
                    r.chooseFiles = !0;
                    const i = r.onInit;
                    r.language || (r.language = e.locale.uiLanguage),
                    r.onInit = l => {
                        i && i(l),
                        l.on("files:choose", d => {
                            const h = d.data.files.toArray()
                              , m = h.filter(v => !v.isImage())
                              , g = h.filter(v => v.isImage());
                            for (const v of m)
                                e.execute("link", v.getUrl());
                            const b = [];
                            for (const v of g) {
                                const x = v.getUrl();
                                b.push(x || l.request("file:getProxyUrl", {
                                    file: v
                                }))
                            }
                            b.length && j0(e, b)
                        }
                        ),
                        l.on("file:choose:resizedImage", d => {
                            const h = d.data.resizedUrl;
                            if (h)
                                j0(e, [h]);
                            else {
                                const m = e.plugins.get("Notification")
                                  , g = e.locale.t;
                                m.showWarning(g("Could not obtain resized image URL."), {
                                    title: g("Selecting resized image failed"),
                                    namespace: "ckfinder"
                                })
                            }
                        }
                        )
                    }
                    ,
                    window.CKFinder[t](r)
                }
            }
            function j0(s, e) {
                if (s.commands.get("insertImage").isEnabled)
                    s.execute("insertImage", {
                        source: e
                    });
                else {
                    const t = s.plugins.get("Notification")
                      , r = s.locale.t;
                    t.showWarning(r("Could not insert image at the current position."), {
                        title: r("Inserting image failed"),
                        namespace: "ckfinder"
                    })
                }
            }
            class $O extends ie {
                static get pluginName() {
                    return "CKFinderEditing"
                }
                static get requires() {
                    return [tg, "LinkEditing"]
                }
                init() {
                    const e = this.editor;
                    if (!e.plugins.has("ImageBlockEditing") && !e.plugins.has("ImageInlineEditing"))
                        throw new U("ckfinder-missing-image-plugin",e);
                    e.commands.add("ckfinder", new WO(e))
                }
            }
            class qO extends ie {
                static get pluginName() {
                    return "CKFinder"
                }
                static get requires() {
                    return ["Link", "CKFinderUploadAdapter", $O, HO]
                }
            }
            class GO extends ie {
                constructor() {
                    super(...arguments),
                    C(this, "_uploadGateway")
                }
                static get pluginName() {
                    return "CloudServicesUploadAdapter"
                }
                static get requires() {
                    return ["CloudServices", br]
                }
                init() {
                    const e = this.editor
                      , t = e.plugins.get("CloudServices")
                      , r = t.token
                      , i = t.uploadUrl;
                    if (!r)
                        return;
                    const l = e.plugins.get("CloudServicesCore");
                    this._uploadGateway = l.createUploadGateway(r, i),
                    e.plugins.get(br).createUploadAdapter = d => new KO(this._uploadGateway,d)
                }
            }
            class KO {
                constructor(e, t) {
                    C(this, "uploadGateway"),
                    C(this, "loader"),
                    C(this, "fileUploader"),
                    this.uploadGateway = e,
                    this.loader = t
                }
                upload() {
                    return this.loader.file.then(e => (this.fileUploader = this.uploadGateway.upload(e),
                    this.fileUploader.on("progress", (t, r) => {
                        this.loader.uploadTotal = r.total,
                        this.loader.uploaded = r.uploaded
                    }
                    ),
                    this.fileUploader.send()))
                }
                abort() {
                    this.fileUploader.abort()
                }
            }
            class YO extends ie {
                static get pluginName() {
                    return "EasyImage"
                }
                static get requires() {
                    return [GO, "ImageUpload"]
                }
                init() {
                    const e = this.editor;
                    e.plugins.has("ImageBlockEditing") || e.plugins.has("ImageInlineEditing") || de("easy-image-image-feature-missing", e)
                }
            }
            class QO extends _e {
                constructor(e) {
                    super(e),
                    this._isEnabledBasedOnSelection = !1
                }
                refresh() {
                    const e = this.editor.model
                      , t = zt(e.document.selection.getSelectedBlocks());
                    this.value = !!t && t.is("element", "paragraph"),
                    this.isEnabled = !!t && L0(t, e.schema)
                }
                execute(e={}) {
                    const t = this.editor.model
                      , r = t.document
                      , i = e.selection || r.selection;
                    t.canEditAt(i) && t.change(l => {
                        const d = i.getSelectedBlocks();
                        for (const h of d)
                            !h.is("element", "paragraph") && L0(h, t.schema) && l.rename(h, "paragraph")
                    }
                    )
                }
            }
            function L0(s, e) {
                return e.checkChild(s.parent, "paragraph") && !e.isObject(s)
            }
            class ZO extends _e {
                constructor(e) {
                    super(e),
                    this._isEnabledBasedOnSelection = !1
                }
                execute(e) {
                    const t = this.editor.model
                      , r = e.attributes;
                    let i = e.position;
                    t.canEditAt(i) && t.change(l => {
                        if (i = this._findPositionToInsertParagraph(i, l),
                        !i)
                            return;
                        const d = l.createElement("paragraph");
                        r && t.schema.setAllowedAttributes(d, r, l),
                        t.insertContent(d, i),
                        l.setSelection(d, "in")
                    }
                    )
                }
                _findPositionToInsertParagraph(e, t) {
                    const r = this.editor.model;
                    if (r.schema.checkChild(e, "paragraph"))
                        return e;
                    const i = r.schema.findAllowedParent(e, "paragraph");
                    if (!i)
                        return null;
                    const l = e.parent
                      , d = r.schema.checkChild(l, "$text");
                    return l.isEmpty || d && e.isAtEnd ? r.createPositionAfter(l) : !l.isEmpty && d && e.isAtStart ? r.createPositionBefore(l) : t.split(e, i).position
                }
            }
            const z0 = class xB extends ie {
                static get pluginName() {
                    return "Paragraph"
                }
                init() {
                    const e = this.editor
                      , t = e.model;
                    e.commands.add("paragraph", new QO(e)),
                    e.commands.add("insertParagraph", new ZO(e)),
                    t.schema.register("paragraph", {
                        inheritAllFrom: "$block"
                    }),
                    e.conversion.elementToElement({
                        model: "paragraph",
                        view: "p"
                    }),
                    e.conversion.for("upcast").elementToElement({
                        model: (r, {writer: i}) => xB.paragraphLikeElements.has(r.name) ? r.isEmpty ? null : i.createElement("paragraph") : null,
                        view: /.+/,
                        converterPriority: "low"
                    })
                }
            }
            ;
            C(z0, "paragraphLikeElements", new Set(["blockquote", "dd", "div", "dt", "h1", "h2", "h3", "h4", "h5", "h6", "li", "p", "td", "th"]));
            let O0 = z0;
            class JO extends _e {
                constructor(e, t) {
                    super(e),
                    C(this, "modelElements"),
                    this.modelElements = t
                }
                refresh() {
                    const e = zt(this.editor.model.document.selection.getSelectedBlocks());
                    this.value = !!e && this.modelElements.includes(e.name) && e.name,
                    this.isEnabled = !!e && this.modelElements.some(t => R0(e, t, this.editor.model.schema))
                }
                execute(e) {
                    const t = this.editor.model
                      , r = t.document
                      , i = e.value;
                    t.change(l => {
                        const d = Array.from(r.selection.getSelectedBlocks()).filter(h => R0(h, i, t.schema));
                        for (const h of d)
                            h.is("element", i) || l.rename(h, i)
                    }
                    )
                }
            }
            function R0(s, e, t) {
                return t.checkChild(s.parent, e) && !t.isObject(s)
            }
            const F0 = "paragraph";
            class XO extends ie {
                static get pluginName() {
                    return "HeadingEditing"
                }
                constructor(e) {
                    super(e),
                    e.config.define("heading", {
                        options: [{
                            model: "paragraph",
                            title: "Paragraph",
                            class: "ck-heading_paragraph"
                        }, {
                            model: "heading1",
                            view: "h2",
                            title: "Heading 1",
                            class: "ck-heading_heading1"
                        }, {
                            model: "heading2",
                            view: "h3",
                            title: "Heading 2",
                            class: "ck-heading_heading2"
                        }, {
                            model: "heading3",
                            view: "h4",
                            title: "Heading 3",
                            class: "ck-heading_heading3"
                        }]
                    })
                }
                static get requires() {
                    return [O0]
                }
                init() {
                    const e = this.editor
                      , t = e.config.get("heading.options")
                      , r = [];
                    for (const i of t)
                        i.model !== "paragraph" && (e.model.schema.register(i.model, {
                            inheritAllFrom: "$block"
                        }),
                        e.conversion.elementToElement(i),
                        r.push(i.model));
                    this._addDefaultH1Conversion(e),
                    e.commands.add("heading", new JO(e,r))
                }
                afterInit() {
                    const e = this.editor
                      , t = e.commands.get("enter")
                      , r = e.config.get("heading.options");
                    t && this.listenTo(t, "afterExecute", (i, l) => {
                        const d = e.model.document.selection.getFirstPosition().parent;
                        r.some(h => d.is("element", h.model)) && !d.is("element", F0) && d.childCount === 0 && l.writer.rename(d, F0)
                    }
                    )
                }
                _addDefaultH1Conversion(e) {
                    e.conversion.for("upcast").elementToElement({
                        model: "heading1",
                        view: "h1",
                        converterPriority: W.low + 1
                    })
                }
            }
            var V0 = u(6269)
              , eR = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(V0.A, eR),
            V0.A.locals;
            class tR extends ie {
                static get pluginName() {
                    return "HeadingUI"
                }
                init() {
                    const e = this.editor
                      , t = e.t
                      , r = function(d) {
                        const h = d.t
                          , m = {
                            Paragraph: h("Paragraph"),
                            "Heading 1": h("Heading 1"),
                            "Heading 2": h("Heading 2"),
                            "Heading 3": h("Heading 3"),
                            "Heading 4": h("Heading 4"),
                            "Heading 5": h("Heading 5"),
                            "Heading 6": h("Heading 6")
                        };
                        return d.config.get("heading.options").map(g => {
                            const b = m[g.title];
                            return b && b != g.title && (g.title = b),
                            g
                        }
                        )
                    }(e)
                      , i = t("Choose heading")
                      , l = t("Heading");
                    e.ui.componentFactory.add("heading", d => {
                        const h = {}
                          , m = new dr
                          , g = e.commands.get("heading")
                          , b = e.commands.get("paragraph")
                          , v = [g];
                        for (const T of r) {
                            const I = {
                                type: "button",
                                model: new ty({
                                    label: T.title,
                                    class: T.class,
                                    role: "menuitemradio",
                                    withText: !0
                                })
                            };
                            T.model === "paragraph" ? (I.model.bind("isOn").to(b, "value"),
                            I.model.set("commandName", "paragraph"),
                            v.push(b)) : (I.model.bind("isOn").to(g, "value", P => P === T.model),
                            I.model.set({
                                commandName: "heading",
                                commandValue: T.model
                            })),
                            m.add(I),
                            h[T.model] = T.title
                        }
                        const x = Nn(d);
                        return RC(x, m, {
                            ariaLabel: l,
                            role: "menu"
                        }),
                        x.buttonView.set({
                            ariaLabel: l,
                            ariaLabelledBy: void 0,
                            isOn: !1,
                            withText: !0,
                            tooltip: l
                        }),
                        x.extendTemplate({
                            attributes: {
                                class: ["ck-heading-dropdown"]
                            }
                        }),
                        x.bind("isEnabled").toMany(v, "isEnabled", (...T) => T.some(I => I)),
                        x.buttonView.bind("label").to(g, "value", b, "value", (T, I) => {
                            const P = I ? "paragraph" : T;
                            return typeof P == "boolean" ? i : h[P] ? h[P] : i
                        }
                        ),
                        x.buttonView.bind("ariaLabel").to(g, "value", b, "value", (T, I) => {
                            const P = I ? "paragraph" : T;
                            return typeof P == "boolean" ? l : h[P] ? `${h[P]}, ${l}` : l
                        }
                        ),
                        this.listenTo(x, "execute", T => {
                            const {commandName: I, commandValue: P} = T.source;
                            e.execute(I, P ? {
                                value: P
                            } : void 0),
                            e.editing.view.focus()
                        }
                        ),
                        x
                    }
                    ),
                    e.ui.componentFactory.add("menuBar:heading", d => {
                        const h = new Os(d)
                          , m = e.commands.get("heading")
                          , g = e.commands.get("paragraph")
                          , b = [m]
                          , v = new su(d);
                        h.set({
                            class: "ck-heading-dropdown"
                        }),
                        v.set({
                            ariaLabel: t("Heading"),
                            role: "menu"
                        }),
                        h.buttonView.set({
                            label: t("Heading")
                        }),
                        h.panelView.children.add(v);
                        for (const x of r) {
                            const T = new iu(d,h)
                              , I = new Xt(d);
                            T.children.add(I),
                            v.items.add(T),
                            I.set({
                                label: x.title,
                                role: "menuitemradio",
                                class: x.class
                            }),
                            I.bind("ariaChecked").to(I, "isOn"),
                            I.delegate("execute").to(h),
                            I.on("execute", () => {
                                const P = x.model === "paragraph" ? "paragraph" : "heading";
                                e.execute(P, {
                                    value: x.model
                                }),
                                e.editing.view.focus()
                            }
                            ),
                            x.model === "paragraph" ? (I.bind("isOn").to(g, "value"),
                            b.push(g)) : I.bind("isOn").to(m, "value", P => P === x.model)
                        }
                        return h.bind("isEnabled").toMany(b, "isEnabled", (...x) => x.some(T => T)),
                        h
                    }
                    )
                }
            }
            class oR extends ie {
                static get requires() {
                    return [XO, tR]
                }
                static get pluginName() {
                    return "Heading"
                }
            }
            function U0(s) {
                return s.createContainerElement("figure", {
                    class: "image"
                }, [s.createEmptyElement("img"), s.createSlot("children")])
            }
            function H0(s, e) {
                const t = s.plugins.get("ImageUtils")
                  , r = s.plugins.has("ImageInlineEditing") && s.plugins.has("ImageBlockEditing");
                return l => t.isInlineImageView(l) ? r && (l.getStyle("display") == "block" || l.findAncestor(t.isBlockImageView) ? "imageBlock" : "imageInline") !== e ? null : i(l) : null;
                function i(l) {
                    const d = {
                        name: !0
                    };
                    return l.hasAttribute("src") && (d.attributes = ["src"]),
                    d
                }
            }
            function dg(s, e) {
                const t = zt(e.getSelectedBlocks());
                return !t || s.isObject(t) || t.isEmpty && t.name != "listItem" ? "imageBlock" : "imageInline"
            }
            function wu(s) {
                return s && s.endsWith("px") ? parseInt(s) : null
            }
            function W0(s) {
                const e = wu(s.getStyle("width"))
                  , t = wu(s.getStyle("height"));
                return !(!e || !t)
            }
            const rR = /^(image|image-inline)$/;
            class ho extends ie {
                constructor() {
                    super(...arguments),
                    C(this, "_domEmitter", new (qo()))
                }
                static get pluginName() {
                    return "ImageUtils"
                }
                isImage(e) {
                    return this.isInlineImage(e) || this.isBlockImage(e)
                }
                isInlineImageView(e) {
                    return !!e && e.is("element", "img")
                }
                isBlockImageView(e) {
                    return !!e && e.is("element", "figure") && e.hasClass("image")
                }
                insertImage(e={}, t=null, r=null, i={}) {
                    const l = this.editor
                      , d = l.model
                      , h = d.document.selection
                      , m = $0(l, t || h, r);
                    e = {
                        ...Object.fromEntries(h.getAttributes()),
                        ...e
                    };
                    for (const g in e)
                        d.schema.checkAttribute(m, g) || delete e[g];
                    return d.change(g => {
                        const {setImageSizes: b=!0} = i
                          , v = g.createElement(m, e);
                        return d.insertObject(v, t, null, {
                            setSelection: "on",
                            findOptimalPosition: t || m == "imageInline" ? void 0 : "auto"
                        }),
                        v.parent ? (b && this.setImageNaturalSizeAttributes(v),
                        v) : null
                    }
                    )
                }
                setImageNaturalSizeAttributes(e) {
                    const t = e.getAttribute("src");
                    t && (e.getAttribute("width") || e.getAttribute("height") || this.editor.model.change(r => {
                        const i = new w.window.Image;
                        this._domEmitter.listenTo(i, "load", () => {
                            e.getAttribute("width") || e.getAttribute("height") || this.editor.model.enqueueChange(r.batch, l => {
                                l.setAttribute("width", i.naturalWidth, e),
                                l.setAttribute("height", i.naturalHeight, e)
                            }
                            ),
                            this._domEmitter.stopListening(i, "load")
                        }
                        ),
                        i.src = t
                    }
                    ))
                }
                getClosestSelectedImageWidget(e) {
                    const t = e.getFirstPosition();
                    if (!t)
                        return null;
                    const r = e.getSelectedElement();
                    if (r && this.isImageWidget(r))
                        return r;
                    let i = t.parent;
                    for (; i; ) {
                        if (i.is("element") && this.isImageWidget(i))
                            return i;
                        i = i.parent
                    }
                    return null
                }
                getClosestSelectedImageElement(e) {
                    const t = e.getSelectedElement();
                    return this.isImage(t) ? t : e.getFirstPosition().findAncestor("imageBlock")
                }
                getImageWidgetFromImageView(e) {
                    return e.findAncestor({
                        classes: rR
                    })
                }
                isImageAllowed() {
                    const e = this.editor.model.document.selection;
                    return function(t, r) {
                        if ($0(t, r, null) == "imageBlock") {
                            const i = function(l, d) {
                                const h = Qy(l, d)
                                  , m = h.start.parent;
                                return m.isEmpty && !m.is("element", "$root") ? m.parent : m
                            }(r, t.model);
                            if (t.model.schema.checkChild(i, "imageBlock"))
                                return !0
                        } else if (t.model.schema.checkChild(r.focus, "imageInline"))
                            return !0;
                        return !1
                    }(this.editor, e) && function(t) {
                        return [...t.focus.getAncestors()].every(r => !r.is("element", "imageBlock"))
                    }(e)
                }
                toImageWidget(e, t, r) {
                    return t.setCustomProperty("image", !0, e),
                    ig(e, t, {
                        label: () => {
                            const i = this.findViewImgElement(e).getAttribute("alt");
                            return i ? `${i} ${r}` : r
                        }
                    })
                }
                isImageWidget(e) {
                    return !!e.getCustomProperty("image") && At(e)
                }
                isBlockImage(e) {
                    return !!e && e.is("element", "imageBlock")
                }
                isInlineImage(e) {
                    return !!e && e.is("element", "imageInline")
                }
                findViewImgElement(e) {
                    if (this.isInlineImageView(e))
                        return e;
                    const t = this.editor.editing.view;
                    for (const {item: r} of t.createRangeIn(e))
                        if (this.isInlineImageView(r))
                            return r
                }
                destroy() {
                    return this._domEmitter.stopListening(),
                    super.destroy()
                }
            }
            function $0(s, e, t) {
                const r = s.model.schema
                  , i = s.config.get("image.insert.type");
                return s.plugins.has("ImageBlockEditing") ? s.plugins.has("ImageInlineEditing") ? t || (i === "inline" ? "imageInline" : i !== "auto" ? "imageBlock" : e.is("selection") ? dg(r, e) : r.checkChild(e, "imageInline") ? "imageInline" : "imageBlock") : "imageBlock" : "imageInline"
            }
            class nR extends _e {
                refresh() {
                    const e = this.editor.plugins.get("ImageUtils").getClosestSelectedImageElement(this.editor.model.document.selection);
                    this.isEnabled = !!e,
                    this.isEnabled && e.hasAttribute("alt") ? this.value = e.getAttribute("alt") : this.value = !1
                }
                execute(e) {
                    const t = this.editor
                      , r = t.plugins.get("ImageUtils")
                      , i = t.model
                      , l = r.getClosestSelectedImageElement(i.document.selection);
                    i.change(d => {
                        d.setAttribute("alt", e.newValue, l)
                    }
                    )
                }
            }
            class iR extends ie {
                static get requires() {
                    return [ho]
                }
                static get pluginName() {
                    return "ImageTextAlternativeEditing"
                }
                init() {
                    this.editor.commands.add("imageTextAlternative", new nR(this.editor))
                }
            }
            var q0 = u(4062)
              , sR = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(q0.A, sR),
            q0.A.locals;
            var G0 = u(2722)
              , aR = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(G0.A, aR),
            G0.A.locals;
            class lR extends pe {
                constructor(e) {
                    super(e),
                    C(this, "focusTracker"),
                    C(this, "keystrokes"),
                    C(this, "labeledInput"),
                    C(this, "saveButtonView"),
                    C(this, "cancelButtonView"),
                    C(this, "_focusables"),
                    C(this, "_focusCycler");
                    const t = this.locale.t;
                    this.focusTracker = new Jt,
                    this.keystrokes = new lo,
                    this.labeledInput = this._createLabeledInputView(),
                    this.saveButtonView = this._createButton(t("Save"), he.check, "ck-button-save"),
                    this.saveButtonView.type = "submit",
                    this.cancelButtonView = this._createButton(t("Cancel"), he.cancel, "ck-button-cancel", "cancel"),
                    this._focusables = new ur,
                    this._focusCycler = new Jr({
                        focusables: this._focusables,
                        focusTracker: this.focusTracker,
                        keystrokeHandler: this.keystrokes,
                        actions: {
                            focusPrevious: "shift + tab",
                            focusNext: "tab"
                        }
                    }),
                    this.setTemplate({
                        tag: "form",
                        attributes: {
                            class: ["ck", "ck-text-alternative-form", "ck-responsive-form"],
                            tabindex: "-1"
                        },
                        children: [this.labeledInput, this.saveButtonView, this.cancelButtonView]
                    })
                }
                render() {
                    super.render(),
                    this.keystrokes.listenTo(this.element),
                    Td({
                        view: this
                    }),
                    [this.labeledInput, this.saveButtonView, this.cancelButtonView].forEach(e => {
                        this._focusables.add(e),
                        this.focusTracker.add(e.element)
                    }
                    )
                }
                destroy() {
                    super.destroy(),
                    this.focusTracker.destroy(),
                    this.keystrokes.destroy()
                }
                _createButton(e, t, r, i) {
                    const l = new Te(this.locale);
                    return l.set({
                        label: e,
                        icon: t,
                        tooltip: !0
                    }),
                    l.extendTemplate({
                        attributes: {
                            class: r
                        }
                    }),
                    i && l.delegate("execute").to(this, i),
                    l
                }
                _createLabeledInputView() {
                    const e = this.locale.t
                      , t = new Wp(this.locale,Qp);
                    return t.label = e("Text alternative"),
                    t
                }
            }
            function K0(s) {
                const e = s.editing.view
                  , t = js.defaultPositions
                  , r = s.plugins.get("ImageUtils");
                return {
                    target: e.domConverter.mapViewToDom(r.getClosestSelectedImageWidget(e.document.selection)),
                    positions: [t.northArrowSouth, t.northArrowSouthWest, t.northArrowSouthEast, t.southArrowNorth, t.southArrowNorthWest, t.southArrowNorthEast, t.viewportStickyNorth]
                }
            }
            class cR extends ie {
                constructor() {
                    super(...arguments),
                    C(this, "_balloon"),
                    C(this, "_form")
                }
                static get requires() {
                    return [nu]
                }
                static get pluginName() {
                    return "ImageTextAlternativeUI"
                }
                init() {
                    this._createButton()
                }
                destroy() {
                    super.destroy(),
                    this._form && this._form.destroy()
                }
                _createButton() {
                    const e = this.editor
                      , t = e.t;
                    e.ui.componentFactory.add("imageTextAlternative", r => {
                        const i = e.commands.get("imageTextAlternative")
                          , l = new Te(r);
                        return l.set({
                            label: t("Change image text alternative"),
                            icon: he.textAlternative,
                            tooltip: !0
                        }),
                        l.bind("isEnabled").to(i, "isEnabled"),
                        l.bind("isOn").to(i, "value", d => !!d),
                        this.listenTo(l, "execute", () => {
                            this._showForm()
                        }
                        ),
                        l
                    }
                    )
                }
                _createForm() {
                    const e = this.editor
                      , t = e.editing.view.document
                      , r = e.plugins.get("ImageUtils");
                    this._balloon = this.editor.plugins.get("ContextualBalloon"),
                    this._form = new (ip(lR))(e.locale),
                    this._form.render(),
                    this.listenTo(this._form, "submit", () => {
                        e.execute("imageTextAlternative", {
                            newValue: this._form.labeledInput.fieldView.element.value
                        }),
                        this._hideForm(!0)
                    }
                    ),
                    this.listenTo(this._form, "cancel", () => {
                        this._hideForm(!0)
                    }
                    ),
                    this._form.keystrokes.set("Esc", (i, l) => {
                        this._hideForm(!0),
                        l()
                    }
                    ),
                    this.listenTo(e.ui, "update", () => {
                        r.getClosestSelectedImageWidget(t.selection) ? this._isVisible && function(i) {
                            const l = i.plugins.get("ContextualBalloon");
                            if (i.plugins.get("ImageUtils").getClosestSelectedImageWidget(i.editing.view.document.selection)) {
                                const d = K0(i);
                                l.updatePosition(d)
                            }
                        }(e) : this._hideForm(!0)
                    }
                    ),
                    Dd({
                        emitter: this._form,
                        activator: () => this._isVisible,
                        contextElements: () => [this._balloon.view.element],
                        callback: () => this._hideForm()
                    })
                }
                _showForm() {
                    if (this._isVisible)
                        return;
                    this._form || this._createForm();
                    const e = this.editor
                      , t = e.commands.get("imageTextAlternative")
                      , r = this._form.labeledInput;
                    this._form.disableCssTransitions(),
                    this._isInBalloon || this._balloon.add({
                        view: this._form,
                        position: K0(e)
                    }),
                    r.fieldView.value = r.fieldView.element.value = t.value || "",
                    this._form.labeledInput.fieldView.select(),
                    this._form.enableCssTransitions()
                }
                _hideForm(e=!1) {
                    this._isInBalloon && (this._form.focusTracker.isFocused && this._form.saveButtonView.focus(),
                    this._balloon.remove(this._form),
                    e && this.editor.editing.view.focus())
                }
                get _isVisible() {
                    return !!this._balloon && this._balloon.visibleView === this._form
                }
                get _isInBalloon() {
                    return !!this._balloon && this._balloon.hasView(this._form)
                }
            }
            class Y0 extends ie {
                static get requires() {
                    return [iR, cR]
                }
                static get pluginName() {
                    return "ImageTextAlternative"
                }
            }
            function Q0(s, e) {
                const t = (r, i, l) => {
                    if (!l.consumable.consume(i.item, r.name))
                        return;
                    const d = l.writer
                      , h = l.mapper.toViewElement(i.item)
                      , m = s.findViewImgElement(h);
                    i.attributeNewValue === null ? (d.removeAttribute("srcset", m),
                    d.removeAttribute("sizes", m)) : i.attributeNewValue && (d.setAttribute("srcset", i.attributeNewValue, m),
                    d.setAttribute("sizes", "100vw", m))
                }
                ;
                return r => {
                    r.on(`attribute:srcset:${e}`, t)
                }
            }
            function Au(s, e, t) {
                const r = (i, l, d) => {
                    if (!d.consumable.consume(l.item, i.name))
                        return;
                    const h = d.writer
                      , m = d.mapper.toViewElement(l.item)
                      , g = s.findViewImgElement(m);
                    h.setAttribute(l.attributeKey, l.attributeNewValue || "", g)
                }
                ;
                return i => {
                    i.on(`attribute:${t}:${e}`, r)
                }
            }
            class Z0 extends Nr {
                observe(e) {
                    this.listenTo(e, "load", (t, r) => {
                        const i = r.target;
                        this.checkShouldIgnoreEventFromTarget(i) || i.tagName == "IMG" && this._fireEvents(r)
                    }
                    , {
                        useCapture: !0
                    })
                }
                stopObserving(e) {
                    this.stopListening(e)
                }
                _fireEvents(e) {
                    this.isEnabled && (this.document.fire("layoutChanged"),
                    this.document.fire("imageLoaded", e))
                }
            }
            class dR extends _e {
                constructor(e) {
                    super(e);
                    const t = e.config.get("image.insert.type");
                    e.plugins.has("ImageBlockEditing") || t === "block" && de("image-block-plugin-required"),
                    e.plugins.has("ImageInlineEditing") || t === "inline" && de("image-inline-plugin-required")
                }
                refresh() {
                    const e = this.editor.plugins.get("ImageUtils");
                    this.isEnabled = e.isImageAllowed()
                }
                execute(e) {
                    const t = Ze(e.source)
                      , r = this.editor.model.document.selection
                      , i = this.editor.plugins.get("ImageUtils")
                      , l = Object.fromEntries(r.getAttributes());
                    t.forEach( (d, h) => {
                        const m = r.getSelectedElement();
                        if (typeof d == "string" && (d = {
                            src: d
                        }),
                        h && m && i.isImage(m)) {
                            const g = this.editor.model.createPositionAfter(m);
                            i.insertImage({
                                ...d,
                                ...l
                            }, g)
                        } else
                            i.insertImage({
                                ...d,
                                ...l
                            })
                    }
                    )
                }
            }
            class uR extends _e {
                constructor(e) {
                    super(e),
                    this.decorate("cleanupImage")
                }
                refresh() {
                    const e = this.editor.plugins.get("ImageUtils")
                      , t = this.editor.model.document.selection.getSelectedElement();
                    this.isEnabled = e.isImage(t),
                    this.value = this.isEnabled ? t.getAttribute("src") : null
                }
                execute(e) {
                    const t = this.editor.model.document.selection.getSelectedElement()
                      , r = this.editor.plugins.get("ImageUtils");
                    this.editor.model.change(i => {
                        i.setAttribute("src", e.source, t),
                        this.cleanupImage(i, t),
                        r.setImageNaturalSizeAttributes(t)
                    }
                    )
                }
                cleanupImage(e, t) {
                    e.removeAttribute("srcset", t),
                    e.removeAttribute("sizes", t),
                    e.removeAttribute("sources", t),
                    e.removeAttribute("width", t),
                    e.removeAttribute("height", t),
                    e.removeAttribute("alt", t)
                }
            }
            class ug extends ie {
                static get requires() {
                    return [ho]
                }
                static get pluginName() {
                    return "ImageEditing"
                }
                init() {
                    const e = this.editor
                      , t = e.conversion;
                    e.editing.view.addObserver(Z0),
                    t.for("upcast").attributeToAttribute({
                        view: {
                            name: "img",
                            key: "alt"
                        },
                        model: "alt"
                    }).attributeToAttribute({
                        view: {
                            name: "img",
                            key: "srcset"
                        },
                        model: "srcset"
                    });
                    const r = new dR(e)
                      , i = new uR(e);
                    e.commands.add("insertImage", r),
                    e.commands.add("replaceImageSource", i),
                    e.commands.add("imageInsert", r)
                }
            }
            class J0 extends ie {
                static get requires() {
                    return [ho]
                }
                static get pluginName() {
                    return "ImageSizeAttributes"
                }
                afterInit() {
                    this._registerSchema(),
                    this._registerConverters("imageBlock"),
                    this._registerConverters("imageInline")
                }
                _registerSchema() {
                    this.editor.plugins.has("ImageBlockEditing") && this.editor.model.schema.extend("imageBlock", {
                        allowAttributes: ["width", "height"]
                    }),
                    this.editor.plugins.has("ImageInlineEditing") && this.editor.model.schema.extend("imageInline", {
                        allowAttributes: ["width", "height"]
                    })
                }
                _registerConverters(e) {
                    const t = this.editor
                      , r = t.plugins.get("ImageUtils")
                      , i = e === "imageBlock" ? "figure" : "img";
                    function l(d, h, m, g) {
                        d.on(`attribute:${h}:${e}`, (b, v, x) => {
                            if (!x.consumable.consume(v.item, b.name))
                                return;
                            const T = x.writer
                              , I = x.mapper.toViewElement(v.item)
                              , P = r.findViewImgElement(I);
                            if (v.attributeNewValue !== null ? T.setAttribute(m, v.attributeNewValue, P) : T.removeAttribute(m, P),
                            v.item.hasAttribute("sources"))
                                return;
                            const O = v.item.hasAttribute("resizedWidth");
                            if (e === "imageInline" && !O && !g)
                                return;
                            const F = v.item.getAttribute("width")
                              , q = v.item.getAttribute("height");
                            F && q && T.setStyle("aspect-ratio", `${F}/${q}`, P)
                        }
                        )
                    }
                    t.conversion.for("upcast").attributeToAttribute({
                        view: {
                            name: i,
                            styles: {
                                width: /.+/
                            }
                        },
                        model: {
                            key: "width",
                            value: d => W0(d) ? wu(d.getStyle("width")) : null
                        }
                    }).attributeToAttribute({
                        view: {
                            name: i,
                            key: "width"
                        },
                        model: "width"
                    }).attributeToAttribute({
                        view: {
                            name: i,
                            styles: {
                                height: /.+/
                            }
                        },
                        model: {
                            key: "height",
                            value: d => W0(d) ? wu(d.getStyle("height")) : null
                        }
                    }).attributeToAttribute({
                        view: {
                            name: i,
                            key: "height"
                        },
                        model: "height"
                    }),
                    t.conversion.for("editingDowncast").add(d => {
                        l(d, "width", "width", !0),
                        l(d, "height", "height", !0)
                    }
                    ),
                    t.conversion.for("dataDowncast").add(d => {
                        l(d, "width", "width", !1),
                        l(d, "height", "height", !1)
                    }
                    )
                }
            }
            class X0 extends _e {
                constructor(e, t) {
                    super(e),
                    C(this, "_modelElementName"),
                    this._modelElementName = t
                }
                refresh() {
                    const e = this.editor.plugins.get("ImageUtils")
                      , t = e.getClosestSelectedImageElement(this.editor.model.document.selection);
                    this._modelElementName === "imageBlock" ? this.isEnabled = e.isInlineImage(t) : this.isEnabled = e.isBlockImage(t)
                }
                execute(e={}) {
                    const t = this.editor
                      , r = this.editor.model
                      , i = t.plugins.get("ImageUtils")
                      , l = i.getClosestSelectedImageElement(r.document.selection)
                      , d = Object.fromEntries(l.getAttributes());
                    return d.src || d.uploadId ? r.change(h => {
                        const {setImageSizes: m=!0} = e
                          , g = Array.from(r.markers).filter(x => x.getRange().containsItem(l))
                          , b = i.insertImage(d, r.createSelection(l, "on"), this._modelElementName, {
                            setImageSizes: m
                        });
                        if (!b)
                            return null;
                        const v = h.createRangeOn(b);
                        for (const x of g) {
                            const T = x.getRange()
                              , I = T.root.rootName != "$graveyard" ? T.getJoined(v, !0) : v;
                            h.updateMarker(x, {
                                range: I
                            })
                        }
                        return {
                            oldElement: l,
                            newElement: b
                        }
                    }
                    ) : null
                }
            }
            var ex = u(7378)
              , hR = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(ex.A, hR),
            ex.A.locals;
            class tx extends ie {
                static get requires() {
                    return [ho]
                }
                static get pluginName() {
                    return "ImagePlaceholder"
                }
                afterInit() {
                    this._setupSchema(),
                    this._setupConversion(),
                    this._setupLoadListener()
                }
                _setupSchema() {
                    const e = this.editor.model.schema;
                    e.isRegistered("imageBlock") && e.extend("imageBlock", {
                        allowAttributes: ["placeholder"]
                    }),
                    e.isRegistered("imageInline") && e.extend("imageInline", {
                        allowAttributes: ["placeholder"]
                    })
                }
                _setupConversion() {
                    const e = this.editor
                      , t = e.conversion
                      , r = e.plugins.get("ImageUtils");
                    t.for("editingDowncast").add(i => {
                        i.on("attribute:placeholder", (l, d, h) => {
                            if (!h.consumable.test(d.item, l.name) || !d.item.is("element", "imageBlock") && !d.item.is("element", "imageInline"))
                                return;
                            h.consumable.consume(d.item, l.name);
                            const m = h.writer
                              , g = h.mapper.toViewElement(d.item)
                              , b = r.findViewImgElement(g);
                            d.attributeNewValue ? (m.addClass("image_placeholder", b),
                            m.setStyle("background-image", `url(${d.attributeNewValue})`, b),
                            m.setCustomProperty("editingPipeline:doNotReuseOnce", !0, b)) : (m.removeClass("image_placeholder", b),
                            m.removeStyle("background-image", b))
                        }
                        )
                    }
                    )
                }
                _setupLoadListener() {
                    const e = this.editor
                      , t = e.model
                      , r = e.editing
                      , i = r.view
                      , l = e.plugins.get("ImageUtils");
                    i.addObserver(Z0),
                    this.listenTo(i.document, "imageLoaded", (d, h) => {
                        const m = i.domConverter.mapDomToView(h.target);
                        if (!m)
                            return;
                        const g = l.getImageWidgetFromImageView(m);
                        if (!g)
                            return;
                        const b = r.mapper.toModelElement(g);
                        b && b.hasAttribute("placeholder") && t.enqueueChange({
                            isUndoable: !1
                        }, v => {
                            v.removeAttribute("placeholder", b)
                        }
                        )
                    }
                    )
                }
            }
            class ox extends ie {
                static get requires() {
                    return [ug, J0, ho, tx, Ko]
                }
                static get pluginName() {
                    return "ImageBlockEditing"
                }
                init() {
                    const e = this.editor;
                    e.model.schema.register("imageBlock", {
                        inheritAllFrom: "$blockObject",
                        allowAttributes: ["alt", "src", "srcset"]
                    }),
                    this._setupConversion(),
                    e.plugins.has("ImageInlineEditing") && (e.commands.add("imageTypeBlock", new X0(this.editor,"imageBlock")),
                    this._setupClipboardIntegration())
                }
                _setupConversion() {
                    const e = this.editor
                      , t = e.t
                      , r = e.conversion
                      , i = e.plugins.get("ImageUtils");
                    r.for("dataDowncast").elementToStructure({
                        model: "imageBlock",
                        view: (l, {writer: d}) => U0(d)
                    }),
                    r.for("editingDowncast").elementToStructure({
                        model: "imageBlock",
                        view: (l, {writer: d}) => i.toImageWidget(U0(d), d, t("image widget"))
                    }),
                    r.for("downcast").add(Au(i, "imageBlock", "src")).add(Au(i, "imageBlock", "alt")).add(Q0(i, "imageBlock")),
                    r.for("upcast").elementToElement({
                        view: H0(e, "imageBlock"),
                        model: (l, {writer: d}) => d.createElement("imageBlock", l.hasAttribute("src") ? {
                            src: l.getAttribute("src")
                        } : void 0)
                    }).add(function(l) {
                        const d = (h, m, g) => {
                            if (!g.consumable.test(m.viewItem, {
                                name: !0,
                                classes: "image"
                            }))
                                return;
                            const b = l.findViewImgElement(m.viewItem);
                            if (!b || !g.consumable.test(b, {
                                name: !0
                            }))
                                return;
                            g.consumable.consume(m.viewItem, {
                                name: !0,
                                classes: "image"
                            });
                            const v = zt(g.convertItem(b, m.modelCursor).modelRange.getItems());
                            v ? (g.convertChildren(m.viewItem, v),
                            g.updateConversionResult(v, m)) : g.consumable.revert(m.viewItem, {
                                name: !0,
                                classes: "image"
                            })
                        }
                        ;
                        return h => {
                            h.on("element:figure", d)
                        }
                    }(i))
                }
                _setupClipboardIntegration() {
                    const e = this.editor
                      , t = e.model
                      , r = e.editing.view
                      , i = e.plugins.get("ImageUtils")
                      , l = e.plugins.get("ClipboardPipeline");
                    this.listenTo(l, "inputTransformation", (d, h) => {
                        const m = Array.from(h.content.getChildren());
                        let g;
                        if (!m.every(i.isInlineImageView))
                            return;
                        g = h.targetRanges ? e.editing.mapper.toModelRange(h.targetRanges[0]) : t.document.selection.getFirstRange();
                        const b = t.createSelection(g);
                        if (dg(t.schema, b) === "imageBlock") {
                            const v = new Zr(r.document)
                              , x = m.map(T => v.createElement("figure", {
                                class: "image"
                            }, T));
                            h.content = v.createDocumentFragment(x)
                        }
                    }
                    ),
                    this.listenTo(l, "contentInsertion", (d, h) => {
                        h.method === "paste" && t.change(m => {
                            const g = m.createRangeIn(h.content);
                            for (const b of g.getItems())
                                b.is("element", "imageBlock") && i.setImageNaturalSizeAttributes(b)
                        }
                        )
                    }
                    )
                }
            }
            var rx = u(3350)
              , mR = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(rx.A, mR),
            rx.A.locals;
            class pR extends pe {
                constructor(e, t=[]) {
                    super(e),
                    C(this, "focusTracker"),
                    C(this, "keystrokes"),
                    C(this, "_focusables"),
                    C(this, "_focusCycler"),
                    C(this, "children"),
                    this.focusTracker = new Jt,
                    this.keystrokes = new lo,
                    this._focusables = new ur,
                    this.children = this.createCollection(),
                    this._focusCycler = new Jr({
                        focusables: this._focusables,
                        focusTracker: this.focusTracker,
                        keystrokeHandler: this.keystrokes,
                        actions: {
                            focusPrevious: "shift + tab",
                            focusNext: "tab"
                        }
                    });
                    for (const r of t)
                        this.children.add(r),
                        this._focusables.add(r),
                        r instanceof jj && this._focusables.addMany(r.children);
                    this.setTemplate({
                        tag: "form",
                        attributes: {
                            class: ["ck", "ck-image-insert-form"],
                            tabindex: -1
                        },
                        children: this.children
                    })
                }
                render() {
                    super.render(),
                    Td({
                        view: this
                    });
                    for (const t of this._focusables)
                        this.focusTracker.add(t.element);
                    this.keystrokes.listenTo(this.element);
                    const e = t => t.stopPropagation();
                    this.keystrokes.set("arrowright", e),
                    this.keystrokes.set("arrowleft", e),
                    this.keystrokes.set("arrowup", e),
                    this.keystrokes.set("arrowdown", e)
                }
                destroy() {
                    super.destroy(),
                    this.focusTracker.destroy(),
                    this.keystrokes.destroy()
                }
                focus() {
                    this._focusCycler.focusFirst()
                }
            }
            class nx extends ie {
                constructor(e) {
                    super(e),
                    C(this, "dropdownView"),
                    C(this, "_integrations", new Map),
                    e.config.define("image.insert.integrations", ["upload", "assetManager", "url"])
                }
                static get pluginName() {
                    return "ImageInsertUI"
                }
                static get requires() {
                    return [ho]
                }
                init() {
                    const e = this.editor
                      , t = e.model.document.selection
                      , r = e.plugins.get("ImageUtils");
                    this.set("isImageSelected", !1),
                    this.listenTo(e.model.document, "change", () => {
                        this.isImageSelected = r.isImage(t.getSelectedElement())
                    }
                    );
                    const i = l => this._createToolbarComponent(l);
                    e.ui.componentFactory.add("insertImage", i),
                    e.ui.componentFactory.add("imageInsert", i),
                    e.ui.componentFactory.add("menuBar:insertImage", l => this._createMenuBarComponent(l))
                }
                registerIntegration({name: e, observable: t, buttonViewCreator: r, formViewCreator: i, menuBarButtonViewCreator: l, requiresForm: d=!1}) {
                    this._integrations.has(e) && de("image-insert-integration-exists", {
                        name: e
                    }),
                    this._integrations.set(e, {
                        observable: t,
                        buttonViewCreator: r,
                        menuBarButtonViewCreator: l,
                        formViewCreator: i,
                        requiresForm: d
                    })
                }
                _createToolbarComponent(e) {
                    const t = this.editor
                      , r = e.t
                      , i = this._prepareIntegrations();
                    if (!i.length)
                        return null;
                    let l;
                    const d = i[0];
                    if (i.length == 1) {
                        if (!d.requiresForm)
                            return d.buttonViewCreator(!0);
                        l = d.buttonViewCreator(!0)
                    } else {
                        const g = d.buttonViewCreator(!1);
                        l = new tu(e,g),
                        l.tooltip = !0,
                        l.bind("label").to(this, "isImageSelected", b => r(b ? "Replace image" : "Insert image"))
                    }
                    const h = this.dropdownView = Nn(e, l)
                      , m = i.map( ({observable: g}) => typeof g == "function" ? g() : g);
                    return h.bind("isEnabled").toMany(m, "isEnabled", (...g) => g.some(b => b)),
                    h.once("change:isOpen", () => {
                        const g = i.map( ({formViewCreator: v}) => v(i.length == 1))
                          , b = new pR(t.locale,g);
                        h.panelView.children.add(b)
                    }
                    ),
                    h
                }
                _createMenuBarComponent(e) {
                    const t = e.t
                      , r = this._prepareIntegrations();
                    if (!r.length)
                        return null;
                    let i;
                    const l = r[0];
                    if (r.length == 1)
                        i = l.menuBarButtonViewCreator(!0);
                    else {
                        i = new Os(e);
                        const d = new su(e);
                        i.panelView.children.add(d),
                        i.buttonView.set({
                            icon: he.image,
                            label: t("Image")
                        });
                        for (const h of r) {
                            const m = new iu(e,i)
                              , g = h.menuBarButtonViewCreator(!1);
                            m.children.add(g),
                            d.items.add(m)
                        }
                    }
                    return i
                }
                _prepareIntegrations() {
                    const e = this.editor.config.get("image.insert.integrations")
                      , t = [];
                    if (!e.length)
                        return de("image-insert-integrations-not-specified"),
                        t;
                    for (const r of e)
                        this._integrations.has(r) ? t.push(this._integrations.get(r)) : ["upload", "assetManager", "url"].includes(r) || de("image-insert-unknown-integration", {
                            item: r
                        });
                    return t.length || de("image-insert-integrations-not-registered"),
                    t
                }
            }
            var ix = u(265)
              , gR = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(ix.A, gR),
            ix.A.locals;
            class fR extends ie {
                static get requires() {
                    return [ox, jl, Y0, nx]
                }
                static get pluginName() {
                    return "ImageBlock"
                }
            }
            class kR extends ie {
                static get requires() {
                    return [ug, J0, ho, tx, Ko]
                }
                static get pluginName() {
                    return "ImageInlineEditing"
                }
                init() {
                    const e = this.editor;
                    e.model.schema.register("imageInline", {
                        inheritAllFrom: "$inlineObject",
                        allowAttributes: ["alt", "src", "srcset"],
                        disallowIn: ["caption"]
                    }),
                    this._setupConversion(),
                    e.plugins.has("ImageBlockEditing") && (e.commands.add("imageTypeInline", new X0(this.editor,"imageInline")),
                    this._setupClipboardIntegration())
                }
                _setupConversion() {
                    const e = this.editor
                      , t = e.t
                      , r = e.conversion
                      , i = e.plugins.get("ImageUtils");
                    r.for("dataDowncast").elementToElement({
                        model: "imageInline",
                        view: (l, {writer: d}) => d.createEmptyElement("img")
                    }),
                    r.for("editingDowncast").elementToStructure({
                        model: "imageInline",
                        view: (l, {writer: d}) => i.toImageWidget(function(h) {
                            return h.createContainerElement("span", {
                                class: "image-inline"
                            }, h.createEmptyElement("img"))
                        }(d), d, t("image widget"))
                    }),
                    r.for("downcast").add(Au(i, "imageInline", "src")).add(Au(i, "imageInline", "alt")).add(Q0(i, "imageInline")),
                    r.for("upcast").elementToElement({
                        view: H0(e, "imageInline"),
                        model: (l, {writer: d}) => d.createElement("imageInline", l.hasAttribute("src") ? {
                            src: l.getAttribute("src")
                        } : void 0)
                    })
                }
                _setupClipboardIntegration() {
                    const e = this.editor
                      , t = e.model
                      , r = e.editing.view
                      , i = e.plugins.get("ImageUtils")
                      , l = e.plugins.get("ClipboardPipeline");
                    this.listenTo(l, "inputTransformation", (d, h) => {
                        const m = Array.from(h.content.getChildren());
                        let g;
                        if (!m.every(i.isBlockImageView))
                            return;
                        g = h.targetRanges ? e.editing.mapper.toModelRange(h.targetRanges[0]) : t.document.selection.getFirstRange();
                        const b = t.createSelection(g);
                        if (dg(t.schema, b) === "imageInline") {
                            const v = new Zr(r.document)
                              , x = m.map(T => T.childCount === 1 ? (Array.from(T.getAttributes()).forEach(I => v.setAttribute(...I, i.findViewImgElement(T))),
                            T.getChild(0)) : T);
                            h.content = v.createDocumentFragment(x)
                        }
                    }
                    ),
                    this.listenTo(l, "contentInsertion", (d, h) => {
                        h.method === "paste" && t.change(m => {
                            const g = m.createRangeIn(h.content);
                            for (const b of g.getItems())
                                b.is("element", "imageInline") && i.setImageNaturalSizeAttributes(b)
                        }
                        )
                    }
                    )
                }
            }
            class bR extends ie {
                static get requires() {
                    return [kR, jl, Y0, nx]
                }
                static get pluginName() {
                    return "ImageInline"
                }
            }
            class wR extends ie {
                static get requires() {
                    return [fR, bR]
                }
                static get pluginName() {
                    return "Image"
                }
            }
            class sx extends ie {
                static get pluginName() {
                    return "ImageCaptionUtils"
                }
                static get requires() {
                    return [ho]
                }
                getCaptionFromImageModelElement(e) {
                    for (const t of e.getChildren())
                        if (t && t.is("element", "caption"))
                            return t;
                    return null
                }
                getCaptionFromModelSelection(e) {
                    const t = this.editor.plugins.get("ImageUtils")
                      , r = e.getFirstPosition().findAncestor("caption");
                    return r && t.isBlockImage(r.parent) ? r : null
                }
                matchImageCaptionViewElement(e) {
                    const t = this.editor.plugins.get("ImageUtils");
                    return e.name == "figcaption" && t.isBlockImageView(e.parent) ? {
                        name: !0
                    } : null
                }
            }
            class AR extends _e {
                refresh() {
                    const e = this.editor
                      , t = e.plugins.get("ImageCaptionUtils")
                      , r = e.plugins.get("ImageUtils");
                    if (!e.plugins.has(ox))
                        return this.isEnabled = !1,
                        void (this.value = !1);
                    const i = e.model.document.selection
                      , l = i.getSelectedElement();
                    if (!l) {
                        const d = t.getCaptionFromModelSelection(i);
                        return this.isEnabled = !!d,
                        void (this.value = !!d)
                    }
                    this.isEnabled = r.isImage(l),
                    this.isEnabled ? this.value = !!t.getCaptionFromImageModelElement(l) : this.value = !1
                }
                execute(e={}) {
                    const {focusCaptionOnShow: t} = e;
                    this.editor.model.change(r => {
                        this.value ? this._hideImageCaption(r) : this._showImageCaption(r, t)
                    }
                    )
                }
                _showImageCaption(e, t) {
                    const r = this.editor.model.document.selection
                      , i = this.editor.plugins.get("ImageCaptionEditing")
                      , l = this.editor.plugins.get("ImageUtils");
                    let d = r.getSelectedElement();
                    const h = i._getSavedCaption(d);
                    l.isInlineImage(d) && (this.editor.execute("imageTypeBlock"),
                    d = r.getSelectedElement());
                    const m = h || e.createElement("caption");
                    e.append(m, d),
                    t && e.setSelection(m, "in")
                }
                _hideImageCaption(e) {
                    const t = this.editor
                      , r = t.model.document.selection
                      , i = t.plugins.get("ImageCaptionEditing")
                      , l = t.plugins.get("ImageCaptionUtils");
                    let d, h = r.getSelectedElement();
                    h ? d = l.getCaptionFromImageModelElement(h) : (d = l.getCaptionFromModelSelection(r),
                    h = d.parent),
                    i._saveCaption(h, d),
                    e.setSelection(h, "on"),
                    e.remove(d)
                }
            }
            class vR extends ie {
                constructor(e) {
                    super(e),
                    C(this, "_savedCaptionsMap"),
                    this._savedCaptionsMap = new WeakMap
                }
                static get requires() {
                    return [ho, sx]
                }
                static get pluginName() {
                    return "ImageCaptionEditing"
                }
                init() {
                    const e = this.editor
                      , t = e.model.schema;
                    t.isRegistered("caption") ? t.extend("caption", {
                        allowIn: "imageBlock"
                    }) : t.register("caption", {
                        allowIn: "imageBlock",
                        allowContentOf: "$block",
                        isLimit: !0
                    }),
                    e.commands.add("toggleImageCaption", new AR(this.editor)),
                    this._setupConversion(),
                    this._setupImageTypeCommandsIntegration(),
                    this._registerCaptionReconversion()
                }
                _setupConversion() {
                    const e = this.editor
                      , t = e.editing.view
                      , r = e.plugins.get("ImageUtils")
                      , i = e.plugins.get("ImageCaptionUtils")
                      , l = e.t;
                    e.conversion.for("upcast").elementToElement({
                        view: d => i.matchImageCaptionViewElement(d),
                        model: "caption"
                    }),
                    e.conversion.for("dataDowncast").elementToElement({
                        model: "caption",
                        view: (d, {writer: h}) => r.isBlockImage(d.parent) ? h.createContainerElement("figcaption") : null
                    }),
                    e.conversion.for("editingDowncast").elementToElement({
                        model: "caption",
                        view: (d, {writer: h}) => {
                            if (!r.isBlockImage(d.parent))
                                return null;
                            const m = h.createEditableElement("figcaption");
                            h.setCustomProperty("imageCaption", !0, m),
                            m.placeholder = l("Enter image caption"),
                            yv({
                                view: t,
                                element: m,
                                keepOnFocus: !0
                            });
                            const g = d.parent.getAttribute("alt");
                            return Yy(m, h, {
                                label: g ? l("Caption for image: %0", [g]) : l("Caption for the image")
                            })
                        }
                    })
                }
                _setupImageTypeCommandsIntegration() {
                    const e = this.editor
                      , t = e.plugins.get("ImageUtils")
                      , r = e.plugins.get("ImageCaptionUtils")
                      , i = e.commands.get("imageTypeInline")
                      , l = e.commands.get("imageTypeBlock")
                      , d = h => {
                        if (!h.return)
                            return;
                        const {oldElement: m, newElement: g} = h.return;
                        if (!m)
                            return;
                        if (t.isBlockImage(m)) {
                            const v = r.getCaptionFromImageModelElement(m);
                            if (v)
                                return void this._saveCaption(g, v)
                        }
                        const b = this._getSavedCaption(m);
                        b && this._saveCaption(g, b)
                    }
                    ;
                    i && this.listenTo(i, "execute", d, {
                        priority: "low"
                    }),
                    l && this.listenTo(l, "execute", d, {
                        priority: "low"
                    })
                }
                _getSavedCaption(e) {
                    const t = this._savedCaptionsMap.get(e);
                    return t ? Fe.fromJSON(t) : null
                }
                _saveCaption(e, t) {
                    this._savedCaptionsMap.set(e, t.toJSON())
                }
                _registerCaptionReconversion() {
                    const e = this.editor
                      , t = e.model
                      , r = e.plugins.get("ImageUtils")
                      , i = e.plugins.get("ImageCaptionUtils");
                    t.document.on("change:data", () => {
                        const l = t.document.differ.getChanges();
                        for (const d of l) {
                            if (d.attributeKey !== "alt")
                                continue;
                            const h = d.range.start.nodeAfter;
                            if (r.isBlockImage(h)) {
                                const m = i.getCaptionFromImageModelElement(h);
                                if (!m)
                                    return;
                                e.editing.reconvertItem(m)
                            }
                        }
                    }
                    )
                }
            }
            class _R extends ie {
                static get requires() {
                    return [sx]
                }
                static get pluginName() {
                    return "ImageCaptionUI"
                }
                init() {
                    const e = this.editor
                      , t = e.editing.view
                      , r = e.plugins.get("ImageCaptionUtils")
                      , i = e.t;
                    e.ui.componentFactory.add("toggleImageCaption", l => {
                        const d = e.commands.get("toggleImageCaption")
                          , h = new Te(l);
                        return h.set({
                            icon: he.caption,
                            tooltip: !0,
                            isToggleable: !0
                        }),
                        h.bind("isOn", "isEnabled").to(d, "value", "isEnabled"),
                        h.bind("label").to(d, "value", m => i(m ? "Toggle caption off" : "Toggle caption on")),
                        this.listenTo(h, "execute", () => {
                            e.execute("toggleImageCaption", {
                                focusCaptionOnShow: !0
                            });
                            const m = r.getCaptionFromModelSelection(e.model.document.selection);
                            if (m) {
                                const g = e.editing.mapper.toViewElement(m);
                                t.scrollToTheSelection(),
                                t.change(b => {
                                    b.addClass("image__caption_highlighted", g)
                                }
                                )
                            }
                            e.editing.view.focus()
                        }
                        ),
                        h
                    }
                    )
                }
            }
            var ax = u(5247)
              , CR = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(ax.A, CR),
            ax.A.locals;
            class yR extends ie {
                static get requires() {
                    return [vR, _R]
                }
                static get pluginName() {
                    return "ImageCaption"
                }
            }
            function lx(s) {
                const e = s.map(t => t.replace("+", "\\+"));
                return new RegExp(`^image\\/(${e.join("|")})$`)
            }
            function xR(s) {
                return new Promise( (e, t) => {
                    const r = s.getAttribute("src");
                    fetch(r).then(i => i.blob()).then(i => {
                        const l = cx(i, r)
                          , d = l.replace("image/", "")
                          , h = new File([i],`image.${d}`,{
                            type: l
                        });
                        e(h)
                    }
                    ).catch(i => i && i.name === "TypeError" ? function(l) {
                        return function(d) {
                            return new Promise( (h, m) => {
                                const g = w.document.createElement("img");
                                g.addEventListener("load", () => {
                                    const b = w.document.createElement("canvas");
                                    b.width = g.width,
                                    b.height = g.height,
                                    b.getContext("2d").drawImage(g, 0, 0),
                                    b.toBlob(v => v ? h(v) : m())
                                }
                                ),
                                g.addEventListener("error", () => m()),
                                g.src = d
                            }
                            )
                        }(l).then(d => {
                            const h = cx(d, l)
                              , m = h.replace("image/", "");
                            return new File([d],`image.${m}`,{
                                type: h
                            })
                        }
                        )
                    }(r).then(e).catch(t) : t(i))
                }
                )
            }
            function cx(s, e) {
                return s.type ? s.type : e.match(/data:(image\/\w+);base64/) ? e.match(/data:(image\/\w+);base64/)[1].toLowerCase() : "image/jpeg"
            }
            class ER extends ie {
                static get pluginName() {
                    return "ImageUploadUI"
                }
                init() {
                    const e = this.editor;
                    e.ui.componentFactory.add("uploadImage", () => this._createToolbarButton()),
                    e.ui.componentFactory.add("imageUpload", () => this._createToolbarButton()),
                    e.ui.componentFactory.add("menuBar:uploadImage", () => this._createMenuBarButton("standalone")),
                    e.plugins.has("ImageInsertUI") && e.plugins.get("ImageInsertUI").registerIntegration({
                        name: "upload",
                        observable: () => e.commands.get("uploadImage"),
                        buttonViewCreator: () => this._createToolbarButton(),
                        formViewCreator: () => this._createDropdownButton(),
                        menuBarButtonViewCreator: t => this._createMenuBarButton(t ? "insertOnly" : "insertNested")
                    })
                }
                _createButton(e) {
                    const t = this.editor
                      , r = t.locale
                      , i = t.commands.get("uploadImage")
                      , l = t.config.get("image.upload.types")
                      , d = lx(l)
                      , h = new e(t.locale)
                      , m = r.t;
                    return h.set({
                        acceptedType: l.map(g => `image/${g}`).join(","),
                        allowMultipleFiles: !0,
                        label: m("Upload from computer"),
                        icon: he.imageUpload
                    }),
                    h.bind("isEnabled").to(i),
                    h.on("done", (g, b) => {
                        const v = Array.from(b).filter(x => d.test(x.type));
                        v.length && (t.execute("uploadImage", {
                            file: v
                        }),
                        t.editing.view.focus())
                    }
                    ),
                    h
                }
                _createToolbarButton() {
                    const e = this.editor.locale.t
                      , t = this.editor.plugins.get("ImageInsertUI")
                      , r = this._createButton(Hp);
                    return r.tooltip = !0,
                    r.bind("label").to(t, "isImageSelected", i => e(i ? "Replace image from computer" : "Upload image from computer")),
                    r
                }
                _createDropdownButton() {
                    const e = this.editor.locale.t
                      , t = this.editor.plugins.get("ImageInsertUI")
                      , r = this._createButton(Hp);
                    return r.withText = !0,
                    r.bind("label").to(t, "isImageSelected", i => e(i ? "Replace from computer" : "Upload from computer")),
                    r.on("execute", () => {
                        t.dropdownView.isOpen = !1
                    }
                    ),
                    r
                }
                _createMenuBarButton(e) {
                    const t = this.editor.locale.t
                      , r = this._createButton(Ay);
                    switch (r.withText = !0,
                    e) {
                    case "standalone":
                        r.label = t("Image from computer");
                        break;
                    case "insertOnly":
                        r.label = t("Image");
                        break;
                    case "insertNested":
                        r.label = t("From computer")
                    }
                    return r
                }
            }
            var dx = u(2267)
              , SR = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(dx.A, SR),
            dx.A.locals;
            var ux = u(7693)
              , DR = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(ux.A, DR),
            ux.A.locals;
            var hx = u(1559)
              , TR = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(hx.A, TR),
            hx.A.locals;
            class IR extends ie {
                constructor(e) {
                    super(e),
                    C(this, "placeholder"),
                    C(this, "uploadStatusChange", (t, r, i) => {
                        const l = this.editor
                          , d = r.item
                          , h = d.getAttribute("uploadId");
                        if (!i.consumable.consume(r.item, t.name))
                            return;
                        const m = l.plugins.get("ImageUtils")
                          , g = l.plugins.get(br)
                          , b = h ? r.attributeNewValue : null
                          , v = this.placeholder
                          , x = l.editing.mapper.toViewElement(d)
                          , T = i.writer;
                        if (b == "reading")
                            return mx(x, T),
                            void px(m, v, x, T);
                        if (b == "uploading") {
                            const I = g.loaders.get(h);
                            return mx(x, T),
                            void (I ? (gx(x, T),
                            function(P, O, F, q) {
                                const Q = function(X) {
                                    const le = X.createUIElement("div", {
                                        class: "ck-progress-bar"
                                    });
                                    return X.setCustomProperty("progressBar", !0, le),
                                    le
                                }(O);
                                O.insert(O.createPositionAt(P, "end"), Q),
                                F.on("change:uploadedPercent", (X, le, ge) => {
                                    q.change(ke => {
                                        ke.setStyle("width", ge + "%", Q)
                                    }
                                    )
                                }
                                )
                            }(x, T, I, l.editing.view),
                            function(P, O, F, q) {
                                if (q.data) {
                                    const Q = P.findViewImgElement(O);
                                    F.setAttribute("src", q.data, Q)
                                }
                            }(m, x, T, I)) : px(m, v, x, T))
                        }
                        b == "complete" && g.loaders.get(h) && function(I, P, O) {
                            const F = P.createUIElement("div", {
                                class: "ck-image-upload-complete-icon"
                            });
                            P.insert(P.createPositionAt(I, "end"), F),
                            setTimeout( () => {
                                O.change(q => q.remove(q.createRangeOn(F)))
                            }
                            , 3e3)
                        }(x, T, l.editing.view),
                        function(I, P) {
                            kx(I, P, "progressBar")
                        }(x, T),
                        gx(x, T),
                        function(I, P) {
                            P.removeClass("ck-appear", I)
                        }(x, T)
                    }
                    ),
                    this.placeholder = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="
                }
                static get pluginName() {
                    return "ImageUploadProgress"
                }
                init() {
                    const e = this.editor;
                    e.plugins.has("ImageBlockEditing") && e.editing.downcastDispatcher.on("attribute:uploadStatus:imageBlock", this.uploadStatusChange),
                    e.plugins.has("ImageInlineEditing") && e.editing.downcastDispatcher.on("attribute:uploadStatus:imageInline", this.uploadStatusChange)
                }
            }
            function mx(s, e) {
                s.hasClass("ck-appear") || e.addClass("ck-appear", s)
            }
            function px(s, e, t, r) {
                t.hasClass("ck-image-upload-placeholder") || r.addClass("ck-image-upload-placeholder", t);
                const i = s.findViewImgElement(t);
                i.getAttribute("src") !== e && r.setAttribute("src", e, i),
                fx(t, "placeholder") || r.insert(r.createPositionAfter(i), function(l) {
                    const d = l.createUIElement("div", {
                        class: "ck-upload-placeholder-loader"
                    });
                    return l.setCustomProperty("placeholder", !0, d),
                    d
                }(r))
            }
            function gx(s, e) {
                s.hasClass("ck-image-upload-placeholder") && e.removeClass("ck-image-upload-placeholder", s),
                kx(s, e, "placeholder")
            }
            function fx(s, e) {
                for (const t of s.getChildren())
                    if (t.getCustomProperty(e))
                        return t
            }
            function kx(s, e, t) {
                const r = fx(s, t);
                r && e.remove(e.createRangeOn(r))
            }
            class MR extends _e {
                refresh() {
                    const e = this.editor
                      , t = e.plugins.get("ImageUtils")
                      , r = e.model.document.selection.getSelectedElement();
                    this.isEnabled = t.isImageAllowed() || t.isImage(r)
                }
                execute(e) {
                    const t = Ze(e.file)
                      , r = this.editor.model.document.selection
                      , i = this.editor.plugins.get("ImageUtils")
                      , l = Object.fromEntries(r.getAttributes());
                    t.forEach( (d, h) => {
                        const m = r.getSelectedElement();
                        if (h && m && i.isImage(m)) {
                            const g = this.editor.model.createPositionAfter(m);
                            this._uploadImage(d, l, g)
                        } else
                            this._uploadImage(d, l)
                    }
                    )
                }
                _uploadImage(e, t, r) {
                    const i = this.editor
                      , l = i.plugins.get(br).createLoader(e)
                      , d = i.plugins.get("ImageUtils");
                    l && d.insertImage({
                        ...t,
                        uploadId: l.id
                    }, r)
                }
            }
            class BR extends ie {
                constructor(e) {
                    super(e),
                    C(this, "_uploadImageElements"),
                    e.config.define("image", {
                        upload: {
                            types: ["jpeg", "png", "gif", "bmp", "webp", "tiff"]
                        }
                    }),
                    this._uploadImageElements = new Map
                }
                static get requires() {
                    return [br, tg, Ko, ho]
                }
                static get pluginName() {
                    return "ImageUploadEditing"
                }
                init() {
                    const e = this.editor
                      , t = e.model.document
                      , r = e.conversion
                      , i = e.plugins.get(br)
                      , l = e.plugins.get("ImageUtils")
                      , d = e.plugins.get("ClipboardPipeline")
                      , h = lx(e.config.get("image.upload.types"))
                      , m = new MR(e);
                    e.commands.add("uploadImage", m),
                    e.commands.add("imageUpload", m),
                    r.for("upcast").attributeToAttribute({
                        view: {
                            name: "img",
                            key: "uploadId"
                        },
                        model: "uploadId"
                    }),
                    this.listenTo(e.editing.view.document, "clipboardInput", (g, b) => {
                        if (v = b.dataTransfer,
                        Array.from(v.types).includes("text/html") && v.getData("text/html") !== "")
                            return;
                        var v;
                        const x = Array.from(b.dataTransfer.files).filter(T => !!T && h.test(T.type));
                        x.length && (g.stop(),
                        e.model.change(T => {
                            b.targetRanges && T.setSelection(b.targetRanges.map(I => e.editing.mapper.toModelRange(I))),
                            e.execute("uploadImage", {
                                file: x
                            })
                        }
                        ))
                    }
                    ),
                    this.listenTo(d, "inputTransformation", (g, b) => {
                        const v = Array.from(e.editing.view.createRangeIn(b.content)).map(T => T.item).filter(T => function(I, P) {
                            return !(!I.isInlineImageView(P) || !P.getAttribute("src") || !P.getAttribute("src").match(/^data:image\/\w+;base64,/g) && !P.getAttribute("src").match(/^blob:/g))
                        }(l, T) && !T.getAttribute("uploadProcessed")).map(T => ({
                            promise: xR(T),
                            imageElement: T
                        }));
                        if (!v.length)
                            return;
                        const x = new Zr(e.editing.view.document);
                        for (const T of v) {
                            x.setAttribute("uploadProcessed", !0, T.imageElement);
                            const I = i.createLoader(T.promise);
                            I && (x.setAttribute("src", "", T.imageElement),
                            x.setAttribute("uploadId", I.id, T.imageElement))
                        }
                    }
                    ),
                    e.editing.view.document.on("dragover", (g, b) => {
                        b.preventDefault()
                    }
                    ),
                    t.on("change", () => {
                        const g = t.differ.getChanges({
                            includeChangesInGraveyard: !0
                        }).reverse()
                          , b = new Set;
                        for (const v of g)
                            if (v.type == "insert" && v.name != "$text") {
                                const x = v.position.nodeAfter
                                  , T = v.position.root.rootName == "$graveyard";
                                for (const I of NR(e, x)) {
                                    const P = I.getAttribute("uploadId");
                                    if (!P)
                                        continue;
                                    const O = i.loaders.get(P);
                                    O && (T ? b.has(P) || O.abort() : (b.add(P),
                                    this._uploadImageElements.set(P, I),
                                    O.status == "idle" && this._readAndUpload(O)))
                                }
                            }
                    }
                    ),
                    this.on("uploadComplete", (g, {imageElement: b, data: v}) => {
                        const x = v.urls ? v.urls : v;
                        this.editor.model.change(T => {
                            T.setAttribute("src", x.default, b),
                            this._parseAndSetSrcsetAttributeOnImage(x, b, T),
                            l.setImageNaturalSizeAttributes(b)
                        }
                        )
                    }
                    , {
                        priority: "low"
                    })
                }
                afterInit() {
                    const e = this.editor.model.schema;
                    this.editor.plugins.has("ImageBlockEditing") && e.extend("imageBlock", {
                        allowAttributes: ["uploadId", "uploadStatus"]
                    }),
                    this.editor.plugins.has("ImageInlineEditing") && e.extend("imageInline", {
                        allowAttributes: ["uploadId", "uploadStatus"]
                    })
                }
                _readAndUpload(e) {
                    const t = this.editor
                      , r = t.model
                      , i = t.locale.t
                      , l = t.plugins.get(br)
                      , d = t.plugins.get(tg)
                      , h = t.plugins.get("ImageUtils")
                      , m = this._uploadImageElements;
                    return r.enqueueChange({
                        isUndoable: !1
                    }, b => {
                        b.setAttribute("uploadStatus", "reading", m.get(e.id))
                    }
                    ),
                    e.read().then( () => {
                        const b = e.upload()
                          , v = m.get(e.id);
                        if (E.isSafari) {
                            const x = t.editing.mapper.toViewElement(v)
                              , T = h.findViewImgElement(x);
                            t.editing.view.once("render", () => {
                                if (!T.parent)
                                    return;
                                const I = t.editing.view.domConverter.mapViewToDom(T.parent);
                                if (!I)
                                    return;
                                const P = I.style.display;
                                I.style.display = "none",
                                I._ckHack = I.offsetHeight,
                                I.style.display = P
                            }
                            )
                        }
                        return t.ui && t.ui.ariaLiveAnnouncer.announce(i("Uploading image")),
                        r.enqueueChange({
                            isUndoable: !1
                        }, x => {
                            x.setAttribute("uploadStatus", "uploading", v)
                        }
                        ),
                        b
                    }
                    ).then(b => {
                        r.enqueueChange({
                            isUndoable: !1
                        }, v => {
                            const x = m.get(e.id);
                            v.setAttribute("uploadStatus", "complete", x),
                            t.ui && t.ui.ariaLiveAnnouncer.announce(i("Image upload complete")),
                            this.fire("uploadComplete", {
                                data: b,
                                imageElement: x
                            })
                        }
                        ),
                        g()
                    }
                    ).catch(b => {
                        if (t.ui && t.ui.ariaLiveAnnouncer.announce(i("Error during image upload")),
                        e.status !== "error" && e.status !== "aborted")
                            throw b;
                        e.status == "error" && b && d.showWarning(b, {
                            title: i("Upload failed"),
                            namespace: "upload"
                        }),
                        r.enqueueChange({
                            isUndoable: !1
                        }, v => {
                            v.remove(m.get(e.id))
                        }
                        ),
                        g()
                    }
                    );
                    function g() {
                        r.enqueueChange({
                            isUndoable: !1
                        }, b => {
                            const v = m.get(e.id);
                            b.removeAttribute("uploadId", v),
                            b.removeAttribute("uploadStatus", v),
                            m.delete(e.id)
                        }
                        ),
                        l.destroyLoader(e)
                    }
                }
                _parseAndSetSrcsetAttributeOnImage(e, t, r) {
                    let i = 0;
                    const l = Object.keys(e).filter(d => {
                        const h = parseInt(d, 10);
                        if (!isNaN(h))
                            return i = Math.max(i, h),
                            !0
                    }
                    ).map(d => `${e[d]} ${d}w`).join(", ");
                    if (l != "") {
                        const d = {
                            srcset: l
                        };
                        t.hasAttribute("width") || t.hasAttribute("height") || (d.width = i),
                        r.setAttributes(d, t)
                    }
                }
            }
            function NR(s, e) {
                const t = s.plugins.get("ImageUtils");
                return Array.from(s.model.createRangeOn(e)).filter(r => t.isImage(r.item)).map(r => r.item)
            }
            class PR extends ie {
                static get pluginName() {
                    return "ImageUpload"
                }
                static get requires() {
                    return [BR, ER, IR]
                }
            }
            var bx = u(4642)
              , jR = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(bx.A, jR),
            bx.A.locals;
            var wx = u(3469)
              , LR = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(wx.A, LR),
            wx.A.locals;
            class zR extends _e {
                constructor(e, t) {
                    super(e),
                    C(this, "_defaultStyles"),
                    C(this, "_styles"),
                    this._defaultStyles = {
                        imageBlock: !1,
                        imageInline: !1
                    },
                    this._styles = new Map(t.map(r => {
                        if (r.isDefault)
                            for (const i of r.modelElements)
                                this._defaultStyles[i] = r.name;
                        return [r.name, r]
                    }
                    ))
                }
                refresh() {
                    const e = this.editor.plugins.get("ImageUtils").getClosestSelectedImageElement(this.editor.model.document.selection);
                    this.isEnabled = !!e,
                    this.isEnabled ? e.hasAttribute("imageStyle") ? this.value = e.getAttribute("imageStyle") : this.value = this._defaultStyles[e.name] : this.value = !1
                }
                execute(e={}) {
                    const t = this.editor
                      , r = t.model
                      , i = t.plugins.get("ImageUtils");
                    r.change(l => {
                        const d = e.value
                          , {setImageSizes: h=!0} = e;
                        let m = i.getClosestSelectedImageElement(r.document.selection);
                        d && this.shouldConvertImageType(d, m) && (this.editor.execute(i.isBlockImage(m) ? "imageTypeInline" : "imageTypeBlock", {
                            setImageSizes: h
                        }),
                        m = i.getClosestSelectedImageElement(r.document.selection)),
                        !d || this._styles.get(d).isDefault ? l.removeAttribute("imageStyle", m) : l.setAttribute("imageStyle", d, m),
                        h && i.setImageNaturalSizeAttributes(m)
                    }
                    )
                }
                shouldConvertImageType(e, t) {
                    return !this._styles.get(e).modelElements.includes(t.name)
                }
            }
            const vu = {
                get inline() {
                    return {
                        name: "inline",
                        title: "In line",
                        icon: he.objectInline,
                        modelElements: ["imageInline"],
                        isDefault: !0
                    }
                },
                get alignLeft() {
                    return {
                        name: "alignLeft",
                        title: "Left aligned image",
                        icon: he.objectLeft,
                        modelElements: ["imageBlock", "imageInline"],
                        className: "image-style-align-left"
                    }
                },
                get alignBlockLeft() {
                    return {
                        name: "alignBlockLeft",
                        title: "Left aligned image",
                        icon: he.objectBlockLeft,
                        modelElements: ["imageBlock"],
                        className: "image-style-block-align-left"
                    }
                },
                get alignCenter() {
                    return {
                        name: "alignCenter",
                        title: "Centered image",
                        icon: he.objectCenter,
                        modelElements: ["imageBlock"],
                        className: "image-style-align-center"
                    }
                },
                get alignRight() {
                    return {
                        name: "alignRight",
                        title: "Right aligned image",
                        icon: he.objectRight,
                        modelElements: ["imageBlock", "imageInline"],
                        className: "image-style-align-right"
                    }
                },
                get alignBlockRight() {
                    return {
                        name: "alignBlockRight",
                        title: "Right aligned image",
                        icon: he.objectBlockRight,
                        modelElements: ["imageBlock"],
                        className: "image-style-block-align-right"
                    }
                },
                get block() {
                    return {
                        name: "block",
                        title: "Centered image",
                        icon: he.objectCenter,
                        modelElements: ["imageBlock"],
                        isDefault: !0
                    }
                },
                get side() {
                    return {
                        name: "side",
                        title: "Side image",
                        icon: he.objectRight,
                        modelElements: ["imageBlock"],
                        className: "image-style-side"
                    }
                }
            }
              , Ax = {
                full: he.objectFullWidth,
                left: he.objectBlockLeft,
                right: he.objectBlockRight,
                center: he.objectCenter,
                inlineLeft: he.objectLeft,
                inlineRight: he.objectRight,
                inline: he.objectInline
            }
              , vx = [{
                name: "imageStyle:wrapText",
                title: "Wrap text",
                defaultItem: "imageStyle:alignLeft",
                items: ["imageStyle:alignLeft", "imageStyle:alignRight"]
            }, {
                name: "imageStyle:breakText",
                title: "Break text",
                defaultItem: "imageStyle:block",
                items: ["imageStyle:alignBlockLeft", "imageStyle:block", "imageStyle:alignBlockRight"]
            }];
            function _x(s) {
                de("image-style-configuration-definition-invalid", s)
            }
            const hg = {
                normalizeStyles: function(s) {
                    return (s.configuredStyles.options || []).map(e => function(t) {
                        return t = typeof t == "string" ? vu[t] ? {
                            ...vu[t]
                        } : {
                            name: t
                        } : function(r, i) {
                            const l = {
                                ...i
                            };
                            for (const d in r)
                                Object.prototype.hasOwnProperty.call(i, d) || (l[d] = r[d]);
                            return l
                        }(vu[t.name], t),
                        typeof t.icon == "string" && (t.icon = Ax[t.icon] || t.icon),
                        t
                    }(e)).filter(e => function(t, {isBlockPluginLoaded: r, isInlinePluginLoaded: i}) {
                        const {modelElements: l, name: d} = t;
                        if (!(l && l.length && d))
                            return _x({
                                style: t
                            }),
                            !1;
                        {
                            const h = [r ? "imageBlock" : null, i ? "imageInline" : null];
                            if (!l.some(m => h.includes(m)))
                                return de("image-style-missing-dependency", {
                                    style: t,
                                    missingPlugins: l.map(m => m === "imageBlock" ? "ImageBlockEditing" : "ImageInlineEditing")
                                }),
                                !1
                        }
                        return !0
                    }(e, s))
                },
                getDefaultStylesConfiguration: function(s, e) {
                    return s && e ? {
                        options: ["inline", "alignLeft", "alignRight", "alignCenter", "alignBlockLeft", "alignBlockRight", "block", "side"]
                    } : s ? {
                        options: ["block", "side"]
                    } : e ? {
                        options: ["inline", "alignLeft", "alignRight"]
                    } : {}
                },
                getDefaultDropdownDefinitions: function(s) {
                    return s.has("ImageBlockEditing") && s.has("ImageInlineEditing") ? [...vx] : []
                },
                warnInvalidStyle: _x,
                DEFAULT_OPTIONS: vu,
                DEFAULT_ICONS: Ax,
                DEFAULT_DROPDOWN_DEFINITIONS: vx
            };
            function Cx(s, e) {
                for (const t of e)
                    if (t.name === s)
                        return t
            }
            class yx extends ie {
                constructor() {
                    super(...arguments),
                    C(this, "normalizedStyles")
                }
                static get pluginName() {
                    return "ImageStyleEditing"
                }
                static get requires() {
                    return [ho]
                }
                init() {
                    const {normalizeStyles: e, getDefaultStylesConfiguration: t} = hg
                      , r = this.editor
                      , i = r.plugins.has("ImageBlockEditing")
                      , l = r.plugins.has("ImageInlineEditing");
                    r.config.define("image.styles", t(i, l)),
                    this.normalizedStyles = e({
                        configuredStyles: r.config.get("image.styles"),
                        isBlockPluginLoaded: i,
                        isInlinePluginLoaded: l
                    }),
                    this._setupConversion(i, l),
                    this._setupPostFixer(),
                    r.commands.add("imageStyle", new zR(r,this.normalizedStyles))
                }
                _setupConversion(e, t) {
                    const r = this.editor
                      , i = r.model.schema
                      , l = (d = this.normalizedStyles,
                    (m, g, b) => {
                        if (!b.consumable.consume(g.item, m.name))
                            return;
                        const v = Cx(g.attributeNewValue, d)
                          , x = Cx(g.attributeOldValue, d)
                          , T = b.mapper.toViewElement(g.item)
                          , I = b.writer;
                        x && I.removeClass(x.className, T),
                        v && I.addClass(v.className, T)
                    }
                    );
                    var d;
                    const h = function(m) {
                        const g = {
                            imageInline: m.filter(b => !b.isDefault && b.modelElements.includes("imageInline")),
                            imageBlock: m.filter(b => !b.isDefault && b.modelElements.includes("imageBlock"))
                        };
                        return (b, v, x) => {
                            if (!v.modelRange)
                                return;
                            const T = v.viewItem
                              , I = zt(v.modelRange.getItems());
                            if (I && x.schema.checkAttribute(I, "imageStyle"))
                                for (const P of g[I.name])
                                    x.consumable.consume(T, {
                                        classes: P.className
                                    }) && x.writer.setAttribute("imageStyle", P.name, I)
                        }
                    }(this.normalizedStyles);
                    r.editing.downcastDispatcher.on("attribute:imageStyle", l),
                    r.data.downcastDispatcher.on("attribute:imageStyle", l),
                    e && (i.extend("imageBlock", {
                        allowAttributes: "imageStyle"
                    }),
                    r.data.upcastDispatcher.on("element:figure", h, {
                        priority: "low"
                    })),
                    t && (i.extend("imageInline", {
                        allowAttributes: "imageStyle"
                    }),
                    r.data.upcastDispatcher.on("element:img", h, {
                        priority: "low"
                    }))
                }
                _setupPostFixer() {
                    const e = this.editor
                      , t = e.model.document
                      , r = e.plugins.get(ho)
                      , i = new Map(this.normalizedStyles.map(l => [l.name, l]));
                    t.registerPostFixer(l => {
                        let d = !1;
                        for (const h of t.differ.getChanges())
                            if (h.type == "insert" || h.type == "attribute" && h.attributeKey == "imageStyle") {
                                let m = h.type == "insert" ? h.position.nodeAfter : h.range.start.nodeAfter;
                                if (m && m.is("element", "paragraph") && m.childCount > 0 && (m = m.getChild(0)),
                                !r.isImage(m))
                                    continue;
                                const g = m.getAttribute("imageStyle");
                                if (!g)
                                    continue;
                                const b = i.get(g);
                                b && b.modelElements.includes(m.name) || (l.removeAttribute("imageStyle", m),
                                d = !0)
                            }
                        return d
                    }
                    )
                }
            }
            var xx = u(6386)
              , OR = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(xx.A, OR),
            xx.A.locals;
            class RR extends ie {
                static get requires() {
                    return [yx]
                }
                static get pluginName() {
                    return "ImageStyleUI"
                }
                get localizedDefaultStylesTitles() {
                    const e = this.editor.t;
                    return {
                        "Wrap text": e("Wrap text"),
                        "Break text": e("Break text"),
                        "In line": e("In line"),
                        "Full size image": e("Full size image"),
                        "Side image": e("Side image"),
                        "Left aligned image": e("Left aligned image"),
                        "Centered image": e("Centered image"),
                        "Right aligned image": e("Right aligned image")
                    }
                }
                init() {
                    const e = this.editor.plugins
                      , t = this.editor.config.get("image.toolbar") || []
                      , r = Ex(e.get("ImageStyleEditing").normalizedStyles, this.localizedDefaultStylesTitles);
                    for (const l of r)
                        this._createButton(l);
                    const i = Ex([...t.filter(Le), ...hg.getDefaultDropdownDefinitions(e)], this.localizedDefaultStylesTitles);
                    for (const l of i)
                        this._createDropdown(l, r)
                }
                _createDropdown(e, t) {
                    const r = this.editor.ui.componentFactory;
                    r.add(e.name, i => {
                        let l;
                        const {defaultItem: d, items: h, title: m} = e
                          , g = h.filter(T => t.find( ({name: I}) => Sx(I) === T)).map(T => {
                            const I = r.create(T);
                            return T === d && (l = I),
                            I
                        }
                        );
                        h.length !== g.length && hg.warnInvalidStyle({
                            dropdown: e
                        });
                        const b = Nn(i, tu)
                          , v = b.buttonView
                          , x = v.arrowView;
                        return Yp(b, g, {
                            enableActiveItemFocusOnDropdownOpen: !0
                        }),
                        v.set({
                            label: Dx(m, l.label),
                            class: null,
                            tooltip: !0
                        }),
                        x.unbind("label"),
                        x.set({
                            label: m
                        }),
                        v.bind("icon").toMany(g, "isOn", (...T) => {
                            const I = T.findIndex(In);
                            return I < 0 ? l.icon : g[I].icon
                        }
                        ),
                        v.bind("label").toMany(g, "isOn", (...T) => {
                            const I = T.findIndex(In);
                            return Dx(m, I < 0 ? l.label : g[I].label)
                        }
                        ),
                        v.bind("isOn").toMany(g, "isOn", (...T) => T.some(In)),
                        v.bind("class").toMany(g, "isOn", (...T) => T.some(In) ? "ck-splitbutton_flatten" : void 0),
                        v.on("execute", () => {
                            g.some( ({isOn: T}) => T) ? b.isOpen = !b.isOpen : l.fire("execute")
                        }
                        ),
                        b.bind("isEnabled").toMany(g, "isEnabled", (...T) => T.some(In)),
                        this.listenTo(b, "execute", () => {
                            this.editor.editing.view.focus()
                        }
                        ),
                        b
                    }
                    )
                }
                _createButton(e) {
                    const t = e.name;
                    this.editor.ui.componentFactory.add(Sx(t), r => {
                        const i = this.editor.commands.get("imageStyle")
                          , l = new Te(r);
                        return l.set({
                            label: e.title,
                            icon: e.icon,
                            tooltip: !0,
                            isToggleable: !0
                        }),
                        l.bind("isEnabled").to(i, "isEnabled"),
                        l.bind("isOn").to(i, "value", d => d === t),
                        l.on("execute", this._executeCommand.bind(this, t)),
                        l
                    }
                    )
                }
                _executeCommand(e) {
                    this.editor.execute("imageStyle", {
                        value: e
                    }),
                    this.editor.editing.view.focus()
                }
            }
            function Ex(s, e) {
                for (const t of s)
                    e[t.title] && (t.title = e[t.title]);
                return s
            }
            function Sx(s) {
                return `imageStyle:${s}`
            }
            function Dx(s, e) {
                return (s ? s + ": " : "") + e
            }
            class FR extends ie {
                static get requires() {
                    return [yx, RR]
                }
                static get pluginName() {
                    return "ImageStyle"
                }
            }
            class VR extends ie {
                static get requires() {
                    return [hu, ho]
                }
                static get pluginName() {
                    return "ImageToolbar"
                }
                afterInit() {
                    const e = this.editor
                      , t = e.t
                      , r = e.plugins.get(hu)
                      , i = e.plugins.get("ImageUtils");
                    var l;
                    r.register("image", {
                        ariaLabel: t("Image toolbar"),
                        items: (l = e.config.get("image.toolbar") || [],
                        l.map(d => Le(d) ? d.name : d)),
                        getRelatedElement: d => i.getClosestSelectedImageWidget(d)
                    })
                }
            }
            class UR extends ie {
                static get requires() {
                    return [ug, ho]
                }
                static get pluginName() {
                    return "PictureEditing"
                }
                afterInit() {
                    const e = this.editor;
                    e.plugins.has("ImageBlockEditing") && e.model.schema.extend("imageBlock", {
                        allowAttributes: ["sources"]
                    }),
                    e.plugins.has("ImageInlineEditing") && e.model.schema.extend("imageInline", {
                        allowAttributes: ["sources"]
                    }),
                    this._setupConversion(),
                    this._setupImageUploadEditingIntegration()
                }
                _setupConversion() {
                    const e = this.editor
                      , t = e.conversion
                      , r = e.plugins.get("ImageUtils");
                    t.for("upcast").add(function(i) {
                        const l = ["srcset", "media", "type", "sizes"]
                          , d = (h, m, g) => {
                            const b = m.viewItem;
                            if (!g.consumable.test(b, {
                                name: !0
                            }))
                                return;
                            const v = new Map;
                            for (const I of b.getChildren())
                                if (I.is("element", "source")) {
                                    const P = {};
                                    for (const O of l)
                                        I.hasAttribute(O) && g.consumable.test(I, {
                                            attributes: O
                                        }) && (P[O] = I.getAttribute(O));
                                    Object.keys(P).length && v.set(I, P)
                                }
                            const x = i.findViewImgElement(b);
                            if (!x)
                                return;
                            let T = m.modelCursor.parent;
                            if (!T.is("element", "imageBlock")) {
                                const I = g.convertItem(x, m.modelCursor);
                                m.modelRange = I.modelRange,
                                m.modelCursor = I.modelCursor,
                                T = zt(I.modelRange.getItems())
                            }
                            g.consumable.consume(b, {
                                name: !0
                            });
                            for (const [I,P] of v)
                                g.consumable.consume(I, {
                                    attributes: Object.keys(P)
                                });
                            v.size && g.writer.setAttribute("sources", Array.from(v.values()), T),
                            g.convertChildren(b, T)
                        }
                        ;
                        return h => {
                            h.on("element:picture", d)
                        }
                    }(r)),
                    t.for("downcast").add(function(i) {
                        const l = (d, h, m) => {
                            if (!m.consumable.consume(h.item, d.name))
                                return;
                            const g = m.writer
                              , b = m.mapper.toViewElement(h.item)
                              , v = i.findViewImgElement(b)
                              , x = h.attributeNewValue;
                            if (x && x.length) {
                                const T = g.createContainerElement("picture", null, x.map(O => g.createEmptyElement("source", O)))
                                  , I = [];
                                let P = v.parent;
                                for (; P && P.is("attributeElement"); ) {
                                    const O = P.parent;
                                    g.unwrap(g.createRangeOn(v), P),
                                    I.unshift(P),
                                    P = O
                                }
                                g.insert(g.createPositionBefore(v), T),
                                g.move(g.createRangeOn(v), g.createPositionAt(T, "end"));
                                for (const O of I)
                                    g.wrap(g.createRangeOn(T), O)
                            } else if (v.parent.is("element", "picture")) {
                                const T = v.parent;
                                g.move(g.createRangeOn(v), g.createPositionBefore(T)),
                                g.remove(T)
                            }
                        }
                        ;
                        return d => {
                            d.on("attribute:sources:imageBlock", l),
                            d.on("attribute:sources:imageInline", l)
                        }
                    }(r))
                }
                _setupImageUploadEditingIntegration() {
                    const e = this.editor;
                    if (!e.plugins.has("ImageUploadEditing"))
                        return;
                    const t = e.plugins.get("ImageUploadEditing");
                    this.listenTo(t, "uploadComplete", (r, {imageElement: i, data: l}) => {
                        const d = l.sources;
                        d && e.model.change(h => {
                            h.setAttributes({
                                sources: d
                            }, i)
                        }
                        )
                    }
                    )
                }
            }
            class HR extends ie {
                static get pluginName() {
                    return "IndentEditing"
                }
                init() {
                    const e = this.editor;
                    e.commands.add("indent", new Av(e)),
                    e.commands.add("outdent", new Av(e))
                }
            }
            class WR extends ie {
                static get pluginName() {
                    return "IndentUI"
                }
                init() {
                    const e = this.editor
                      , t = e.locale
                      , r = e.t
                      , i = t.uiLanguageDirection == "ltr" ? he.indent : he.outdent
                      , l = t.uiLanguageDirection == "ltr" ? he.outdent : he.indent;
                    this._defineButton("indent", r("Increase indent"), i),
                    this._defineButton("outdent", r("Decrease indent"), l)
                }
                _defineButton(e, t, r) {
                    const i = this.editor;
                    i.ui.componentFactory.add(e, () => {
                        const l = this._createButton(Te, e, t, r);
                        return l.set({
                            tooltip: !0
                        }),
                        l
                    }
                    ),
                    i.ui.componentFactory.add("menuBar:" + e, () => this._createButton(Xt, e, t, r))
                }
                _createButton(e, t, r, i) {
                    const l = this.editor
                      , d = l.commands.get(t)
                      , h = new e(l.locale);
                    return h.set({
                        label: r,
                        icon: i
                    }),
                    h.bind("isEnabled").to(d, "isEnabled"),
                    this.listenTo(h, "execute", () => {
                        l.execute(t),
                        l.editing.view.focus()
                    }
                    ),
                    h
                }
            }
            class $R extends ie {
                static get pluginName() {
                    return "Indent"
                }
                static get requires() {
                    return [HR, WR]
                }
            }
            class qR {
                constructor() {
                    C(this, "_definitions", new Set)
                }
                get length() {
                    return this._definitions.size
                }
                add(e) {
                    Array.isArray(e) ? e.forEach(t => this._definitions.add(t)) : this._definitions.add(e)
                }
                getDispatcher() {
                    return e => {
                        e.on("attribute:linkHref", (t, r, i) => {
                            if (!i.consumable.test(r.item, "attribute:linkHref") || !r.item.is("selection") && !i.schema.isInline(r.item))
                                return;
                            const l = i.writer
                              , d = l.document.selection;
                            for (const h of this._definitions) {
                                const m = l.createAttributeElement("a", h.attributes, {
                                    priority: 5
                                });
                                h.classes && l.addClass(h.classes, m);
                                for (const g in h.styles)
                                    l.setStyle(g, h.styles[g], m);
                                l.setCustomProperty("link", !0, m),
                                h.callback(r.attributeNewValue) ? r.item.is("selection") ? l.wrap(d.getFirstRange(), m) : l.wrap(i.mapper.toViewRange(r.range), m) : l.unwrap(i.mapper.toViewRange(r.range), m)
                            }
                        }
                        , {
                            priority: "high"
                        })
                    }
                }
                getDispatcherForLinkedImage() {
                    return e => {
                        e.on("attribute:linkHref:imageBlock", (t, r, {writer: i, mapper: l}) => {
                            const d = l.toViewElement(r.item)
                              , h = Array.from(d.getChildren()).find(m => m.is("element", "a"));
                            for (const m of this._definitions) {
                                const g = Ir(m.attributes);
                                if (m.callback(r.attributeNewValue)) {
                                    for (const [b,v] of g)
                                        b === "class" ? i.addClass(v, h) : i.setAttribute(b, v, h);
                                    m.classes && i.addClass(m.classes, h);
                                    for (const b in m.styles)
                                        i.setStyle(b, m.styles[b], h)
                                } else {
                                    for (const [b,v] of g)
                                        b === "class" ? i.removeClass(v, h) : i.removeAttribute(b, h);
                                    m.classes && i.removeClass(m.classes, h);
                                    for (const b in m.styles)
                                        i.removeStyle(b, h)
                                }
                            }
                        }
                        )
                    }
                }
            }
            const GR = function(s, e, t) {
                var r = s.length;
                return t = t === void 0 ? r : t,
                !e && t >= r ? s : Iv(s, e, t)
            };
            var KR = RegExp("[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\ufe0e\\ufe0f]");
            const Tx = function(s) {
                return KR.test(s)
            }
              , YR = function(s) {
                return s.split("")
            };
            var Ix = "\\ud800-\\udfff"
              , QR = "[" + Ix + "]"
              , mg = "[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]"
              , pg = "\\ud83c[\\udffb-\\udfff]"
              , Mx = "[^" + Ix + "]"
              , Bx = "(?:\\ud83c[\\udde6-\\uddff]){2}"
              , Nx = "[\\ud800-\\udbff][\\udc00-\\udfff]"
              , Px = "(?:" + mg + "|" + pg + ")?"
              , jx = "[\\ufe0e\\ufe0f]?"
              , ZR = jx + Px + ("(?:\\u200d(?:" + [Mx, Bx, Nx].join("|") + ")" + jx + Px + ")*")
              , JR = "(?:" + [Mx + mg + "?", mg, Bx, Nx, QR].join("|") + ")"
              , XR = RegExp(pg + "(?=" + pg + ")|" + JR + ZR, "g");
            const eF = function(s) {
                return s.match(XR) || []
            }
              , tF = function(s) {
                return Tx(s) ? eF(s) : YR(s)
            }
              , oF = function(s) {
                return function(e) {
                    e = dp(e);
                    var t = Tx(e) ? tF(e) : void 0
                      , r = t ? t[0] : e.charAt(0)
                      , i = t ? GR(t, 1).join("") : e.slice(1);
                    return r[s]() + i
                }
            }("toUpperCase")
              , rF = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g
              , nF = /^[\S]+@((?![-_])(?:[-\w\u00a1-\uffff]{0,63}[^-_]\.))+(?:[a-z\u00a1-\uffff]{2,})$/i
              , iF = /^((\w+:(\/{2,})?)|(\W))/i
              , sF = ["https?", "ftps?", "mailto"]
              , _u = "Ctrl+K";
            function Lx(s, {writer: e}) {
                const t = e.createAttributeElement("a", {
                    href: s
                }, {
                    priority: 5
                });
                return e.setCustomProperty("link", !0, t),
                t
            }
            function zx(s, e=sF) {
                const t = String(s)
                  , r = e.join("|");
                return function(i, l) {
                    return !!i.replace(rF, "").match(l)
                }(t, new RegExp(`${"^(?:(?:<protocols>):|[^a-z]|[a-z+.-]+(?:[^a-z+.:-]|$))".replace("<protocols>", r)}`,"i")) ? t : "#"
            }
            function gg(s, e) {
                return !!s && e.checkAttribute(s.name, "linkHref")
            }
            function fg(s, e) {
                const t = (r = s,
                nF.test(r) ? "mailto:" : e);
                var r;
                const i = !!t && !Ox(s);
                return s && i ? t + s : s
            }
            function Ox(s) {
                return iF.test(s)
            }
            function Rx(s) {
                window.open(s, "_blank", "noopener")
            }
            class aF extends _e {
                constructor() {
                    super(...arguments),
                    C(this, "manualDecorators", new dr),
                    C(this, "automaticDecorators", new qR)
                }
                restoreManualDecoratorStates() {
                    for (const e of this.manualDecorators)
                        e.value = this._getDecoratorStateFromModel(e.id)
                }
                refresh() {
                    const e = this.editor.model
                      , t = e.document.selection
                      , r = t.getSelectedElement() || zt(t.getSelectedBlocks());
                    gg(r, e.schema) ? (this.value = r.getAttribute("linkHref"),
                    this.isEnabled = e.schema.checkAttribute(r, "linkHref")) : (this.value = t.getAttribute("linkHref"),
                    this.isEnabled = e.schema.checkAttributeInSelection(t, "linkHref"));
                    for (const i of this.manualDecorators)
                        i.value = this._getDecoratorStateFromModel(i.id)
                }
                execute(e, t={}) {
                    const r = this.editor.model
                      , i = r.document.selection
                      , l = []
                      , d = [];
                    for (const h in t)
                        t[h] ? l.push(h) : d.push(h);
                    r.change(h => {
                        if (i.isCollapsed) {
                            const m = i.getFirstPosition();
                            if (i.hasAttribute("linkHref")) {
                                const g = Fx(i);
                                let b = cu(m, "linkHref", i.getAttribute("linkHref"), r);
                                i.getAttribute("linkHref") === g && (b = this._updateLinkContent(r, h, b, e)),
                                h.setAttribute("linkHref", e, b),
                                l.forEach(v => {
                                    h.setAttribute(v, !0, b)
                                }
                                ),
                                d.forEach(v => {
                                    h.removeAttribute(v, b)
                                }
                                ),
                                h.setSelection(h.createPositionAfter(b.end.nodeBefore))
                            } else if (e !== "") {
                                const g = Ir(i.getAttributes());
                                g.set("linkHref", e),
                                l.forEach(v => {
                                    g.set(v, !0)
                                }
                                );
                                const {end: b} = r.insertContent(h.createText(e, g), m);
                                h.setSelection(b)
                            }
                            ["linkHref", ...l, ...d].forEach(g => {
                                h.removeSelectionAttribute(g)
                            }
                            )
                        } else {
                            const m = r.schema.getValidRanges(i.getRanges(), "linkHref")
                              , g = [];
                            for (const v of i.getSelectedBlocks())
                                r.schema.checkAttribute(v, "linkHref") && g.push(h.createRangeOn(v));
                            const b = g.slice();
                            for (const v of m)
                                this._isRangeToUpdate(v, g) && b.push(v);
                            for (const v of b) {
                                let x = v;
                                if (b.length === 1) {
                                    const T = Fx(i);
                                    i.getAttribute("linkHref") === T && (x = this._updateLinkContent(r, h, v, e),
                                    h.setSelection(h.createSelection(x)))
                                }
                                h.setAttribute("linkHref", e, x),
                                l.forEach(T => {
                                    h.setAttribute(T, !0, x)
                                }
                                ),
                                d.forEach(T => {
                                    h.removeAttribute(T, x)
                                }
                                )
                            }
                        }
                    }
                    )
                }
                _getDecoratorStateFromModel(e) {
                    const t = this.editor.model
                      , r = t.document.selection
                      , i = r.getSelectedElement();
                    return gg(i, t.schema) ? i.getAttribute(e) : r.getAttribute(e)
                }
                _isRangeToUpdate(e, t) {
                    for (const r of t)
                        if (r.containsRange(e))
                            return !1;
                    return !0
                }
                _updateLinkContent(e, t, r, i) {
                    const l = t.createText(i, {
                        linkHref: i
                    });
                    return e.insertContent(l, r)
                }
            }
            function Fx(s) {
                if (s.isCollapsed) {
                    const e = s.getFirstPosition();
                    return e.textNode && e.textNode.data
                }
                {
                    const e = Array.from(s.getFirstRange().getItems());
                    if (e.length > 1)
                        return null;
                    const t = e[0];
                    return t.is("$text") || t.is("$textProxy") ? t.data : null
                }
            }
            class lF extends _e {
                refresh() {
                    const e = this.editor.model
                      , t = e.document.selection
                      , r = t.getSelectedElement();
                    gg(r, e.schema) ? this.isEnabled = e.schema.checkAttribute(r, "linkHref") : this.isEnabled = e.schema.checkAttributeInSelection(t, "linkHref")
                }
                execute() {
                    const e = this.editor
                      , t = this.editor.model
                      , r = t.document.selection
                      , i = e.commands.get("link");
                    t.change(l => {
                        const d = r.isCollapsed ? [cu(r.getFirstPosition(), "linkHref", r.getAttribute("linkHref"), t)] : t.schema.getValidRanges(r.getRanges(), "linkHref");
                        for (const h of d)
                            if (l.removeAttribute("linkHref", h),
                            i)
                                for (const m of i.manualDecorators)
                                    l.removeAttribute(m.id, h)
                    }
                    )
                }
            }
            class cF extends ye() {
                constructor({id: e, label: t, attributes: r, classes: i, styles: l, defaultValue: d}) {
                    super(),
                    C(this, "id"),
                    C(this, "defaultValue"),
                    C(this, "label"),
                    C(this, "attributes"),
                    C(this, "classes"),
                    C(this, "styles"),
                    this.id = e,
                    this.set("value", void 0),
                    this.defaultValue = d,
                    this.label = t,
                    this.attributes = r,
                    this.classes = i,
                    this.styles = l
                }
                _createPattern() {
                    return {
                        attributes: this.attributes,
                        classes: this.classes,
                        styles: this.styles
                    }
                }
            }
            var Vx = u(7719)
              , dF = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(Vx.A, dF),
            Vx.A.locals;
            const Ux = "automatic"
              , uF = /^(https?:)?\/\//;
            class Hx extends ie {
                static get pluginName() {
                    return "LinkEditing"
                }
                static get requires() {
                    return [Oy, My, Ko]
                }
                constructor(e) {
                    super(e),
                    e.config.define("link", {
                        allowCreatingEmptyLinks: !1,
                        addTargetToExternalLinks: !1
                    })
                }
                init() {
                    const e = this.editor
                      , t = this.editor.config.get("link.allowedProtocols");
                    e.model.schema.extend("$text", {
                        allowAttributes: "linkHref"
                    }),
                    e.conversion.for("dataDowncast").attributeToElement({
                        model: "linkHref",
                        view: Lx
                    }),
                    e.conversion.for("editingDowncast").attributeToElement({
                        model: "linkHref",
                        view: (i, l) => Lx(zx(i, t), l)
                    }),
                    e.conversion.for("upcast").elementToAttribute({
                        view: {
                            name: "a",
                            attributes: {
                                href: !0
                            }
                        },
                        model: {
                            key: "linkHref",
                            value: i => i.getAttribute("href")
                        }
                    }),
                    e.commands.add("link", new aF(e)),
                    e.commands.add("unlink", new lF(e));
                    const r = function(i, l) {
                        const d = {
                            "Open in a new tab": i("Open in a new tab"),
                            Downloadable: i("Downloadable")
                        };
                        return l.forEach(h => ("label"in h && d[h.label] && (h.label = d[h.label]),
                        h)),
                        l
                    }(e.t, function(i) {
                        const l = [];
                        if (i)
                            for (const [d,h] of Object.entries(i)) {
                                const m = Object.assign({}, h, {
                                    id: `link${oF(d)}`
                                });
                                l.push(m)
                            }
                        return l
                    }(e.config.get("link.decorators")));
                    this._enableAutomaticDecorators(r.filter(i => i.mode === Ux)),
                    this._enableManualDecorators(r.filter(i => i.mode === "manual")),
                    e.plugins.get(Oy).registerAttribute("linkHref"),
                    function(i, l, d, h) {
                        const m = i.editing.view
                          , g = new Set;
                        m.document.registerPostFixer(b => {
                            const v = i.model.document.selection;
                            let x = !1;
                            if (v.hasAttribute(l)) {
                                const T = cu(v.getFirstPosition(), l, v.getAttribute(l), i.model)
                                  , I = i.editing.mapper.toViewRange(T);
                                for (const P of I.getItems())
                                    P.is("element", d) && !P.hasClass(h) && (b.addClass(h, P),
                                    g.add(P),
                                    x = !0)
                            }
                            return x
                        }
                        ),
                        i.conversion.for("editingDowncast").add(b => {
                            function v() {
                                m.change(x => {
                                    for (const T of g.values())
                                        x.removeClass(h, T),
                                        g.delete(T)
                                }
                                )
                            }
                            b.on("insert", v, {
                                priority: "highest"
                            }),
                            b.on("remove", v, {
                                priority: "highest"
                            }),
                            b.on("attribute", v, {
                                priority: "highest"
                            }),
                            b.on("selection", v, {
                                priority: "highest"
                            })
                        }
                        )
                    }(e, "linkHref", "a", "ck-link_selected"),
                    this._enableLinkOpen(),
                    this._enableSelectionAttributesFixer(),
                    this._enableClipboardIntegration()
                }
                _enableAutomaticDecorators(e) {
                    const t = this.editor
                      , r = t.commands.get("link").automaticDecorators;
                    t.config.get("link.addTargetToExternalLinks") && r.add({
                        id: "linkIsExternal",
                        mode: Ux,
                        callback: i => !!i && uF.test(i),
                        attributes: {
                            target: "_blank",
                            rel: "noopener noreferrer"
                        }
                    }),
                    r.add(e),
                    r.length && t.conversion.for("downcast").add(r.getDispatcher())
                }
                _enableManualDecorators(e) {
                    if (!e.length)
                        return;
                    const t = this.editor
                      , r = t.commands.get("link").manualDecorators;
                    e.forEach(i => {
                        t.model.schema.extend("$text", {
                            allowAttributes: i.id
                        });
                        const l = new cF(i);
                        r.add(l),
                        t.conversion.for("downcast").attributeToElement({
                            model: l.id,
                            view: (d, {writer: h, schema: m}, {item: g}) => {
                                if ((g.is("selection") || m.isInline(g)) && d) {
                                    const b = h.createAttributeElement("a", l.attributes, {
                                        priority: 5
                                    });
                                    l.classes && h.addClass(l.classes, b);
                                    for (const v in l.styles)
                                        h.setStyle(v, l.styles[v], b);
                                    return h.setCustomProperty("link", !0, b),
                                    b
                                }
                            }
                        }),
                        t.conversion.for("upcast").elementToAttribute({
                            view: {
                                name: "a",
                                ...l._createPattern()
                            },
                            model: {
                                key: l.id
                            }
                        })
                    }
                    )
                }
                _enableLinkOpen() {
                    const e = this.editor
                      , t = e.editing.view.document;
                    this.listenTo(t, "click", (r, i) => {
                        if (!(E.isMac ? i.domEvent.metaKey : i.domEvent.ctrlKey))
                            return;
                        let l = i.domTarget;
                        if (l.tagName.toLowerCase() != "a" && (l = l.closest("a")),
                        !l)
                            return;
                        const d = l.getAttribute("href");
                        d && (r.stop(),
                        i.preventDefault(),
                        Rx(d))
                    }
                    , {
                        context: "$capture"
                    }),
                    this.listenTo(t, "keydown", (r, i) => {
                        const l = e.commands.get("link").value;
                        l && i.keyCode === Me.enter && i.altKey && (r.stop(),
                        Rx(l))
                    }
                    )
                }
                _enableSelectionAttributesFixer() {
                    const e = this.editor.model
                      , t = e.document.selection;
                    this.listenTo(t, "change:attribute", (r, {attributeKeys: i}) => {
                        i.includes("linkHref") && !t.hasAttribute("linkHref") && e.change(l => {
                            var d;
                            (function(h, m) {
                                h.removeSelectionAttribute("linkHref");
                                for (const g of m)
                                    h.removeSelectionAttribute(g)
                            }
                            )(l, (d = e.schema,
                            d.getDefinition("$text").allowAttributes.filter(h => h.startsWith("link"))))
                        }
                        )
                    }
                    )
                }
                _enableClipboardIntegration() {
                    const e = this.editor
                      , t = e.model
                      , r = this.editor.config.get("link.defaultProtocol");
                    r && this.listenTo(e.plugins.get("ClipboardPipeline"), "contentInsertion", (i, l) => {
                        t.change(d => {
                            const h = d.createRangeIn(l.content);
                            for (const m of h.getItems())
                                if (m.hasAttribute("linkHref")) {
                                    const g = fg(m.getAttribute("linkHref"), r);
                                    d.setAttribute("linkHref", g, m)
                                }
                        }
                        )
                    }
                    )
                }
            }
            var Wx = u(3817)
              , hF = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(Wx.A, hF),
            Wx.A.locals;
            class mF extends pe {
                constructor(e, t, r) {
                    super(e),
                    C(this, "focusTracker", new Jt),
                    C(this, "keystrokes", new lo),
                    C(this, "urlInputView"),
                    C(this, "saveButtonView"),
                    C(this, "cancelButtonView"),
                    C(this, "_manualDecoratorSwitches"),
                    C(this, "children"),
                    C(this, "_validators"),
                    C(this, "_focusables", new ur),
                    C(this, "_focusCycler");
                    const i = e.t;
                    this._validators = r,
                    this.urlInputView = this._createUrlInput(),
                    this.saveButtonView = this._createButton(i("Save"), he.check, "ck-button-save"),
                    this.saveButtonView.type = "submit",
                    this.cancelButtonView = this._createButton(i("Cancel"), he.cancel, "ck-button-cancel", "cancel"),
                    this._manualDecoratorSwitches = this._createManualDecoratorSwitches(t),
                    this.children = this._createFormChildren(t.manualDecorators),
                    this._focusCycler = new Jr({
                        focusables: this._focusables,
                        focusTracker: this.focusTracker,
                        keystrokeHandler: this.keystrokes,
                        actions: {
                            focusPrevious: "shift + tab",
                            focusNext: "tab"
                        }
                    });
                    const l = ["ck", "ck-link-form", "ck-responsive-form"];
                    t.manualDecorators.length && l.push("ck-link-form_layout-vertical", "ck-vertical-form"),
                    this.setTemplate({
                        tag: "form",
                        attributes: {
                            class: l,
                            tabindex: "-1"
                        },
                        children: this.children
                    })
                }
                getDecoratorSwitchesState() {
                    return Array.from(this._manualDecoratorSwitches).reduce( (e, t) => (e[t.name] = t.isOn,
                    e), {})
                }
                render() {
                    super.render(),
                    Td({
                        view: this
                    }),
                    [this.urlInputView, ...this._manualDecoratorSwitches, this.saveButtonView, this.cancelButtonView].forEach(e => {
                        this._focusables.add(e),
                        this.focusTracker.add(e.element)
                    }
                    ),
                    this.keystrokes.listenTo(this.element)
                }
                destroy() {
                    super.destroy(),
                    this.focusTracker.destroy(),
                    this.keystrokes.destroy()
                }
                focus() {
                    this._focusCycler.focusFirst()
                }
                isValid() {
                    this.resetFormStatus();
                    for (const e of this._validators) {
                        const t = e(this);
                        if (t)
                            return this.urlInputView.errorText = t,
                            !1
                    }
                    return !0
                }
                resetFormStatus() {
                    this.urlInputView.errorText = null
                }
                _createUrlInput() {
                    const e = this.locale.t
                      , t = new Wp(this.locale,Qp);
                    return t.fieldView.inputMode = "url",
                    t.label = e("Link URL"),
                    t
                }
                _createButton(e, t, r, i) {
                    const l = new Te(this.locale);
                    return l.set({
                        label: e,
                        icon: t,
                        tooltip: !0
                    }),
                    l.extendTemplate({
                        attributes: {
                            class: r
                        }
                    }),
                    i && l.delegate("execute").to(this, i),
                    l
                }
                _createManualDecoratorSwitches(e) {
                    const t = this.createCollection();
                    for (const r of e.manualDecorators) {
                        const i = new Jd(this.locale);
                        i.set({
                            name: r.id,
                            label: r.label,
                            withText: !0
                        }),
                        i.bind("isOn").toMany([r, e], "value", (l, d) => d === void 0 && l === void 0 ? !!r.defaultValue : !!l),
                        i.on("execute", () => {
                            r.set("value", !i.isOn)
                        }
                        ),
                        t.add(i)
                    }
                    return t
                }
                _createFormChildren(e) {
                    const t = this.createCollection();
                    if (t.add(this.urlInputView),
                    e.length) {
                        const r = new pe;
                        r.setTemplate({
                            tag: "ul",
                            children: this._manualDecoratorSwitches.map(i => ({
                                tag: "li",
                                children: [i],
                                attributes: {
                                    class: ["ck", "ck-list__item"]
                                }
                            })),
                            attributes: {
                                class: ["ck", "ck-reset", "ck-list"]
                            }
                        }),
                        t.add(r)
                    }
                    return t.add(this.saveButtonView),
                    t.add(this.cancelButtonView),
                    t
                }
                get url() {
                    const {element: e} = this.urlInputView.fieldView;
                    return e ? e.value.trim() : null
                }
            }
            var $x = u(8762)
              , pF = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()($x.A, pF),
            $x.A.locals;
            class gF extends pe {
                constructor(e, t={}) {
                    super(e),
                    C(this, "focusTracker", new Jt),
                    C(this, "keystrokes", new lo),
                    C(this, "previewButtonView"),
                    C(this, "unlinkButtonView"),
                    C(this, "editButtonView"),
                    C(this, "_focusables", new ur),
                    C(this, "_focusCycler"),
                    C(this, "_linkConfig");
                    const r = e.t;
                    this.previewButtonView = this._createPreviewButton(),
                    this.unlinkButtonView = this._createButton(r("Unlink"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184zm4.919 10.562-1.414 1.414a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.061-1.06l1.414 1.414 1.414-1.415a.75.75 0 0 1 1.061 1.061l-1.414 1.414 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414z"/></svg>', "unlink"),
                    this.editButtonView = this._createButton(r("Edit link"), he.pencil, "edit"),
                    this.set("href", void 0),
                    this._linkConfig = t,
                    this._focusCycler = new Jr({
                        focusables: this._focusables,
                        focusTracker: this.focusTracker,
                        keystrokeHandler: this.keystrokes,
                        actions: {
                            focusPrevious: "shift + tab",
                            focusNext: "tab"
                        }
                    }),
                    this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck", "ck-link-actions", "ck-responsive-form"],
                            tabindex: "-1"
                        },
                        children: [this.previewButtonView, this.editButtonView, this.unlinkButtonView]
                    })
                }
                render() {
                    super.render(),
                    [this.previewButtonView, this.editButtonView, this.unlinkButtonView].forEach(e => {
                        this._focusables.add(e),
                        this.focusTracker.add(e.element)
                    }
                    ),
                    this.keystrokes.listenTo(this.element)
                }
                destroy() {
                    super.destroy(),
                    this.focusTracker.destroy(),
                    this.keystrokes.destroy()
                }
                focus() {
                    this._focusCycler.focusFirst()
                }
                _createButton(e, t, r) {
                    const i = new Te(this.locale);
                    return i.set({
                        label: e,
                        icon: t,
                        tooltip: !0
                    }),
                    i.delegate("execute").to(this, r),
                    i
                }
                _createPreviewButton() {
                    const e = new Te(this.locale)
                      , t = this.bindTemplate
                      , r = this.t;
                    return e.set({
                        withText: !0,
                        tooltip: r("Open link in new tab")
                    }),
                    e.extendTemplate({
                        attributes: {
                            class: ["ck", "ck-link-actions__preview"],
                            href: t.to("href", i => i && zx(i, this._linkConfig.allowedProtocols)),
                            target: "_blank",
                            rel: "noopener noreferrer"
                        }
                    }),
                    e.bind("label").to(this, "href", i => i || r("This link has no URL")),
                    e.bind("isEnabled").to(this, "href", i => !!i),
                    e.template.tag = "a",
                    e.template.eventListeners = {},
                    e
                }
            }
            const Lr = "link-ui";
            class fF extends ie {
                constructor() {
                    super(...arguments),
                    C(this, "actionsView", null),
                    C(this, "formView", null),
                    C(this, "_balloon")
                }
                static get requires() {
                    return [nu]
                }
                static get pluginName() {
                    return "LinkUI"
                }
                init() {
                    const e = this.editor
                      , t = this.editor.t;
                    e.editing.view.addObserver(rj),
                    this._balloon = e.plugins.get(nu),
                    this._createToolbarLinkButton(),
                    this._enableBalloonActivators(),
                    e.conversion.for("editingDowncast").markerToHighlight({
                        model: Lr,
                        view: {
                            classes: ["ck-fake-link-selection"]
                        }
                    }),
                    e.conversion.for("editingDowncast").markerToElement({
                        model: Lr,
                        view: {
                            name: "span",
                            classes: ["ck-fake-link-selection", "ck-fake-link-selection_collapsed"]
                        }
                    }),
                    e.accessibility.addKeystrokeInfos({
                        keystrokes: [{
                            label: t("Create link"),
                            keystroke: _u
                        }, {
                            label: t("Move out of a link"),
                            keystroke: [["arrowleft", "arrowleft"], ["arrowright", "arrowright"]]
                        }]
                    })
                }
                destroy() {
                    super.destroy(),
                    this.formView && this.formView.destroy(),
                    this.actionsView && this.actionsView.destroy()
                }
                _createViews() {
                    this.actionsView = this._createActionsView(),
                    this.formView = this._createFormView(),
                    this._enableUserBalloonInteractions()
                }
                _createActionsView() {
                    const e = this.editor
                      , t = new gF(e.locale,e.config.get("link"))
                      , r = e.commands.get("link")
                      , i = e.commands.get("unlink");
                    return t.bind("href").to(r, "value"),
                    t.editButtonView.bind("isEnabled").to(r),
                    t.unlinkButtonView.bind("isEnabled").to(i),
                    this.listenTo(t, "edit", () => {
                        this._addFormView()
                    }
                    ),
                    this.listenTo(t, "unlink", () => {
                        e.execute("unlink"),
                        this._hideUI()
                    }
                    ),
                    t.keystrokes.set("Esc", (l, d) => {
                        this._hideUI(),
                        d()
                    }
                    ),
                    t.keystrokes.set(_u, (l, d) => {
                        this._addFormView(),
                        d()
                    }
                    ),
                    t
                }
                _createFormView() {
                    const e = this.editor
                      , t = e.commands.get("link")
                      , r = e.config.get("link.defaultProtocol")
                      , i = new (ip(mF))(e.locale,t,function(l) {
                        const d = l.t
                          , h = l.config.get("link.allowCreatingEmptyLinks");
                        return [m => {
                            if (!h && !m.url.length)
                                return d("Link URL must not be empty.")
                        }
                        ]
                    }(e));
                    return i.urlInputView.fieldView.bind("value").to(t, "value"),
                    i.urlInputView.bind("isEnabled").to(t, "isEnabled"),
                    i.saveButtonView.bind("isEnabled").to(t, "isEnabled"),
                    this.listenTo(i, "submit", () => {
                        if (i.isValid()) {
                            const {value: l} = i.urlInputView.fieldView.element
                              , d = fg(l, r);
                            e.execute("link", d, i.getDecoratorSwitchesState()),
                            this._closeFormView()
                        }
                    }
                    ),
                    this.listenTo(i.urlInputView, "change:errorText", () => {
                        e.ui.update()
                    }
                    ),
                    this.listenTo(i, "cancel", () => {
                        this._closeFormView()
                    }
                    ),
                    i.keystrokes.set("Esc", (l, d) => {
                        this._closeFormView(),
                        d()
                    }
                    ),
                    i
                }
                _createToolbarLinkButton() {
                    const e = this.editor
                      , t = e.commands.get("link");
                    e.ui.componentFactory.add("link", () => {
                        const r = this._createButton(Te);
                        return r.set({
                            tooltip: !0,
                            isToggleable: !0
                        }),
                        r.bind("isOn").to(t, "value", i => !!i),
                        r
                    }
                    ),
                    e.ui.componentFactory.add("menuBar:link", () => this._createButton(Xt))
                }
                _createButton(e) {
                    const t = this.editor
                      , r = t.locale
                      , i = t.commands.get("link")
                      , l = new e(t.locale)
                      , d = r.t;
                    return l.set({
                        label: d("Link"),
                        icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184z"/></svg>',
                        keystroke: _u
                    }),
                    l.bind("isEnabled").to(i, "isEnabled"),
                    this.listenTo(l, "execute", () => this._showUI(!0)),
                    l
                }
                _enableBalloonActivators() {
                    const e = this.editor
                      , t = e.editing.view.document;
                    this.listenTo(t, "click", () => {
                        this._getSelectedLinkElement() && this._showUI()
                    }
                    ),
                    e.keystrokes.set(_u, (r, i) => {
                        i(),
                        e.commands.get("link").isEnabled && this._showUI(!0)
                    }
                    )
                }
                _enableUserBalloonInteractions() {
                    this.editor.keystrokes.set("Tab", (e, t) => {
                        this._areActionsVisible && !this.actionsView.focusTracker.isFocused && (this.actionsView.focus(),
                        t())
                    }
                    , {
                        priority: "high"
                    }),
                    this.editor.keystrokes.set("Esc", (e, t) => {
                        this._isUIVisible && (this._hideUI(),
                        t())
                    }
                    ),
                    Dd({
                        emitter: this.formView,
                        activator: () => this._isUIInPanel,
                        contextElements: () => [this._balloon.view.element],
                        callback: () => this._hideUI()
                    })
                }
                _addActionsView() {
                    this.actionsView || this._createViews(),
                    this._areActionsInPanel || this._balloon.add({
                        view: this.actionsView,
                        position: this._getBalloonPositionData()
                    })
                }
                _addFormView() {
                    if (this.formView || this._createViews(),
                    this._isFormInPanel)
                        return;
                    const e = this.editor.commands.get("link");
                    this.formView.disableCssTransitions(),
                    this.formView.resetFormStatus(),
                    this._balloon.add({
                        view: this.formView,
                        position: this._getBalloonPositionData()
                    }),
                    this.formView.urlInputView.fieldView.value = e.value || "",
                    this._balloon.visibleView === this.formView && this.formView.urlInputView.fieldView.select(),
                    this.formView.enableCssTransitions()
                }
                _closeFormView() {
                    const e = this.editor.commands.get("link");
                    e.restoreManualDecoratorStates(),
                    e.value !== void 0 ? this._removeFormView() : this._hideUI()
                }
                _removeFormView() {
                    this._isFormInPanel && (this.formView.saveButtonView.focus(),
                    this.formView.urlInputView.fieldView.reset(),
                    this._balloon.remove(this.formView),
                    this.editor.editing.view.focus(),
                    this._hideFakeVisualSelection())
                }
                _showUI(e=!1) {
                    this.formView || this._createViews(),
                    this._getSelectedLinkElement() ? (this._areActionsVisible ? this._addFormView() : this._addActionsView(),
                    e && this._balloon.showStack("main")) : (this._showFakeVisualSelection(),
                    this._addActionsView(),
                    e && this._balloon.showStack("main"),
                    this._addFormView()),
                    this._startUpdatingUI()
                }
                _hideUI() {
                    if (!this._isUIInPanel)
                        return;
                    const e = this.editor;
                    this.stopListening(e.ui, "update"),
                    this.stopListening(this._balloon, "change:visibleView"),
                    e.editing.view.focus(),
                    this._removeFormView(),
                    this._balloon.remove(this.actionsView),
                    this._hideFakeVisualSelection()
                }
                _startUpdatingUI() {
                    const e = this.editor
                      , t = e.editing.view.document;
                    let r = this._getSelectedLinkElement()
                      , i = d();
                    const l = () => {
                        const h = this._getSelectedLinkElement()
                          , m = d();
                        r && !h || !r && m !== i ? this._hideUI() : this._isUIVisible && this._balloon.updatePosition(this._getBalloonPositionData()),
                        r = h,
                        i = m
                    }
                    ;
                    function d() {
                        return t.selection.focus.getAncestors().reverse().find(h => h.is("element"))
                    }
                    this.listenTo(e.ui, "update", l),
                    this.listenTo(this._balloon, "change:visibleView", l)
                }
                get _isFormInPanel() {
                    return !!this.formView && this._balloon.hasView(this.formView)
                }
                get _areActionsInPanel() {
                    return !!this.actionsView && this._balloon.hasView(this.actionsView)
                }
                get _areActionsVisible() {
                    return !!this.actionsView && this._balloon.visibleView === this.actionsView
                }
                get _isUIInPanel() {
                    return this._isFormInPanel || this._areActionsInPanel
                }
                get _isUIVisible() {
                    const e = this._balloon.visibleView;
                    return !!this.formView && e == this.formView || this._areActionsVisible
                }
                _getBalloonPositionData() {
                    const e = this.editor.editing.view
                      , t = this.editor.model
                      , r = e.document;
                    let i;
                    if (t.markers.has(Lr)) {
                        const l = Array.from(this.editor.editing.mapper.markerNameToElements(Lr))
                          , d = e.createRange(e.createPositionBefore(l[0]), e.createPositionAfter(l[l.length - 1]));
                        i = e.domConverter.viewRangeToDom(d)
                    } else
                        i = () => {
                            const l = this._getSelectedLinkElement();
                            return l ? e.domConverter.mapViewToDom(l) : e.domConverter.viewRangeToDom(r.selection.getFirstRange())
                        }
                        ;
                    return {
                        target: i
                    }
                }
                _getSelectedLinkElement() {
                    const e = this.editor.editing.view
                      , t = e.document.selection
                      , r = t.getSelectedElement();
                    if (t.isCollapsed || r && At(r))
                        return kg(t.getFirstPosition());
                    {
                        const i = t.getFirstRange().getTrimmed()
                          , l = kg(i.start)
                          , d = kg(i.end);
                        return l && l == d && e.createRangeIn(l).getTrimmed().isEqual(i) ? l : null
                    }
                }
                _showFakeVisualSelection() {
                    const e = this.editor.model;
                    e.change(t => {
                        const r = e.document.selection.getFirstRange();
                        if (e.markers.has(Lr))
                            t.updateMarker(Lr, {
                                range: r
                            });
                        else if (r.start.isAtEnd) {
                            const i = r.start.getLastMatchingPosition( ({item: l}) => !e.schema.isContent(l), {
                                boundaries: r
                            });
                            t.addMarker(Lr, {
                                usingOperation: !1,
                                affectsData: !1,
                                range: t.createRange(i, r.end)
                            })
                        } else
                            t.addMarker(Lr, {
                                usingOperation: !1,
                                affectsData: !1,
                                range: r
                            })
                    }
                    )
                }
                _hideFakeVisualSelection() {
                    const e = this.editor.model;
                    e.markers.has(Lr) && e.change(t => {
                        t.removeMarker(Lr)
                    }
                    )
                }
            }
            function kg(s) {
                return s.getAncestors().find(e => {
                    return (t = e).is("attributeElement") && !!t.getCustomProperty("link");
                    var t
                }
                ) || null
            }
            const qx = new RegExp("(^|\\s)(((?:(?:(?:https?|ftp):)?\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(((?!www\\.)|(www\\.))(?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.)+(?:[a-z\\u00a1-\\uffff]{2,63})))(?::\\d{2,5})?(?:[/?#]\\S*)?)|((www.|(\\S+@))((?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.))+(?:[a-z\\u00a1-\\uffff]{2,63})))$","i");
            class kF extends ie {
                static get requires() {
                    return [Xr, Hx]
                }
                static get pluginName() {
                    return "AutoLink"
                }
                init() {
                    const e = this.editor.model.document.selection;
                    e.on("change:range", () => {
                        this.isEnabled = !e.anchor.parent.is("element", "codeBlock")
                    }
                    ),
                    this._enableTypingHandling()
                }
                afterInit() {
                    this._enableEnterHandling(),
                    this._enableShiftEnterHandling(),
                    this._enablePasteLinking()
                }
                _expandLinkRange(e, t) {
                    return t.textNode && t.textNode.hasAttribute("linkHref") ? cu(t, "linkHref", t.textNode.getAttribute("linkHref"), e) : null
                }
                _selectEntireLinks(e, t) {
                    const r = this.editor.model
                      , i = r.document.selection
                      , l = i.getFirstPosition()
                      , d = i.getLastPosition();
                    let h = t.getJoined(this._expandLinkRange(r, l) || t);
                    h && (h = h.getJoined(this._expandLinkRange(r, d) || t)),
                    h && (h.start.isBefore(l) || h.end.isAfter(d)) && e.setSelection(h)
                }
                _enablePasteLinking() {
                    const e = this.editor
                      , t = e.model
                      , r = t.document.selection
                      , i = e.plugins.get("ClipboardPipeline")
                      , l = e.commands.get("link");
                    i.on("inputTransformation", (d, h) => {
                        if (!this.isEnabled || !l.isEnabled || r.isCollapsed || h.method !== "paste" || r.rangeCount > 1)
                            return;
                        const m = r.getFirstRange()
                          , g = h.dataTransfer.getData("text/plain");
                        if (!g)
                            return;
                        const b = g.match(qx);
                        b && b[2] === g && (t.change(v => {
                            this._selectEntireLinks(v, m),
                            l.execute(g)
                        }
                        ),
                        d.stop())
                    }
                    , {
                        priority: "high"
                    })
                }
                _enableTypingHandling() {
                    const e = this.editor
                      , t = new zy(e.model,r => {
                        if (!function(l) {
                            return l.length > 4 && l[l.length - 1] === " " && l[l.length - 2] !== " "
                        }(r))
                            return;
                        const i = Gx(r.substr(0, r.length - 1));
                        return i ? {
                            url: i
                        } : void 0
                    }
                    );
                    t.on("matched:data", (r, i) => {
                        const {batch: l, range: d, url: h} = i;
                        if (!l.isTyping)
                            return;
                        const m = d.end.getShiftedBy(-1)
                          , g = m.getShiftedBy(-h.length)
                          , b = e.model.createRange(g, m);
                        this._applyAutoLink(h, b)
                    }
                    ),
                    t.bind("isEnabled").to(this)
                }
                _enableEnterHandling() {
                    const e = this.editor
                      , t = e.model
                      , r = e.commands.get("enter");
                    r && r.on("execute", () => {
                        const i = t.document.selection.getFirstPosition();
                        if (!i.parent.previousSibling)
                            return;
                        const l = t.createRangeIn(i.parent.previousSibling);
                        this._checkAndApplyAutoLinkOnRange(l)
                    }
                    )
                }
                _enableShiftEnterHandling() {
                    const e = this.editor
                      , t = e.model
                      , r = e.commands.get("shiftEnter");
                    r && r.on("execute", () => {
                        const i = t.document.selection.getFirstPosition()
                          , l = t.createRange(t.createPositionAt(i.parent, 0), i.getShiftedBy(-1));
                        this._checkAndApplyAutoLinkOnRange(l)
                    }
                    )
                }
                _checkAndApplyAutoLinkOnRange(e) {
                    const t = this.editor.model
                      , {text: r, range: i} = Ly(e, t)
                      , l = Gx(r);
                    if (l) {
                        const d = t.createRange(i.end.getShiftedBy(-l.length), i.end);
                        this._applyAutoLink(l, d)
                    }
                }
                _applyAutoLink(e, t) {
                    const r = this.editor.model
                      , i = fg(e, this.editor.config.get("link.defaultProtocol"));
                    this.isEnabled && function(l, d) {
                        return d.schema.checkAttributeInSelection(d.createSelection(l), "linkHref")
                    }(t, r) && Ox(i) && !function(l) {
                        const d = l.start.nodeAfter;
                        return !!d && d.hasAttribute("linkHref")
                    }(t) && this._persistAutoLink(i, t)
                }
                _persistAutoLink(e, t) {
                    const r = this.editor.model
                      , i = this.editor.plugins.get("Delete");
                    r.enqueueChange(l => {
                        l.setAttribute("linkHref", e, t),
                        r.enqueueChange( () => {
                            i.requestUndoOnBackspace()
                        }
                        )
                    }
                    )
                }
            }
            function Gx(s) {
                const e = qx.exec(s);
                return e ? e[2] : null
            }
            class bF extends ie {
                static get requires() {
                    return [Hx, fF, kF]
                }
                static get pluginName() {
                    return "Link"
                }
            }
            var Kx = u(4808)
              , wF = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(Kx.A, wF),
            Kx.A.locals;
            class Qo {
                constructor(e, t) {
                    C(this, "_startElement"),
                    C(this, "_referenceIndent"),
                    C(this, "_isForward"),
                    C(this, "_includeSelf"),
                    C(this, "_sameAttributes"),
                    C(this, "_sameIndent"),
                    C(this, "_lowerIndent"),
                    C(this, "_higherIndent"),
                    this._startElement = e,
                    this._referenceIndent = e.getAttribute("listIndent"),
                    this._isForward = t.direction == "forward",
                    this._includeSelf = !!t.includeSelf,
                    this._sameAttributes = Ze(t.sameAttributes || []),
                    this._sameIndent = !!t.sameIndent,
                    this._lowerIndent = !!t.lowerIndent,
                    this._higherIndent = !!t.higherIndent
                }
                static first(e, t) {
                    return zt(new this(e,t)[Symbol.iterator]())
                }
                *[Symbol.iterator]() {
                    const e = [];
                    for (const {node: t} of Ol(this._getStartNode(), this._isForward ? "forward" : "backward")) {
                        const r = t.getAttribute("listIndent");
                        if (r < this._referenceIndent) {
                            if (!this._lowerIndent)
                                break;
                            this._referenceIndent = r
                        } else if (r > this._referenceIndent) {
                            if (!this._higherIndent)
                                continue;
                            if (!this._isForward) {
                                e.push(t);
                                continue
                            }
                        } else {
                            if (!this._sameIndent) {
                                if (this._higherIndent) {
                                    e.length && (yield*e,
                                    e.length = 0);
                                    break
                                }
                                continue
                            }
                            if (this._sameAttributes.some(i => t.getAttribute(i) !== this._startElement.getAttribute(i)))
                                break
                        }
                        e.length && (yield*e,
                        e.length = 0),
                        yield t
                    }
                }
                _getStartNode() {
                    return this._includeSelf ? this._startElement : this._isForward ? this._startElement.nextSibling : this._startElement.previousSibling
                }
            }
            function *Ol(s, e="forward") {
                const t = e == "forward"
                  , r = [];
                let i = null;
                for (; Bt(s); ) {
                    let l = null;
                    if (i) {
                        const d = s.getAttribute("listIndent")
                          , h = i.getAttribute("listIndent");
                        d > h ? r[h] = i : d < h ? (l = r[d],
                        r.length = d) : l = i
                    }
                    yield{
                        node: s,
                        previous: i,
                        previousNodeInList: l
                    },
                    i = s,
                    s = t ? s.nextSibling : s.previousSibling
                }
            }
            class AF {
                constructor(e) {
                    C(this, "_listHead"),
                    this._listHead = e
                }
                [Symbol.iterator]() {
                    return Ol(this._listHead, "forward")
                }
            }
            class Ws {
                static next() {
                    return H()
                }
            }
            function Bt(s) {
                return !!s && s.is("element") && s.hasAttribute("listItemId")
            }
            function bg(s, e={}) {
                return [...zn(s, {
                    ...e,
                    direction: "backward"
                }), ...zn(s, {
                    ...e,
                    direction: "forward"
                })]
            }
            function zn(s, e={}) {
                const t = e.direction == "forward"
                  , r = Array.from(new Qo(s,{
                    ...e,
                    includeSelf: t,
                    sameIndent: !0,
                    sameAttributes: "listItemId"
                }));
                return t ? r : r.reverse()
            }
            function Yx(s, e) {
                const t = new Qo(s,{
                    sameIndent: !0,
                    sameAttributes: "listType",
                    ...e
                })
                  , r = new Qo(s,{
                    sameIndent: !0,
                    sameAttributes: "listType",
                    includeSelf: !0,
                    direction: "forward",
                    ...e
                });
                return [...Array.from(t).reverse(), ...r]
            }
            function zi(s) {
                return !Qo.first(s, {
                    sameIndent: !0,
                    sameAttributes: "listItemId"
                })
            }
            function Qx(s) {
                return !Qo.first(s, {
                    direction: "forward",
                    sameIndent: !0,
                    sameAttributes: "listItemId"
                })
            }
            function Rl(s, e={}) {
                s = Ze(s);
                const t = e.withNested !== !1
                  , r = new Set;
                for (const i of s)
                    for (const l of bg(i, {
                        higherIndent: t
                    }))
                        r.add(l);
                return Oi(r)
            }
            function vF(s) {
                s = Ze(s);
                const e = new Set;
                for (const t of s)
                    for (const r of Yx(t))
                        e.add(r);
                return Oi(e)
            }
            function wg(s, e) {
                const t = zn(s, {
                    direction: "forward"
                })
                  , r = Ws.next();
                for (const i of t)
                    e.setAttribute("listItemId", r, i);
                return t
            }
            function Ag(s, e, t) {
                const r = {};
                for (const [l,d] of e.getAttributes())
                    l.startsWith("list") && (r[l] = d);
                const i = zn(s, {
                    direction: "forward"
                });
                for (const l of i)
                    t.setAttributes(r, l);
                return i
            }
            function vg(s, e, {expand: t, indentBy: r=1}={}) {
                s = Ze(s);
                const i = t ? Rl(s) : s;
                for (const l of i) {
                    const d = l.getAttribute("listIndent") + r;
                    d < 0 ? Cu(l, e) : e.setAttribute("listIndent", d, l)
                }
                return i
            }
            function Cu(s, e) {
                s = Ze(s);
                for (const t of s)
                    t.is("element", "listItem") && e.rename(t, "paragraph");
                for (const t of s)
                    for (const r of t.getAttributeKeys())
                        r.startsWith("list") && e.removeAttribute(r, t);
                return s
            }
            function Fl(s) {
                if (!s.length)
                    return !1;
                const e = s[0].getAttribute("listItemId");
                return !!e && !s.some(t => t.getAttribute("listItemId") != e)
            }
            function Oi(s) {
                return Array.from(s).filter(e => e.root.rootName !== "$graveyard").sort( (e, t) => e.index - t.index)
            }
            function Vl(s) {
                const e = s.document.selection.getSelectedElement();
                return e && s.schema.isObject(e) && s.schema.isBlock(e) ? e : null
            }
            function _g(s, e) {
                return e.checkChild(s.parent, "listItem") && e.checkChild(s, "$text") && !e.isObject(s)
            }
            function _F(s) {
                return s == "numbered" || s == "customNumbered"
            }
            function CF(s, e, t) {
                return zn(e, {
                    direction: "forward"
                }).pop().index > s.index ? Ag(s, e, t) : []
            }
            class Zx extends _e {
                constructor(e, t) {
                    super(e),
                    C(this, "_direction"),
                    this._direction = t
                }
                refresh() {
                    this.isEnabled = this._checkEnabled()
                }
                execute() {
                    const e = this.editor.model
                      , t = Jx(e.document.selection);
                    e.change(r => {
                        const i = [];
                        Fl(t) && !zi(t[0]) ? (this._direction == "forward" && i.push(...vg(t, r)),
                        i.push(...wg(t[0], r))) : this._direction == "forward" ? i.push(...vg(t, r, {
                            expand: !0
                        })) : i.push(...function(l, d) {
                            const h = Rl(l = Ze(l))
                              , m = new Set
                              , g = Math.min(...h.map(v => v.getAttribute("listIndent")))
                              , b = new Map;
                            for (const v of h)
                                b.set(v, Qo.first(v, {
                                    lowerIndent: !0
                                }));
                            for (const v of h) {
                                if (m.has(v))
                                    continue;
                                m.add(v);
                                const x = v.getAttribute("listIndent") - 1;
                                if (x < 0)
                                    Cu(v, d);
                                else {
                                    if (v.getAttribute("listIndent") == g) {
                                        const T = CF(v, b.get(v), d);
                                        for (const I of T)
                                            m.add(I);
                                        if (T.length)
                                            continue
                                    }
                                    d.setAttribute("listIndent", x, v)
                                }
                            }
                            return Oi(m)
                        }(t, r));
                        for (const l of i) {
                            if (!l.hasAttribute("listType"))
                                continue;
                            const d = Qo.first(l, {
                                sameIndent: !0
                            });
                            d && r.setAttribute("listType", d.getAttribute("listType"), l)
                        }
                        this._fireAfterExecute(i)
                    }
                    )
                }
                _fireAfterExecute(e) {
                    this.fire("afterExecute", Oi(new Set(e)))
                }
                _checkEnabled() {
                    let e = Jx(this.editor.model.document.selection)
                      , t = e[0];
                    if (!t)
                        return !1;
                    if (this._direction == "backward" || Fl(e) && !zi(e[0]))
                        return !0;
                    e = Rl(e),
                    t = e[0];
                    const r = Qo.first(t, {
                        sameIndent: !0
                    });
                    return !!r && r.getAttribute("listType") == t.getAttribute("listType")
                }
            }
            function Jx(s) {
                const e = Array.from(s.getSelectedBlocks())
                  , t = e.findIndex(r => !Bt(r));
                return t != -1 && (e.length = t),
                e
            }
            class yu extends _e {
                constructor(e, t, r={}) {
                    super(e),
                    C(this, "type"),
                    C(this, "_listWalkerOptions"),
                    this.type = t,
                    this._listWalkerOptions = r.multiLevel ? {
                        higherIndent: !0,
                        lowerIndent: !0,
                        sameAttributes: []
                    } : void 0
                }
                refresh() {
                    this.value = this._getValue(),
                    this.isEnabled = this._checkEnabled()
                }
                execute(e={}) {
                    const t = this.editor.model
                      , r = t.document
                      , i = Vl(t)
                      , l = Array.from(r.selection.getSelectedBlocks()).filter(h => t.schema.checkAttribute(h, "listType") || _g(h, t.schema))
                      , d = e.forceValue !== void 0 ? !e.forceValue : this.value;
                    t.change(h => {
                        if (d) {
                            const m = l[l.length - 1]
                              , g = zn(m, {
                                direction: "forward"
                            })
                              , b = [];
                            g.length > 1 && b.push(...wg(g[1], h)),
                            b.push(...Cu(l, h)),
                            b.push(...function(v, x) {
                                const T = [];
                                let I = Number.POSITIVE_INFINITY;
                                for (const {node: P} of Ol(v.nextSibling, "forward")) {
                                    const O = P.getAttribute("listIndent");
                                    if (O == 0)
                                        break;
                                    O < I && (I = O);
                                    const F = O - I;
                                    x.setAttribute("listIndent", F, P),
                                    T.push(P)
                                }
                                return T
                            }(m, h)),
                            this._fireAfterExecute(b)
                        } else if ((i || r.selection.isCollapsed) && Bt(l[0])) {
                            const m = Yx(i || l[0], this._listWalkerOptions);
                            for (const g of m)
                                h.setAttributes({
                                    ...e.additionalAttributes,
                                    listType: this.type
                                }, g);
                            this._fireAfterExecute(m)
                        } else {
                            const m = [];
                            for (const g of l)
                                if (g.hasAttribute("listType"))
                                    for (const b of Rl(g, {
                                        withNested: !1
                                    }))
                                        b.getAttribute("listType") != this.type && (h.setAttributes({
                                            ...e.additionalAttributes,
                                            listType: this.type
                                        }, b),
                                        m.push(b));
                                else
                                    !g.is("element", "listItem") && _g(g, t.schema) && h.rename(g, "listItem"),
                                    h.setAttributes({
                                        ...e.additionalAttributes,
                                        listIndent: 0,
                                        listItemId: Ws.next(),
                                        listType: this.type
                                    }, g),
                                    m.push(g);
                            this._fireAfterExecute(m)
                        }
                    }
                    )
                }
                _fireAfterExecute(e) {
                    this.fire("afterExecute", Oi(new Set(e)))
                }
                _getValue() {
                    const e = this.editor.model.document.selection
                      , t = Array.from(e.getSelectedBlocks());
                    if (!t.length)
                        return !1;
                    for (const r of t)
                        if (r.getAttribute("listType") != this.type)
                            return !1;
                    return !0
                }
                _checkEnabled() {
                    const e = this.editor.model
                      , t = e.schema
                      , r = e.document.selection
                      , i = Array.from(r.getSelectedBlocks());
                    if (!i.length)
                        return !1;
                    if (this.value)
                        return !0;
                    for (const l of i)
                        if (t.checkAttribute(l, "listType") || _g(l, t))
                            return !0;
                    return !1
                }
            }
            class Xx extends _e {
                constructor(e, t) {
                    super(e),
                    C(this, "_direction"),
                    this._direction = t
                }
                refresh() {
                    this.isEnabled = this._checkEnabled()
                }
                execute({shouldMergeOnBlocksContentLevel: e=!1}={}) {
                    const t = this.editor.model
                      , r = t.document.selection
                      , i = [];
                    t.change(l => {
                        const {firstElement: d, lastElement: h} = this._getMergeSubjectElements(r, e)
                          , m = d.getAttribute("listIndent") || 0
                          , g = h.getAttribute("listIndent")
                          , b = h.getAttribute("listItemId");
                        if (m != g) {
                            const x = (v = h,
                            Array.from(new Qo(v,{
                                direction: "forward",
                                higherIndent: !0
                            })));
                            i.push(...vg([h, ...x], l, {
                                indentBy: m - g,
                                expand: m < g
                            }))
                        }
                        var v;
                        if (e) {
                            let x = r;
                            r.isCollapsed && (x = l.createSelection(l.createRange(l.createPositionAt(d, "end"), l.createPositionAt(h, 0)))),
                            t.deleteContent(x, {
                                doNotResetEntireContent: r.isCollapsed
                            });
                            const T = x.getLastPosition().parent
                              , I = T.nextSibling;
                            i.push(T),
                            I && I !== h && I.getAttribute("listItemId") == b && i.push(...Ag(I, T, l))
                        } else
                            i.push(...Ag(h, d, l));
                        this._fireAfterExecute(i)
                    }
                    )
                }
                _fireAfterExecute(e) {
                    this.fire("afterExecute", Oi(new Set(e)))
                }
                _checkEnabled() {
                    const e = this.editor.model
                      , t = e.document.selection
                      , r = Vl(e);
                    if (t.isCollapsed || r) {
                        const i = r || t.getFirstPosition().parent;
                        if (!Bt(i))
                            return !1;
                        const l = this._direction == "backward" ? i.previousSibling : i.nextSibling;
                        if (!l || Fl([i, l]))
                            return !1
                    } else {
                        const i = t.getLastPosition()
                          , l = t.getFirstPosition();
                        if (i.parent === l.parent || !Bt(i.parent))
                            return !1
                    }
                    return !0
                }
                _getMergeSubjectElements(e, t) {
                    const r = Vl(this.editor.model);
                    let i, l;
                    if (e.isCollapsed || r) {
                        const d = r || e.getFirstPosition().parent
                          , h = zi(d);
                        this._direction == "backward" ? (l = d,
                        i = h && !t ? Qo.first(d, {
                            sameIndent: !0,
                            lowerIndent: !0
                        }) : d.previousSibling) : (i = d,
                        l = d.nextSibling)
                    } else
                        i = e.getFirstPosition().parent,
                        l = e.getLastPosition().parent;
                    return {
                        firstElement: i,
                        lastElement: l
                    }
                }
            }
            class e1 extends _e {
                constructor(e, t) {
                    super(e),
                    C(this, "_direction"),
                    this._direction = t
                }
                refresh() {
                    this.isEnabled = this._checkEnabled()
                }
                execute() {
                    this.editor.model.change(e => {
                        const t = wg(this._getStartBlock(), e);
                        this._fireAfterExecute(t)
                    }
                    )
                }
                _fireAfterExecute(e) {
                    this.fire("afterExecute", Oi(new Set(e)))
                }
                _checkEnabled() {
                    const e = this.editor.model.document.selection
                      , t = this._getStartBlock();
                    return e.isCollapsed && Bt(t) && !zi(t)
                }
                _getStartBlock() {
                    const e = this.editor.model.document.selection.getFirstPosition().parent;
                    return this._direction == "before" ? e : e.nextSibling
                }
            }
            class yF extends ie {
                static get pluginName() {
                    return "ListUtils"
                }
                expandListBlocksToCompleteList(e) {
                    return vF(e)
                }
                isFirstBlockOfListItem(e) {
                    return zi(e)
                }
                isListItemBlock(e) {
                    return Bt(e)
                }
                expandListBlocksToCompleteItems(e, t={}) {
                    return Rl(e, t)
                }
                isNumberedListType(e) {
                    return _F(e)
                }
            }
            function t1(s) {
                return s.is("element", "ol") || s.is("element", "ul")
            }
            function xu(s) {
                return s.is("element", "li")
            }
            function xF(s, e, t, r=r1(t, e)) {
                return s.createAttributeElement(o1(t), null, {
                    priority: 2 * e / 100 - 100,
                    id: r
                })
            }
            function EF(s, e, t) {
                return s.createAttributeElement("li", null, {
                    priority: (2 * e + 1) / 100 - 100,
                    id: t
                })
            }
            function o1(s) {
                return s == "numbered" || s == "customNumbered" ? "ol" : "ul"
            }
            function r1(s, e) {
                return `list-${s}-${e}`
            }
            function wr(s, e) {
                const t = s.nodeBefore;
                if (Bt(t)) {
                    let r = t;
                    for (const {node: i} of Ol(r, "backward"))
                        if (r = i,
                        e.has(r))
                            return;
                    e.set(t, r)
                } else {
                    const r = s.nodeAfter;
                    Bt(r) && e.set(r, r)
                }
            }
            function SF() {
                return (s, e, t) => {
                    const {writer: r, schema: i} = t;
                    if (!e.modelRange)
                        return;
                    const l = Array.from(e.modelRange.getItems({
                        shallow: !0
                    })).filter(v => i.checkAttribute(v, "listItemId"));
                    if (!l.length)
                        return;
                    const d = Ws.next()
                      , h = function(v) {
                        let x = 0
                          , T = v.parent;
                        for (; T; ) {
                            if (xu(T))
                                x++;
                            else {
                                const I = T.previousSibling;
                                I && xu(I) && x++
                            }
                            T = T.parent
                        }
                        return x
                    }(e.viewItem);
                    let m = e.viewItem.parent && e.viewItem.parent.is("element", "ol") ? "numbered" : "bulleted";
                    const g = l[0].getAttribute("listType");
                    g && (m = g);
                    const b = {
                        listItemId: d,
                        listIndent: h,
                        listType: m
                    };
                    for (const v of l)
                        v.hasAttribute("listItemId") || r.setAttributes(b, v);
                    l.length > 1 && l[1].getAttribute("listItemId") != b.listItemId && t.keepEmptyElement(l[0])
                }
            }
            function n1() {
                return (s, e, t) => {
                    if (!t.consumable.test(e.viewItem, {
                        name: !0
                    }))
                        return;
                    const r = new Zr(e.viewItem.document);
                    for (const i of Array.from(e.viewItem.getChildren()))
                        xu(i) || t1(i) || r.remove(i)
                }
            }
            function i1(s, e, t, {dataPipeline: r}={}) {
                const i = function(l) {
                    return (d, h) => {
                        const m = [];
                        for (const g of l)
                            d.hasAttribute(g) && m.push(`attribute:${g}`);
                        return !!m.every(g => h.test(d, g) !== !1) && (m.forEach(g => h.consume(d, g)),
                        !0)
                    }
                }(s);
                return (l, d, h) => {
                    const {writer: m, mapper: g, consumable: b} = h
                      , v = d.item;
                    if (!s.includes(d.attributeKey) || !i(v, b))
                        return;
                    const x = function(I, P, O) {
                        const F = O.createRangeOn(I);
                        return P.toViewRange(F).getTrimmed().end.nodeBefore
                    }(v, g, t);
                    a1(x, m, g),
                    function(I, P) {
                        let O = I.parent;
                        for (; O.is("attributeElement") && ["ul", "ol", "li"].includes(O.name); ) {
                            const F = O.parent;
                            P.unwrap(P.createRangeOn(I), O),
                            O = F
                        }
                    }(x, m);
                    const T = function(I, P, O, F, {dataPipeline: q}) {
                        let Q = F.createRangeOn(P);
                        if (!zi(I))
                            return Q;
                        for (const X of O) {
                            if (X.scope != "itemMarker")
                                continue;
                            const le = X.createElement(F, I, {
                                dataPipeline: q
                            });
                            if (!le || (F.setCustomProperty("listItemMarker", !0, le),
                            X.canInjectMarkerIntoElement && X.canInjectMarkerIntoElement(I) ? F.insert(F.createPositionAt(P, 0), le) : (F.insert(Q.start, le),
                            Q = F.createRange(F.createPositionBefore(le), F.createPositionAfter(P))),
                            !X.createWrapperElement || !X.canWrapElement))
                                continue;
                            const ge = X.createWrapperElement(F, I, {
                                dataPipeline: q
                            });
                            F.setCustomProperty("listItemWrapper", !0, ge),
                            X.canWrapElement(I) ? Q = F.wrap(Q, ge) : (Q = F.wrap(F.createRangeOn(le), ge),
                            Q = F.createRange(Q.start, F.createPositionAfter(P)))
                        }
                        return Q
                    }(v, x, e, m, {
                        dataPipeline: r
                    });
                    (function(I, P, O, F) {
                        if (!I.hasAttribute("listIndent"))
                            return;
                        const q = I.getAttribute("listIndent");
                        let Q = I;
                        for (let X = q; X >= 0; X--) {
                            const le = EF(F, X, Q.getAttribute("listItemId"))
                              , ge = xF(F, X, Q.getAttribute("listType"));
                            for (const ke of O)
                                ke.scope != "list" && ke.scope != "item" || !Q.hasAttribute(ke.attributeName) || ke.setAttributeOnDowncast(F, Q.getAttribute(ke.attributeName), ke.scope == "list" ? ge : le);
                            if (P = F.wrap(P, le),
                            P = F.wrap(P, ge),
                            X == 0 || (Q = Qo.first(Q, {
                                lowerIndent: !0
                            }),
                            !Q))
                                break
                        }
                    }
                    )(v, T, e, m)
                }
            }
            function s1(s, {dataPipeline: e}={}) {
                return (t, {writer: r}) => {
                    if (!l1(t, s))
                        return null;
                    if (!e)
                        return r.createContainerElement("span", {
                            class: "ck-list-bogus-paragraph"
                        });
                    const i = r.createContainerElement("p");
                    return r.setCustomProperty("dataPipeline:transparentRendering", !0, i),
                    i
                }
            }
            function a1(s, e, t) {
                for (; s.parent.is("attributeElement") && s.parent.getCustomProperty("listItemWrapper"); )
                    e.unwrap(e.createRangeOn(s), s.parent);
                const r = [];
                i(e.createPositionBefore(s).getWalker({
                    direction: "backward"
                })),
                i(e.createRangeIn(s).getWalker());
                for (const l of r)
                    e.remove(l);
                function i(l) {
                    for (const {item: d} of l) {
                        if (d.is("element") && t.toModelElement(d))
                            break;
                        d.is("element") && d.getCustomProperty("listItemMarker") && r.push(d)
                    }
                }
            }
            function l1(s, e, t=bg(s)) {
                if (!Bt(s))
                    return !1;
                for (const r of s.getAttributeKeys())
                    if (!r.startsWith("selection:") && !e.includes(r))
                        return !1;
                return t.length < 2
            }
            var c1 = u(1232)
              , DF = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(c1.A, DF),
            c1.A.locals;
            var d1 = u(6903)
              , TF = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(d1.A, TF),
            d1.A.locals;
            const Eu = ["listType", "listIndent", "listItemId"];
            class IF extends ie {
                constructor(e) {
                    super(e),
                    C(this, "_downcastStrategies", []),
                    e.config.define("list.multiBlock", !0)
                }
                static get pluginName() {
                    return "ListEditing"
                }
                static get requires() {
                    return [du, Xr, yF, Ko]
                }
                init() {
                    const e = this.editor
                      , t = e.model
                      , r = e.config.get("list.multiBlock");
                    if (e.plugins.has("LegacyListEditing"))
                        throw new U("list-feature-conflict",this,{
                            conflictPlugin: "LegacyListEditing"
                        });
                    t.schema.register("$listItem", {
                        allowAttributes: Eu
                    }),
                    r ? (t.schema.extend("$container", {
                        allowAttributesOf: "$listItem"
                    }),
                    t.schema.extend("$block", {
                        allowAttributesOf: "$listItem"
                    }),
                    t.schema.extend("$blockObject", {
                        allowAttributesOf: "$listItem"
                    })) : t.schema.register("listItem", {
                        inheritAllFrom: "$block",
                        allowAttributesOf: "$listItem"
                    });
                    for (const i of Eu)
                        t.schema.setAttributeProperties(i, {
                            copyOnReplace: !0
                        });
                    e.commands.add("numberedList", new yu(e,"numbered")),
                    e.commands.add("bulletedList", new yu(e,"bulleted")),
                    e.commands.add("customNumberedList", new yu(e,"customNumbered",{
                        multiLevel: !0
                    })),
                    e.commands.add("customBulletedList", new yu(e,"customBulleted",{
                        multiLevel: !0
                    })),
                    e.commands.add("indentList", new Zx(e,"forward")),
                    e.commands.add("outdentList", new Zx(e,"backward")),
                    e.commands.add("splitListItemBefore", new e1(e,"before")),
                    e.commands.add("splitListItemAfter", new e1(e,"after")),
                    r && (e.commands.add("mergeListItemBackward", new Xx(e,"backward")),
                    e.commands.add("mergeListItemForward", new Xx(e,"forward"))),
                    this._setupDeleteIntegration(),
                    this._setupEnterIntegration(),
                    this._setupTabIntegration(),
                    this._setupClipboardIntegration(),
                    this._setupAccessibilityIntegration()
                }
                afterInit() {
                    const e = this.editor.commands
                      , t = e.get("indent")
                      , r = e.get("outdent");
                    t && t.registerChildCommand(e.get("indentList"), {
                        priority: "high"
                    }),
                    r && r.registerChildCommand(e.get("outdentList"), {
                        priority: "lowest"
                    }),
                    this._setupModelPostFixing(),
                    this._setupConversion()
                }
                registerDowncastStrategy(e) {
                    this._downcastStrategies.push(e)
                }
                getListAttributeNames() {
                    return [...Eu, ...this._downcastStrategies.map(e => e.attributeName)]
                }
                _setupDeleteIntegration() {
                    const e = this.editor
                      , t = e.commands.get("mergeListItemBackward")
                      , r = e.commands.get("mergeListItemForward");
                    this.listenTo(e.editing.view.document, "delete", (i, l) => {
                        const d = e.model.document.selection;
                        Vl(e.model) || e.model.change( () => {
                            const h = d.getFirstPosition();
                            if (d.isCollapsed && l.direction == "backward") {
                                if (!h.isAtStart)
                                    return;
                                const m = h.parent;
                                if (!Bt(m))
                                    return;
                                if (Qo.first(m, {
                                    sameAttributes: "listType",
                                    sameIndent: !0
                                }) || m.getAttribute("listIndent") !== 0) {
                                    if (!t || !t.isEnabled)
                                        return;
                                    t.execute({
                                        shouldMergeOnBlocksContentLevel: u1(e.model, "backward")
                                    })
                                } else
                                    Qx(m) || e.execute("splitListItemAfter"),
                                    e.execute("outdentList");
                                l.preventDefault(),
                                i.stop()
                            } else {
                                if (d.isCollapsed && !d.getLastPosition().isAtEnd || !r || !r.isEnabled)
                                    return;
                                r.execute({
                                    shouldMergeOnBlocksContentLevel: u1(e.model, "forward")
                                }),
                                l.preventDefault(),
                                i.stop()
                            }
                        }
                        )
                    }
                    , {
                        context: "li"
                    })
                }
                _setupEnterIntegration() {
                    const e = this.editor
                      , t = e.model
                      , r = e.commands
                      , i = r.get("enter");
                    this.listenTo(e.editing.view.document, "enter", (l, d) => {
                        const h = t.document
                          , m = h.selection.getFirstPosition().parent;
                        if (h.selection.isCollapsed && Bt(m) && m.isEmpty && !d.isSoft) {
                            const g = zi(m)
                              , b = Qx(m);
                            g && b ? (e.execute("outdentList"),
                            d.preventDefault(),
                            l.stop()) : g && !b ? (e.execute("splitListItemAfter"),
                            d.preventDefault(),
                            l.stop()) : b && (e.execute("splitListItemBefore"),
                            d.preventDefault(),
                            l.stop())
                        }
                    }
                    , {
                        context: "li"
                    }),
                    this.listenTo(i, "afterExecute", () => {
                        const l = r.get("splitListItemBefore");
                        l.refresh(),
                        l.isEnabled && bg(e.model.document.selection.getLastPosition().parent).length === 2 && l.execute()
                    }
                    )
                }
                _setupTabIntegration() {
                    const e = this.editor;
                    this.listenTo(e.editing.view.document, "tab", (t, r) => {
                        const i = r.shiftKey ? "outdentList" : "indentList";
                        this.editor.commands.get(i).isEnabled && (e.execute(i),
                        r.stopPropagation(),
                        r.preventDefault(),
                        t.stop())
                    }
                    , {
                        context: "li"
                    })
                }
                _setupConversion() {
                    const e = this.editor
                      , t = e.model
                      , r = this.getListAttributeNames()
                      , i = e.config.get("list.multiBlock")
                      , l = i ? "paragraph" : "listItem";
                    e.conversion.for("upcast").elementToElement({
                        view: "li",
                        model: (g, {writer: b}) => b.createElement(l, {
                            listType: ""
                        })
                    }).elementToElement({
                        view: "p",
                        model: (g, {writer: b}) => g.parent && g.parent.is("element", "li") ? b.createElement(l, {
                            listType: ""
                        }) : null,
                        converterPriority: "high"
                    }).add(g => {
                        g.on("element:li", SF()),
                        g.on("element:ul", n1(), {
                            priority: "high"
                        }),
                        g.on("element:ol", n1(), {
                            priority: "high"
                        })
                    }
                    ),
                    i || e.conversion.for("downcast").elementToElement({
                        model: "listItem",
                        view: "p"
                    }),
                    e.conversion.for("editingDowncast").elementToElement({
                        model: l,
                        view: s1(r),
                        converterPriority: "high"
                    }).add(g => {
                        var b;
                        g.on("attribute", i1(r, this._downcastStrategies, t)),
                        g.on("remove", (b = t.schema,
                        (v, x, T) => {
                            const {writer: I, mapper: P} = T
                              , O = v.name.split(":")[1];
                            if (!b.checkAttribute(O, "listItemId"))
                                return;
                            const F = P.toViewPosition(x.position)
                              , q = x.position.getShiftedBy(x.length)
                              , Q = P.toViewPosition(q, {
                                isPhantom: !0
                            })
                              , X = I.createRange(F, Q).getTrimmed().end.nodeBefore;
                            X && a1(X, I, P)
                        }
                        ))
                    }
                    ),
                    e.conversion.for("dataDowncast").elementToElement({
                        model: l,
                        view: s1(r, {
                            dataPipeline: !0
                        }),
                        converterPriority: "high"
                    }).add(g => {
                        g.on("attribute", i1(r, this._downcastStrategies, t, {
                            dataPipeline: !0
                        }))
                    }
                    );
                    const d = (h = this._downcastStrategies,
                    m = e.editing.view,
                    (g, b) => {
                        if (b.modelPosition.offset > 0)
                            return;
                        const v = b.modelPosition.parent;
                        if (!Bt(v) || !h.some(O => O.scope == "itemMarker" && O.canInjectMarkerIntoElement && O.canInjectMarkerIntoElement(v)))
                            return;
                        const x = b.mapper.toViewElement(v)
                          , T = m.createRangeIn(x)
                          , I = T.getWalker();
                        let P = T.start;
                        for (const {item: O} of I) {
                            if (O.is("element") && b.mapper.toModelElement(O) || O.is("$textProxy"))
                                break;
                            O.is("element") && O.getCustomProperty("listItemMarker") && (P = m.createPositionAfter(O),
                            I.skip( ({previousPosition: F}) => !F.isEqual(P)))
                        }
                        b.viewPosition = P
                    }
                    );
                    var h, m;
                    e.editing.mapper.on("modelToViewPosition", d),
                    e.data.mapper.on("modelToViewPosition", d),
                    this.listenTo(t.document, "change:data", function(g, b, v, x) {
                        return () => {
                            const O = g.document.differ.getChanges()
                              , F = []
                              , q = new Map
                              , Q = new Set;
                            for (const X of O)
                                if (X.type == "insert" && X.name != "$text")
                                    wr(X.position, q),
                                    X.attributes.has("listItemId") ? Q.add(X.position.nodeAfter) : wr(X.position.getShiftedBy(X.length), q);
                                else if (X.type == "remove" && X.attributes.has("listItemId"))
                                    wr(X.position, q);
                                else if (X.type == "attribute") {
                                    const le = X.range.start.nodeAfter;
                                    v.includes(X.attributeKey) ? (wr(X.range.start, q),
                                    X.attributeNewValue === null ? (wr(X.range.start.getShiftedBy(1), q),
                                    I(le) && F.push(le)) : Q.add(le)) : Bt(le) && I(le) && F.push(le)
                                }
                            for (const X of q.values())
                                F.push(...T(X, Q));
                            for (const X of new Set(F))
                                b.reconvertItem(X)
                        }
                        ;
                        function T(O, F) {
                            const q = []
                              , Q = new Set
                              , X = [];
                            for (const {node: le, previous: ge} of Ol(O, "forward")) {
                                if (Q.has(le))
                                    continue;
                                const ke = le.getAttribute("listIndent");
                                ge && ke < ge.getAttribute("listIndent") && (X.length = ke + 1),
                                X[ke] = Object.fromEntries(Array.from(le.getAttributes()).filter( ([Nt]) => v.includes(Nt)));
                                const vt = zn(le, {
                                    direction: "forward"
                                });
                                for (const Nt of vt)
                                    Q.add(Nt),
                                    (I(Nt, vt) || P(Nt, X, F)) && q.push(Nt)
                            }
                            return q
                        }
                        function I(O, F) {
                            const q = b.mapper.toViewElement(O);
                            if (!q)
                                return !1;
                            if (x.fire("checkElement", {
                                modelElement: O,
                                viewElement: q
                            }))
                                return !0;
                            if (!O.is("element", "paragraph") && !O.is("element", "listItem"))
                                return !1;
                            const Q = l1(O, v, F);
                            return !(!Q || !q.is("element", "p")) || !(Q || !q.is("element", "span"))
                        }
                        function P(O, F, q) {
                            if (q.has(O))
                                return !1;
                            const Q = b.mapper.toViewElement(O);
                            let X = F.length - 1;
                            for (let le = Q.parent; !le.is("editableElement"); le = le.parent) {
                                const ge = xu(le)
                                  , ke = t1(le);
                                if (!ke && !ge)
                                    continue;
                                const vt = "checkAttributes:" + (ge ? "item" : "list");
                                if (x.fire(vt, {
                                    viewElement: le,
                                    modelAttributes: F[X]
                                }))
                                    break;
                                if (ke && (X--,
                                X < 0))
                                    return !1
                            }
                            return !0
                        }
                    }(t, e.editing, r, this), {
                        priority: "high"
                    }),
                    this.on("checkAttributes:item", (g, {viewElement: b, modelAttributes: v}) => {
                        b.id != v.listItemId && (g.return = !0,
                        g.stop())
                    }
                    ),
                    this.on("checkAttributes:list", (g, {viewElement: b, modelAttributes: v}) => {
                        b.name == o1(v.listType) && b.id == r1(v.listType, v.listIndent) || (g.return = !0,
                        g.stop())
                    }
                    )
                }
                _setupModelPostFixing() {
                    const e = this.editor.model
                      , t = this.getListAttributeNames();
                    e.document.registerPostFixer(r => function(i, l, d, h) {
                        const m = i.document.differ.getChanges()
                          , g = new Map
                          , b = h.editor.config.get("list.multiBlock");
                        let v = !1;
                        for (const T of m) {
                            if (T.type == "insert" && T.name != "$text") {
                                const I = T.position.nodeAfter;
                                if (!i.schema.checkAttribute(I, "listItemId"))
                                    for (const P of Array.from(I.getAttributeKeys()))
                                        d.includes(P) && (l.removeAttribute(P, I),
                                        v = !0);
                                wr(T.position, g),
                                T.attributes.has("listItemId") || wr(T.position.getShiftedBy(T.length), g);
                                for (const {item: P, previousPosition: O} of i.createRangeIn(I))
                                    Bt(P) && wr(O, g)
                            } else
                                T.type == "remove" ? wr(T.position, g) : T.type == "attribute" && d.includes(T.attributeKey) && (wr(T.range.start, g),
                                T.attributeNewValue === null && wr(T.range.start.getShiftedBy(1), g));
                            if (!b && T.type == "attribute" && Eu.includes(T.attributeKey)) {
                                const I = T.range.start.nodeAfter;
                                T.attributeNewValue === null && I && I.is("element", "listItem") ? (l.rename(I, "paragraph"),
                                v = !0) : T.attributeOldValue === null && I && I.is("element") && I.name != "listItem" && (l.rename(I, "listItem"),
                                v = !0)
                            }
                        }
                        const x = new Set;
                        for (const T of g.values())
                            v = h.fire("postFixer", {
                                listNodes: new AF(T),
                                listHead: T,
                                writer: l,
                                seenIds: x
                            }) || v;
                        return v
                    }(e, r, t, this)),
                    this.on("postFixer", (r, {listNodes: i, writer: l}) => {
                        r.return = function(d, h) {
                            let m = 0
                              , g = -1
                              , b = null
                              , v = !1;
                            for (const {node: x} of d) {
                                const T = x.getAttribute("listIndent");
                                if (T > m) {
                                    let I;
                                    b === null ? (b = T - m,
                                    I = m) : (b > T && (b = T),
                                    I = T - b),
                                    I > g + 1 && (I = g + 1),
                                    h.setAttribute("listIndent", I, x),
                                    v = !0,
                                    g = I
                                } else
                                    b = null,
                                    m = T + 1,
                                    g = T
                            }
                            return v
                        }(i, l) || r.return
                    }
                    , {
                        priority: "high"
                    }),
                    this.on("postFixer", (r, {listNodes: i, writer: l, seenIds: d}) => {
                        r.return = function(h, m, g) {
                            const b = new Set;
                            let v = !1;
                            for (const {node: x} of h) {
                                if (b.has(x))
                                    continue;
                                let T = x.getAttribute("listType")
                                  , I = x.getAttribute("listItemId");
                                if (m.has(I) && (I = Ws.next()),
                                m.add(I),
                                x.is("element", "listItem"))
                                    x.getAttribute("listItemId") != I && (g.setAttribute("listItemId", I, x),
                                    v = !0);
                                else
                                    for (const P of zn(x, {
                                        direction: "forward"
                                    }))
                                        b.add(P),
                                        P.getAttribute("listType") != T && (I = Ws.next(),
                                        T = P.getAttribute("listType")),
                                        P.getAttribute("listItemId") != I && (g.setAttribute("listItemId", I, P),
                                        v = !0)
                            }
                            return v
                        }(i, d, l) || r.return
                    }
                    , {
                        priority: "high"
                    })
                }
                _setupClipboardIntegration() {
                    const e = this.editor.model
                      , t = this.editor.plugins.get("ClipboardPipeline");
                    this.listenTo(e, "insertContent", function(r) {
                        return (i, [l,d]) => {
                            const h = l.is("documentFragment") ? Array.from(l.getChildren()) : [l];
                            if (!h.length)
                                return;
                            const m = (d ? r.createSelection(d) : r.document.selection).getFirstPosition();
                            let g;
                            if (Bt(m.parent))
                                g = m.parent;
                            else {
                                if (!Bt(m.nodeBefore))
                                    return;
                                g = m.nodeBefore
                            }
                            r.change(b => {
                                const v = g.getAttribute("listType")
                                  , x = g.getAttribute("listIndent")
                                  , T = h[0].getAttribute("listIndent") || 0
                                  , I = Math.max(x - T, 0);
                                for (const P of h) {
                                    const O = Bt(P);
                                    g.is("element", "listItem") && P.is("element", "paragraph") && b.rename(P, "listItem"),
                                    b.setAttributes({
                                        listIndent: (O ? P.getAttribute("listIndent") : 0) + I,
                                        listItemId: O ? P.getAttribute("listItemId") : Ws.next(),
                                        listType: v
                                    }, P)
                                }
                            }
                            )
                        }
                    }(e), {
                        priority: "high"
                    }),
                    this.listenTo(t, "outputTransformation", (r, i) => {
                        e.change(l => {
                            const d = Array.from(i.content.getChildren())
                              , h = d[d.length - 1];
                            if (d.length > 1 && h.is("element") && h.isEmpty && d.slice(0, -1).every(Bt) && l.remove(h),
                            i.method == "copy" || i.method == "cut") {
                                const m = Array.from(i.content.getChildren());
                                Fl(m) && Cu(m, l)
                            }
                        }
                        )
                    }
                    )
                }
                _setupAccessibilityIntegration() {
                    const e = this.editor
                      , t = e.t;
                    e.accessibility.addKeystrokeInfoGroup({
                        id: "list",
                        label: t("Keystrokes that can be used in a list"),
                        keystrokes: [{
                            label: t("Increase list item indent"),
                            keystroke: "Tab"
                        }, {
                            label: t("Decrease list item indent"),
                            keystroke: "Shift+Tab"
                        }]
                    })
                }
            }
            function u1(s, e) {
                const t = s.document.selection;
                if (!t.isCollapsed)
                    return !Vl(s);
                if (e === "forward")
                    return !0;
                const r = t.getFirstPosition().parent
                  , i = r.previousSibling;
                return !s.schema.isObject(i) && (!!i.isEmpty || Fl([r, i]))
            }
            function h1(s, e, t, r) {
                s.ui.componentFactory.add(e, () => {
                    const i = m1(Te, s, e, t, r);
                    return i.set({
                        tooltip: !0,
                        isToggleable: !0
                    }),
                    i
                }
                ),
                s.ui.componentFactory.add(`menuBar:${e}`, () => m1(Xt, s, e, t, r))
            }
            function m1(s, e, t, r, i) {
                const l = e.commands.get(t)
                  , d = new s(e.locale);
                return d.set({
                    label: r,
                    icon: i
                }),
                d.bind("isOn", "isEnabled").to(l, "value", "isEnabled"),
                d.on("execute", () => {
                    e.execute(t),
                    e.editing.view.focus()
                }
                ),
                d
            }
            class MF extends ie {
                static get pluginName() {
                    return "ListUI"
                }
                init() {
                    const e = this.editor.t;
                    this.editor.ui.componentFactory.has("numberedList") || h1(this.editor, "numberedList", e("Numbered List"), he.numberedList),
                    this.editor.ui.componentFactory.has("bulletedList") || h1(this.editor, "bulletedList", e("Bulleted List"), he.bulletedList)
                }
            }
            class BF extends ie {
                static get requires() {
                    return [IF, MF]
                }
                static get pluginName() {
                    return "List"
                }
            }
            const NF = [{
                listStyle: "disc",
                typeAttribute: "disc",
                listType: "bulleted"
            }, {
                listStyle: "circle",
                typeAttribute: "circle",
                listType: "bulleted"
            }, {
                listStyle: "square",
                typeAttribute: "square",
                listType: "bulleted"
            }, {
                listStyle: "decimal",
                typeAttribute: "1",
                listType: "numbered"
            }, {
                listStyle: "decimal-leading-zero",
                typeAttribute: null,
                listType: "numbered"
            }, {
                listStyle: "lower-roman",
                typeAttribute: "i",
                listType: "numbered"
            }, {
                listStyle: "upper-roman",
                typeAttribute: "I",
                listType: "numbered"
            }, {
                listStyle: "lower-alpha",
                typeAttribute: "a",
                listType: "numbered"
            }, {
                listStyle: "upper-alpha",
                typeAttribute: "A",
                listType: "numbered"
            }, {
                listStyle: "lower-latin",
                typeAttribute: "a",
                listType: "numbered"
            }, {
                listStyle: "upper-latin",
                typeAttribute: "A",
                listType: "numbered"
            }];
            for (const {listStyle: s, typeAttribute: e, listType: t} of NF)
                ;
            var p1 = u(9968)
              , PF = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(p1.A, PF),
            p1.A.locals;
            var g1 = u(7141)
              , jF = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(g1.A, jF),
            g1.A.locals;
            var f1 = u(8991)
              , LF = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(f1.A, LF),
            f1.A.locals;
            function k1(s, e) {
                const t = (r, i, l) => {
                    if (!l.consumable.consume(i.item, r.name))
                        return;
                    const d = i.attributeNewValue
                      , h = l.writer
                      , m = l.mapper.toViewElement(i.item)
                      , g = [...m.getChildren()].find(v => v.getCustomProperty("media-content"));
                    h.remove(g);
                    const b = s.getMediaViewElement(h, d, e);
                    h.insert(h.createPositionAt(m, 0), b)
                }
                ;
                return r => {
                    r.on("attribute:url:media", t)
                }
            }
            function b1(s, e, t, r) {
                return s.createContainerElement("figure", {
                    class: "media"
                }, [e.getMediaViewElement(s, t, r), s.createSlot()])
            }
            function w1(s) {
                const e = s.getSelectedElement();
                return e && e.is("element", "media") ? e : null
            }
            function A1(s, e, t, r) {
                s.change(i => {
                    const l = i.createElement("media", {
                        url: e
                    });
                    s.insertObject(l, t, null, {
                        setSelection: "on",
                        findOptimalPosition: r ? "auto" : void 0
                    })
                }
                )
            }
            class zF extends _e {
                refresh() {
                    const e = this.editor.model
                      , t = e.document.selection
                      , r = w1(t);
                    this.value = r ? r.getAttribute("url") : void 0,
                    this.isEnabled = function(i) {
                        const l = i.getSelectedElement();
                        return !!l && l.name === "media"
                    }(t) || function(i, l) {
                        let d = Qy(i, l).start.parent;
                        return d.isEmpty && !l.schema.isLimit(d) && (d = d.parent),
                        l.schema.checkChild(d, "media")
                    }(t, e)
                }
                execute(e) {
                    const t = this.editor.model
                      , r = t.document.selection
                      , i = w1(r);
                    i ? t.change(l => {
                        l.setAttribute("url", e, i)
                    }
                    ) : A1(t, e, r, !0)
                }
            }
            class OF {
                constructor(e, t) {
                    C(this, "locale"),
                    C(this, "providerDefinitions");
                    const r = t.providers
                      , i = t.extraProviders || []
                      , l = new Set(t.removeProviders)
                      , d = r.concat(i).filter(h => {
                        const m = h.name;
                        return m ? !l.has(m) : (de("media-embed-no-provider-name", {
                            provider: h
                        }),
                        !1)
                    }
                    );
                    this.locale = e,
                    this.providerDefinitions = d
                }
                hasMedia(e) {
                    return !!this._getMedia(e)
                }
                getMediaViewElement(e, t, r) {
                    return this._getMedia(t).getViewElement(e, r)
                }
                _getMedia(e) {
                    if (!e)
                        return new v1(this.locale);
                    e = e.trim();
                    for (const t of this.providerDefinitions) {
                        const r = t.html
                          , i = Ze(t.url);
                        for (const l of i) {
                            const d = this._getUrlMatches(e, l);
                            if (d)
                                return new v1(this.locale,e,d,r)
                        }
                    }
                    return null
                }
                _getUrlMatches(e, t) {
                    let r = e.match(t);
                    if (r)
                        return r;
                    let i = e.replace(/^https?:\/\//, "");
                    return r = i.match(t),
                    r || (i = i.replace(/^www\./, ""),
                    r = i.match(t),
                    r || null)
                }
            }
            class v1 {
                constructor(e, t, r, i) {
                    C(this, "url"),
                    C(this, "_locale"),
                    C(this, "_match"),
                    C(this, "_previewRenderer"),
                    this.url = this._getValidUrl(t),
                    this._locale = e,
                    this._match = r,
                    this._previewRenderer = i
                }
                getViewElement(e, t) {
                    const r = {};
                    let i;
                    if (t.renderForEditingView || t.renderMediaPreview && this.url && this._previewRenderer) {
                        this.url && (r["data-oembed-url"] = this.url),
                        t.renderForEditingView && (r.class = "ck-media__wrapper");
                        const l = this._getPreviewHtml(t);
                        i = e.createRawElement("div", r, (d, h) => {
                            h.setContentOf(d, l)
                        }
                        )
                    } else
                        this.url && (r.url = this.url),
                        i = e.createEmptyElement(t.elementName, r);
                    return e.setCustomProperty("media-content", !0, i),
                    i
                }
                _getPreviewHtml(e) {
                    return this._previewRenderer ? this._previewRenderer(this._match) : this.url && e.renderForEditingView ? this._getPlaceholderHtml() : ""
                }
                _getPlaceholderHtml() {
                    const e = new Ni
                      , t = this._locale.t;
                    return e.content = '<svg viewBox="0 0 64 42" xmlns="http://www.w3.org/2000/svg"><path d="M47.426 17V3.713L63.102 0v19.389h-.001l.001.272c0 1.595-2.032 3.43-4.538 4.098-2.506.668-4.538-.083-4.538-1.678 0-1.594 2.032-3.43 4.538-4.098.914-.244 2.032-.565 2.888-.603V4.516L49.076 7.447v9.556A1.014 1.014 0 0 0 49 17h-1.574zM29.5 17h-8.343a7.073 7.073 0 1 0-4.657 4.06v3.781H3.3a2.803 2.803 0 0 1-2.8-2.804V8.63a2.803 2.803 0 0 1 2.8-2.805h4.082L8.58 2.768A1.994 1.994 0 0 1 10.435 1.5h8.985c.773 0 1.477.448 1.805 1.149l1.488 3.177H26.7c1.546 0 2.8 1.256 2.8 2.805V17zm-11.637 0H17.5a1 1 0 0 0-1 1v.05A4.244 4.244 0 1 1 17.863 17zm29.684 2c.97 0 .953-.048.953.889v20.743c0 .953.016.905-.953.905H19.453c-.97 0-.953.048-.953-.905V19.89c0-.937-.016-.889.97-.889h28.077zm-4.701 19.338V22.183H24.154v16.155h18.692zM20.6 21.375v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616V37.53H20.6zm24.233-16.155v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615V37.53h-1.615zM29.485 25.283a.4.4 0 0 1 .593-.35l9.05 4.977a.4.4 0 0 1 0 .701l-9.05 4.978a.4.4 0 0 1-.593-.35v-9.956z"/></svg>',
                    e.viewBox = "0 0 64 42",
                    new hr({
                        tag: "div",
                        attributes: {
                            class: "ck ck-reset_all ck-media__placeholder"
                        },
                        children: [{
                            tag: "div",
                            attributes: {
                                class: "ck-media__placeholder__icon"
                            },
                            children: [e]
                        }, {
                            tag: "a",
                            attributes: {
                                class: "ck-media__placeholder__url",
                                target: "_blank",
                                rel: "noopener noreferrer",
                                href: this.url,
                                "data-cke-tooltip-text": t("Open media in new tab")
                            },
                            children: [{
                                tag: "span",
                                attributes: {
                                    class: "ck-media__placeholder__url__text"
                                },
                                children: [this.url]
                            }]
                        }]
                    }).render().outerHTML
                }
                _getValidUrl(e) {
                    return e ? e.match(/^https?/) ? e : "https://" + e : null
                }
            }
            var _1 = u(7048)
              , RF = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(_1.A, RF),
            _1.A.locals;
            class Su extends ie {
                constructor(e) {
                    super(e),
                    C(this, "registry"),
                    e.config.define("mediaEmbed", {
                        elementName: "oembed",
                        providers: [{
                            name: "dailymotion",
                            url: [/^dailymotion\.com\/video\/(\w+)/, /^dai.ly\/(\w+)/],
                            html: t => `<div style="position: relative; padding-bottom: 100%; height: 0; "><iframe src="https://www.dailymotion.com/embed/video/${t[1]}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" width="480" height="270" allowfullscreen allow="autoplay"></iframe></div>`
                        }, {
                            name: "spotify",
                            url: [/^open\.spotify\.com\/(artist\/\w+)/, /^open\.spotify\.com\/(album\/\w+)/, /^open\.spotify\.com\/(track\/\w+)/],
                            html: t => `<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 126%;"><iframe src="https://open.spotify.com/embed/${t[1]}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" allowtransparency="true" allow="encrypted-media"></iframe></div>`
                        }, {
                            name: "youtube",
                            url: [/^(?:m\.)?youtube\.com\/watch\?v=([\w-]+)(?:&t=(\d+))?/, /^(?:m\.)?youtube\.com\/v\/([\w-]+)(?:\?t=(\d+))?/, /^youtube\.com\/embed\/([\w-]+)(?:\?start=(\d+))?/, /^youtu\.be\/([\w-]+)(?:\?t=(\d+))?/],
                            html: t => {
                                const r = t[1]
                                  , i = t[2];
                                return `<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 56.2493%;"><iframe src="https://www.youtube.com/embed/${r}${i ? `?start=${i}` : ""}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div>`
                            }
                        }, {
                            name: "vimeo",
                            url: [/^vimeo\.com\/(\d+)/, /^vimeo\.com\/[^/]+\/[^/]+\/video\/(\d+)/, /^vimeo\.com\/album\/[^/]+\/video\/(\d+)/, /^vimeo\.com\/channels\/[^/]+\/(\d+)/, /^vimeo\.com\/groups\/[^/]+\/videos\/(\d+)/, /^vimeo\.com\/ondemand\/[^/]+\/(\d+)/, /^player\.vimeo\.com\/video\/(\d+)/],
                            html: t => `<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 56.2493%;"><iframe src="https://player.vimeo.com/video/${t[1]}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe></div>`
                        }, {
                            name: "instagram",
                            url: /^instagram\.com\/p\/(\w+)/
                        }, {
                            name: "twitter",
                            url: /^twitter\.com/
                        }, {
                            name: "googleMaps",
                            url: [/^google\.com\/maps/, /^goo\.gl\/maps/, /^maps\.google\.com/, /^maps\.app\.goo\.gl/]
                        }, {
                            name: "flickr",
                            url: /^flickr\.com/
                        }, {
                            name: "facebook",
                            url: /^facebook\.com/
                        }]
                    }),
                    this.registry = new OF(e.locale,e.config.get("mediaEmbed"))
                }
                static get pluginName() {
                    return "MediaEmbedEditing"
                }
                init() {
                    const e = this.editor
                      , t = e.model.schema
                      , r = e.t
                      , i = e.conversion
                      , l = e.config.get("mediaEmbed.previewsInData")
                      , d = e.config.get("mediaEmbed.elementName")
                      , h = this.registry;
                    e.commands.add("mediaEmbed", new zF(e)),
                    t.register("media", {
                        inheritAllFrom: "$blockObject",
                        allowAttributes: ["url"]
                    }),
                    i.for("dataDowncast").elementToStructure({
                        model: "media",
                        view: (m, {writer: g}) => {
                            const b = m.getAttribute("url");
                            return b1(g, h, b, {
                                elementName: d,
                                renderMediaPreview: !!b && l
                            })
                        }
                    }),
                    i.for("dataDowncast").add(k1(h, {
                        elementName: d,
                        renderMediaPreview: l
                    })),
                    i.for("editingDowncast").elementToStructure({
                        model: "media",
                        view: (m, {writer: g}) => {
                            const b = m.getAttribute("url");
                            return function(v, x, T) {
                                return x.setCustomProperty("media", !0, v),
                                ig(v, x, {
                                    label: T
                                })
                            }(b1(g, h, b, {
                                elementName: d,
                                renderForEditingView: !0
                            }), g, r("media widget"))
                        }
                    }),
                    i.for("editingDowncast").add(k1(h, {
                        elementName: d,
                        renderForEditingView: !0
                    })),
                    i.for("upcast").elementToElement({
                        view: m => ["oembed", d].includes(m.name) && m.getAttribute("url") ? {
                            name: !0
                        } : null,
                        model: (m, {writer: g}) => {
                            const b = m.getAttribute("url");
                            return h.hasMedia(b) ? g.createElement("media", {
                                url: b
                            }) : null
                        }
                    }).elementToElement({
                        view: {
                            name: "div",
                            attributes: {
                                "data-oembed-url": !0
                            }
                        },
                        model: (m, {writer: g}) => {
                            const b = m.getAttribute("data-oembed-url");
                            return h.hasMedia(b) ? g.createElement("media", {
                                url: b
                            }) : null
                        }
                    }).add(m => {
                        m.on("element:figure", (g, b, v) => {
                            if (!v.consumable.consume(b.viewItem, {
                                name: !0,
                                classes: "media"
                            }))
                                return;
                            const {modelRange: x, modelCursor: T} = v.convertChildren(b.viewItem, b.modelCursor);
                            b.modelRange = x,
                            b.modelCursor = T,
                            zt(x.getItems()) || v.consumable.revert(b.viewItem, {
                                name: !0,
                                classes: "media"
                            })
                        }
                        )
                    }
                    )
                }
            }
            const FF = /^(?:http(s)?:\/\/)?[\w-]+\.[\w-.~:/?#[\]@!$&'()*+,;=%]+$/;
            class VF extends ie {
                constructor(e) {
                    super(e),
                    C(this, "_timeoutId"),
                    C(this, "_positionToInsert"),
                    this._timeoutId = null,
                    this._positionToInsert = null
                }
                static get requires() {
                    return [m0, Xr, f0]
                }
                static get pluginName() {
                    return "AutoMediaEmbed"
                }
                init() {
                    const e = this.editor
                      , t = e.model.document
                      , r = e.plugins.get("ClipboardPipeline");
                    this.listenTo(r, "inputTransformation", () => {
                        const i = t.selection.getFirstRange()
                          , l = Ut.fromPosition(i.start);
                        l.stickiness = "toPrevious";
                        const d = Ut.fromPosition(i.end);
                        d.stickiness = "toNext",
                        t.once("change:data", () => {
                            this._embedMediaBetweenPositions(l, d),
                            l.detach(),
                            d.detach()
                        }
                        , {
                            priority: "high"
                        })
                    }
                    ),
                    e.commands.get("undo").on("execute", () => {
                        this._timeoutId && (w.window.clearTimeout(this._timeoutId),
                        this._positionToInsert.detach(),
                        this._timeoutId = null,
                        this._positionToInsert = null)
                    }
                    , {
                        priority: "high"
                    })
                }
                _embedMediaBetweenPositions(e, t) {
                    const r = this.editor
                      , i = r.plugins.get(Su).registry
                      , l = new Io(e,t)
                      , d = l.getWalker({
                        ignoreElementEnd: !0
                    });
                    let h = "";
                    for (const m of d)
                        m.item.is("$textProxy") && (h += m.item.data);
                    if (h = h.trim(),
                    !h.match(FF) || !i.hasMedia(h))
                        return void l.detach();
                    r.commands.get("mediaEmbed").isEnabled ? (this._positionToInsert = Ut.fromPosition(e),
                    this._timeoutId = w.window.setTimeout( () => {
                        r.model.change(m => {
                            this._timeoutId = null,
                            m.remove(l),
                            l.detach();
                            let g = null;
                            this._positionToInsert.root.rootName !== "$graveyard" && (g = this._positionToInsert),
                            A1(r.model, h, g, !1),
                            this._positionToInsert.detach(),
                            this._positionToInsert = null
                        }
                        ),
                        r.plugins.get(Xr).requestUndoOnBackspace()
                    }
                    , 100)) : l.detach()
                }
            }
            var C1 = u(5651)
              , UF = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(C1.A, UF),
            C1.A.locals;
            class HF extends pe {
                constructor(e, t) {
                    super(t),
                    C(this, "focusTracker"),
                    C(this, "keystrokes"),
                    C(this, "urlInputView"),
                    C(this, "_validators"),
                    C(this, "_urlInputViewInfoDefault"),
                    C(this, "_urlInputViewInfoTip"),
                    this.focusTracker = new Jt,
                    this.keystrokes = new lo,
                    this.set("mediaURLInputValue", ""),
                    this.urlInputView = this._createUrlInput(),
                    this._validators = e,
                    this.setTemplate({
                        tag: "form",
                        attributes: {
                            class: ["ck", "ck-media-form", "ck-responsive-form"],
                            tabindex: "-1"
                        },
                        children: [this.urlInputView]
                    })
                }
                render() {
                    super.render(),
                    Td({
                        view: this
                    }),
                    this.focusTracker.add(this.urlInputView.element),
                    this.keystrokes.listenTo(this.element)
                }
                destroy() {
                    super.destroy(),
                    this.focusTracker.destroy(),
                    this.keystrokes.destroy()
                }
                focus() {
                    this.urlInputView.focus()
                }
                get url() {
                    return this.urlInputView.fieldView.element.value.trim()
                }
                set url(e) {
                    this.urlInputView.fieldView.value = e.trim()
                }
                isValid() {
                    this.resetFormStatus();
                    for (const e of this._validators) {
                        const t = e(this);
                        if (t)
                            return this.urlInputView.errorText = t,
                            !1
                    }
                    return !0
                }
                resetFormStatus() {
                    this.urlInputView.errorText = null,
                    this.urlInputView.infoText = this._urlInputViewInfoDefault
                }
                _createUrlInput() {
                    const e = this.locale.t
                      , t = new Wp(this.locale,Qp)
                      , r = t.fieldView;
                    return this._urlInputViewInfoDefault = e("Paste the media URL in the input."),
                    this._urlInputViewInfoTip = e("Tip: Paste the URL into the content to embed faster."),
                    t.label = e("Media URL"),
                    t.infoText = this._urlInputViewInfoDefault,
                    r.inputMode = "url",
                    r.on("input", () => {
                        t.infoText = r.element.value ? this._urlInputViewInfoTip : this._urlInputViewInfoDefault,
                        this.mediaURLInputValue = r.element.value.trim()
                    }
                    ),
                    t
                }
            }
            class WF extends ie {
                constructor() {
                    super(...arguments),
                    C(this, "_formView")
                }
                static get requires() {
                    return [Su, wC]
                }
                static get pluginName() {
                    return "MediaEmbedUI"
                }
                init() {
                    const e = this.editor;
                    e.ui.componentFactory.add("mediaEmbed", () => {
                        const t = this.editor.locale.t
                          , r = this._createDialogButton(Te);
                        return r.tooltip = !0,
                        r.label = t("Insert media"),
                        r
                    }
                    ),
                    e.ui.componentFactory.add("menuBar:mediaEmbed", () => {
                        const t = this.editor.locale.t
                          , r = this._createDialogButton(Xt);
                        return r.label = t("Media"),
                        r
                    }
                    )
                }
                _createDialogButton(e) {
                    const t = this.editor
                      , r = new e(t.locale)
                      , i = t.commands.get("mediaEmbed")
                      , l = this.editor.plugins.get("Dialog");
                    return r.icon = '<svg viewBox="0 0 22 20" xmlns="http://www.w3.org/2000/svg"><path d="M1.587 1.5c-.612 0-.601-.029-.601.551v14.84c0 .59-.01.559.591.559h18.846c.602 0 .591.03.591-.56V2.052c0-.58.01-.55-.591-.55H1.587Zm.701.971h1.003v1H2.288v-1Zm16.448 0h1.003v1h-1.003v-1Zm-14.24 1h13.008v12H4.467l.029-12Zm-2.208 1h1.003v1H2.288v-1Zm16.448 0h1.003v1h-1.003v-1Zm-16.448 2h1.003v1H2.288v-1Zm16.448 0h1.003v1h-1.003v-1Zm-16.448 2h1.003v1H2.288v-1Zm16.448 0h1.003v1h-1.003v-1Zm-16.448 2h1.003v1H2.288v-1Zm16.448 0h1.003v1h-1.003v-1Zm-16.448 2h1.003l-.029 1h-.974v-1Zm16.448 0h1.003v1h-1.003v-1Zm-16.448 2h.974v1h-.974v-1Zm16.448 0h1.003v1h-1.003v-1Z"/><path d="M8.374 6.648a.399.399 0 0 1 .395-.4.402.402 0 0 1 .2.049l5.148 2.824a.4.4 0 0 1 0 .7l-5.148 2.824a.403.403 0 0 1-.595-.35V6.648Z"/></svg>',
                    r.bind("isEnabled").to(i, "isEnabled"),
                    r.on("execute", () => {
                        l.id === "mediaEmbed" ? l.hide() : this._showDialog()
                    }
                    ),
                    r
                }
                _showDialog() {
                    const e = this.editor
                      , t = e.plugins.get("Dialog")
                      , r = e.commands.get("mediaEmbed")
                      , i = e.locale.t;
                    if (!this._formView) {
                        const l = e.plugins.get(Su).registry;
                        this._formView = new (ip(HF))(function(d, h) {
                            return [m => {
                                if (!m.url.length)
                                    return d("The URL must not be empty.")
                            }
                            , m => {
                                if (!h.hasMedia(m.url))
                                    return d("This media URL is not supported.")
                            }
                            ]
                        }(e.t, l),e.locale),
                        this._formView.on("submit", () => this._handleSubmitForm())
                    }
                    t.show({
                        id: "mediaEmbed",
                        title: i("Insert media"),
                        content: this._formView,
                        isModal: !0,
                        onShow: () => {
                            this._formView.url = r.value || "",
                            this._formView.resetFormStatus(),
                            this._formView.urlInputView.fieldView.select()
                        }
                        ,
                        actionButtons: [{
                            label: i("Cancel"),
                            withText: !0,
                            onExecute: () => t.hide()
                        }, {
                            label: i("Accept"),
                            class: "ck-button-action",
                            withText: !0,
                            onExecute: () => this._handleSubmitForm()
                        }]
                    })
                }
                _handleSubmitForm() {
                    const e = this.editor
                      , t = e.plugins.get("Dialog");
                    this._formView.isValid() && (e.execute("mediaEmbed", this._formView.url),
                    t.hide(),
                    e.editing.view.focus())
                }
            }
            var y1 = u(70)
              , $F = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(y1.A, $F),
            y1.A.locals;
            class qF extends ie {
                static get requires() {
                    return [Su, WF, VF, jl]
                }
                static get pluginName() {
                    return "MediaEmbed"
                }
            }
            function x1(s) {
                return s !== void 0 && s.endsWith("px")
            }
            function $s(s) {
                return s.toFixed(2).replace(/\.?0+$/, "") + "px"
            }
            function GF(s, e, t) {
                if (!s.childCount)
                    return;
                const r = new Zr(s.document)
                  , i = function(h, m) {
                    const g = m.createRangeIn(h)
                      , b = []
                      , v = new Set;
                    for (const x of g.getItems()) {
                        if (!x.is("element") || !x.name.match(/^(p|h\d+|li|div)$/))
                            continue;
                        let T = t6(x);
                        if (T === void 0 || parseFloat(T) != 0 || Array.from(x.getClassNames()).find(I => I.startsWith("MsoList")) || (T = void 0),
                        x.hasStyle("mso-list") || T !== void 0 && v.has(T)) {
                            const I = XF(x);
                            b.push({
                                element: x,
                                id: I.id,
                                order: I.order,
                                indent: I.indent,
                                marginLeft: T
                            }),
                            T !== void 0 && v.add(T)
                        } else
                            v.clear()
                    }
                    return b
                }(s, r);
                if (!i.length)
                    return;
                const l = {}
                  , d = [];
                for (const h of i)
                    if (h.indent !== void 0) {
                        KF(h) || (d.length = 0);
                        const m = `${h.id}:${h.indent}`
                          , g = Math.min(h.indent - 1, d.length);
                        if (g < d.length && d[g].id !== h.id && (d.length = g),
                        g < d.length - 1)
                            d.length = g + 1;
                        else {
                            const v = QF(h, e);
                            if (g > d.length - 1 || d[g].listElement.name != v.type) {
                                g == 0 && v.type == "ol" && h.id !== void 0 && l[m] && (v.startIndex = l[m]);
                                const x = JF(v, r, t);
                                if (x1(h.marginLeft) && (g == 0 || x1(d[g - 1].marginLeft))) {
                                    let T = h.marginLeft;
                                    g > 0 && (T = $s(parseFloat(T) - parseFloat(d[g - 1].marginLeft))),
                                    r.setStyle("padding-left", T, x)
                                }
                                if (d.length == 0) {
                                    const T = h.element.parent
                                      , I = T.getChildIndex(h.element) + 1;
                                    r.insertChild(I, x, T)
                                } else {
                                    const T = d[g - 1].listItemElements;
                                    r.appendChild(x, T[T.length - 1])
                                }
                                d[g] = {
                                    ...h,
                                    listElement: x,
                                    listItemElements: []
                                },
                                g == 0 && h.id !== void 0 && (l[m] = v.startIndex || 1)
                            }
                        }
                        const b = h.element.name == "li" ? h.element : r.createElement("li");
                        r.appendChild(b, d[g].listElement),
                        d[g].listItemElements.push(b),
                        g == 0 && h.id !== void 0 && l[m]++,
                        h.element != b && r.appendChild(h.element, b),
                        e6(h.element, r),
                        r.removeStyle("text-indent", h.element),
                        r.removeStyle("margin-left", h.element)
                    } else {
                        const m = d.find(g => g.marginLeft == h.marginLeft);
                        if (m) {
                            const g = m.listItemElements;
                            r.appendChild(h.element, g[g.length - 1]),
                            r.removeStyle("margin-left", h.element)
                        } else
                            d.length = 0
                    }
            }
            function KF(s) {
                const e = s.element.previousSibling;
                return YF(e || s.element.parent)
            }
            function YF(s) {
                return s.is("element", "ol") || s.is("element", "ul")
            }
            function QF(s, e) {
                const t = new RegExp(`@list l${s.id}:level${s.indent}\\s*({[^}]*)`,"gi")
                  , r = /mso-level-number-format:([^;]{0,100});/gi
                  , i = /mso-level-start-at:\s{0,100}([0-9]{0,10})\s{0,100};/gi
                  , l = new RegExp(`@list\\s+l${s.id}:level\\d\\s*{[^{]*mso-level-text:"%\\d\\\\.`,"gi")
                  , d = new RegExp(`@list l${s.id}:level\\d\\s*{[^{]*mso-level-number-format:`,"gi")
                  , h = l.exec(e)
                  , m = d.exec(e)
                  , g = h && !m
                  , b = t.exec(e);
                let v = "decimal"
                  , x = "ol"
                  , T = null;
                if (b && b[1]) {
                    const I = r.exec(b[1]);
                    if (I && I[1] && (v = I[1].trim(),
                    x = v !== "bullet" && v !== "image" ? "ol" : "ul"),
                    v === "bullet") {
                        const P = function(O) {
                            if (O.name == "li" && O.parent.name == "ul" && O.parent.hasAttribute("type"))
                                return O.parent.getAttribute("type");
                            const F = function(Q) {
                                if (Q.getChild(0).is("$text"))
                                    return null;
                                for (const X of Q.getChildren()) {
                                    if (!X.is("element", "span"))
                                        continue;
                                    const le = X.getChild(0);
                                    if (le)
                                        return le.is("$text") ? le : le.getChild(0)
                                }
                                return null
                            }(O);
                            if (!F)
                                return null;
                            const q = F._data;
                            return q === "o" ? "circle" : q === "·" ? "disc" : q === "§" ? "square" : null
                        }(s.element);
                        P && (v = P)
                    } else {
                        const P = i.exec(b[1]);
                        P && P[1] && (T = parseInt(P[1]))
                    }
                    g && (x = "ol")
                }
                return {
                    type: x,
                    startIndex: T,
                    style: ZF(v),
                    isLegalStyleList: g
                }
            }
            function ZF(s) {
                if (s.startsWith("arabic-leading-zero"))
                    return "decimal-leading-zero";
                switch (s) {
                case "alpha-upper":
                    return "upper-alpha";
                case "alpha-lower":
                    return "lower-alpha";
                case "roman-upper":
                    return "upper-roman";
                case "roman-lower":
                    return "lower-roman";
                case "circle":
                case "disc":
                case "square":
                    return s;
                default:
                    return null
                }
            }
            function JF(s, e, t) {
                const r = e.createElement(s.type);
                return s.style && e.setStyle("list-style-type", s.style, r),
                s.startIndex && s.startIndex > 1 && e.setAttribute("start", s.startIndex, r),
                s.isLegalStyleList && t && e.addClass("legal-list", r),
                r
            }
            function XF(s) {
                const e = s.getStyle("mso-list");
                if (e === void 0)
                    return {};
                const t = e.match(/(^|\s{1,100})l(\d+)/i)
                  , r = e.match(/\s{0,100}lfo(\d+)/i)
                  , i = e.match(/\s{0,100}level(\d+)/i);
                return t && r && i ? {
                    id: t[2],
                    order: r[1],
                    indent: parseInt(i[1])
                } : {
                    indent: 1
                }
            }
            function e6(s, e) {
                const t = new Br({
                    name: "span",
                    styles: {
                        "mso-list": "Ignore"
                    }
                })
                  , r = e.createRangeIn(s);
                for (const i of r)
                    i.type === "elementStart" && t.match(i.item) && e.remove(i.item)
            }
            function t6(s) {
                const e = s.getStyle("margin-left");
                return e === void 0 || e.endsWith("px") ? e : function(t) {
                    const r = parseFloat(t);
                    return t.endsWith("pt") ? $s(96 * r / 72) : t.endsWith("pc") ? $s(12 * r * 96 / 72) : t.endsWith("in") ? $s(96 * r) : t.endsWith("cm") ? $s(96 * r / 2.54) : t.endsWith("mm") ? $s(r / 10 * 96 / 2.54) : t
                }(e)
            }
            function o6(s, e) {
                if (!s.childCount)
                    return;
                const t = new Zr(s.document)
                  , r = function(l, d) {
                    const h = d.createRangeIn(l)
                      , m = new Br({
                        name: /v:(.+)/
                    })
                      , g = [];
                    for (const b of h) {
                        if (b.type != "elementStart")
                            continue;
                        const v = b.item
                          , x = v.previousSibling
                          , T = x && x.is("element") ? x.name : null
                          , I = ["Chart"]
                          , P = m.match(v)
                          , O = v.getAttribute("o:gfxdata")
                          , F = T === "v:shapetype"
                          , q = O && I.some(Q => v.getAttribute("id").includes(Q));
                        P && O && !F && !q && g.push(b.item.getAttribute("id"))
                    }
                    return g
                }(s, t);
                (function(l, d, h) {
                    const m = h.createRangeIn(d)
                      , g = new Br({
                        name: "img"
                    })
                      , b = [];
                    for (const v of m)
                        if (v.item.is("element") && g.match(v.item)) {
                            const x = v.item
                              , T = x.getAttribute("v:shapes") ? x.getAttribute("v:shapes").split(" ") : [];
                            T.length && T.every(I => l.indexOf(I) > -1) ? b.push(x) : x.getAttribute("src") || b.push(x)
                        }
                    for (const v of b)
                        h.remove(v)
                }
                )(r, s, t),
                function(l, d, h) {
                    const m = h.createRangeIn(d)
                      , g = [];
                    for (const x of m)
                        if (x.type == "elementStart" && x.item.is("element", "v:shape")) {
                            const T = x.item.getAttribute("id");
                            if (l.includes(T))
                                continue;
                            b(x.item.parent.getChildren(), T) || g.push(x.item)
                        }
                    for (const x of g) {
                        const T = {
                            src: v(x)
                        };
                        x.hasAttribute("alt") && (T.alt = x.getAttribute("alt"));
                        const I = h.createElement("img", T);
                        h.insertChild(x.index + 1, I, x.parent)
                    }
                    function b(x, T) {
                        for (const I of x)
                            if (I.is("element") && (I.name == "img" && I.getAttribute("v:shapes") == T || b(I.getChildren(), T)))
                                return !0;
                        return !1
                    }
                    function v(x) {
                        for (const T of x.getChildren())
                            if (T.is("element") && T.getAttribute("src"))
                                return T.getAttribute("src")
                    }
                }(r, s, t),
                function(l, d) {
                    const h = d.createRangeIn(l)
                      , m = new Br({
                        name: /v:(.+)/
                    })
                      , g = [];
                    for (const b of h)
                        b.type == "elementStart" && m.match(b.item) && g.push(b.item);
                    for (const b of g)
                        d.remove(b)
                }(s, t);
                const i = function(l, d) {
                    const h = d.createRangeIn(l)
                      , m = new Br({
                        name: "img"
                    })
                      , g = [];
                    for (const b of h)
                        b.item.is("element") && m.match(b.item) && b.item.getAttribute("src").startsWith("file://") && g.push(b.item);
                    return g
                }(s, t);
                i.length && function(l, d, h) {
                    if (l.length === d.length)
                        for (let m = 0; m < l.length; m++) {
                            const g = `data:${d[m].type};base64,${r6(d[m].hex)}`;
                            h.setAttribute("src", g, l[m])
                        }
                }(i, function(l) {
                    if (!l)
                        return [];
                    const d = /{\\pict[\s\S]+?\\bliptag-?\d+(\\blipupi-?\d+)?({\\\*\\blipuid\s?[\da-fA-F]+)?[\s}]*?/
                      , h = new RegExp("(?:(" + d.source + "))([\\da-fA-F\\s]+)\\}","g")
                      , m = l.match(h)
                      , g = [];
                    if (m)
                        for (const b of m) {
                            let v = !1;
                            b.includes("\\pngblip") ? v = "image/png" : b.includes("\\jpegblip") && (v = "image/jpeg"),
                            v && g.push({
                                hex: b.replace(d, "").replace(/[^\da-fA-F]/g, ""),
                                type: v
                            })
                        }
                    return g
                }(e), t)
            }
            function r6(s) {
                return btoa(s.match(/\w{2}/g).map(e => String.fromCharCode(parseInt(e, 16))).join(""))
            }
            const n6 = /<meta\s*name="?generator"?\s*content="?microsoft\s*word\s*\d+"?\/?>/i
              , i6 = /xmlns:o="urn:schemas-microsoft-com/i;
            class s6 {
                constructor(e, t=!1) {
                    C(this, "document"),
                    C(this, "hasMultiLevelListPlugin"),
                    this.document = e,
                    this.hasMultiLevelListPlugin = t
                }
                isActive(e) {
                    return n6.test(e) || i6.test(e)
                }
                execute(e) {
                    const {body: t, stylesString: r} = e._parsedData;
                    GF(t, r, this.hasMultiLevelListPlugin),
                    o6(t, e.dataTransfer.getData("text/rtf")),
                    function(i) {
                        const l = []
                          , d = new Zr(i.document);
                        for (const {item: h} of d.createRangeIn(i))
                            if (h.is("element")) {
                                for (const m of h.getClassNames())
                                    /\bmso/gi.exec(m) && d.removeClass(m, h);
                                for (const m of h.getStyleNames())
                                    /\bmso/gi.exec(m) && d.removeStyle(m, h);
                                (h.is("element", "w:sdt") || h.is("element", "w:sdtpr") && h.isEmpty || h.is("element", "o:p") && h.isEmpty) && l.push(h)
                            }
                        for (const h of l) {
                            const m = h.parent
                              , g = m.getChildIndex(h);
                            d.insertChild(g, h.getChildren(), m),
                            d.remove(h)
                        }
                    }(t),
                    e.content = t
                }
            }
            function E1(s, e, t, {blockElements: r, inlineObjectElements: i}) {
                let l = t.createPositionAt(s, e == "forward" ? "after" : "before");
                return l = l.getLastMatchingPosition( ({item: d}) => d.is("element") && !r.includes(d.name) && !i.includes(d.name), {
                    direction: e
                }),
                e == "forward" ? l.nodeAfter : l.nodeBefore
            }
            function S1(s, e) {
                return !!s && s.is("element") && e.includes(s.name)
            }
            const a6 = /id=("|')docs-internal-guid-[-0-9a-f]+("|')/i;
            class l6 {
                constructor(e) {
                    C(this, "document"),
                    this.document = e
                }
                isActive(e) {
                    return a6.test(e)
                }
                execute(e) {
                    const t = new Zr(this.document)
                      , {body: r} = e._parsedData;
                    (function(i, l) {
                        for (const d of i.getChildren())
                            if (d.is("element", "b") && d.getStyle("font-weight") === "normal") {
                                const h = i.getChildIndex(d);
                                l.remove(d),
                                l.insertChild(h, d.getChildren(), i)
                            }
                    }
                    )(r, t),
                    function(i, l) {
                        for (const d of l.createRangeIn(i)) {
                            const h = d.item;
                            if (h.is("element", "li")) {
                                const m = h.getChild(0);
                                m && m.is("element", "p") && l.unwrapElement(m)
                            }
                        }
                    }(r, t),
                    function(i, l) {
                        const d = new zd(l.document.stylesProcessor)
                          , h = new Fd(d,{
                            renderingMode: "data"
                        })
                          , m = h.blockElements
                          , g = h.inlineObjectElements
                          , b = [];
                        for (const v of l.createRangeIn(i)) {
                            const x = v.item;
                            if (x.is("element", "br")) {
                                const T = E1(x, "forward", l, {
                                    blockElements: m,
                                    inlineObjectElements: g
                                })
                                  , I = E1(x, "backward", l, {
                                    blockElements: m,
                                    inlineObjectElements: g
                                })
                                  , P = S1(T, m);
                                (S1(I, m) || P) && b.push(x)
                            }
                        }
                        for (const v of b)
                            v.hasClass("Apple-interchange-newline") ? l.remove(v) : l.replace(v, l.createElement("p"))
                    }(r, t),
                    e.content = r
                }
            }
            const c6 = /<google-sheets-html-origin/i;
            class d6 {
                constructor(e) {
                    C(this, "document"),
                    this.document = e
                }
                isActive(e) {
                    return c6.test(e)
                }
                execute(e) {
                    const t = new Zr(this.document)
                      , {body: r} = e._parsedData;
                    (function(i, l) {
                        for (const d of i.getChildren())
                            if (d.is("element", "google-sheets-html-origin")) {
                                const h = i.getChildIndex(d);
                                l.remove(d),
                                l.insertChild(h, d.getChildren(), i)
                            }
                    }
                    )(r, t),
                    function(i, l) {
                        for (const d of i.getChildren())
                            d.is("element", "table") && d.hasAttribute("xmlns") && l.removeAttribute("xmlns", d)
                    }(r, t),
                    function(i, l) {
                        for (const d of i.getChildren())
                            d.is("element", "table") && d.getStyle("width") === "0px" && l.removeStyle("width", d)
                    }(r, t),
                    function(i, l) {
                        for (const d of Array.from(i.getChildren()))
                            d.is("element", "style") && l.remove(d)
                    }(r, t),
                    e.content = r
                }
            }
            function D1(s) {
                return s.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, (e, t) => t.length === 1 ? " " : Array(t.length + 1).join("  ").substr(0, t.length))
            }
            function u6(s, e) {
                const t = new DOMParser
                  , r = function(m) {
                    return D1(D1(m)).replace(/(<span\s+style=['"]mso-spacerun:yes['"]>[^\S\r\n]*?)[\r\n]+([^\S\r\n]*<\/span>)/g, "$1$2").replace(/<span\s+style=['"]mso-spacerun:yes['"]><\/span>/g, "").replace(/(<span\s+style=['"]letter-spacing:[^'"]+?['"]>)[\r\n]+(<\/span>)/g, "$1 $2").replace(/ <\//g, " </").replace(/ <o:p><\/o:p>/g, " <o:p></o:p>").replace(/<o:p>(&nbsp;|\u00A0)<\/o:p>/g, "").replace(/>([^\S\r\n]*[\r\n]\s*)</g, "><")
                }(function(m) {
                    const g = "</body>"
                      , b = "</html>"
                      , v = m.indexOf(g);
                    if (v < 0)
                        return m;
                    const x = m.indexOf(b, v + g.length);
                    return m.substring(0, v + g.length) + (x >= 0 ? m.substring(x) : "")
                }(s = (s = s.replace(/<!--\[if gte vml 1]>/g, "")).replace(/<o:SmartTagType(?:\s+[^\s>=]+(?:="[^"]*")?)*\s*\/?>/gi, "")))
                  , i = t.parseFromString(r, "text/html");
                (function(m) {
                    m.querySelectorAll("span[style*=spacerun]").forEach(g => {
                        const b = g
                          , v = b.innerText.length || 0;
                        b.innerText = Array(v + 1).join("  ").substr(0, v)
                    }
                    )
                }
                )(i);
                const l = i.body.innerHTML
                  , d = function(m, g) {
                    const b = new zd(g)
                      , v = new Fd(b,{
                        renderingMode: "data"
                    })
                      , x = m.createDocumentFragment()
                      , T = m.body.childNodes;
                    for (; T.length > 0; )
                        x.appendChild(T[0]);
                    return v.domToView(x, {
                        skipComments: !0
                    })
                }(i, e)
                  , h = function(m) {
                    const g = []
                      , b = []
                      , v = Array.from(m.getElementsByTagName("style"));
                    for (const x of v)
                        x.sheet && x.sheet.cssRules && x.sheet.cssRules.length && (g.push(x.sheet),
                        b.push(x.innerHTML));
                    return {
                        styles: g,
                        stylesString: b.join(" ")
                    }
                }(i);
                return {
                    body: d,
                    bodyString: l,
                    styles: h.styles,
                    stylesString: h.stylesString
                }
            }
            class h6 extends ie {
                static get pluginName() {
                    return "PasteFromOffice"
                }
                static get requires() {
                    return [Ko]
                }
                init() {
                    const e = this.editor
                      , t = e.plugins.get("ClipboardPipeline")
                      , r = e.editing.view.document
                      , i = []
                      , l = this.editor.plugins.has("MultiLevelList");
                    i.push(new s6(r,l)),
                    i.push(new l6(r)),
                    i.push(new d6(r)),
                    t.on("inputTransformation", (d, h) => {
                        if (h._isTransformedWithPasteFromOffice || e.model.document.selection.getFirstPosition().parent.is("element", "codeBlock"))
                            return;
                        const m = h.dataTransfer.getData("text/html")
                          , g = i.find(b => b.isActive(m));
                        g && (h._parsedData || (h._parsedData = u6(m, r.stylesProcessor)),
                        g.execute(h),
                        h._isTransformedWithPasteFromOffice = !0)
                    }
                    , {
                        priority: "high"
                    })
                }
            }
            function pt(s, e, t, r, i=1) {
                e != null && i != null && e > i ? r.setAttribute(s, e, t) : r.removeAttribute(s, t)
            }
            function Ri(s, e, t={}) {
                const r = s.createElement("tableCell", t);
                return s.insertElement("paragraph", r),
                s.insert(r, e),
                r
            }
            function Cg(s, e) {
                const t = e.parent.parent
                  , r = parseInt(t.getAttribute("headingColumns") || "0")
                  , {column: i} = s.getCellLocation(e);
                return !!r && i < r
            }
            function m6() {
                return s => {
                    s.on("element:table", (e, t, r) => {
                        const i = t.viewItem;
                        if (!r.consumable.test(i, {
                            name: !0
                        }))
                            return;
                        const {rows: l, headingRows: d, headingColumns: h} = function(b) {
                            let v, x = 0;
                            const T = []
                              , I = [];
                            let P;
                            for (const O of Array.from(b.getChildren())) {
                                if (O.name !== "tbody" && O.name !== "thead" && O.name !== "tfoot")
                                    continue;
                                O.name !== "thead" || P || (P = O);
                                const F = Array.from(O.getChildren()).filter(q => q.is("element", "tr"));
                                for (const q of F)
                                    if (P && O === P || O.name === "tbody" && Array.from(q.getChildren()).length && Array.from(q.getChildren()).every(Q => Q.is("element", "th")))
                                        x++,
                                        T.push(q);
                                    else {
                                        I.push(q);
                                        const Q = p6(q);
                                        (!v || Q < v) && (v = Q)
                                    }
                            }
                            return {
                                headingRows: x,
                                headingColumns: v || 0,
                                rows: [...T, ...I]
                            }
                        }(i)
                          , m = {};
                        h && (m.headingColumns = h),
                        d && (m.headingRows = d);
                        const g = r.writer.createElement("table", m);
                        if (r.safeInsert(g, t.modelCursor)) {
                            if (r.consumable.consume(i, {
                                name: !0
                            }),
                            l.forEach(b => r.convertItem(b, r.writer.createPositionAt(g, "end"))),
                            r.convertChildren(i, r.writer.createPositionAt(g, "end")),
                            g.isEmpty) {
                                const b = r.writer.createElement("tableRow");
                                r.writer.insert(b, r.writer.createPositionAt(g, "end")),
                                Ri(r.writer, r.writer.createPositionAt(b, "end"))
                            }
                            r.updateConversionResult(g, t)
                        }
                    }
                    )
                }
            }
            function T1(s) {
                return e => {
                    e.on(`element:${s}`, (t, r, {writer: i}) => {
                        if (!r.modelRange)
                            return;
                        const l = r.modelRange.start.nodeAfter
                          , d = i.createPositionAt(l, 0);
                        if (r.viewItem.isEmpty)
                            return void i.insertElement("paragraph", d);
                        const h = Array.from(l.getChildren());
                        if (h.every(m => m.is("element", "$marker"))) {
                            const m = i.createElement("paragraph");
                            i.insert(m, i.createPositionAt(l, 0));
                            for (const g of h)
                                i.move(i.createRangeOn(g), i.createPositionAt(m, "end"))
                        }
                    }
                    , {
                        priority: "low"
                    })
                }
            }
            function p6(s) {
                let e = 0
                  , t = 0;
                const r = Array.from(s.getChildren()).filter(i => i.name === "th" || i.name === "td");
                for (; t < r.length && r[t].name === "th"; ) {
                    const i = r[t];
                    e += parseInt(i.getAttribute("colspan") || "1"),
                    t++
                }
                return e
            }
            class Ve {
                constructor(e, t={}) {
                    C(this, "_table"),
                    C(this, "_startRow"),
                    C(this, "_endRow"),
                    C(this, "_startColumn"),
                    C(this, "_endColumn"),
                    C(this, "_includeAllSlots"),
                    C(this, "_skipRows"),
                    C(this, "_row"),
                    C(this, "_rowIndex"),
                    C(this, "_column"),
                    C(this, "_cellIndex"),
                    C(this, "_spannedCells"),
                    C(this, "_nextCellAtColumn"),
                    C(this, "_jumpedToStartRow", !1),
                    this._table = e,
                    this._startRow = t.row !== void 0 ? t.row : t.startRow || 0,
                    this._endRow = t.row !== void 0 ? t.row : t.endRow,
                    this._startColumn = t.column !== void 0 ? t.column : t.startColumn || 0,
                    this._endColumn = t.column !== void 0 ? t.column : t.endColumn,
                    this._includeAllSlots = !!t.includeAllSlots,
                    this._skipRows = new Set,
                    this._row = 0,
                    this._rowIndex = 0,
                    this._column = 0,
                    this._cellIndex = 0,
                    this._spannedCells = new Map,
                    this._nextCellAtColumn = -1
                }
                [Symbol.iterator]() {
                    return this
                }
                next() {
                    this._canJumpToStartRow() && this._jumpToNonSpannedRowClosestToStartRow();
                    const e = this._table.getChild(this._rowIndex);
                    if (!e || this._isOverEndRow())
                        return {
                            done: !0,
                            value: void 0
                        };
                    if (!e.is("element", "tableRow"))
                        return this._rowIndex++,
                        this.next();
                    if (this._isOverEndColumn())
                        return this._advanceToNextRow();
                    let t = null;
                    const r = this._getSpanned();
                    if (r)
                        this._includeAllSlots && !this._shouldSkipSlot() && (t = this._formatOutValue(r.cell, r.row, r.column));
                    else {
                        const i = e.getChild(this._cellIndex);
                        if (!i)
                            return this._advanceToNextRow();
                        const l = parseInt(i.getAttribute("colspan") || "1")
                          , d = parseInt(i.getAttribute("rowspan") || "1");
                        (l > 1 || d > 1) && this._recordSpans(i, d, l),
                        this._shouldSkipSlot() || (t = this._formatOutValue(i)),
                        this._nextCellAtColumn = this._column + l
                    }
                    return this._column++,
                    this._column == this._nextCellAtColumn && this._cellIndex++,
                    t || this.next()
                }
                skipRow(e) {
                    this._skipRows.add(e)
                }
                _advanceToNextRow() {
                    return this._row++,
                    this._rowIndex++,
                    this._column = 0,
                    this._cellIndex = 0,
                    this._nextCellAtColumn = -1,
                    this.next()
                }
                _isOverEndRow() {
                    return this._endRow !== void 0 && this._row > this._endRow
                }
                _isOverEndColumn() {
                    return this._endColumn !== void 0 && this._column > this._endColumn
                }
                _formatOutValue(e, t=this._row, r=this._column) {
                    return {
                        done: !1,
                        value: new g6(this,e,t,r)
                    }
                }
                _shouldSkipSlot() {
                    const e = this._skipRows.has(this._row)
                      , t = this._row < this._startRow
                      , r = this._column < this._startColumn
                      , i = this._endColumn !== void 0 && this._column > this._endColumn;
                    return e || t || r || i
                }
                _getSpanned() {
                    const e = this._spannedCells.get(this._row);
                    return e && e.get(this._column) || null
                }
                _recordSpans(e, t, r) {
                    const i = {
                        cell: e,
                        row: this._row,
                        column: this._column
                    };
                    for (let l = this._row; l < this._row + t; l++)
                        for (let d = this._column; d < this._column + r; d++)
                            l == this._row && d == this._column || this._markSpannedCell(l, d, i)
                }
                _markSpannedCell(e, t, r) {
                    this._spannedCells.has(e) || this._spannedCells.set(e, new Map),
                    this._spannedCells.get(e).set(t, r)
                }
                _canJumpToStartRow() {
                    return !!this._startRow && this._startRow > 0 && !this._jumpedToStartRow
                }
                _jumpToNonSpannedRowClosestToStartRow() {
                    const e = this._getRowLength(0);
                    for (let t = this._startRow; !this._jumpedToStartRow; t--)
                        e === this._getRowLength(t) && (this._row = t,
                        this._rowIndex = t,
                        this._jumpedToStartRow = !0)
                }
                _getRowLength(e) {
                    return [...this._table.getChild(e).getChildren()].reduce( (t, r) => t + parseInt(r.getAttribute("colspan") || "1"), 0)
                }
            }
            class g6 {
                constructor(e, t, r, i) {
                    C(this, "cell"),
                    C(this, "row"),
                    C(this, "column"),
                    C(this, "cellAnchorRow"),
                    C(this, "cellAnchorColumn"),
                    C(this, "_cellIndex"),
                    C(this, "_rowIndex"),
                    C(this, "_table"),
                    this.cell = t,
                    this.row = e._row,
                    this.column = e._column,
                    this.cellAnchorRow = r,
                    this.cellAnchorColumn = i,
                    this._cellIndex = e._cellIndex,
                    this._rowIndex = e._rowIndex,
                    this._table = e._table
                }
                get isAnchor() {
                    return this.row === this.cellAnchorRow && this.column === this.cellAnchorColumn
                }
                get cellWidth() {
                    return parseInt(this.cell.getAttribute("colspan") || "1")
                }
                get cellHeight() {
                    return parseInt(this.cell.getAttribute("rowspan") || "1")
                }
                get rowIndex() {
                    return this._rowIndex
                }
                getPositionBefore() {
                    return this._table.root.document.model.createPositionAt(this._table.getChild(this.row), this._cellIndex)
                }
            }
            function I1(s, e) {
                return (t, {writer: r}) => {
                    const i = t.getAttribute("headingRows") || 0
                      , l = r.createContainerElement("table", null, [])
                      , d = r.createContainerElement("figure", {
                        class: "table"
                    }, l);
                    i > 0 && r.insert(r.createPositionAt(l, "end"), r.createContainerElement("thead", null, r.createSlot(h => h.is("element", "tableRow") && h.index < i))),
                    i < s.getRows(t) && r.insert(r.createPositionAt(l, "end"), r.createContainerElement("tbody", null, r.createSlot(h => h.is("element", "tableRow") && h.index >= i)));
                    for (const {positionOffset: h, filter: m} of e.additionalSlots)
                        r.insert(r.createPositionAt(l, h), r.createSlot(m));
                    return r.insert(r.createPositionAt(l, "after"), r.createSlot(h => !h.is("element", "tableRow") && !e.additionalSlots.some( ({filter: m}) => m(h)))),
                    e.asWidget ? function(h, m) {
                        return m.setCustomProperty("table", !0, h),
                        ig(h, m, {
                            hasSelectionHandle: !0
                        })
                    }(d, r) : d
                }
            }
            function M1(s={}) {
                return (e, {writer: t}) => {
                    const r = e.parent
                      , i = r.parent
                      , l = i.getChildIndex(r)
                      , d = new Ve(i,{
                        row: l
                    })
                      , h = i.getAttribute("headingRows") || 0
                      , m = i.getAttribute("headingColumns") || 0;
                    let g = null;
                    for (const b of d)
                        if (b.cell == e) {
                            const v = b.row < h || b.column < m ? "th" : "td";
                            g = s.asWidget ? Yy(t.createEditableElement(v), t) : t.createContainerElement(v);
                            break
                        }
                    return g
                }
            }
            function B1(s={}) {
                return (e, {writer: t}) => {
                    if (!e.parent.is("element", "tableCell") || !N1(e))
                        return null;
                    if (s.asWidget)
                        return t.createContainerElement("span", {
                            class: "ck-table-bogus-paragraph"
                        });
                    {
                        const r = t.createContainerElement("p");
                        return t.setCustomProperty("dataPipeline:transparentRendering", !0, r),
                        r
                    }
                }
            }
            function N1(s) {
                return s.parent.childCount == 1 && !!s.getAttributeKeys().next().done
            }
            class f6 extends _e {
                refresh() {
                    const e = this.editor.model
                      , t = e.document.selection
                      , r = e.schema;
                    this.isEnabled = function(i, l) {
                        const d = i.getFirstPosition().parent
                          , h = d === d.root ? d : d.parent;
                        return l.checkChild(h, "table")
                    }(t, r)
                }
                execute(e={}) {
                    const t = this.editor
                      , r = t.model
                      , i = t.plugins.get("TableUtils")
                      , l = t.config.get("table.defaultHeadings.rows")
                      , d = t.config.get("table.defaultHeadings.columns");
                    e.headingRows === void 0 && l && (e.headingRows = l),
                    e.headingColumns === void 0 && d && (e.headingColumns = d),
                    r.change(h => {
                        const m = i.createTable(h, e);
                        r.insertObject(m, null, null, {
                            findOptimalPosition: "auto"
                        }),
                        h.setSelection(h.createPositionAt(m.getNodeByPath([0, 0, 0]), 0))
                    }
                    )
                }
            }
            class P1 extends _e {
                constructor(e, t={}) {
                    super(e),
                    C(this, "order"),
                    this.order = t.order || "below"
                }
                refresh() {
                    const e = this.editor.model.document.selection
                      , t = !!this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(e).length;
                    this.isEnabled = t
                }
                execute() {
                    const e = this.editor
                      , t = e.model.document.selection
                      , r = e.plugins.get("TableUtils")
                      , i = this.order === "above"
                      , l = r.getSelectionAffectedTableCells(t)
                      , d = r.getRowIndexes(l)
                      , h = i ? d.first : d.last
                      , m = l[0].findAncestor("table");
                    r.insertRows(m, {
                        at: i ? h : h + 1,
                        copyStructureFromAbove: !i
                    })
                }
            }
            class j1 extends _e {
                constructor(e, t={}) {
                    super(e),
                    C(this, "order"),
                    this.order = t.order || "right"
                }
                refresh() {
                    const e = this.editor.model.document.selection
                      , t = !!this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(e).length;
                    this.isEnabled = t
                }
                execute() {
                    const e = this.editor
                      , t = e.model.document.selection
                      , r = e.plugins.get("TableUtils")
                      , i = this.order === "left"
                      , l = r.getSelectionAffectedTableCells(t)
                      , d = r.getColumnIndexes(l)
                      , h = i ? d.first : d.last
                      , m = l[0].findAncestor("table");
                    r.insertColumns(m, {
                        columns: 1,
                        at: i ? h : h + 1
                    })
                }
            }
            class L1 extends _e {
                constructor(e, t={}) {
                    super(e),
                    C(this, "direction"),
                    this.direction = t.direction || "horizontally"
                }
                refresh() {
                    const e = this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(this.editor.model.document.selection);
                    this.isEnabled = e.length === 1
                }
                execute() {
                    const e = this.editor.plugins.get("TableUtils")
                      , t = e.getSelectionAffectedTableCells(this.editor.model.document.selection)[0];
                    this.direction === "horizontally" ? e.splitCellHorizontally(t, 2) : e.splitCellVertically(t, 2)
                }
            }
            function z1(s, e, t) {
                const {startRow: r, startColumn: i, endRow: l, endColumn: d} = e
                  , h = t.createElement("table")
                  , m = l - r + 1;
                for (let b = 0; b < m; b++)
                    t.insertElement("tableRow", h, "end");
                const g = [...new Ve(s,{
                    startRow: r,
                    endRow: l,
                    startColumn: i,
                    endColumn: d,
                    includeAllSlots: !0
                })];
                for (const {row: b, column: v, cell: x, isAnchor: T, cellAnchorRow: I, cellAnchorColumn: P} of g) {
                    const O = b - r
                      , F = h.getChild(O);
                    if (T) {
                        const q = t.cloneElement(x);
                        t.append(q, F),
                        U1(q, b, v, l, d, t)
                    } else
                        (I < r || P < i) && Ri(t, t.createPositionAt(F, "end"))
                }
                return function(b, v, x, T, I) {
                    const P = parseInt(v.getAttribute("headingRows") || "0");
                    P > 0 && pt("headingRows", P - x, b, I, 0);
                    const O = parseInt(v.getAttribute("headingColumns") || "0");
                    O > 0 && pt("headingColumns", O - T, b, I, 0)
                }(h, s, r, i, t),
                h
            }
            function O1(s, e, t=0) {
                const r = []
                  , i = new Ve(s,{
                    startRow: t,
                    endRow: e - 1
                });
                for (const l of i) {
                    const {row: d, cellHeight: h} = l;
                    d < e && e <= d + h - 1 && r.push(l)
                }
                return r
            }
            function R1(s, e, t) {
                const r = s.parent
                  , i = r.parent
                  , l = r.index
                  , d = e - l
                  , h = {}
                  , m = parseInt(s.getAttribute("rowspan")) - d;
                m > 1 && (h.rowspan = m);
                const g = parseInt(s.getAttribute("colspan") || "1");
                g > 1 && (h.colspan = g);
                const b = l + d
                  , v = [...new Ve(i,{
                    startRow: l,
                    endRow: b,
                    includeAllSlots: !0
                })];
                let x, T = null;
                for (const I of v) {
                    const {row: P, column: O, cell: F} = I;
                    F === s && x === void 0 && (x = O),
                    x !== void 0 && x === O && P === b && (T = Ri(t, I.getPositionBefore(), h))
                }
                return pt("rowspan", d, s, t),
                T
            }
            function F1(s, e) {
                const t = []
                  , r = new Ve(s);
                for (const i of r) {
                    const {column: l, cellWidth: d} = i;
                    l < e && e <= l + d - 1 && t.push(i)
                }
                return t
            }
            function V1(s, e, t, r) {
                const i = t - e
                  , l = {}
                  , d = parseInt(s.getAttribute("colspan")) - i;
                d > 1 && (l.colspan = d);
                const h = parseInt(s.getAttribute("rowspan") || "1");
                h > 1 && (l.rowspan = h);
                const m = Ri(r, r.createPositionAfter(s), l);
                return pt("colspan", i, s, r),
                m
            }
            function U1(s, e, t, r, i, l) {
                const d = parseInt(s.getAttribute("colspan") || "1")
                  , h = parseInt(s.getAttribute("rowspan") || "1");
                t + d - 1 > i && pt("colspan", i - t + 1, s, l, 1),
                e + h - 1 > r && pt("rowspan", r - e + 1, s, l, 1)
            }
            function yg(s, e) {
                const t = e.getColumns(s)
                  , r = new Array(t).fill(0);
                for (const {column: l} of new Ve(s))
                    r[l]++;
                const i = r.reduce( (l, d, h) => d ? l : [...l, h], []);
                if (i.length > 0) {
                    const l = i[i.length - 1];
                    return e.removeColumns(s, {
                        at: l
                    }),
                    !0
                }
                return !1
            }
            function xg(s, e) {
                const t = []
                  , r = e.getRows(s);
                for (let i = 0; i < r; i++)
                    s.getChild(i).isEmpty && t.push(i);
                if (t.length > 0) {
                    const i = t[t.length - 1];
                    return e.removeRows(s, {
                        at: i
                    }),
                    !0
                }
                return !1
            }
            function Eg(s, e) {
                yg(s, e) || xg(s, e)
            }
            function H1(s, e) {
                const t = Array.from(new Ve(s,{
                    startColumn: e.firstColumn,
                    endColumn: e.lastColumn,
                    row: e.lastRow
                }));
                if (t.every( ({cellHeight: i}) => i === 1))
                    return e.lastRow;
                const r = t[0].cellHeight - 1;
                return e.lastRow + r
            }
            function W1(s, e) {
                const t = Array.from(new Ve(s,{
                    startRow: e.firstRow,
                    endRow: e.lastRow,
                    column: e.lastColumn
                }));
                if (t.every( ({cellWidth: i}) => i === 1))
                    return e.lastColumn;
                const r = t[0].cellWidth - 1;
                return e.lastColumn + r
            }
            class Du extends _e {
                constructor(e, t) {
                    super(e),
                    C(this, "direction"),
                    C(this, "isHorizontal"),
                    this.direction = t.direction,
                    this.isHorizontal = this.direction == "right" || this.direction == "left"
                }
                refresh() {
                    const e = this._getMergeableCell();
                    this.value = e,
                    this.isEnabled = !!e
                }
                execute() {
                    const e = this.editor.model
                      , t = e.document
                      , r = this.editor.plugins.get("TableUtils").getTableCellsContainingSelection(t.selection)[0]
                      , i = this.value
                      , l = this.direction;
                    e.change(d => {
                        const h = l == "right" || l == "down"
                          , m = h ? r : i
                          , g = h ? i : r
                          , b = g.parent;
                        (function(P, O, F) {
                            $1(P) || ($1(O) && F.remove(F.createRangeIn(O)),
                            F.move(F.createRangeIn(P), F.createPositionAt(O, "end"))),
                            F.remove(P)
                        }
                        )(g, m, d);
                        const v = this.isHorizontal ? "colspan" : "rowspan"
                          , x = parseInt(r.getAttribute(v) || "1")
                          , T = parseInt(i.getAttribute(v) || "1");
                        d.setAttribute(v, x + T, m),
                        d.setSelection(d.createRangeIn(m));
                        const I = this.editor.plugins.get("TableUtils");
                        Eg(b.findAncestor("table"), I)
                    }
                    )
                }
                _getMergeableCell() {
                    const e = this.editor.model.document
                      , t = this.editor.plugins.get("TableUtils")
                      , r = t.getTableCellsContainingSelection(e.selection)[0];
                    if (!r)
                        return;
                    const i = this.isHorizontal ? function(h, m, g) {
                        const b = h.parent
                          , v = b.parent
                          , x = m == "right" ? h.nextSibling : h.previousSibling
                          , T = (v.getAttribute("headingColumns") || 0) > 0;
                        if (!x)
                            return;
                        const I = m == "right" ? h : x
                          , P = m == "right" ? x : h
                          , {column: O} = g.getCellLocation(I)
                          , {column: F} = g.getCellLocation(P)
                          , q = parseInt(I.getAttribute("colspan") || "1")
                          , Q = Cg(g, I)
                          , X = Cg(g, P);
                        if (!(T && Q != X))
                            return O + q === F ? x : void 0
                    }(r, this.direction, t) : function(h, m, g) {
                        const b = h.parent
                          , v = b.parent
                          , x = v.getChildIndex(b);
                        if (m == "down" && x === g.getRows(v) - 1 || m == "up" && x === 0)
                            return null;
                        const T = parseInt(h.getAttribute("rowspan") || "1")
                          , I = v.getAttribute("headingRows") || 0
                          , P = m == "down" && x + T === I
                          , O = m == "up" && x === I;
                        if (I && (P || O))
                            return null;
                        const F = parseInt(h.getAttribute("rowspan") || "1")
                          , q = m == "down" ? x + F : x
                          , Q = [...new Ve(v,{
                            endRow: q
                        })]
                          , X = Q.find(ke => ke.cell === h)
                          , le = X.column
                          , ge = Q.find( ({row: ke, cellHeight: vt, column: Nt}) => Nt === le && (m == "down" ? ke === q : q === ke + vt));
                        return ge && ge.cell ? ge.cell : null
                    }(r, this.direction, t);
                    if (!i)
                        return;
                    const l = this.isHorizontal ? "rowspan" : "colspan"
                      , d = parseInt(r.getAttribute(l) || "1");
                    return parseInt(i.getAttribute(l) || "1") === d ? i : void 0
                }
            }
            function $1(s) {
                const e = s.getChild(0);
                return s.childCount == 1 && e.is("element", "paragraph") && e.isEmpty
            }
            class k6 extends _e {
                refresh() {
                    const e = this.editor.plugins.get("TableUtils")
                      , t = e.getSelectionAffectedTableCells(this.editor.model.document.selection)
                      , r = t[0];
                    if (r) {
                        const i = r.findAncestor("table")
                          , l = e.getRows(i) - 1
                          , d = e.getRowIndexes(t)
                          , h = d.first === 0 && d.last === l;
                        this.isEnabled = !h
                    } else
                        this.isEnabled = !1
                }
                execute() {
                    const e = this.editor.model
                      , t = this.editor.plugins.get("TableUtils")
                      , r = t.getSelectionAffectedTableCells(e.document.selection)
                      , i = t.getRowIndexes(r)
                      , l = r[0]
                      , d = l.findAncestor("table")
                      , h = t.getCellLocation(l).column;
                    e.change(m => {
                        const g = i.last - i.first + 1;
                        t.removeRows(d, {
                            at: i.first,
                            rows: g
                        });
                        const b = function(v, x, T, I) {
                            const P = v.getChild(Math.min(x, I - 1));
                            let O = P.getChild(0)
                              , F = 0;
                            for (const q of P.getChildren()) {
                                if (F > T)
                                    return O;
                                O = q,
                                F += parseInt(q.getAttribute("colspan") || "1")
                            }
                            return O
                        }(d, i.first, h, t.getRows(d));
                        m.setSelection(m.createPositionAt(b, 0))
                    }
                    )
                }
            }
            class b6 extends _e {
                refresh() {
                    const e = this.editor.plugins.get("TableUtils")
                      , t = e.getSelectionAffectedTableCells(this.editor.model.document.selection)
                      , r = t[0];
                    if (r) {
                        const i = r.findAncestor("table")
                          , l = e.getColumns(i)
                          , {first: d, last: h} = e.getColumnIndexes(t);
                        this.isEnabled = h - d < l - 1
                    } else
                        this.isEnabled = !1
                }
                execute() {
                    const e = this.editor.plugins.get("TableUtils")
                      , [t,r] = function(m, g) {
                        const b = g.getSelectionAffectedTableCells(m)
                          , v = b[0]
                          , x = b.pop()
                          , T = [v, x];
                        return v.isBefore(x) ? T : T.reverse()
                    }(this.editor.model.document.selection, e)
                      , i = t.parent.parent
                      , l = [...new Ve(i)]
                      , d = {
                        first: l.find(m => m.cell === t).column,
                        last: l.find(m => m.cell === r).column
                    }
                      , h = function(m, g, b, v) {
                        return parseInt(b.getAttribute("colspan") || "1") > 1 ? b : g.previousSibling || b.nextSibling ? b.nextSibling || g.previousSibling : v.first ? m.reverse().find( ({column: x}) => x < v.first).cell : m.reverse().find( ({column: x}) => x > v.last).cell
                    }(l, t, r, d);
                    this.editor.model.change(m => {
                        const g = d.last - d.first + 1;
                        e.removeColumns(i, {
                            at: d.first,
                            columns: g
                        }),
                        m.setSelection(m.createPositionAt(h, 0))
                    }
                    )
                }
            }
            class w6 extends _e {
                refresh() {
                    const e = this.editor.plugins.get("TableUtils")
                      , t = this.editor.model
                      , r = e.getSelectionAffectedTableCells(t.document.selection)
                      , i = r.length > 0;
                    this.isEnabled = i,
                    this.value = i && r.every(l => this._isInHeading(l, l.parent.parent))
                }
                execute(e={}) {
                    if (e.forceValue === this.value)
                        return;
                    const t = this.editor.plugins.get("TableUtils")
                      , r = this.editor.model
                      , i = t.getSelectionAffectedTableCells(r.document.selection)
                      , l = i[0].findAncestor("table")
                      , {first: d, last: h} = t.getRowIndexes(i)
                      , m = this.value ? d : h + 1
                      , g = l.getAttribute("headingRows") || 0;
                    r.change(b => {
                        if (m) {
                            const v = O1(l, m, m > g ? g : 0);
                            for (const {cell: x} of v)
                                R1(x, m, b)
                        }
                        pt("headingRows", m, l, b, 0)
                    }
                    )
                }
                _isInHeading(e, t) {
                    const r = parseInt(t.getAttribute("headingRows") || "0");
                    return !!r && e.parent.index < r
                }
            }
            class A6 extends _e {
                refresh() {
                    const e = this.editor.model
                      , t = this.editor.plugins.get("TableUtils")
                      , r = t.getSelectionAffectedTableCells(e.document.selection)
                      , i = r.length > 0;
                    this.isEnabled = i,
                    this.value = i && r.every(l => Cg(t, l))
                }
                execute(e={}) {
                    if (e.forceValue === this.value)
                        return;
                    const t = this.editor.plugins.get("TableUtils")
                      , r = this.editor.model
                      , i = t.getSelectionAffectedTableCells(r.document.selection)
                      , l = i[0].findAncestor("table")
                      , {first: d, last: h} = t.getColumnIndexes(i)
                      , m = this.value ? d : h + 1;
                    r.change(g => {
                        if (m) {
                            const b = F1(l, m);
                            for (const {cell: v, column: x} of b)
                                V1(v, x, m, g)
                        }
                        pt("headingColumns", m, l, g, 0)
                    }
                    )
                }
            }
            function v6(s) {
                if (s.is("element", "tableColumnGroup"))
                    return s;
                const e = s.getChildren();
                return Array.from(e).find(t => t.is("element", "tableColumnGroup"))
            }
            function _6(s) {
                const e = v6(s);
                return e ? Array.from(e.getChildren()) : []
            }
            class Ht extends ie {
                static get pluginName() {
                    return "TableUtils"
                }
                init() {
                    this.decorate("insertColumns"),
                    this.decorate("insertRows")
                }
                getCellLocation(e) {
                    const t = e.parent
                      , r = t.parent
                      , i = r.getChildIndex(t)
                      , l = new Ve(r,{
                        row: i
                    });
                    for (const {cell: d, row: h, column: m} of l)
                        if (d === e)
                            return {
                                row: h,
                                column: m
                            }
                }
                createTable(e, t) {
                    const r = e.createElement("table")
                      , i = t.rows || 2
                      , l = t.columns || 2;
                    return Sg(e, r, 0, i, l),
                    t.headingRows && pt("headingRows", Math.min(t.headingRows, i), r, e, 0),
                    t.headingColumns && pt("headingColumns", Math.min(t.headingColumns, l), r, e, 0),
                    r
                }
                insertRows(e, t={}) {
                    const r = this.editor.model
                      , i = t.at || 0
                      , l = t.rows || 1
                      , d = t.copyStructureFromAbove !== void 0
                      , h = t.copyStructureFromAbove ? i - 1 : i
                      , m = this.getRows(e)
                      , g = this.getColumns(e);
                    if (i > m)
                        throw new U("tableutils-insertrows-insert-out-of-range",this,{
                            options: t
                        });
                    r.change(b => {
                        const v = e.getAttribute("headingRows") || 0;
                        if (v > i && pt("headingRows", v + l, e, b, 0),
                        !d && (i === 0 || i === m))
                            return void Sg(b, e, i, l, g);
                        const x = d ? Math.max(i, h) : i
                          , T = new Ve(e,{
                            endRow: x
                        })
                          , I = new Array(g).fill(1);
                        for (const {row: P, column: O, cellHeight: F, cellWidth: q, cell: Q} of T) {
                            const X = P + F - 1
                              , le = P <= h && h <= X;
                            P < i && i <= X ? (b.setAttribute("rowspan", F + l, Q),
                            I[O] = -q) : d && le && (I[O] = q)
                        }
                        for (let P = 0; P < l; P++) {
                            const O = b.createElement("tableRow");
                            b.insert(O, e, i);
                            for (let F = 0; F < I.length; F++) {
                                const q = I[F]
                                  , Q = b.createPositionAt(O, "end");
                                q > 0 && Ri(b, Q, q > 1 ? {
                                    colspan: q
                                } : void 0),
                                F += Math.abs(q) - 1
                            }
                        }
                    }
                    )
                }
                insertColumns(e, t={}) {
                    const r = this.editor.model
                      , i = t.at || 0
                      , l = t.columns || 1;
                    r.change(d => {
                        const h = e.getAttribute("headingColumns");
                        i < h && d.setAttribute("headingColumns", h + l, e);
                        const m = this.getColumns(e);
                        if (i === 0 || m === i) {
                            for (const b of e.getChildren())
                                b.is("element", "tableRow") && qs(l, d, d.createPositionAt(b, i ? "end" : 0));
                            return
                        }
                        const g = new Ve(e,{
                            column: i,
                            includeAllSlots: !0
                        });
                        for (const b of g) {
                            const {row: v, cell: x, cellAnchorColumn: T, cellAnchorRow: I, cellWidth: P, cellHeight: O} = b;
                            if (T < i) {
                                d.setAttribute("colspan", P + l, x);
                                const F = I + O - 1;
                                for (let q = v; q <= F; q++)
                                    g.skipRow(q)
                            } else
                                qs(l, d, b.getPositionBefore())
                        }
                    }
                    )
                }
                removeRows(e, t) {
                    const r = this.editor.model
                      , i = t.rows || 1
                      , l = this.getRows(e)
                      , d = t.at
                      , h = d + i - 1;
                    if (h > l - 1)
                        throw new U("tableutils-removerows-row-index-out-of-range",this,{
                            table: e,
                            options: t
                        });
                    r.change(m => {
                        const g = {
                            first: d,
                            last: h
                        }
                          , {cellsToMove: b, cellsToTrim: v} = function(x, {first: T, last: I}) {
                            const P = new Map
                              , O = [];
                            for (const {row: F, column: q, cellHeight: Q, cell: X} of new Ve(x,{
                                endRow: I
                            })) {
                                const le = F + Q - 1;
                                if (F >= T && F <= I && le > I) {
                                    const ge = Q - (I - F + 1);
                                    P.set(q, {
                                        cell: X,
                                        rowspan: ge
                                    })
                                }
                                if (F < T && le >= T) {
                                    let ge;
                                    ge = le >= I ? I - T + 1 : le - T + 1,
                                    O.push({
                                        cell: X,
                                        rowspan: Q - ge
                                    })
                                }
                            }
                            return {
                                cellsToMove: P,
                                cellsToTrim: O
                            }
                        }(e, g);
                        b.size && function(x, T, I, P) {
                            const O = new Ve(x,{
                                includeAllSlots: !0,
                                row: T
                            })
                              , F = [...O]
                              , q = x.getChild(T);
                            let Q;
                            for (const {column: X, cell: le, isAnchor: ge} of F)
                                if (I.has(X)) {
                                    const {cell: ke, rowspan: vt} = I.get(X)
                                      , Nt = Q ? P.createPositionAfter(Q) : P.createPositionAt(q, 0);
                                    P.move(P.createRangeOn(ke), Nt),
                                    pt("rowspan", vt, ke, P),
                                    Q = ke
                                } else
                                    ge && (Q = le)
                        }(e, h + 1, b, m);
                        for (let x = h; x >= d; x--)
                            m.remove(e.getChild(x));
                        for (const {rowspan: x, cell: T} of v)
                            pt("rowspan", x, T, m);
                        (function(x, {first: T, last: I}, P) {
                            const O = x.getAttribute("headingRows") || 0;
                            T < O && pt("headingRows", I < O ? O - (I - T + 1) : T, x, P, 0)
                        }
                        )(e, g, m),
                        yg(e, this) || xg(e, this)
                    }
                    )
                }
                removeColumns(e, t) {
                    const r = this.editor.model
                      , i = t.at
                      , l = t.columns || 1
                      , d = t.at + l - 1;
                    r.change(h => {
                        (function(g, b, v) {
                            const x = g.getAttribute("headingColumns") || 0;
                            if (x && b.first < x) {
                                const T = Math.min(x - 1, b.last) - b.first + 1;
                                v.setAttribute("headingColumns", x - T, g)
                            }
                        }
                        )(e, {
                            first: i,
                            last: d
                        }, h);
                        const m = _6(e);
                        for (let g = d; g >= i; g--) {
                            for (const {cell: b, column: v, cellWidth: x} of [...new Ve(e)])
                                v <= g && x > 1 && v + x > g ? pt("colspan", x - 1, b, h) : v === g && h.remove(b);
                            if (m[g]) {
                                const b = g === 0 ? m[1] : m[g - 1]
                                  , v = parseFloat(m[g].getAttribute("columnWidth"))
                                  , x = parseFloat(b.getAttribute("columnWidth"));
                                h.remove(m[g]),
                                h.setAttribute("columnWidth", v + x + "%", b)
                            }
                        }
                        xg(e, this) || yg(e, this)
                    }
                    )
                }
                splitCellVertically(e, t=2) {
                    const r = this.editor.model
                      , i = e.parent.parent
                      , l = parseInt(e.getAttribute("rowspan") || "1")
                      , d = parseInt(e.getAttribute("colspan") || "1");
                    r.change(h => {
                        if (d > 1) {
                            const {newCellsSpan: m, updatedSpan: g} = q1(d, t);
                            pt("colspan", g, e, h);
                            const b = {};
                            m > 1 && (b.colspan = m),
                            l > 1 && (b.rowspan = l),
                            qs(d > t ? t - 1 : d - 1, h, h.createPositionAfter(e), b)
                        }
                        if (d < t) {
                            const m = t - d
                              , g = [...new Ve(i)]
                              , {column: b} = g.find( ({cell: I}) => I === e)
                              , v = g.filter( ({cell: I, cellWidth: P, column: O}) => I !== e && O === b || O < b && O + P > b);
                            for (const {cell: I, cellWidth: P} of v)
                                h.setAttribute("colspan", P + m, I);
                            const x = {};
                            l > 1 && (x.rowspan = l),
                            qs(m, h, h.createPositionAfter(e), x);
                            const T = i.getAttribute("headingColumns") || 0;
                            T > b && pt("headingColumns", T + m, i, h)
                        }
                    }
                    )
                }
                splitCellHorizontally(e, t=2) {
                    const r = this.editor.model
                      , i = e.parent
                      , l = i.parent
                      , d = l.getChildIndex(i)
                      , h = parseInt(e.getAttribute("rowspan") || "1")
                      , m = parseInt(e.getAttribute("colspan") || "1");
                    r.change(g => {
                        if (h > 1) {
                            const b = [...new Ve(l,{
                                startRow: d,
                                endRow: d + h - 1,
                                includeAllSlots: !0
                            })]
                              , {newCellsSpan: v, updatedSpan: x} = q1(h, t);
                            pt("rowspan", x, e, g);
                            const {column: T} = b.find( ({cell: P}) => P === e)
                              , I = {};
                            v > 1 && (I.rowspan = v),
                            m > 1 && (I.colspan = m);
                            for (const P of b) {
                                const {column: O, row: F} = P;
                                F >= d + x && O === T && (F + d + x) % v == 0 && qs(1, g, P.getPositionBefore(), I)
                            }
                        }
                        if (h < t) {
                            const b = t - h
                              , v = [...new Ve(l,{
                                startRow: 0,
                                endRow: d
                            })];
                            for (const {cell: I, cellHeight: P, row: O} of v)
                                if (I !== e && O + P > d) {
                                    const F = P + b;
                                    g.setAttribute("rowspan", F, I)
                                }
                            const x = {};
                            m > 1 && (x.colspan = m),
                            Sg(g, l, d + 1, b, 1, x);
                            const T = l.getAttribute("headingRows") || 0;
                            T > d && pt("headingRows", T + b, l, g)
                        }
                    }
                    )
                }
                getColumns(e) {
                    return [...e.getChild(0).getChildren()].filter(t => t.is("element", "tableCell")).reduce( (t, r) => t + parseInt(r.getAttribute("colspan") || "1"), 0)
                }
                getRows(e) {
                    return Array.from(e.getChildren()).reduce( (t, r) => r.is("element", "tableRow") ? t + 1 : t, 0)
                }
                createTableWalker(e, t={}) {
                    return new Ve(e,t)
                }
                getSelectedTableCells(e) {
                    const t = [];
                    for (const r of this.sortRanges(e.getRanges())) {
                        const i = r.getContainedElement();
                        i && i.is("element", "tableCell") && t.push(i)
                    }
                    return t
                }
                getTableCellsContainingSelection(e) {
                    const t = [];
                    for (const r of e.getRanges()) {
                        const i = r.start.findAncestor("tableCell");
                        i && t.push(i)
                    }
                    return t
                }
                getSelectionAffectedTableCells(e) {
                    const t = this.getSelectedTableCells(e);
                    return t.length ? t : this.getTableCellsContainingSelection(e)
                }
                getRowIndexes(e) {
                    const t = e.map(r => r.parent.index);
                    return this._getFirstLastIndexesObject(t)
                }
                getColumnIndexes(e) {
                    const t = e[0].findAncestor("table")
                      , r = [...new Ve(t)].filter(i => e.includes(i.cell)).map(i => i.column);
                    return this._getFirstLastIndexesObject(r)
                }
                isSelectionRectangular(e) {
                    if (e.length < 2 || !this._areCellInTheSameTableSection(e))
                        return !1;
                    const t = new Set
                      , r = new Set;
                    let i = 0;
                    for (const l of e) {
                        const {row: d, column: h} = this.getCellLocation(l)
                          , m = parseInt(l.getAttribute("rowspan")) || 1
                          , g = parseInt(l.getAttribute("colspan")) || 1;
                        t.add(d),
                        r.add(h),
                        m > 1 && t.add(d + m - 1),
                        g > 1 && r.add(h + g - 1),
                        i += m * g
                    }
                    return function(l, d) {
                        const h = Array.from(l.values())
                          , m = Array.from(d.values())
                          , g = Math.max(...h)
                          , b = Math.min(...h)
                          , v = Math.max(...m)
                          , x = Math.min(...m);
                        return (g - b + 1) * (v - x + 1)
                    }(t, r) == i
                }
                sortRanges(e) {
                    return Array.from(e).sort(C6)
                }
                _getFirstLastIndexesObject(e) {
                    const t = e.sort( (r, i) => r - i);
                    return {
                        first: t[0],
                        last: t[t.length - 1]
                    }
                }
                _areCellInTheSameTableSection(e) {
                    const t = e[0].findAncestor("table")
                      , r = this.getRowIndexes(e)
                      , i = parseInt(t.getAttribute("headingRows")) || 0;
                    if (!this._areIndexesInSameSection(r, i))
                        return !1;
                    const l = this.getColumnIndexes(e)
                      , d = parseInt(t.getAttribute("headingColumns")) || 0;
                    return this._areIndexesInSameSection(l, d)
                }
                _areIndexesInSameSection({first: e, last: t}, r) {
                    return e < r == t < r
                }
            }
            function Sg(s, e, t, r, i, l={}) {
                for (let d = 0; d < r; d++) {
                    const h = s.createElement("tableRow");
                    s.insert(h, e, t),
                    qs(i, s, s.createPositionAt(h, "end"), l)
                }
            }
            function qs(s, e, t, r={}) {
                for (let i = 0; i < s; i++)
                    Ri(e, t, r)
            }
            function q1(s, e) {
                if (s < e)
                    return {
                        newCellsSpan: 1,
                        updatedSpan: 1
                    };
                const t = Math.floor(s / e);
                return {
                    newCellsSpan: t,
                    updatedSpan: s - t * e + t
                }
            }
            function C6(s, e) {
                const t = s.start
                  , r = e.start;
                return t.isBefore(r) ? -1 : 1
            }
            class y6 extends _e {
                refresh() {
                    const e = this.editor.plugins.get(Ht)
                      , t = e.getSelectedTableCells(this.editor.model.document.selection);
                    this.isEnabled = e.isSelectionRectangular(t)
                }
                execute() {
                    const e = this.editor.model
                      , t = this.editor.plugins.get(Ht);
                    e.change(r => {
                        const i = t.getSelectedTableCells(e.document.selection)
                          , l = i.shift()
                          , {mergeWidth: d, mergeHeight: h} = function(m, g, b) {
                            let v = 0
                              , x = 0;
                            for (const F of g) {
                                const {row: q, column: Q} = b.getCellLocation(F);
                                v = K1(F, Q, v, "colspan"),
                                x = K1(F, q, x, "rowspan")
                            }
                            const {row: T, column: I} = b.getCellLocation(m)
                              , P = v - I
                              , O = x - T;
                            return {
                                mergeWidth: P,
                                mergeHeight: O
                            }
                        }(l, i, t);
                        pt("colspan", d, l, r),
                        pt("rowspan", h, l, r);
                        for (const m of i)
                            x6(m, l, r);
                        Eg(l.findAncestor("table"), t),
                        r.setSelection(l, "in")
                    }
                    )
                }
            }
            function x6(s, e, t) {
                G1(s) || (G1(e) && t.remove(t.createRangeIn(e)),
                t.move(t.createRangeIn(s), t.createPositionAt(e, "end"))),
                t.remove(s)
            }
            function G1(s) {
                const e = s.getChild(0);
                return s.childCount == 1 && e.is("element", "paragraph") && e.isEmpty
            }
            function K1(s, e, t, r) {
                const i = parseInt(s.getAttribute(r) || "1");
                return Math.max(t, e + i)
            }
            class E6 extends _e {
                constructor(e) {
                    super(e),
                    this.affectsData = !1
                }
                refresh() {
                    const e = this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(this.editor.model.document.selection);
                    this.isEnabled = e.length > 0
                }
                execute() {
                    const e = this.editor.model
                      , t = this.editor.plugins.get("TableUtils")
                      , r = t.getSelectionAffectedTableCells(e.document.selection)
                      , i = t.getRowIndexes(r)
                      , l = r[0].findAncestor("table")
                      , d = [];
                    for (let h = i.first; h <= i.last; h++)
                        for (const m of l.getChild(h).getChildren())
                            d.push(e.createRangeOn(m));
                    e.change(h => {
                        h.setSelection(d)
                    }
                    )
                }
            }
            class S6 extends _e {
                constructor(e) {
                    super(e),
                    this.affectsData = !1
                }
                refresh() {
                    const e = this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(this.editor.model.document.selection);
                    this.isEnabled = e.length > 0
                }
                execute() {
                    const e = this.editor.plugins.get("TableUtils")
                      , t = this.editor.model
                      , r = e.getSelectionAffectedTableCells(t.document.selection)
                      , i = r[0]
                      , l = r.pop()
                      , d = i.findAncestor("table")
                      , h = e.getCellLocation(i)
                      , m = e.getCellLocation(l)
                      , g = Math.min(h.column, m.column)
                      , b = Math.max(h.column, m.column)
                      , v = [];
                    for (const x of new Ve(d,{
                        startColumn: g,
                        endColumn: b
                    }))
                        v.push(t.createRangeOn(x.cell));
                    t.change(x => {
                        x.setSelection(v)
                    }
                    )
                }
            }
            function D6(s) {
                s.document.registerPostFixer(e => function(t, r) {
                    const i = r.document.differ.getChanges();
                    let l = !1;
                    const d = new Set;
                    for (const h of i) {
                        let m = null;
                        h.type == "insert" && h.name == "table" && (m = h.position.nodeAfter),
                        h.type != "insert" && h.type != "remove" || h.name != "tableRow" && h.name != "tableCell" || (m = h.position.findAncestor("table")),
                        M6(h) && (m = h.range.start.findAncestor("table")),
                        m && !d.has(m) && (l = T6(m, t) || l,
                        l = I6(m, t) || l,
                        d.add(m))
                    }
                    return l
                }(e, s))
            }
            function T6(s, e) {
                let t = !1;
                const r = function(i) {
                    const l = parseInt(i.getAttribute("headingRows") || "0")
                      , d = Array.from(i.getChildren()).reduce( (m, g) => g.is("element", "tableRow") ? m + 1 : m, 0)
                      , h = [];
                    for (const {row: m, cell: g, cellHeight: b} of new Ve(i)) {
                        if (b < 2)
                            continue;
                        const v = m < l ? l : d;
                        if (m + b > v) {
                            const x = v - m;
                            h.push({
                                cell: g,
                                rowspan: x
                            })
                        }
                    }
                    return h
                }(s);
                if (r.length) {
                    t = !0;
                    for (const i of r)
                        pt("rowspan", i.rowspan, i.cell, e, 1)
                }
                return t
            }
            function I6(s, e) {
                let t = !1;
                const r = function(h) {
                    const m = new Array(h.childCount).fill(0);
                    for (const {rowIndex: g} of new Ve(h,{
                        includeAllSlots: !0
                    }))
                        m[g]++;
                    return m
                }(s)
                  , i = [];
                for (const [h,m] of r.entries())
                    !m && s.getChild(h).is("element", "tableRow") && i.push(h);
                if (i.length) {
                    t = !0;
                    for (const h of i.reverse())
                        e.remove(s.getChild(h)),
                        r.splice(h, 1)
                }
                const l = r.filter( (h, m) => s.getChild(m).is("element", "tableRow"))
                  , d = l[0];
                if (!l.every(h => h === d)) {
                    const h = l.reduce( (m, g) => g > m ? g : m, 0);
                    for (const [m,g] of l.entries()) {
                        const b = h - g;
                        if (b) {
                            for (let v = 0; v < b; v++)
                                Ri(e, e.createPositionAt(s.getChild(m), "end"));
                            t = !0
                        }
                    }
                }
                return t
            }
            function M6(s) {
                if (s.type !== "attribute")
                    return !1;
                const e = s.attributeKey;
                return e === "headingRows" || e === "colspan" || e === "rowspan"
            }
            function B6(s) {
                s.document.registerPostFixer(e => function(t, r) {
                    const i = r.document.differ.getChanges();
                    let l = !1;
                    for (const d of i)
                        d.type == "insert" && d.name == "table" && (l = N6(d.position.nodeAfter, t) || l),
                        d.type == "insert" && d.name == "tableRow" && (l = Y1(d.position.nodeAfter, t) || l),
                        d.type == "insert" && d.name == "tableCell" && (l = Dg(d.position.nodeAfter, t) || l),
                        d.type != "remove" && d.type != "insert" || !P6(d) || (l = Dg(d.position.parent, t) || l);
                    return l
                }(e, s))
            }
            function N6(s, e) {
                let t = !1;
                for (const r of s.getChildren())
                    r.is("element", "tableRow") && (t = Y1(r, e) || t);
                return t
            }
            function Y1(s, e) {
                let t = !1;
                for (const r of s.getChildren())
                    t = Dg(r, e) || t;
                return t
            }
            function Dg(s, e) {
                if (s.childCount == 0)
                    return e.insertElement("paragraph", s),
                    !0;
                const t = Array.from(s.getChildren()).filter(r => r.is("$text"));
                for (const r of t)
                    e.wrap(e.createRangeOn(r), "paragraph");
                return !!t.length
            }
            function P6(s) {
                return !!s.position.parent.is("element", "tableCell") && (s.type == "insert" && s.name == "$text" || s.type == "remove")
            }
            function j6(s, e) {
                if (!s.is("element", "paragraph"))
                    return !1;
                const t = e.toViewElement(s);
                return !!t && N1(s) !== t.is("element", "span")
            }
            var Q1 = u(8137)
              , L6 = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(Q1.A, L6),
            Q1.A.locals;
            class z6 extends ie {
                constructor(e) {
                    super(e),
                    C(this, "_additionalSlots"),
                    this._additionalSlots = []
                }
                static get pluginName() {
                    return "TableEditing"
                }
                static get requires() {
                    return [Ht]
                }
                init() {
                    const e = this.editor
                      , t = e.model
                      , r = t.schema
                      , i = e.conversion
                      , l = e.plugins.get(Ht);
                    r.register("table", {
                        inheritAllFrom: "$blockObject",
                        allowAttributes: ["headingRows", "headingColumns"]
                    }),
                    r.register("tableRow", {
                        allowIn: "table",
                        isLimit: !0
                    }),
                    r.register("tableCell", {
                        allowContentOf: "$container",
                        allowIn: "tableRow",
                        allowAttributes: ["colspan", "rowspan"],
                        isLimit: !0,
                        isSelectable: !0
                    }),
                    i.for("upcast").add(d => {
                        d.on("element:figure", (h, m, g) => {
                            if (!g.consumable.test(m.viewItem, {
                                name: !0,
                                classes: "table"
                            }))
                                return;
                            const b = function(x) {
                                for (const T of x.getChildren())
                                    if (T.is("element", "table"))
                                        return T
                            }(m.viewItem);
                            if (!b || !g.consumable.test(b, {
                                name: !0
                            }))
                                return;
                            g.consumable.consume(m.viewItem, {
                                name: !0,
                                classes: "table"
                            });
                            const v = zt(g.convertItem(b, m.modelCursor).modelRange.getItems());
                            v ? (g.convertChildren(m.viewItem, g.writer.createPositionAt(v, "end")),
                            g.updateConversionResult(v, m)) : g.consumable.revert(m.viewItem, {
                                name: !0,
                                classes: "table"
                            })
                        }
                        )
                    }
                    ),
                    i.for("upcast").add(m6()),
                    i.for("editingDowncast").elementToStructure({
                        model: {
                            name: "table",
                            attributes: ["headingRows"]
                        },
                        view: I1(l, {
                            asWidget: !0,
                            additionalSlots: this._additionalSlots
                        })
                    }),
                    i.for("dataDowncast").elementToStructure({
                        model: {
                            name: "table",
                            attributes: ["headingRows"]
                        },
                        view: I1(l, {
                            additionalSlots: this._additionalSlots
                        })
                    }),
                    i.for("upcast").elementToElement({
                        model: "tableRow",
                        view: "tr"
                    }),
                    i.for("upcast").add(d => {
                        d.on("element:tr", (h, m) => {
                            m.viewItem.isEmpty && m.modelCursor.index == 0 && h.stop()
                        }
                        , {
                            priority: "high"
                        })
                    }
                    ),
                    i.for("downcast").elementToElement({
                        model: "tableRow",
                        view: (d, {writer: h}) => d.isEmpty ? h.createEmptyElement("tr") : h.createContainerElement("tr")
                    }),
                    i.for("upcast").elementToElement({
                        model: "tableCell",
                        view: "td"
                    }),
                    i.for("upcast").elementToElement({
                        model: "tableCell",
                        view: "th"
                    }),
                    i.for("upcast").add(T1("td")),
                    i.for("upcast").add(T1("th")),
                    i.for("editingDowncast").elementToElement({
                        model: "tableCell",
                        view: M1({
                            asWidget: !0
                        })
                    }),
                    i.for("dataDowncast").elementToElement({
                        model: "tableCell",
                        view: M1()
                    }),
                    i.for("editingDowncast").elementToElement({
                        model: "paragraph",
                        view: B1({
                            asWidget: !0
                        }),
                        converterPriority: "high"
                    }),
                    i.for("dataDowncast").elementToElement({
                        model: "paragraph",
                        view: B1(),
                        converterPriority: "high"
                    }),
                    i.for("downcast").attributeToAttribute({
                        model: "colspan",
                        view: "colspan"
                    }),
                    i.for("upcast").attributeToAttribute({
                        model: {
                            key: "colspan",
                            value: Z1("colspan")
                        },
                        view: "colspan"
                    }),
                    i.for("downcast").attributeToAttribute({
                        model: "rowspan",
                        view: "rowspan"
                    }),
                    i.for("upcast").attributeToAttribute({
                        model: {
                            key: "rowspan",
                            value: Z1("rowspan")
                        },
                        view: "rowspan"
                    }),
                    e.config.define("table.defaultHeadings.rows", 0),
                    e.config.define("table.defaultHeadings.columns", 0),
                    e.commands.add("insertTable", new f6(e)),
                    e.commands.add("insertTableRowAbove", new P1(e,{
                        order: "above"
                    })),
                    e.commands.add("insertTableRowBelow", new P1(e,{
                        order: "below"
                    })),
                    e.commands.add("insertTableColumnLeft", new j1(e,{
                        order: "left"
                    })),
                    e.commands.add("insertTableColumnRight", new j1(e,{
                        order: "right"
                    })),
                    e.commands.add("removeTableRow", new k6(e)),
                    e.commands.add("removeTableColumn", new b6(e)),
                    e.commands.add("splitTableCellVertically", new L1(e,{
                        direction: "vertically"
                    })),
                    e.commands.add("splitTableCellHorizontally", new L1(e,{
                        direction: "horizontally"
                    })),
                    e.commands.add("mergeTableCells", new y6(e)),
                    e.commands.add("mergeTableCellRight", new Du(e,{
                        direction: "right"
                    })),
                    e.commands.add("mergeTableCellLeft", new Du(e,{
                        direction: "left"
                    })),
                    e.commands.add("mergeTableCellDown", new Du(e,{
                        direction: "down"
                    })),
                    e.commands.add("mergeTableCellUp", new Du(e,{
                        direction: "up"
                    })),
                    e.commands.add("setTableColumnHeader", new A6(e)),
                    e.commands.add("setTableRowHeader", new w6(e)),
                    e.commands.add("selectTableRow", new E6(e)),
                    e.commands.add("selectTableColumn", new S6(e)),
                    D6(t),
                    B6(t),
                    this.listenTo(t.document, "change:data", () => {
                        (function(d, h) {
                            const m = d.document.differ;
                            for (const g of m.getChanges()) {
                                let b, v = !1;
                                if (g.type == "attribute") {
                                    const P = g.range.start.nodeAfter;
                                    if (!P || !P.is("element", "table") || g.attributeKey != "headingRows" && g.attributeKey != "headingColumns")
                                        continue;
                                    b = P,
                                    v = g.attributeKey == "headingRows"
                                } else
                                    g.name != "tableRow" && g.name != "tableCell" || (b = g.position.findAncestor("table"),
                                    v = g.name == "tableRow");
                                if (!b)
                                    continue;
                                const x = b.getAttribute("headingRows") || 0
                                  , T = b.getAttribute("headingColumns") || 0
                                  , I = new Ve(b);
                                for (const P of I) {
                                    const O = P.row < x || P.column < T ? "th" : "td"
                                      , F = h.mapper.toViewElement(P.cell);
                                    F && F.is("element") && F.name != O && h.reconvertItem(v ? P.cell.parent : P.cell)
                                }
                            }
                        }
                        )(t, e.editing),
                        function(d, h) {
                            const m = d.document.differ
                              , g = new Set;
                            for (const b of m.getChanges()) {
                                const v = b.type == "attribute" ? b.range.start.parent : b.position.parent;
                                v.is("element", "tableCell") && g.add(v)
                            }
                            for (const b of g.values()) {
                                const v = Array.from(b.getChildren()).filter(x => j6(x, h.mapper));
                                for (const x of v)
                                    h.reconvertItem(x)
                            }
                        }(t, e.editing)
                    }
                    )
                }
                registerAdditionalSlot(e) {
                    this._additionalSlots.push(e)
                }
            }
            function Z1(s) {
                return e => {
                    const t = parseInt(e.getAttribute(s));
                    return Number.isNaN(t) || t <= 0 ? null : t
                }
            }
            var J1 = u(5032)
              , O6 = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(J1.A, O6),
            J1.A.locals;
            class X1 extends pe {
                constructor(e) {
                    super(e),
                    C(this, "items"),
                    C(this, "keystrokes"),
                    C(this, "focusTracker");
                    const t = this.bindTemplate;
                    this.items = this._createGridCollection(),
                    this.keystrokes = new lo,
                    this.focusTracker = new Jt,
                    this.set("rows", 0),
                    this.set("columns", 0),
                    this.bind("label").to(this, "columns", this, "rows", (r, i) => `${i} × ${r}`),
                    this.setTemplate({
                        tag: "div",
                        attributes: {
                            class: ["ck"]
                        },
                        children: [{
                            tag: "div",
                            attributes: {
                                class: ["ck-insert-table-dropdown__grid"]
                            },
                            on: {
                                "mouseover@.ck-insert-table-dropdown-grid-box": t.to("boxover")
                            },
                            children: this.items
                        }, {
                            tag: "div",
                            attributes: {
                                class: ["ck", "ck-insert-table-dropdown__label"],
                                "aria-hidden": !0
                            },
                            children: [{
                                text: t.to("label")
                            }]
                        }],
                        on: {
                            mousedown: t.to(r => {
                                r.preventDefault()
                            }
                            ),
                            click: t.to( () => {
                                this.fire("execute")
                            }
                            )
                        }
                    }),
                    this.on("boxover", (r, i) => {
                        const {row: l, column: d} = i.target.dataset;
                        this.items.get(10 * (parseInt(l, 10) - 1) + (parseInt(d, 10) - 1)).focus()
                    }
                    ),
                    this.focusTracker.on("change:focusedElement", (r, i, l) => {
                        if (!l)
                            return;
                        const {row: d, column: h} = l.dataset;
                        this.set({
                            rows: parseInt(d),
                            columns: parseInt(h)
                        })
                    }
                    ),
                    this.on("change:columns", () => this._highlightGridBoxes()),
                    this.on("change:rows", () => this._highlightGridBoxes())
                }
                render() {
                    super.render(),
                    L4({
                        keystrokeHandler: this.keystrokes,
                        focusTracker: this.focusTracker,
                        gridItems: this.items,
                        numberOfColumns: 10,
                        uiLanguageDirection: this.locale && this.locale.uiLanguageDirection
                    });
                    for (const e of this.items)
                        this.focusTracker.add(e.element);
                    this.keystrokes.listenTo(this.element)
                }
                reset() {
                    this.set({
                        rows: 1,
                        columns: 1
                    })
                }
                focus() {
                    this.items.get(0).focus()
                }
                focusLast() {
                    this.items.get(0).focus()
                }
                _highlightGridBoxes() {
                    const e = this.rows
                      , t = this.columns;
                    this.items.map( (r, i) => {
                        const l = Math.floor(i / 10) < e && i % 10 < t;
                        r.set("isOn", l)
                    }
                    )
                }
                _createGridButton(e, t, r, i) {
                    const l = new Te(e);
                    return l.set({
                        label: i,
                        class: "ck-insert-table-dropdown-grid-box"
                    }),
                    l.extendTemplate({
                        attributes: {
                            "data-row": t,
                            "data-column": r
                        }
                    }),
                    l
                }
                _createGridCollection() {
                    const e = [];
                    for (let t = 0; t < 100; t++) {
                        const r = Math.floor(t / 10)
                          , i = t % 10
                          , l = `${r + 1} × ${i + 1}`;
                        e.push(this._createGridButton(this.locale, r + 1, i + 1, l))
                    }
                    return this.createCollection(e)
                }
            }
            class R6 extends ie {
                static get pluginName() {
                    return "TableUI"
                }
                init() {
                    const e = this.editor
                      , t = this.editor.t
                      , r = e.locale.contentLanguageDirection === "ltr";
                    e.ui.componentFactory.add("insertTable", i => {
                        const l = e.commands.get("insertTable")
                          , d = Nn(i);
                        let h;
                        return d.bind("isEnabled").to(l),
                        d.buttonView.set({
                            icon: he.table,
                            label: t("Insert table"),
                            tooltip: !0
                        }),
                        d.on("change:isOpen", () => {
                            h || (h = new X1(i),
                            d.panelView.children.add(h),
                            h.delegate("execute").to(d),
                            d.on("execute", () => {
                                e.execute("insertTable", {
                                    rows: h.rows,
                                    columns: h.columns
                                }),
                                e.editing.view.focus()
                            }
                            ))
                        }
                        ),
                        d
                    }
                    ),
                    e.ui.componentFactory.add("menuBar:insertTable", i => {
                        const l = e.commands.get("insertTable")
                          , d = new Os(i)
                          , h = new X1(i);
                        return h.delegate("execute").to(d),
                        d.on("change:isOpen", (m, g, b) => {
                            b || h.reset()
                        }
                        ),
                        h.on("execute", () => {
                            e.execute("insertTable", {
                                rows: h.rows,
                                columns: h.columns
                            }),
                            e.editing.view.focus()
                        }
                        ),
                        d.buttonView.set({
                            label: t("Table"),
                            icon: he.table
                        }),
                        d.panelView.children.add(h),
                        d.bind("isEnabled").to(l),
                        d
                    }
                    ),
                    e.ui.componentFactory.add("tableColumn", i => {
                        const l = [{
                            type: "switchbutton",
                            model: {
                                commandName: "setTableColumnHeader",
                                label: t("Header column"),
                                bindIsOn: !0
                            }
                        }, {
                            type: "separator"
                        }, {
                            type: "button",
                            model: {
                                commandName: r ? "insertTableColumnLeft" : "insertTableColumnRight",
                                label: t("Insert column left")
                            }
                        }, {
                            type: "button",
                            model: {
                                commandName: r ? "insertTableColumnRight" : "insertTableColumnLeft",
                                label: t("Insert column right")
                            }
                        }, {
                            type: "button",
                            model: {
                                commandName: "removeTableColumn",
                                label: t("Delete column")
                            }
                        }, {
                            type: "button",
                            model: {
                                commandName: "selectTableColumn",
                                label: t("Select column")
                            }
                        }];
                        return this._prepareDropdown(t("Column"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M18 7v1H2V7h16zm0 5v1H2v-1h16z" opacity=".6"/><path d="M14 1v18a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V1a1 1 0 0 1 1-1h6a1 1 0 0 1 1 1zm-2 1H8v4h4V2zm0 6H8v4h4V8zm0 6H8v4h4v-4z"/></svg>', l, i)
                    }
                    ),
                    e.ui.componentFactory.add("tableRow", i => {
                        const l = [{
                            type: "switchbutton",
                            model: {
                                commandName: "setTableRowHeader",
                                label: t("Header row"),
                                bindIsOn: !0
                            }
                        }, {
                            type: "separator"
                        }, {
                            type: "button",
                            model: {
                                commandName: "insertTableRowAbove",
                                label: t("Insert row above")
                            }
                        }, {
                            type: "button",
                            model: {
                                commandName: "insertTableRowBelow",
                                label: t("Insert row below")
                            }
                        }, {
                            type: "button",
                            model: {
                                commandName: "removeTableRow",
                                label: t("Delete row")
                            }
                        }, {
                            type: "button",
                            model: {
                                commandName: "selectTableRow",
                                label: t("Select row")
                            }
                        }];
                        return this._prepareDropdown(t("Row"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M7 2h1v16H7V2zm5 0h1v16h-1V2z" opacity=".6"/><path d="M1 6h18a1 1 0 0 1 1 1v6a1 1 0 0 1-1 1H1a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1zm1 2v4h4V8H2zm6 0v4h4V8H8zm6 0v4h4V8h-4z"/></svg>', l, i)
                    }
                    ),
                    e.ui.componentFactory.add("mergeTableCells", i => {
                        const l = [{
                            type: "button",
                            model: {
                                commandName: "mergeTableCellUp",
                                label: t("Merge cell up")
                            }
                        }, {
                            type: "button",
                            model: {
                                commandName: r ? "mergeTableCellRight" : "mergeTableCellLeft",
                                label: t("Merge cell right")
                            }
                        }, {
                            type: "button",
                            model: {
                                commandName: "mergeTableCellDown",
                                label: t("Merge cell down")
                            }
                        }, {
                            type: "button",
                            model: {
                                commandName: r ? "mergeTableCellLeft" : "mergeTableCellRight",
                                label: t("Merge cell left")
                            }
                        }, {
                            type: "separator"
                        }, {
                            type: "button",
                            model: {
                                commandName: "splitTableCellVertically",
                                label: t("Split cell vertically")
                            }
                        }, {
                            type: "button",
                            model: {
                                commandName: "splitTableCellHorizontally",
                                label: t("Split cell horizontally")
                            }
                        }];
                        return this._prepareMergeSplitButtonDropdown(t("Merge cells"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M7 2h1v16H7V2zm5 0h1v7h-1V2zm6 5v1H2V7h16zM8 12v1H2v-1h6z" opacity=".6"/><path d="M7 7h12a1 1 0 0 1 1 1v11a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V8a1 1 0 0 1 1-1zm1 2v9h10V9H8z"/></svg>', l, i)
                    }
                    )
                }
                _prepareDropdown(e, t, r, i) {
                    const l = this.editor
                      , d = Nn(i)
                      , h = this._fillDropdownWithListOptions(d, r);
                    return d.buttonView.set({
                        label: e,
                        icon: t,
                        tooltip: !0
                    }),
                    d.bind("isEnabled").toMany(h, "isEnabled", (...m) => m.some(g => g)),
                    this.listenTo(d, "execute", m => {
                        l.execute(m.source.commandName),
                        m.source instanceof Jd || l.editing.view.focus()
                    }
                    ),
                    d
                }
                _prepareMergeSplitButtonDropdown(e, t, r, i) {
                    const l = this.editor
                      , d = Nn(i, tu)
                      , h = "mergeTableCells"
                      , m = l.commands.get(h)
                      , g = this._fillDropdownWithListOptions(d, r);
                    return d.buttonView.set({
                        label: e,
                        icon: t,
                        tooltip: !0,
                        isEnabled: !0
                    }),
                    d.bind("isEnabled").toMany([m, ...g], "isEnabled", (...b) => b.some(v => v)),
                    this.listenTo(d.buttonView, "execute", () => {
                        l.execute(h),
                        l.editing.view.focus()
                    }
                    ),
                    this.listenTo(d, "execute", b => {
                        l.execute(b.source.commandName),
                        l.editing.view.focus()
                    }
                    ),
                    d
                }
                _fillDropdownWithListOptions(e, t) {
                    const r = this.editor
                      , i = []
                      , l = new dr;
                    for (const d of t)
                        F6(d, r, i, l);
                    return RC(e, l),
                    i
                }
            }
            function F6(s, e, t, r) {
                if (s.type === "button" || s.type === "switchbutton") {
                    const i = s.model = new ty(s.model)
                      , {commandName: l, bindIsOn: d} = s.model
                      , h = e.commands.get(l);
                    t.push(h),
                    i.set({
                        commandName: l
                    }),
                    i.bind("isEnabled").to(h),
                    d && i.bind("isOn").to(h, "value"),
                    i.set({
                        withText: !0
                    })
                }
                r.add(s)
            }
            var eE = u(8423)
              , V6 = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(eE.A, V6),
            eE.A.locals;
            class Fi extends ie {
                static get pluginName() {
                    return "TableSelection"
                }
                static get requires() {
                    return [Ht, Ht]
                }
                init() {
                    const e = this.editor
                      , t = e.model
                      , r = e.editing.view;
                    this.listenTo(t, "deleteContent", (i, l) => this._handleDeleteContent(i, l), {
                        priority: "high"
                    }),
                    this.listenTo(r.document, "insertText", (i, l) => this._handleInsertTextEvent(i, l), {
                        priority: "high"
                    }),
                    this._defineSelectionConverter(),
                    this._enablePluginDisabling()
                }
                getSelectedTableCells() {
                    const e = this.editor.plugins.get(Ht)
                      , t = this.editor.model.document.selection
                      , r = e.getSelectedTableCells(t);
                    return r.length == 0 ? null : r
                }
                getSelectionAsFragment() {
                    const e = this.editor.plugins.get(Ht)
                      , t = this.getSelectedTableCells();
                    return t ? this.editor.model.change(r => {
                        const i = r.createDocumentFragment()
                          , {first: l, last: d} = e.getColumnIndexes(t)
                          , {first: h, last: m} = e.getRowIndexes(t)
                          , g = t[0].findAncestor("table");
                        let b = m
                          , v = d;
                        if (e.isSelectionRectangular(t)) {
                            const T = {
                                firstColumn: l,
                                lastColumn: d,
                                firstRow: h,
                                lastRow: m
                            };
                            b = H1(g, T),
                            v = W1(g, T)
                        }
                        const x = z1(g, {
                            startRow: h,
                            startColumn: l,
                            endRow: b,
                            endColumn: v
                        }, r);
                        return r.insert(x, i, 0),
                        i
                    }
                    ) : null
                }
                setCellSelection(e, t) {
                    const r = this._getCellsToSelect(e, t);
                    this.editor.model.change(i => {
                        i.setSelection(r.cells.map(l => i.createRangeOn(l)), {
                            backward: r.backward
                        })
                    }
                    )
                }
                getFocusCell() {
                    const e = [...this.editor.model.document.selection.getRanges()].pop().getContainedElement();
                    return e && e.is("element", "tableCell") ? e : null
                }
                getAnchorCell() {
                    const e = zt(this.editor.model.document.selection.getRanges()).getContainedElement();
                    return e && e.is("element", "tableCell") ? e : null
                }
                _defineSelectionConverter() {
                    const e = this.editor
                      , t = new Set;
                    e.conversion.for("editingDowncast").add(r => r.on("selection", (i, l, d) => {
                        const h = d.writer;
                        (function(b) {
                            for (const v of t)
                                b.removeClass("ck-editor__editable_selected", v);
                            t.clear()
                        }
                        )(h);
                        const m = this.getSelectedTableCells();
                        if (!m)
                            return;
                        for (const b of m) {
                            const v = d.mapper.toViewElement(b);
                            h.addClass("ck-editor__editable_selected", v),
                            t.add(v)
                        }
                        const g = d.mapper.toViewElement(m[m.length - 1]);
                        h.setSelection(g, 0)
                    }
                    , {
                        priority: "lowest"
                    }))
                }
                _enablePluginDisabling() {
                    const e = this.editor;
                    this.on("change:isEnabled", () => {
                        if (!this.isEnabled) {
                            const t = this.getSelectedTableCells();
                            if (!t)
                                return;
                            e.model.change(r => {
                                const i = r.createPositionAt(t[0], 0)
                                  , l = e.model.schema.getNearestSelectionRange(i);
                                r.setSelection(l)
                            }
                            )
                        }
                    }
                    )
                }
                _handleDeleteContent(e, t) {
                    const r = this.editor.plugins.get(Ht)
                      , i = t[0]
                      , l = t[1]
                      , d = this.editor.model
                      , h = !l || l.direction == "backward"
                      , m = r.getSelectedTableCells(i);
                    m.length && (e.stop(),
                    d.change(g => {
                        const b = m[h ? m.length - 1 : 0];
                        d.change(x => {
                            for (const T of m)
                                d.deleteContent(x.createSelection(T, "in"))
                        }
                        );
                        const v = d.schema.getNearestSelectionRange(g.createPositionAt(b, 0));
                        i.is("documentSelection") ? g.setSelection(v) : i.setTo(v)
                    }
                    ))
                }
                _handleInsertTextEvent(e, t) {
                    const r = this.editor
                      , i = this.getSelectedTableCells();
                    if (!i)
                        return;
                    const l = r.editing.view
                      , d = r.editing.mapper
                      , h = i.map(m => l.createRangeOn(d.toViewElement(m)));
                    t.selection = l.createSelection(h)
                }
                _getCellsToSelect(e, t) {
                    const r = this.editor.plugins.get("TableUtils")
                      , i = r.getCellLocation(e)
                      , l = r.getCellLocation(t)
                      , d = Math.min(i.row, l.row)
                      , h = Math.max(i.row, l.row)
                      , m = Math.min(i.column, l.column)
                      , g = Math.max(i.column, l.column)
                      , b = new Array(h - d + 1).fill(null).map( () => [])
                      , v = {
                        startRow: d,
                        endRow: h,
                        startColumn: m,
                        endColumn: g
                    };
                    for (const {row: I, cell: P} of new Ve(e.findAncestor("table"),v))
                        b[I - d].push(P);
                    const x = l.row < i.row
                      , T = l.column < i.column;
                    return x && b.reverse(),
                    T && b.forEach(I => I.reverse()),
                    {
                        cells: b.flat(),
                        backward: x || T
                    }
                }
            }
            class U6 extends ie {
                static get pluginName() {
                    return "TableClipboard"
                }
                static get requires() {
                    return [Ml, Ko, Fi, Ht]
                }
                init() {
                    const e = this.editor
                      , t = e.editing.view.document;
                    this.listenTo(t, "copy", (r, i) => this._onCopyCut(r, i)),
                    this.listenTo(t, "cut", (r, i) => this._onCopyCut(r, i)),
                    this.listenTo(e.model, "insertContent", (r, [i,l]) => this._onInsertContent(r, i, l), {
                        priority: "high"
                    }),
                    this.decorate("_replaceTableSlotCell")
                }
                _onCopyCut(e, t) {
                    const r = this.editor.editing.view
                      , i = this.editor.plugins.get(Fi)
                      , l = this.editor.plugins.get(Ml);
                    i.getSelectedTableCells() && (e.name != "cut" || this.editor.model.canEditAt(this.editor.model.document.selection)) && (t.preventDefault(),
                    e.stop(),
                    this.editor.model.enqueueChange({
                        isUndoable: e.name === "cut"
                    }, () => {
                        const d = l._copySelectedFragmentWithMarkers(e.name, this.editor.model.document.selection, () => i.getSelectionAsFragment());
                        r.document.fire("clipboardOutput", {
                            dataTransfer: t.dataTransfer,
                            content: this.editor.data.toView(d),
                            method: e.name
                        })
                    }
                    ))
                }
                _onInsertContent(e, t, r) {
                    if (r && !r.is("documentSelection"))
                        return;
                    const i = this.editor.model
                      , l = this.editor.plugins.get(Ht)
                      , d = this.editor.plugins.get(Ml)
                      , h = this.getTableIfOnlyTableInContent(t, i);
                    if (!h)
                        return;
                    const m = l.getSelectionAffectedTableCells(i.document.selection);
                    m.length ? (e.stop(),
                    t.is("documentFragment") ? d._pasteMarkersIntoTransformedElement(t.markers, g => this._replaceSelectedCells(h, m, g)) : this.editor.model.change(g => {
                        this._replaceSelectedCells(h, m, g)
                    }
                    )) : Eg(h, l)
                }
                _replaceSelectedCells(e, t, r) {
                    const i = this.editor.plugins.get(Ht)
                      , l = {
                        width: i.getColumns(e),
                        height: i.getRows(e)
                    }
                      , d = function(v, x, T, I) {
                        const P = v[0].findAncestor("table")
                          , O = I.getColumnIndexes(v)
                          , F = I.getRowIndexes(v)
                          , q = {
                            firstColumn: O.first,
                            lastColumn: O.last,
                            firstRow: F.first,
                            lastRow: F.last
                        }
                          , Q = v.length === 1;
                        return Q && (q.lastRow += x.height - 1,
                        q.lastColumn += x.width - 1,
                        function(X, le, ge, ke) {
                            const vt = ke.getColumns(X)
                              , Nt = ke.getRows(X);
                            ge > vt && ke.insertColumns(X, {
                                at: vt,
                                columns: ge - vt
                            }),
                            le > Nt && ke.insertRows(X, {
                                at: Nt,
                                rows: le - Nt
                            })
                        }(P, q.lastRow + 1, q.lastColumn + 1, I)),
                        Q || !I.isSelectionRectangular(v) ? function(X, le, ge) {
                            const {firstRow: ke, lastRow: vt, firstColumn: Nt, lastColumn: pE} = le
                              , gE = {
                                first: ke,
                                last: vt
                            }
                              , fE = {
                                first: Nt,
                                last: pE
                            };
                            Ig(X, Nt, gE, ge),
                            Ig(X, pE + 1, gE, ge),
                            Tg(X, ke, fE, ge),
                            Tg(X, vt + 1, fE, ge, ke)
                        }(P, q, T) : (q.lastRow = H1(P, q),
                        q.lastColumn = W1(P, q)),
                        q
                    }(t, l, r, i)
                      , h = d.lastRow - d.firstRow + 1
                      , m = d.lastColumn - d.firstColumn + 1;
                    e = z1(e, {
                        startRow: 0,
                        startColumn: 0,
                        endRow: Math.min(h, l.height) - 1,
                        endColumn: Math.min(m, l.width) - 1
                    }, r);
                    const g = t[0].findAncestor("table")
                      , b = this._replaceSelectedCellsWithPasted(e, l, g, d, r);
                    if (this.editor.plugins.get("TableSelection").isEnabled) {
                        const v = i.sortRanges(b.map(x => r.createRangeOn(x)));
                        r.setSelection(v)
                    } else
                        r.setSelection(b[0], 0);
                    return g
                }
                _replaceSelectedCellsWithPasted(e, t, r, i, l) {
                    const {width: d, height: h} = t
                      , m = function(O, F, q) {
                        const Q = new Array(q).fill(null).map( () => new Array(F).fill(null));
                        for (const {column: X, row: le, cell: ge} of new Ve(O))
                            Q[le][X] = ge;
                        return Q
                    }(e, d, h)
                      , g = [...new Ve(r,{
                        startRow: i.firstRow,
                        endRow: i.lastRow,
                        startColumn: i.firstColumn,
                        endColumn: i.lastColumn,
                        includeAllSlots: !0
                    })]
                      , b = [];
                    let v;
                    for (const O of g) {
                        const {row: F, column: q} = O;
                        q === i.firstColumn && (v = O.getPositionBefore());
                        const Q = F - i.firstRow
                          , X = q - i.firstColumn
                          , le = m[Q % h][X % d]
                          , ge = le ? l.cloneElement(le) : null
                          , ke = this._replaceTableSlotCell(O, ge, v, l);
                        ke && (U1(ke, F, q, i.lastRow, i.lastColumn, l),
                        b.push(ke),
                        v = l.createPositionAfter(ke))
                    }
                    const x = parseInt(r.getAttribute("headingRows") || "0")
                      , T = parseInt(r.getAttribute("headingColumns") || "0")
                      , I = i.firstRow < x && x <= i.lastRow
                      , P = i.firstColumn < T && T <= i.lastColumn;
                    if (I) {
                        const O = Tg(r, x, {
                            first: i.firstColumn,
                            last: i.lastColumn
                        }, l, i.firstRow);
                        b.push(...O)
                    }
                    if (P) {
                        const O = Ig(r, T, {
                            first: i.firstRow,
                            last: i.lastRow
                        }, l);
                        b.push(...O)
                    }
                    return b
                }
                _replaceTableSlotCell(e, t, r, i) {
                    const {cell: l, isAnchor: d} = e;
                    return d && i.remove(l),
                    t ? (i.insert(t, r),
                    t) : null
                }
                getTableIfOnlyTableInContent(e, t) {
                    if (!e.is("documentFragment") && !e.is("element"))
                        return null;
                    if (e.is("element", "table"))
                        return e;
                    if (e.childCount == 1 && e.getChild(0).is("element", "table"))
                        return e.getChild(0);
                    const r = t.createRangeIn(e);
                    for (const i of r.getItems())
                        if (i.is("element", "table")) {
                            const l = t.createRange(r.start, t.createPositionBefore(i));
                            if (t.hasContent(l, {
                                ignoreWhitespaces: !0
                            }))
                                return null;
                            const d = t.createRange(t.createPositionAfter(i), r.end);
                            return t.hasContent(d, {
                                ignoreWhitespaces: !0
                            }) ? null : i
                        }
                    return null
                }
            }
            function Tg(s, e, t, r, i=0) {
                if (!(e < 1))
                    return O1(s, e, i).filter( ({column: l, cellWidth: d}) => tE(l, d, t)).map( ({cell: l}) => R1(l, e, r))
            }
            function Ig(s, e, t, r) {
                if (!(e < 1))
                    return F1(s, e).filter( ({row: i, cellHeight: l}) => tE(i, l, t)).map( ({cell: i, column: l}) => V1(i, l, e, r))
            }
            function tE(s, e, t) {
                const r = s + e - 1
                  , {first: i, last: l} = t;
                return s >= i && s <= l || s < i && r >= i
            }
            class H6 extends ie {
                static get pluginName() {
                    return "TableKeyboard"
                }
                static get requires() {
                    return [Fi, Ht]
                }
                init() {
                    const e = this.editor
                      , t = e.editing.view.document
                      , r = e.t;
                    this.listenTo(t, "arrowKey", (...i) => this._onArrowKey(...i), {
                        context: "table"
                    }),
                    this.listenTo(t, "tab", (...i) => this._handleTabOnSelectedTable(...i), {
                        context: "figure"
                    }),
                    this.listenTo(t, "tab", (...i) => this._handleTab(...i), {
                        context: ["th", "td"]
                    }),
                    e.accessibility.addKeystrokeInfoGroup({
                        id: "table",
                        label: r("Keystrokes that can be used in a table cell"),
                        keystrokes: [{
                            label: r("Move the selection to the next cell"),
                            keystroke: "Tab"
                        }, {
                            label: r("Move the selection to the previous cell"),
                            keystroke: "Shift+Tab"
                        }, {
                            label: r("Insert a new table row (when in the last cell of a table)"),
                            keystroke: "Tab"
                        }, {
                            label: r("Navigate through the table"),
                            keystroke: [["arrowup"], ["arrowright"], ["arrowdown"], ["arrowleft"]]
                        }]
                    })
                }
                _handleTabOnSelectedTable(e, t) {
                    const r = this.editor
                      , i = r.model.document.selection.getSelectedElement();
                    i && i.is("element", "table") && (t.preventDefault(),
                    t.stopPropagation(),
                    e.stop(),
                    r.model.change(l => {
                        l.setSelection(l.createRangeIn(i.getChild(0).getChild(0)))
                    }
                    ))
                }
                _handleTab(e, t) {
                    const r = this.editor
                      , i = this.editor.plugins.get(Ht)
                      , l = this.editor.plugins.get("TableSelection")
                      , d = r.model.document.selection
                      , h = !t.shiftKey;
                    let m = i.getTableCellsContainingSelection(d)[0];
                    if (m || (m = l.getFocusCell()),
                    !m)
                        return;
                    t.preventDefault(),
                    t.stopPropagation(),
                    e.stop();
                    const g = m.parent
                      , b = g.parent
                      , v = b.getChildIndex(g)
                      , x = g.getChildIndex(m)
                      , T = x === 0;
                    if (!h && T && v === 0)
                        return void r.model.change(F => {
                            F.setSelection(F.createRangeOn(b))
                        }
                        );
                    const I = x === g.childCount - 1
                      , P = v === i.getRows(b) - 1;
                    if (h && P && I && (r.execute("insertTableRowBelow"),
                    v === i.getRows(b) - 1))
                        return void r.model.change(F => {
                            F.setSelection(F.createRangeOn(b))
                        }
                        );
                    let O;
                    if (h && I)
                        O = b.getChild(v + 1).getChild(0);
                    else if (!h && T) {
                        const F = b.getChild(v - 1);
                        O = F.getChild(F.childCount - 1)
                    } else
                        O = g.getChild(x + (h ? 1 : -1));
                    r.model.change(F => {
                        F.setSelection(F.createRangeIn(O))
                    }
                    )
                }
                _onArrowKey(e, t) {
                    const r = this.editor
                      , i = Zm(t.keyCode, r.locale.contentLanguageDirection);
                    this._handleArrowKeys(i, t.shiftKey) && (t.preventDefault(),
                    t.stopPropagation(),
                    e.stop())
                }
                _handleArrowKeys(e, t) {
                    const r = this.editor.plugins.get(Ht)
                      , i = this.editor.plugins.get("TableSelection")
                      , l = this.editor.model
                      , d = l.document.selection
                      , h = ["right", "down"].includes(e)
                      , m = r.getSelectedTableCells(d);
                    if (m.length) {
                        let b;
                        return b = t ? i.getFocusCell() : h ? m[m.length - 1] : m[0],
                        this._navigateFromCellInDirection(b, e, t),
                        !0
                    }
                    const g = d.focus.findAncestor("tableCell");
                    if (!g)
                        return !1;
                    if (!d.isCollapsed)
                        if (t) {
                            if (d.isBackward == h && !d.containsEntireContent(g))
                                return !1
                        } else {
                            const b = d.getSelectedElement();
                            if (!b || !l.schema.isObject(b))
                                return !1
                        }
                    return !!this._isSelectionAtCellEdge(d, g, h) && (this._navigateFromCellInDirection(g, e, t),
                    !0)
                }
                _isSelectionAtCellEdge(e, t, r) {
                    const i = this.editor.model
                      , l = this.editor.model.schema
                      , d = r ? e.getLastPosition() : e.getFirstPosition();
                    if (!l.getLimitElement(d).is("element", "tableCell"))
                        return i.createPositionAt(t, r ? "end" : 0).isTouching(d);
                    const h = i.createSelection(d);
                    return i.modifySelection(h, {
                        direction: r ? "forward" : "backward"
                    }),
                    d.isEqual(h.focus)
                }
                _navigateFromCellInDirection(e, t, r=!1) {
                    const i = this.editor.model
                      , l = e.findAncestor("table")
                      , d = [...new Ve(l,{
                        includeAllSlots: !0
                    })]
                      , {row: h, column: m} = d[d.length - 1]
                      , g = d.find( ({cell: P}) => P == e);
                    let {row: b, column: v} = g;
                    switch (t) {
                    case "left":
                        v--;
                        break;
                    case "up":
                        b--;
                        break;
                    case "right":
                        v += g.cellWidth;
                        break;
                    case "down":
                        b += g.cellHeight
                    }
                    if (b < 0 || b > h || v < 0 && b <= 0 || v > m && b >= h)
                        return void i.change(P => {
                            P.setSelection(P.createRangeOn(l))
                        }
                        );
                    v < 0 ? (v = r ? 0 : m,
                    b--) : v > m && (v = r ? m : 0,
                    b++);
                    const x = d.find(P => P.row == b && P.column == v).cell
                      , T = ["right", "down"].includes(t)
                      , I = this.editor.plugins.get("TableSelection");
                    if (r && I.isEnabled) {
                        const P = I.getAnchorCell() || e;
                        I.setCellSelection(P, x)
                    } else {
                        const P = i.createPositionAt(x, T ? 0 : "end");
                        i.change(O => {
                            O.setSelection(P)
                        }
                        )
                    }
                }
            }
            class W6 extends Mn {
                constructor() {
                    super(...arguments),
                    C(this, "domEventType", ["mousemove", "mouseleave"])
                }
                onDomEvent(e) {
                    this.fire(e.type, e)
                }
            }
            class $6 extends ie {
                static get pluginName() {
                    return "TableMouse"
                }
                static get requires() {
                    return [Fi, Ht]
                }
                init() {
                    this.editor.editing.view.addObserver(W6),
                    this._enableShiftClickSelection(),
                    this._enableMouseDragSelection()
                }
                _enableShiftClickSelection() {
                    const e = this.editor
                      , t = e.plugins.get(Ht);
                    let r = !1;
                    const i = e.plugins.get(Fi);
                    this.listenTo(e.editing.view.document, "mousedown", (l, d) => {
                        const h = e.model.document.selection;
                        if (!this.isEnabled || !i.isEnabled || !d.domEvent.shiftKey)
                            return;
                        const m = i.getAnchorCell() || t.getTableCellsContainingSelection(h)[0];
                        if (!m)
                            return;
                        const g = this._getModelTableCellFromDomEvent(d);
                        g && oE(m, g) && (r = !0,
                        i.setCellSelection(m, g),
                        d.preventDefault())
                    }
                    ),
                    this.listenTo(e.editing.view.document, "mouseup", () => {
                        r = !1
                    }
                    ),
                    this.listenTo(e.editing.view.document, "selectionChange", l => {
                        r && l.stop()
                    }
                    , {
                        priority: "highest"
                    })
                }
                _enableMouseDragSelection() {
                    const e = this.editor;
                    let t, r, i = !1, l = !1;
                    const d = e.plugins.get(Fi);
                    this.listenTo(e.editing.view.document, "mousedown", (h, m) => {
                        this.isEnabled && d.isEnabled && (m.domEvent.shiftKey || m.domEvent.ctrlKey || m.domEvent.altKey || (t = this._getModelTableCellFromDomEvent(m)))
                    }
                    ),
                    this.listenTo(e.editing.view.document, "mousemove", (h, m) => {
                        if (!m.domEvent.buttons || !t)
                            return;
                        const g = this._getModelTableCellFromDomEvent(m);
                        g && oE(t, g) && (r = g,
                        i || r == t || (i = !0)),
                        i && (l = !0,
                        d.setCellSelection(t, r),
                        m.preventDefault())
                    }
                    ),
                    this.listenTo(e.editing.view.document, "mouseup", () => {
                        i = !1,
                        l = !1,
                        t = null,
                        r = null
                    }
                    ),
                    this.listenTo(e.editing.view.document, "selectionChange", h => {
                        l && h.stop()
                    }
                    , {
                        priority: "highest"
                    })
                }
                _getModelTableCellFromDomEvent(e) {
                    const t = e.target
                      , r = this.editor.editing.view.createPositionAt(t, 0);
                    return this.editor.editing.mapper.toModelPosition(r).parent.findAncestor("tableCell", {
                        includeSelf: !0
                    })
                }
            }
            function oE(s, e) {
                return s.parent.parent == e.parent.parent
            }
            var rE = u(2329)
              , q6 = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(rE.A, q6),
            rE.A.locals;
            class G6 extends ie {
                static get requires() {
                    return [z6, R6, Fi, $6, H6, U6, jl]
                }
                static get pluginName() {
                    return "Table"
                }
            }
            function K6(s) {
                const e = s.getSelectedElement();
                return e && nE(e) ? e : null
            }
            function Y6(s) {
                const e = s.getFirstPosition();
                if (!e)
                    return null;
                let t = e.parent;
                for (; t; ) {
                    if (t.is("element") && nE(t))
                        return t;
                    t = t.parent
                }
                return null
            }
            function nE(s) {
                return !!s.getCustomProperty("table") && At(s)
            }
            class Q6 extends ie {
                static get requires() {
                    return [hu]
                }
                static get pluginName() {
                    return "TableToolbar"
                }
                afterInit() {
                    const e = this.editor
                      , t = e.t
                      , r = e.plugins.get(hu)
                      , i = e.config.get("table.contentToolbar")
                      , l = e.config.get("table.tableToolbar");
                    i && r.register("tableContent", {
                        ariaLabel: t("Table toolbar"),
                        items: i,
                        getRelatedElement: Y6
                    }),
                    l && r.register("table", {
                        ariaLabel: t("Table toolbar"),
                        items: l,
                        getRelatedElement: K6
                    })
                }
            }
            var iE = u(5506)
              , Z6 = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(iE.A, Z6),
            iE.A.locals;
            var sE = u(2655)
              , J6 = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(sE.A, J6),
            sE.A.locals;
            var aE = u(4043)
              , X6 = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(aE.A, X6),
            aE.A.locals;
            var lE = u(1623)
              , e7 = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(lE.A, e7),
            lE.A.locals;
            var cE = u(8986)
              , t7 = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(cE.A, t7),
            cE.A.locals;
            var dE = u(5562)
              , o7 = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(dE.A, o7),
            dE.A.locals;
            var uE = u(4143)
              , r7 = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(uE.A, r7),
            uE.A.locals;
            var hE = u(8795)
              , n7 = {
                injectType: "singletonStyleTag",
                attributes: {
                    "data-cke": !0
                },
                insert: "head",
                singleton: !0
            };
            se()(hE.A, n7),
            hE.A.locals;
            const i7 = {
                autoRefresh: !0
            }
              , mE = 36e5;
            class Mg extends ye() {
                constructor(e, t={}) {
                    if (super(),
                    C(this, "_refresh"),
                    C(this, "_options"),
                    C(this, "_tokenRefreshTimeout"),
                    !e)
                        throw new U("token-missing-token-url",this);
                    t.initValue && this._validateTokenValue(t.initValue),
                    this.set("value", t.initValue),
                    this._refresh = typeof e == "function" ? e : () => {
                        return r = e,
                        new Promise( (i, l) => {
                            const d = new XMLHttpRequest;
                            d.open("GET", r),
                            d.addEventListener("load", () => {
                                const h = d.status
                                  , m = d.response;
                                return h < 200 || h > 299 ? l(new U("token-cannot-download-new-token",null)) : i(m)
                            }
                            ),
                            d.addEventListener("error", () => l(new Error("Network Error"))),
                            d.addEventListener("abort", () => l(new Error("Abort"))),
                            d.send()
                        }
                        );
                        var r
                    }
                    ,
                    this._options = {
                        ...i7,
                        ...t
                    }
                }
                init() {
                    return new Promise( (e, t) => {
                        this.value ? (this._options.autoRefresh && this._registerRefreshTokenTimeout(),
                        e(this)) : this.refreshToken().then(e).catch(t)
                    }
                    )
                }
                refreshToken() {
                    return this._refresh().then(e => (this._validateTokenValue(e),
                    this.set("value", e),
                    this._options.autoRefresh && this._registerRefreshTokenTimeout(),
                    this))
                }
                destroy() {
                    clearTimeout(this._tokenRefreshTimeout)
                }
                _validateTokenValue(e) {
                    const t = typeof e == "string"
                      , r = !/^".*"$/.test(e)
                      , i = t && e.split(".").length === 3;
                    if (!r || !i)
                        throw new U("token-not-in-jwt-format",this)
                }
                _registerRefreshTokenTimeout() {
                    const e = this._getTokenRefreshTimeoutTime();
                    clearTimeout(this._tokenRefreshTimeout),
                    this._tokenRefreshTimeout = setTimeout( () => {
                        this.refreshToken()
                    }
                    , e)
                }
                _getTokenRefreshTimeoutTime() {
                    try {
                        const [,e] = this.value.split(".")
                          , {exp: t} = JSON.parse(atob(e));
                        return t ? Math.floor((1e3 * t - Date.now()) / 2) : mE
                    } catch {
                        return mE
                    }
                }
                static create(e, t={}) {
                    return new Mg(e,t).init()
                }
            }
            const Bg = /^data:(\S*?);base64,/;
            class s7 extends Se() {
                constructor(e, t, r) {
                    if (super(),
                    C(this, "file"),
                    C(this, "xhr"),
                    C(this, "_token"),
                    C(this, "_apiAddress"),
                    !e)
                        throw new U("fileuploader-missing-file",null);
                    if (!t)
                        throw new U("fileuploader-missing-token",null);
                    if (!r)
                        throw new U("fileuploader-missing-api-address",null);
                    this.file = function(i) {
                        if (typeof i != "string")
                            return !1;
                        const l = i.match(Bg);
                        return !(!l || !l.length)
                    }(e) ? function(i, l=512) {
                        try {
                            const d = i.match(Bg)[1]
                              , h = atob(i.replace(Bg, ""))
                              , m = [];
                            for (let g = 0; g < h.length; g += l) {
                                const b = h.slice(g, g + l)
                                  , v = new Array(b.length);
                                for (let x = 0; x < b.length; x++)
                                    v[x] = b.charCodeAt(x);
                                m.push(new Uint8Array(v))
                            }
                            return new Blob(m,{
                                type: d
                            })
                        } catch {
                            throw new U("fileuploader-decoding-image-data-error",null)
                        }
                    }(e) : e,
                    this._token = t,
                    this._apiAddress = r
                }
                onProgress(e) {
                    return this.on("progress", (t, r) => e(r)),
                    this
                }
                onError(e) {
                    return this.once("error", (t, r) => e(r)),
                    this
                }
                abort() {
                    this.xhr.abort()
                }
                send() {
                    return this._prepareRequest(),
                    this._attachXHRListeners(),
                    this._sendRequest()
                }
                _prepareRequest() {
                    const e = new XMLHttpRequest;
                    e.open("POST", this._apiAddress),
                    e.setRequestHeader("Authorization", this._token.value),
                    e.responseType = "json",
                    this.xhr = e
                }
                _attachXHRListeners() {
                    const e = this.xhr
                      , t = r => () => this.fire("error", r);
                    e.addEventListener("error", t("Network Error")),
                    e.addEventListener("abort", t("Abort")),
                    e.upload && e.upload.addEventListener("progress", r => {
                        r.lengthComputable && this.fire("progress", {
                            total: r.total,
                            uploaded: r.loaded
                        })
                    }
                    ),
                    e.addEventListener("load", () => {
                        const r = e.status
                          , i = e.response;
                        if (r < 200 || r > 299)
                            return this.fire("error", i.message || i.error)
                    }
                    )
                }
                _sendRequest() {
                    const e = new FormData
                      , t = this.xhr;
                    return e.append("file", this.file),
                    new Promise( (r, i) => {
                        t.addEventListener("load", () => {
                            const l = t.status
                              , d = t.response;
                            return l < 200 || l > 299 ? d.message ? i(new U("fileuploader-uploading-data-failed",this,{
                                message: d.message
                            })) : i(d.error) : r(d)
                        }
                        ),
                        t.addEventListener("error", () => i(new Error("Network Error"))),
                        t.addEventListener("abort", () => i(new Error("Abort"))),
                        t.send(e)
                    }
                    )
                }
            }
            class a7 {
                constructor(e, t) {
                    if (C(this, "_token"),
                    C(this, "_apiAddress"),
                    !e)
                        throw new U("uploadgateway-missing-token",null);
                    if (!t)
                        throw new U("uploadgateway-missing-api-address",null);
                    this._token = e,
                    this._apiAddress = t
                }
                upload(e) {
                    return new s7(e,this._token,this._apiAddress)
                }
            }
            class l7 extends Md {
                static get pluginName() {
                    return "CloudServicesCore"
                }
                createToken(e, t) {
                    return new Mg(e,t)
                }
                createUploadGateway(e, t) {
                    return new a7(e,t)
                }
            }
            class c7 extends Md {
                constructor() {
                    super(...arguments),
                    C(this, "tokenUrl"),
                    C(this, "uploadUrl"),
                    C(this, "webSocketUrl"),
                    C(this, "bundleVersion"),
                    C(this, "token", null),
                    C(this, "_tokens", new Map)
                }
                static get pluginName() {
                    return "CloudServices"
                }
                static get requires() {
                    return [l7]
                }
                async init() {
                    const e = this.context.config.get("cloudServices") || {};
                    for (const [r,i] of Object.entries(e))
                        this[r] = i;
                    if (!this.tokenUrl)
                        return void (this.token = null);
                    const t = this.context.plugins.get("CloudServicesCore");
                    this.token = await t.createToken(this.tokenUrl).init(),
                    this._tokens.set(this.tokenUrl, this.token)
                }
                async registerTokenUrl(e) {
                    if (this._tokens.has(e))
                        return this.getTokenFor(e);
                    const t = this.context.plugins.get("CloudServicesCore")
                      , r = await t.createToken(e).init();
                    return this._tokens.set(e, r),
                    r
                }
                getTokenFor(e) {
                    const t = this._tokens.get(e);
                    if (!t)
                        throw new U("cloudservices-token-not-registered",this);
                    return t
                }
                destroy() {
                    super.destroy();
                    for (const e of this._tokens.values())
                        e.destroy()
                }
            }
            class Ng extends rz {
            }
            C(Ng, "builtinPlugins", [lO, uO, mO, fO, AO, xO, VO, qO, c7, YO, oR, wR, yR, FR, VR, PR, $R, bF, BF, qF, O0, h6, UR, G6, Q6, Cz]),
            C(Ng, "defaultConfig", {
                toolbar: {
                    items: ["undo", "redo", "|", "heading", "|", "bold", "italic", "|", "link", "uploadImage", "insertTable", "blockQuote", "mediaEmbed", "|", "bulletedList", "numberedList", "outdent", "indent"]
                },
                image: {
                    toolbar: ["imageStyle:inline", "imageStyle:block", "imageStyle:side", "|", "toggleImageCaption", "imageTextAlternative"]
                },
                table: {
                    contentToolbar: ["tableColumn", "tableRow", "mergeTableCells"]
                },
                language: "en"
            })
        }
        )(),
        p = p.default
    }
    )())
}
)(tm, tm.exports);
var qK = tm.exports;
const GK = nb(qK);
function KK() {
    const [o,n] = R.useState([])
      , [a,c] = R.useState(null)
      , [u,p] = R.useState(!0)
      , f = R.useRef(null)
      , w = async () => {
        p(!0);
        try {
            const S = await Hc("get-merchants.php");
            if (S != null && S.success) {
                n(S.merchants || []);
                let A = a;
                if (!A && S.merchants.length > 0)
                    A = {
                        ...S.merchants[0]
                    };
                else if (A) {
                    const D = S.merchants.find(N => String(N.merchant_id) === String(A.merchant_id));
                    D && (A = {
                        ...D
                    })
                }
                A && (c(A),
                f.current = Number(A.conversion_rate ?? 0))
            } else
                console.warn("[Admin] get-merchants error:", S == null ? void 0 : S.error)
        } catch (S) {
            console.error("[Admin] get-merchants failed:", S)
        } finally {
            p(!1)
        }
    }
    ;
    R.useEffect( () => {
        w()
    }
    , []);
    const k = async S => {
        var A;
        if (S.preventDefault(),
        !a)
            return;
        const D = Number(f.current ?? 0)
          , N = Number(a.conversion_rate ?? 0)
          , L = Number.isFinite(D) && Number.isFinite(N) && D !== N
          , z = await Ne("save-merchant.php", a);
        if (!(z != null && z.success)) {
            alert("Save failed: " + ((z == null ? void 0 : z.error) || "Unknown error"));
            return
        }
        const B = await Hc("get-merchants.php").catch( () => null);
        if (B != null && B.success) {
            n(B.merchants || []);
            const M = (B.merchants || []).find(j => String(j.merchant_id) === String(a.merchant_id));
            c(M || ((A = B.merchants) == null ? void 0 : A[0]) || null),
            M && (f.current = Number(M.conversion_rate ?? 0))
        }
        if (L && window.confirm(`Conversion rate changed from ${D} to ${N}.

Update ALL wallets for merchant "${a.merchant_id}" to use the new conversion rate and recalculate cash balances?`))
            try {
                const M = await Ne("bulk-refresh-points.php", {
                    merchant_id: a.merchant_id,
                    conversion_rate: N,
                    recalc_cash: !0,
                    requested_by: "AdminRateChange"
                });
                if (!(M != null && M.success))
                    throw new Error((M == null ? void 0 : M.error) || "Bulk wallet rate/cash update failed");
                alert(`Wallets updated for merchant ${a.merchant_id}.
Updated: ${M.updated}
` + (M.points_overlay_applied ? `Points overlay applied to ${M.points_overlay_applied} wallet(s)
` : "") + `New rate: ${N}`)
            } catch (M) {
                alert(`Bulk wallet update error: ${M.message || M}`)
            }
        alert("Merchant saved!")
    }
      , y = async S => {
        if (window.confirm("Delete this merchant?"))
            try {
                const A = await Ne("delete-merchant.php", {
                    merchant_id: S
                });
                if (A != null && A.success) {
                    alert("Deleted");
                    const D = o.filter(N => String(N.merchant_id) !== String(S));
                    n(D),
                    c(D[0] || null),
                    D[0] && (f.current = Number(D[0].conversion_rate ?? 0))
                } else
                    alert("Delete failed: " + ((A == null ? void 0 : A.error) || "Unknown error"))
            } catch (A) {
                console.error("[Admin] delete-merchant failed:", A),
                alert("Delete failed: network/server error")
            }
    }
      , E = S => {
        const {name: A, value: D, type: N, checked: L} = S.target;
        c(z => ({
            ...z,
            [A]: N === "checkbox" ? L ? 1 : 0 : D
        }))
    }
    ;
    return _.jsxs("div", {
        id: "admin-container",
        className: "app-container app-content",
        children: [_.jsx("h1", {
            className: "page-title",
            children: "Merchant Admin"
        }), _.jsx("p", {
            className: "page-deck",
            children: "This page is used for administrative purposes to manage Merchant related data."
        }), _.jsx("div", {
            className: "card",
            children: a ? _.jsxs("form", {
                onSubmit: k,
                className: "form-grid",
                children: [_.jsx(an, {
                    label: "Merchant ID",
                    children: _.jsx("input", {
                        className: "form-input",
                        type: "text",
                        name: "merchant_id",
                        value: (a == null ? void 0 : a.merchant_id) || "",
                        onChange: E,
                        required: !0
                    })
                }), _.jsx(an, {
                    label: "Merchant Name",
                    children: _.jsx("input", {
                        className: "form-input",
                        type: "text",
                        name: "merchant_name",
                        value: (a == null ? void 0 : a.merchant_name) || "",
                        onChange: E,
                        required: !0
                    })
                }), _.jsx(an, {
                    label: "Program Name",
                    children: _.jsx("input", {
                        className: "form-input",
                        type: "text",
                        name: "program_name",
                        value: (a == null ? void 0 : a.program_name) || "",
                        onChange: E
                    })
                }), _.jsx(an, {
                    label: "Contact Email",
                    children: _.jsx("input", {
                        className: "form-input",
                        type: "email",
                        name: "contact_email",
                        value: (a == null ? void 0 : a.contact_email) || "",
                        onChange: E
                    })
                }), _.jsx(an, {
                    label: "Contact Phone",
                    children: _.jsx("input", {
                        className: "form-input",
                        type: "text",
                        name: "contact_phone",
                        value: (a == null ? void 0 : a.contact_phone) || "",
                        onChange: E
                    })
                }), _.jsx(an, {
                    label: "Website URL",
                    children: _.jsx("input", {
                        className: "form-input",
                        type: "url",
                        name: "website_url",
                        value: (a == null ? void 0 : a.website_url) || "",
                        onChange: E
                    })
                }), _.jsx(an, {
                    label: "Conversion Rate",
                    children: _.jsx("input", {
                        className: "form-input",
                        type: "number",
                        step: "0.0001",
                        name: "conversion_rate",
                        value: (a == null ? void 0 : a.conversion_rate) ?? "0.01",
                        onChange: E
                    })
                }), _.jsxs("div", {
                    className: "form-row",
                    style: {
                        flexDirection: "column",
                        alignItems: "stretch",
                        marginBottom: "1rem"
                    },
                    children: [_.jsx("label", {
                        className: "wysiwyg-label",
                        style: {
                            marginBottom: "0.25rem",
                            textAlign: "left"
                        },
                        children: "Promotion Text:"
                    }), _.jsx(AB, {
                        editor: GK,
                        data: (a == null ? void 0 : a.promotion_text) || "",
                        onChange: (S, A) => {
                            const D = A.getData();
                            c(N => ({
                                ...N,
                                promotion_text: D
                            }))
                        }
                        ,
                        config: {
                            placeholder: "Enter promotion text here..."
                        }
                    })]
                }), _.jsx(an, {
                    label: "Promotion Active",
                    children: _.jsx("input", {
                        type: "checkbox",
                        name: "promotion_active",
                        checked: !!(a != null && a.promotion_active),
                        onChange: E
                    })
                }), _.jsx(an, {
                    label: "Merchant Active",
                    children: _.jsx("input", {
                        type: "checkbox",
                        name: "active_status",
                        checked: !!(a != null && a.active_status),
                        onChange: E
                    })
                }), _.jsxs("div", {
                    className: "card-actions",
                    children: [_.jsx("button", {
                        type: "submit",
                        className: "btn-primary",
                        children: "Save Merchant"
                    }), (a == null ? void 0 : a.merchant_id) && _.jsx("button", {
                        type: "button",
                        className: "btn-primary",
                        style: {
                            background: "#dc2626"
                        },
                        onClick: () => y(a.merchant_id),
                        children: "Delete Merchant"
                    })]
                })]
            }) : _.jsx("p", {
                className: "body-text",
                children: "Select a merchant from the table below to edit."
            })
        }), _.jsx("h2", {
            className: "subheading",
            children: "Merchant Records"
        }), u ? _.jsx("p", {
            children: "Loading..."
        }) : _.jsx("div", {
            className: "card",
            children: _.jsxs("table", {
                className: "basket-table",
                children: [_.jsx("thead", {
                    children: _.jsxs("tr", {
                        children: [_.jsx("th", {
                            children: "Merchant ID"
                        }), _.jsx("th", {
                            children: "Name"
                        }), _.jsx("th", {
                            children: "Status"
                        }), _.jsx("th", {
                            children: "Promotion Active"
                        }), _.jsx("th", {
                            children: "Actions"
                        })]
                    })
                }), _.jsx("tbody", {
                    children: o.map(S => _.jsxs("tr", {
                        children: [_.jsx("td", {
                            children: S.merchant_id
                        }), _.jsx("td", {
                            children: S.merchant_name
                        }), _.jsx("td", {
                            children: S.active_status ? "Active" : "Inactive"
                        }), _.jsx("td", {
                            children: S.promotion_active ? "Yes" : "No"
                        }), _.jsx("td", {
                            children: _.jsx("button", {
                                className: "btn-secondary",
                                onClick: () => {
                                    c({
                                        ...S
                                    }),
                                    f.current = Number(S.conversion_rate ?? 0)
                                }
                                ,
                                children: "Edit"
                            })
                        })]
                    }, S.merchant_id))
                })]
            })
        })]
    })
}
function an({label: o, children: n}) {
    return _.jsxs("div", {
        className: "form-row",
        children: [o && _.jsxs("label", {
            className: "form-label",
            children: [o, ":"]
        }), n]
    })
}
function YK() {
    const [o,n] = R.useState([])
      , [a,c] = R.useState(null)
      , [u,p] = R.useState(!0)
      , [f,w] = R.useState("")
      , k = R.useRef(null)
      , [y,E] = R.useState([])
      , [S,A] = R.useState(!0)
      , D = R.useMemo( () => {
        try {
            return Intl.DateTimeFormat().resolvedOptions().timeZone || "America/New_York"
        } catch {
            return "America/New_York"
        }
    }
    , [])
      , N = R.useMemo( () => ["America/New_York", "America/Chicago", "America/Denver", "America/Los_Angeles", "America/Phoenix", "America/Anchorage", "Pacific/Honolulu", "America/Detroit", "America/Indiana/Indianapolis", "America/Kentucky/Louisville", "America/Toronto", "America/Vancouver", "America/Winnipeg", "America/Edmonton", "America/Mexico_City", "America/Cancun", "Europe/London", "Europe/Dublin", "Europe/Paris", "Europe/Berlin", "Europe/Madrid", "Europe/Rome", "Europe/Amsterdam", "Europe/Brussels", "Asia/Tokyo", "Asia/Shanghai", "Asia/Hong_Kong", "Asia/Singapore", "Asia/Taipei", "Asia/Seoul", "Asia/Kolkata", "Asia/Dubai", "Australia/Sydney", "Australia/Melbourne", "Australia/Brisbane", "Australia/Perth", "Pacific/Auckland", "UTC"], [])
      , L = R.useMemo( () => {
        var H;
        const W = (H = a == null ? void 0 : a.member_timezone) == null ? void 0 : H.trim();
        return W ? N.includes(W) ? N : [W, ...N] : N
    }
    , [a == null ? void 0 : a.member_timezone, N])
      , z = R.useMemo( () => {
        var H;
        const W = (H = a == null ? void 0 : a.member_timezone) == null ? void 0 : H.trim();
        return !!W && !N.includes(W)
    }
    , [a == null ? void 0 : a.member_timezone, N])
      , B = H => {
        const W = Number(H);
        return !Number.isFinite(W) || W <= 0 ? 0 : W >= 1 ? W / 100 : W
    }
      , M = (H, W) => {
        const ee = Number(H || 0)
          , re = B(W);
        return !Number.isFinite(ee) || !Number.isFinite(re) || re <= 0 ? 0 : Math.round(ee * re * 100) / 100
    }
      , j = R.useMemo( () => a && y.find(H => String(H.merchant_id) === String(a.merchant_id)) || null, [y, a])
      , V = (j == null ? void 0 : j.conversion_rate) ?? 0;
    R.useEffect( () => {
        (async () => {
            A(!0);
            try {
                const H = await Hc("get-merchants.php");
                E(H != null && H.success ? H.merchants || [] : []),
                H != null && H.success || console.warn("[WalletAdmin] merchants error:", H == null ? void 0 : H.error)
            } catch (H) {
                console.error("[WalletAdmin] merchants fetch failed", H),
                E([])
            } finally {
                A(!1)
            }
        }
        )()
    }
    , []),
    R.useEffect( () => {
        (async () => {
            p(!0);
            try {
                const H = await Hc("get-multiple-wallets.php");
                if (H != null && H.success) {
                    n(H.wallets || []);
                    const W = localStorage.getItem("memberId");
                    let ee = null;
                    if (W && (ee = (H.wallets || []).find(re => String(re.member_id) === String(W))),
                    !ee && (H.wallets || []).length > 0 && (ee = H.wallets[0]),
                    ee) {
                        const re = y.find(me => String(me.merchant_id) === String(ee.merchant_id))
                          , U = (re == null ? void 0 : re.conversion_rate) ?? 0
                          , de = Number(ee.points || 0)
                          , te = M(de, U)
                          , ue = ee.member_timezone && String(ee.member_timezone).trim() !== "" ? ee.member_timezone : D;
                        c({
                            ...ee,
                            cash_balance: te,
                            merchant_name: ee.merchant_name || (re == null ? void 0 : re.merchant_name) || "",
                            member_timezone: ue
                        })
                    }
                } else
                    console.warn("[WalletAdmin] wallets error:", H == null ? void 0 : H.error)
            } catch (H) {
                console.error("[WalletAdmin] wallets fetch failed", H)
            } finally {
                p(!1)
            }
        }
        )()
    }
    , [y, D]);
    const G = async H => {
        if (H.preventDefault(),
        !a)
            return;
        const W = {
            ...a
        };
        f.trim() && (W.new_password = f.trim());
        const ee = Number(W.points || 0);
        W.cash_balance = M(ee, V),
        delete W.conversion_rate;
        try {
            const re = await Ne("save-wallet.php", W);
            re != null && re.success ? (alert("Wallet saved!"),
            w(""),
            window.location.reload()) : alert("Save failed: " + ((re == null ? void 0 : re.error) || "Unknown error"))
        } catch (re) {
            console.error("[WalletAdmin] save failed", re),
            alert("Save failed: network/server error")
        }
    }
      , Y = async H => {
        if (window.confirm("Delete this wallet?"))
            try {
                const W = await Ne("delete-wallet.php", {
                    record_id: H
                });
                W != null && W.success ? (alert("Deleted"),
                n(o.filter(ee => ee.record_id !== H)),
                (a == null ? void 0 : a.record_id) === H && c(null)) : alert("Delete failed: " + ((W == null ? void 0 : W.error) || "Unknown error"))
            } catch (W) {
                console.error("[WalletAdmin] delete failed", W),
                alert("Delete failed: network/server error")
            }
    }
      , $ = H => {
        const {name: W, value: ee} = H.target
          , re = {
            ...a,
            [W]: ee
        };
        if (W === "points") {
            const U = Number(re.points || 0);
            re.cash_balance = M(U, V)
        }
        c(re)
    }
      , K = H => {
        const W = H.target.value
          , ee = y.find(te => String(te.merchant_id) === String(W))
          , re = {
            ...a,
            merchant_id: W,
            merchant_name: (ee == null ? void 0 : ee.merchant_name) || ""
        }
          , U = Number(re.points || 0)
          , de = (ee == null ? void 0 : ee.conversion_rate) ?? 0;
        re.cash_balance = M(U, de),
        c(re)
    }
      , Z = H => {
        const W = {
            ...H
        }
          , ee = Number(W.points || 0)
          , re = y.find(de => String(de.merchant_id) === String(W.merchant_id))
          , U = (re == null ? void 0 : re.conversion_rate) ?? 0;
        W.cash_balance = M(ee, U),
        !W.merchant_name && re != null && re.merchant_name && (W.merchant_name = re.merchant_name),
        !W.broker && re != null && re.broker && (W.broker = re.broker),
        !W.broker_url && re != null && re.broker_url && (W.broker_url = re.broker_url),
        (!W.member_timezone || String(W.member_timezone).trim() === "") && (W.member_timezone = D),
        c(W),
        w(""),
        setTimeout( () => {
            var de;
            (de = k.current) == null || de.scrollIntoView({
                behavior: "smooth",
                block: "start"
            })
        }
        , 100)
    }
    ;
    return _.jsxs("div", {
        className: "app-container app-content",
        children: [_.jsx("h1", {
            className: "page-title",
            children: "Wallet Administration"
        }), _.jsx("p", {
            className: "page-deck",
            children: "This administration page is to manage member wallet information to correct or originate information for demonstration purposes."
        }), _.jsx("div", {
            className: "card",
            ref: k,
            children: a ? _.jsxs("form", {
                onSubmit: G,
                className: "form-grid",
                children: [_.jsx("input", {
                    type: "hidden",
                    name: "record_id",
                    value: (a == null ? void 0 : a.record_id) || ""
                }), _.jsx(ct, {
                    label: "Member ID",
                    children: _.jsx("input", {
                        className: "form-input",
                        type: "text",
                        name: "member_id",
                        value: (a == null ? void 0 : a.member_id) || "",
                        onChange: $,
                        required: !0
                    })
                }), _.jsx(ct, {
                    label: "Member Email",
                    children: _.jsx("input", {
                        className: "form-input",
                        type: "email",
                        name: "member_email",
                        value: (a == null ? void 0 : a.member_email) || "",
                        onChange: $
                    })
                }), _.jsx(ct, {
                    label: "Reset Password",
                    children: _.jsx("input", {
                        className: "form-input",
                        type: "password",
                        name: "new_password",
                        value: f,
                        placeholder: "Enter new password to reset",
                        onChange: H => w(H.target.value)
                    })
                }), _.jsx(ct, {
                    label: "First Name",
                    children: _.jsx("input", {
                        className: "form-input",
                        type: "text",
                        name: "first_name",
                        value: (a == null ? void 0 : a.first_name) || "",
                        onChange: $
                    })
                }), _.jsx(ct, {
                    label: "Middle Name",
                    children: _.jsx("input", {
                        className: "form-input",
                        type: "text",
                        name: "middle_name",
                        value: (a == null ? void 0 : a.middle_name) || "",
                        onChange: $
                    })
                }), _.jsx(ct, {
                    label: "Last Name",
                    children: _.jsx("input", {
                        className: "form-input",
                        type: "text",
                        name: "last_name",
                        value: (a == null ? void 0 : a.last_name) || "",
                        onChange: $
                    })
                }), _.jsx(ct, {
                    label: "Address Line 1",
                    children: _.jsx("input", {
                        className: "form-input",
                        type: "text",
                        name: "member_address_line1",
                        value: (a == null ? void 0 : a.member_address_line1) || "",
                        onChange: $
                    })
                }), _.jsx(ct, {
                    label: "Address Line 2",
                    children: _.jsx("input", {
                        className: "form-input",
                        type: "text",
                        name: "member_address_line2",
                        value: (a == null ? void 0 : a.member_address_line2) || "",
                        onChange: $
                    })
                }), _.jsx(ct, {
                    label: "Town/City",
                    children: _.jsx("input", {
                        className: "form-input",
                        type: "text",
                        name: "member_town_city",
                        value: (a == null ? void 0 : a.member_town_city) || "",
                        onChange: $
                    })
                }), _.jsx(ct, {
                    label: "State",
                    children: _.jsx("input", {
                        className: "form-input",
                        type: "text",
                        name: "member_state",
                        value: (a == null ? void 0 : a.member_state) || "",
                        onChange: $
                    })
                }), _.jsx(ct, {
                    label: "ZIP",
                    children: _.jsx("input", {
                        className: "form-input",
                        type: "text",
                        name: "member_zip",
                        value: (a == null ? void 0 : a.member_zip) || "",
                        onChange: $
                    })
                }), _.jsx(ct, {
                    label: "Country",
                    children: _.jsx("input", {
                        className: "form-input",
                        type: "text",
                        name: "member_country",
                        value: (a == null ? void 0 : a.member_country) || "",
                        onChange: $
                    })
                }), _.jsx(ct, {
                    label: "Local Timezone",
                    children: _.jsxs("div", {
                        className: "form-inline",
                        children: [_.jsxs("select", {
                            className: "form-input",
                            name: "member_timezone",
                            value: (a == null ? void 0 : a.member_timezone) ?? "",
                            onChange: $,
                            children: [_.jsx("option", {
                                value: "",
                                children: "-- Select Timezone --"
                            }), L.map(H => _.jsx("option", {
                                value: H,
                                children: H
                            }, H))]
                        }), _.jsxs("small", {
                            className: "subtext",
                            style: {
                                marginLeft: "0.5rem"
                            },
                            children: ["Detected: ", _.jsx("strong", {
                                children: D
                            }), z && _.jsx("span", {
                                style: {
                                    marginLeft: 8,
                                    color: "#b45309"
                                },
                                children: "(Non-standard; consider switching)"
                            })]
                        })]
                    })
                }), _.jsx(ct, {
                    label: "Merchant ID",
                    children: _.jsxs("select", {
                        className: "form-input",
                        name: "merchant_id",
                        value: String((a == null ? void 0 : a.merchant_id) ?? ""),
                        onChange: K,
                        disabled: S,
                        children: [_.jsx("option", {
                            value: "",
                            children: S ? "Loading…" : "Select a merchant"
                        }), y.map(H => _.jsxs("option", {
                            value: String(H.merchant_id),
                            children: [H.merchant_name, " (", H.merchant_id, ")"]
                        }, H.merchant_id))]
                    })
                }), _.jsx(ct, {
                    label: "Merchant Name",
                    children: _.jsx("input", {
                        className: "form-input",
                        type: "text",
                        name: "merchant_name",
                        value: (a == null ? void 0 : a.merchant_name) || "",
                        readOnly: !0
                    })
                }), _.jsx(ct, {
                    label: "Conversion Rate (from Merchant)",
                    children: _.jsx("input", {
                        className: "form-input",
                        type: "text",
                        name: "conversion_rate_display",
                        value: V ? `${V} ${V >= 1 ? "(% or ratio)" : ""}` : "",
                        readOnly: !0
                    })
                }), _.jsx(ct, {
                    label: "Broker",
                    children: _.jsx("input", {
                        className: "form-input",
                        type: "text",
                        name: "broker",
                        value: (a == null ? void 0 : a.broker) || "",
                        onChange: $
                    })
                }), _.jsx(ct, {
                    label: "Broker URL",
                    children: _.jsx("input", {
                        className: "form-input",
                        type: "url",
                        name: "broker_url",
                        value: (a == null ? void 0 : a.broker_url) || "",
                        onChange: $
                    })
                }), _.jsx(ct, {
                    label: "Election Type",
                    children: _.jsx("input", {
                        className: "form-input",
                        type: "text",
                        name: "election_type",
                        value: (a == null ? void 0 : a.election_type) || "",
                        onChange: $
                    })
                }), _.jsx(ct, {
                    label: "Points",
                    children: _.jsx("input", {
                        className: "form-input",
                        type: "number",
                        name: "points",
                        value: (a == null ? void 0 : a.points) ?? "",
                        onChange: $
                    })
                }), _.jsx(ct, {
                    label: "Cash Balance (calc)",
                    children: _.jsx("input", {
                        className: "form-input",
                        type: "number",
                        step: "0.01",
                        name: "cash_balance",
                        value: Number.isFinite(Number(a == null ? void 0 : a.cash_balance)) ? a == null ? void 0 : a.cash_balance : M(Number((a == null ? void 0 : a.points) || 0), V),
                        readOnly: !0
                    })
                }), _.jsx(ct, {
                    label: "Portfolio Value",
                    children: _.jsx("input", {
                        className: "form-input",
                        type: "number",
                        step: "0.01",
                        name: "portfolio_value",
                        value: (a == null ? void 0 : a.portfolio_value) ?? "",
                        onChange: $
                    })
                }), _.jsx(ct, {
                    label: "Sweep %",
                    children: _.jsx("input", {
                        className: "form-input",
                        type: "number",
                        step: "0.01",
                        name: "sweep_percentage",
                        value: (a == null ? void 0 : a.sweep_percentage) ?? "",
                        onChange: $
                    })
                }), _.jsxs("div", {
                    className: "card-actions",
                    children: [_.jsx("button", {
                        type: "submit",
                        className: "btn-primary",
                        children: "Save Wallet"
                    }), (a == null ? void 0 : a.record_id) && _.jsx("button", {
                        type: "button",
                        className: "btn-primary",
                        style: {
                            background: "#dc2626"
                        },
                        onClick: () => Y(a.record_id),
                        children: "Delete Wallet"
                    })]
                })]
            }) : _.jsx("p", {
                className: "body-text",
                children: "Select a wallet from the table below to edit."
            })
        }), _.jsx("h2", {
            className: "subheading",
            children: "Wallet Records"
        }), u ? _.jsx("p", {
            children: "Loading..."
        }) : _.jsx("div", {
            className: "card",
            children: _.jsxs("table", {
                className: "basket-table",
                children: [_.jsx("thead", {
                    children: _.jsxs("tr", {
                        children: [_.jsx("th", {
                            children: "Member ID"
                        }), _.jsx("th", {
                            children: "Email"
                        }), _.jsx("th", {
                            children: "Merchant / Broker"
                        }), _.jsx("th", {
                            children: "Points → Cash / Portfolio"
                        }), _.jsx("th", {
                            children: "Actions"
                        })]
                    })
                }), _.jsx("tbody", {
                    children: o.map(H => {
                        const W = H.points == null || isNaN(Number(H.points)) ? null : Number(H.points)
                          , ee = H.cash_balance != null && !isNaN(Number(H.cash_balance)) ? Number(H.cash_balance) : null
                          , re = H.portfolio_value == null || isNaN(Number(H.portfolio_value)) ? null : Number(H.portfolio_value);
                        return _.jsxs("tr", {
                            children: [_.jsx("td", {
                                children: H.member_id
                            }), _.jsxs("td", {
                                children: [_.jsx("div", {
                                    children: H.member_email
                                }), H.member_timezone && _.jsx("div", {
                                    className: "subtext",
                                    children: H.member_timezone
                                })]
                            }), _.jsxs("td", {
                                children: [_.jsx("div", {
                                    children: H.merchant_name || "-"
                                }), _.jsx("div", {
                                    className: "subtext",
                                    children: H.broker || "-"
                                })]
                            }), _.jsxs("td", {
                                children: [_.jsxs("div", {
                                    style: {
                                        display: "flex",
                                        alignItems: "center",
                                        gap: "0.4rem"
                                    },
                                    children: [_.jsx("span", {
                                        children: W == null ? "-" : W.toLocaleString()
                                    }), _.jsx("span", {
                                        "aria-hidden": "true",
                                        title: "converts to",
                                        children: "➜"
                                    }), _.jsx("span", {
                                        children: ee == null ? "-" : ee.toLocaleString(void 0, {
                                            style: "currency",
                                            currency: "USD"
                                        })
                                    })]
                                }), _.jsx("div", {
                                    className: "subtext",
                                    style: {
                                        marginTop: "0.15rem"
                                    },
                                    children: re == null ? "-" : re.toLocaleString(void 0, {
                                        style: "currency",
                                        currency: "USD"
                                    })
                                })]
                            }), _.jsx("td", {
                                children: _.jsx("button", {
                                    className: "btn-secondary",
                                    onClick: () => Z(H),
                                    children: "Edit"
                                })
                            })]
                        }, H.record_id)
                    }
                    )
                })]
            })
        })]
    })
}
function ct({label: o, children: n}) {
    return _.jsxs("div", {
        className: "form-row",
        children: [o && _.jsxs("label", {
            className: "form-label",
            children: [o, ":"]
        }), n]
    })
}
function QK() {
    const [o,n] = R.useState([])
      , [a,c] = R.useState(null)
      , [u,p] = R.useState(!0)
      , [f,w] = R.useState(!1)
      , [k,y] = R.useState("member_id")
      , [E,S] = R.useState("")
      , A = R.useRef(null)
      , D = R.useMemo( () => {
        try {
            return Intl.DateTimeFormat().resolvedOptions().timeZone || "America/New_York"
        } catch {
            return "America/New_York"
        }
    }
    , [])
      , N = R.useMemo( () => ["America/New_York", "America/Chicago", "America/Denver", "America/Los_Angeles", "America/Phoenix", "America/Anchorage", "Pacific/Honolulu", "America/Detroit", "America/Indiana/Indianapolis", "America/Kentucky/Louisville", "America/Toronto", "America/Vancouver", "America/Winnipeg", "America/Edmonton", "America/Mexico_City", "America/Cancun", "Europe/London", "Europe/Dublin", "Europe/Paris", "Europe/Berlin", "Europe/Madrid", "Europe/Rome", "Europe/Amsterdam", "Europe/Brussels", "Asia/Tokyo", "Asia/Shanghai", "Asia/Hong_Kong", "Asia/Singapore", "Asia/Taipei", "Asia/Seoul", "Asia/Kolkata", "Asia/Dubai", "Australia/Sydney", "Australia/Melbourne", "Australia/Brisbane", "Australia/Perth", "Pacific/Auckland", "UTC"], []);
    R.useEffect( () => {
        const W = localStorage.getItem("memberId") || "";
        W ? (y("member_id"),
        S(W),
        z({
            member_id: W
        })) : z({})
    }
    , []);
    const L = () => {
        const W = {
            sort_by: "created_at",
            sort_dir: "DESC",
            limit: 200
        }
          , ee = (E || "").trim();
        switch (k) {
        case "member_id":
            ee && (W.member_id = ee);
            break;
        case "tx_type":
            ee && (W.tx_type = ee);
            break;
        case "date":
            {
                if (ee && /^\d{4}-\d{2}-\d{2}$/.test(ee)) {
                    const re = `${ee} 00:00:00`
                      , U = new Date(`${ee}T00:00:00Z`);
                    if (!isNaN(U.getTime())) {
                        const de = new Date(U.getTime() + 864e5)
                          , te = de.getUTCFullYear()
                          , ue = String(de.getUTCMonth() + 1).padStart(2, "0")
                          , me = String(de.getUTCDate()).padStart(2, "0")
                          , Ce = `${te}-${ue}-${me} 00:00:00`;
                        W.start_date = re,
                        W.end_date = Ce
                    }
                }
                break
            }
        case "inbound":
            W.direction = "inbound";
            break;
        case "outbound":
            W.direction = "outbound";
            break
        }
        return W
    }
      , z = async W => {
        p(!0);
        try {
            const ee = await Ne("get-ledger.php", {
                sort_by: "created_at",
                sort_dir: "DESC",
                limit: 200,
                ...W
            });
            if (ee != null && ee.success) {
                const re = ee.rows || [];
                n(re),
                re.length > 0 ? c(B(re[0], D)) : c(null)
            } else
                console.warn("[TransactionsLedgerAdmin] fetch error:", ee == null ? void 0 : ee.error),
                n([]),
                c(null)
        } catch (ee) {
            console.error("[TransactionsLedgerAdmin] fetch failed", ee),
            n([]),
            c(null)
        } finally {
            p(!1)
        }
    }
      , B = (W, ee) => {
        const re = {
            ...W
        };
        return (!re.member_timezone || String(re.member_timezone).trim() === "") && (re.member_timezone = ee),
        re
    }
      , M = W => W ? W.id ?? W.tx_id ?? W.record_id ?? W.ledger_id ?? null : null
      , j = (W, ee) => {
        if (!W)
            return "-";
        let re = String(W).trim();
        /Z$|[+-]\d{2}:\d{2}$/.test(re) || (re = re.replace(" ", "T") + "Z");
        const U = new Date(re);
        if (isNaN(U.getTime()))
            return W;
        try {
            return new Intl.DateTimeFormat(void 0,{
                year: "numeric",
                month: "short",
                day: "2-digit",
                hour: "2-digit",
                minute: "2-digit",
                second: "2-digit",
                hour12: !0,
                timeZone: ee || D,
                timeZoneName: "short"
            }).format(U)
        } catch {
            return U.toLocaleString()
        }
    }
      , V = async W => {
        if (W.preventDefault(),
        !!a) {
            w(!0);
            try {
                const ee = {
                    ...a
                }
                  , re = await Ne("save-transactions-ledger.php", ee);
                if (re != null && re.success) {
                    alert("Ledger row saved!");
                    const U = L();
                    await z(U);
                    const de = M(a)
                      , te = (o || []).find(ue => M(ue) === de);
                    te && c(B(te, D))
                } else
                    alert("Save failed: " + ((re == null ? void 0 : re.error) || "Unknown error"))
            } catch (ee) {
                console.error("[TransactionsLedgerAdmin] save failed", ee),
                alert("Save failed: network/server error")
            } finally {
                w(!1)
            }
        }
    }
      , G = async W => {
        const ee = M(W);
        if (!ee) {
            alert("Cannot determine primary key for this row.");
            return
        }
        if (window.confirm("Delete this ledger row?"))
            try {
                const re = await Ne("delete-transactions-ledger.php", {
                    id: W.id,
                    tx_id: W.tx_id,
                    record_id: W.record_id,
                    ledger_id: W.ledger_id
                });
                if (re != null && re.success) {
                    alert("Deleted");
                    const U = L();
                    await z(U),
                    a && M(a) === ee && c(null)
                } else
                    alert("Delete failed: " + ((re == null ? void 0 : re.error) || "Unknown error"))
            } catch (re) {
                console.error("[TransactionsLedgerAdmin] delete failed", re),
                alert("Delete failed: network/server error")
            }
    }
      , Y = W => {
        const {name: ee, value: re} = W.target;
        c(U => ({
            ...U,
            [ee]: re
        }))
    }
      , $ = W => {
        c(B(W, D)),
        setTimeout( () => {
            var ee;
            (ee = A.current) == null || ee.scrollIntoView({
                behavior: "smooth",
                block: "start"
            })
        }
        , 100)
    }
      , K = W => W == null || isNaN(Number(W)) ? "-" : Number(W).toLocaleString(void 0, {
        style: "currency",
        currency: "USD"
    })
      , Z = k === "member_id" ? "e.g. M-12345" : k === "date" ? "YYYY-MM-DD" : k === "tx_type" ? "e.g. points_received" : ""
      , H = k === "inbound" || k === "outbound";
    return _.jsxs("div", {
        className: "app-container app-content",
        children: [_.jsx("h1", {
            className: "page-title",
            children: "Transactions Ledger Administration"
        }), _.jsxs("p", {
            className: "page-deck",
            children: ["Review and edit entries in ", _.jsx("code", {
                children: "transactions_ledger"
            }), ". Timestamps are stored in UTC; the local preview renders using ", _.jsx("code", {
                children: "member_timezone"
            }), "."]
        }), _.jsx("div", {
            className: "card",
            style: {
                marginBottom: "1rem"
            },
            children: _.jsxs("div", {
                className: "form-row",
                style: {
                    flexWrap: "wrap",
                    gap: "0.5rem"
                },
                children: [_.jsx("label", {
                    className: "form-label",
                    children: "Filter:"
                }), _.jsxs("select", {
                    className: "form-input",
                    style: {
                        maxWidth: 220
                    },
                    value: k,
                    onChange: W => {
                        const ee = W.target.value;
                        y(ee),
                        (ee === "inbound" || ee === "outbound") && S("")
                    }
                    ,
                    children: [_.jsx("option", {
                        value: "member_id",
                        children: "Member ID"
                    }), _.jsx("option", {
                        value: "date",
                        children: "Date (day)"
                    }), _.jsx("option", {
                        value: "tx_type",
                        children: "TX Type"
                    }), _.jsx("option", {
                        value: "inbound",
                        children: "Inbound (direction)"
                    }), _.jsx("option", {
                        value: "outbound",
                        children: "Outbound (direction)"
                    })]
                }), _.jsx("input", {
                    className: "form-input",
                    type: "text",
                    placeholder: Z,
                    value: E,
                    onChange: W => S(W.target.value),
                    disabled: H,
                    style: {
                        maxWidth: 260
                    }
                }), k === "member_id" && _.jsx("button", {
                    type: "button",
                    className: "btn-secondary",
                    onClick: () => {
                        const W = localStorage.getItem("memberId") || "";
                        S(W)
                    }
                    ,
                    children: "Use my memberId"
                }), _.jsx("button", {
                    type: "button",
                    className: "btn-primary",
                    onClick: () => {
                        const W = L();
                        z(W)
                    }
                    ,
                    children: "Filter"
                }), _.jsx("button", {
                    type: "button",
                    className: "btn-secondary",
                    onClick: () => {
                        y("member_id"),
                        S(""),
                        z({})
                    }
                    ,
                    children: "Clear"
                })]
            })
        }), _.jsx("div", {
            className: "card",
            ref: A,
            children: a ? _.jsxs("form", {
                onSubmit: V,
                className: "form-grid",
                children: [_.jsx(Wt, {
                    label: "TX ID",
                    children: _.jsx("input", {
                        className: "form-input",
                        type: "text",
                        value: M(a) ?? "",
                        readOnly: !0
                    })
                }), _.jsx(Wt, {
                    label: "Member ID",
                    children: _.jsx("input", {
                        className: "form-input",
                        name: "member_id",
                        type: "text",
                        value: a.member_id ?? "",
                        onChange: Y
                    })
                }), _.jsx(Wt, {
                    label: "Order ID",
                    children: _.jsx("input", {
                        className: "form-input",
                        name: "order_id",
                        type: "text",
                        value: a.order_id ?? "",
                        onChange: Y
                    })
                }), _.jsx(Wt, {
                    label: "Merchant ID",
                    children: _.jsx("input", {
                        className: "form-input",
                        name: "merchant_id",
                        type: "text",
                        value: a.merchant_id ?? "",
                        onChange: Y
                    })
                }), _.jsx(Wt, {
                    label: "Broker",
                    children: _.jsx("input", {
                        className: "form-input",
                        name: "broker",
                        type: "text",
                        value: a.broker ?? "",
                        onChange: Y
                    })
                }), _.jsx(Wt, {
                    label: "Client TX ID",
                    children: _.jsx("input", {
                        className: "form-input",
                        name: "client_tx_id",
                        type: "text",
                        value: a.client_tx_id ?? "",
                        onChange: Y
                    })
                }), _.jsx(Wt, {
                    label: "External Ref",
                    children: _.jsx("input", {
                        className: "form-input",
                        name: "external_ref",
                        type: "text",
                        value: a.external_ref ?? "",
                        onChange: Y
                    })
                }), _.jsx(Wt, {
                    label: "TX Type",
                    children: _.jsx("input", {
                        className: "form-input",
                        name: "tx_type",
                        type: "text",
                        value: a.tx_type ?? "",
                        onChange: Y
                    })
                }), _.jsx(Wt, {
                    label: "Direction",
                    children: _.jsx("input", {
                        className: "form-input",
                        name: "direction",
                        type: "text",
                        value: a.direction ?? "",
                        onChange: Y
                    })
                }), _.jsx(Wt, {
                    label: "Channel",
                    children: _.jsx("input", {
                        className: "form-input",
                        name: "channel",
                        type: "text",
                        value: a.channel ?? "",
                        onChange: Y
                    })
                }), _.jsx(Wt, {
                    label: "Status",
                    children: _.jsx("input", {
                        className: "form-input",
                        name: "status",
                        type: "text",
                        value: a.status ?? "",
                        onChange: Y
                    })
                }), _.jsx(Wt, {
                    label: "Amount (Points)",
                    children: _.jsx("input", {
                        className: "form-input",
                        name: "amount_points",
                        type: "number",
                        step: "0.0001",
                        value: a.amount_points ?? "",
                        onChange: Y
                    })
                }), _.jsx(Wt, {
                    label: "Amount (Cash)",
                    children: _.jsx("input", {
                        className: "form-input",
                        name: "amount_cash",
                        type: "number",
                        step: "0.01",
                        value: a.amount_cash ?? "",
                        onChange: Y
                    })
                }), _.jsx(Wt, {
                    label: "Note",
                    children: _.jsx("input", {
                        className: "form-input",
                        name: "note",
                        type: "text",
                        value: a.note ?? "",
                        onChange: Y
                    })
                }), _.jsx(Wt, {
                    label: "Event At (UTC)",
                    children: _.jsx("input", {
                        className: "form-input",
                        name: "event_at",
                        type: "text",
                        placeholder: "YYYY-MM-DD HH:MM:SS (UTC)",
                        value: a.event_at ?? "",
                        onChange: Y
                    })
                }), _.jsx(Wt, {
                    label: "Event Time (Local Preview)",
                    children: _.jsx("input", {
                        className: "form-input",
                        type: "text",
                        value: j(a.event_at, a.member_timezone || D),
                        readOnly: !0
                    })
                }), _.jsx(Wt, {
                    label: "Member Timezone",
                    children: _.jsxs("div", {
                        className: "form-inline",
                        children: [_.jsxs("select", {
                            className: "form-input",
                            name: "member_timezone",
                            value: (a == null ? void 0 : a.member_timezone) ?? "",
                            onChange: Y,
                            children: [_.jsx("option", {
                                value: "",
                                children: "-- Select Timezone --"
                            }), N.map(W => _.jsx("option", {
                                value: W,
                                children: W
                            }, W))]
                        }), _.jsxs("small", {
                            className: "subtext",
                            style: {
                                marginLeft: "0.5rem"
                            },
                            children: ["Detected: ", _.jsx("strong", {
                                children: D
                            })]
                        })]
                    })
                }), _.jsxs("div", {
                    className: "card-actions",
                    children: [_.jsx("button", {
                        type: "submit",
                        className: "btn-primary",
                        disabled: f,
                        children: f ? "Saving…" : "Save Row"
                    }), a && _.jsx("button", {
                        type: "button",
                        className: "btn-primary",
                        style: {
                            background: "#dc2626"
                        },
                        onClick: () => G(a),
                        children: "Delete Row"
                    })]
                })]
            }) : _.jsx("p", {
                className: "body-text",
                children: "Select a ledger row from the table below to edit."
            })
        }), _.jsx("h2", {
            className: "subheading",
            children: "Ledger Records"
        }), u ? _.jsx("p", {
            children: "Loading..."
        }) : _.jsx("div", {
            className: "card",
            children: _.jsxs("table", {
                className: "basket-table",
                children: [_.jsx("thead", {
                    children: _.jsxs("tr", {
                        children: [_.jsx("th", {
                            children: "ID"
                        }), _.jsx("th", {
                            children: "Member"
                        }), _.jsx("th", {
                            children: "Order"
                        }), _.jsx("th", {
                            children: "Type / Dir"
                        }), _.jsx("th", {
                            children: "Channel / Status"
                        }), _.jsx("th", {
                            children: "Points / Cash"
                        }), _.jsx("th", {
                            children: "Event (Local)"
                        }), _.jsx("th", {
                            children: "Timezone"
                        }), _.jsx("th", {
                            children: "Actions"
                        })]
                    })
                }), _.jsxs("tbody", {
                    children: [o.map(W => {
                        const ee = M(W)
                          , re = j(W == null ? void 0 : W.event_at, (W == null ? void 0 : W.member_timezone) || D);
                        return _.jsxs("tr", {
                            children: [_.jsx("td", {
                                children: ee ?? "-"
                            }), _.jsx("td", {
                                children: (W == null ? void 0 : W.member_id) ?? "-"
                            }), _.jsx("td", {
                                children: (W == null ? void 0 : W.order_id) ?? "-"
                            }), _.jsxs("td", {
                                children: [_.jsx("div", {
                                    children: (W == null ? void 0 : W.tx_type) || "-"
                                }), _.jsx("div", {
                                    className: "subtext",
                                    children: (W == null ? void 0 : W.direction) || "-"
                                })]
                            }), _.jsxs("td", {
                                children: [_.jsx("div", {
                                    children: (W == null ? void 0 : W.channel) || "-"
                                }), _.jsx("div", {
                                    className: "subtext",
                                    children: (W == null ? void 0 : W.status) || "-"
                                })]
                            }), _.jsxs("td", {
                                children: [_.jsxs("div", {
                                    className: "subtext",
                                    children: ["Pts: ", (W == null ? void 0 : W.amount_points) == null ? "-" : Number(W.amount_points).toLocaleString()]
                                }), _.jsxs("div", {
                                    children: ["Cash: ", K(W == null ? void 0 : W.amount_cash)]
                                })]
                            }), _.jsx("td", {
                                children: re
                            }), _.jsx("td", {
                                className: "subtext",
                                children: (W == null ? void 0 : W.member_timezone) || "-"
                            }), _.jsxs("td", {
                                children: [_.jsx("button", {
                                    className: "btn-secondary",
                                    onClick: () => $(W),
                                    children: "Edit"
                                }), _.jsx("button", {
                                    className: "btn-secondary",
                                    style: {
                                        marginLeft: 8,
                                        color: "#dc2626",
                                        borderColor: "#dc2626"
                                    },
                                    onClick: () => G(W),
                                    children: "Delete"
                                })]
                            })]
                        }, ee ?? Math.random())
                    }
                    ), o.length === 0 && _.jsx("tr", {
                        children: _.jsx("td", {
                            colSpan: 9,
                            style: {
                                textAlign: "center",
                                padding: "1rem"
                            },
                            children: "No ledger records found."
                        })
                    })]
                })]
            })
        })]
    })
}
function Wt({label: o, children: n}) {
    return _.jsxs("div", {
        className: "form-row",
        children: [o && _.jsxs("label", {
            className: "form-label",
            children: [o, ":"]
        }), n]
    })
}
function ZK() {
    const [o,n] = R.useState([])
      , [a,c] = R.useState(!0)
      , [u,p] = R.useState("")
      , {presetMerchantId: f, presetMemberId: w, presetPoints: k} = R.useMemo( () => {
        const H = new URLSearchParams(window.location.search);
        return {
            presetMerchantId: H.get("merchant_id") || "",
            presetMemberId: H.get("member_id") || "",
            presetPoints: H.get("points") || "100"
        }
    }
    , [])
      , [y,E] = R.useState(f)
      , [S,A] = R.useState(w)
      , [D,N] = R.useState(k)
      , [L,z] = R.useState("100")
      , [B,M] = R.useState(!1);
    R.useEffect( () => {
        (async () => {
            c(!0),
            p("");
            try {
                const H = await Hc("get-merchants.php");
                if (!(H != null && H.success))
                    throw new Error((H == null ? void 0 : H.error) || "Failed to load merchants");
                const W = H.merchants || [];
                n(W),
                !f && W.length && E(W[0].merchant_id)
            } catch (H) {
                console.error("[DemoLaunch] get-merchants failed:", H),
                p((H == null ? void 0 : H.message) || "Network/server error loading merchants")
            } finally {
                c(!1)
            }
        }
        )()
    }
    , [f]);
    function j(H) {
        return o.find(W => String(W.merchant_id) === String(H)) || null
    }
    function V(H) {
        let W = Number(H || 0);
        return !Number.isFinite(W) || W <= 0 ? 0 : (W >= 1 && (W = W / 100),
        W)
    }
    function G(H, W) {
        return Math.round(Number(H) * Number(W) * 100) / 100
    }
    async function Y({memberId: H, merchantId: W, points: ee, action: re}) {
        const U = `demo_${H}_${W}_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`
          , de = {
            member_id: H,
            merchant_id: W,
            points: Number(ee),
            action: re,
            client_tx_id: U
        }
          , te = await Ne("log-ledger.php", de);
        if (!(te != null && te.success))
            throw new Error((te == null ? void 0 : te.error) || "Failed to log ledger");
        return te
    }
    async function $({memberId: H, merchantId: W, points: ee}) {
        const re = j(W)
          , U = V(re == null ? void 0 : re.conversion_rate)
          , de = U > 0 ? G(ee, U) : 0
          , te = await Ne("update-wallet-balance.php", {
            member_id: H,
            merchant_id: W,
            points: Number(ee),
            cash_balance: de
        });
        if (!(te != null && te.success))
            throw new Error((te == null ? void 0 : te.error) || "Failed to update wallet balance");
        return te
    }
    const K = async () => {
        const H = S.trim()
          , W = Number(D);
        if (!y)
            return alert("Select a merchant first");
        if (!H)
            return alert("Please enter a Member ID");
        if (!Number.isFinite(W) || W <= 0)
            return alert("Points must be a positive number");
        try {
            await Y({
                memberId: H,
                merchantId: y,
                points: W,
                action: "earn"
            }),
            await $({
                memberId: H,
                merchantId: y,
                points: W
            })
        } catch (re) {
            console.warn("[DemoLaunch] pre-launch update failed:", (re == null ? void 0 : re.message) || re)
        }
        const ee = window.location.origin + `/?member_id=${encodeURIComponent(H)}&merchant_id=${encodeURIComponent(y)}&points=${encodeURIComponent(W)}&action=earn`;
        window.open(ee, "_blank")
    }
      , Z = async () => {
        const H = y
          , W = Number(L);
        if (!H)
            return alert("Select a merchant first");
        if (!Number.isFinite(W) || W < 0)
            return alert("Bulk points must be 0 or a positive number");
        if (window.confirm(`This will FORCE-SET ALL members of merchant ${H} to exactly ${W} points (overlay), and log per-member adjustments. Continue?`)) {
            M(!0);
            try {
                const ee = await Ne("bulk-refresh-points.php", {
                    merchant_id: H,
                    points: W,
                    requested_by: "DemoLaunch"
                });
                if (!(ee != null && ee.success))
                    throw new Error((ee == null ? void 0 : ee.error) || "Bulk refresh failed");
                alert(`Bulk overlay complete.
Updated: ${ee.updated}
Unchanged: ${ee.skipped}
Target: ${ee.target_points}`)
            } catch (ee) {
                alert(`Bulk refresh error: ${ee.message || ee}`)
            } finally {
                M(!1)
            }
        }
    }
    ;
    return _.jsxs("div", {
        className: "app-container app-content",
        children: [_.jsx("h1", {
            className: "page-title",
            children: "Launch Demo"
        }), _.jsx("p", {
            className: "page-deck",
            children: "Simulate a member arriving from a merchant by selecting a merchant, entering a Member ID, and reward points. You can also force-overlay points for all members of a merchant."
        }), _.jsx("div", {
            className: "card",
            children: a ? _.jsx("p", {
                children: "Loading merchants…"
            }) : u ? _.jsx("p", {
                className: "form-error",
                children: u
            }) : o.length === 0 ? _.jsx("p", {
                children: "No merchants found. Add one from the Admin page first."
            }) : _.jsxs("div", {
                className: "form-grid",
                children: [_.jsxs("div", {
                    className: "form-row",
                    children: [_.jsx("label", {
                        className: "form-label",
                        children: "Merchant:"
                    }), _.jsx("select", {
                        className: "form-input",
                        value: y,
                        onChange: H => E(H.target.value),
                        children: o.map(H => _.jsxs("option", {
                            value: H.merchant_id,
                            children: [H.merchant_name, " (", H.merchant_id, ")"]
                        }, H.merchant_id))
                    })]
                }), _.jsxs("div", {
                    className: "form-row",
                    children: [_.jsx("label", {
                        className: "form-label",
                        children: "Member ID:"
                    }), _.jsx("input", {
                        className: "form-input",
                        placeholder: "Enter Member ID",
                        value: S,
                        onChange: H => A(H.target.value)
                    })]
                }), _.jsxs("div", {
                    className: "form-row",
                    children: [_.jsx("label", {
                        className: "form-label",
                        children: "Reward Points:"
                    }), _.jsx("input", {
                        className: "form-input",
                        type: "number",
                        value: D,
                        onChange: H => N(H.target.value)
                    })]
                }), _.jsx("div", {
                    className: "card-actions",
                    children: _.jsx("button", {
                        className: "btn-primary",
                        onClick: K,
                        children: "Launch StockLoyal PWA"
                    })
                }), _.jsx("hr", {
                    className: "my-4"
                }), _.jsxs("div", {
                    className: "form-row",
                    children: [_.jsx("label", {
                        className: "form-label",
                        children: "Bulk Points (force overlay for ALL members of selected merchant):"
                    }), _.jsx("input", {
                        className: "form-input",
                        type: "number",
                        min: "0",
                        value: L,
                        onChange: H => z(H.target.value)
                    })]
                }), _.jsx("div", {
                    className: "card-actions",
                    children: _.jsx("button", {
                        className: "btn-secondary",
                        onClick: Z,
                        disabled: B,
                        title: "Hard-set wallet.points for all members of selected merchant; log adjust_points per member",
                        children: B ? "Refreshing…" : "Refresh All Members for Merchant"
                    })
                })]
            })
        })]
    })
}
function dt({children: o}) {
    const n = Lt()
      , [a,c] = R.useState("forward")
      , u = {
        initial: f => ({
            x: f === "backward" ? "-100%" : "100%",
            opacity: 0
        }),
        enter: {
            x: 0,
            opacity: 1,
            transition: {
                duration: .35,
                ease: "easeOut"
            }
        },
        exit: f => ({
            x: f === "backward" ? "100%" : "-100%",
            opacity: 0,
            transition: {
                duration: .35,
                ease: "easeIn"
            }
        })
    }
      , p = () => {
        c("backward"),
        setTimeout( () => {
            n(-1)
        }
        , 350)
    }
    ;
    return _.jsx("div", {
        className: "app-container",
        style: {
            flex: 1,
            position: "relative"
        },
        children: _.jsxs(gG.div, {
            custom: a,
            variants: u,
            initial: "initial",
            animate: "enter",
            exit: "exit",
            className: "app-content",
            style: {
                flex: 1,
                minHeight: "100vh",
                position: "relative"
            },
            children: [_.jsx("img", {
                src: "/icons/back-arrow.png",
                alt: "Go Back",
                onClick: p,
                style: {
                    position: "absolute",
                    top: "1rem",
                    left: "-.5rem",
                    zIndex: 50,
                    width: "28px",
                    height: "28px",
                    cursor: "pointer"
                }
            }), o]
        })
    })
}
function JK() {
    const o = Zt();
    return _.jsx(fG, {
        children: _.jsx(LW, {
            mode: "wait",
            children: _.jsxs(tU, {
                location: o,
                children: [_.jsxs(Je, {
                    element: _.jsx(kG, {}),
                    children: [_.jsx(Je, {
                        path: "/",
                        element: _.jsx(JG, {})
                    }), _.jsx(Je, {
                        path: "/promotions",
                        element: _.jsx(dt, {
                            children: _.jsx(XG, {})
                        })
                    }), _.jsx(Je, {
                        path: "/login",
                        element: _.jsx(dt, {
                            children: _.jsx(eK, {})
                        })
                    }), _.jsx(Je, {
                        path: "/terms",
                        element: _.jsx(dt, {
                            children: _.jsx(oK, {})
                        })
                    }), _.jsx(Je, {
                        path: "/goodbye",
                        element: _.jsx(dt, {
                            children: _.jsx(rK, {})
                        })
                    })]
                }), _.jsxs(Je, {
                    element: _.jsx(QG, {}),
                    children: [_.jsx(Je, {
                        path: "/about",
                        element: _.jsx(dt, {
                            children: _.jsx(nK, {})
                        })
                    }), _.jsx(Je, {
                        path: "/member-onboard",
                        element: _.jsx(dt, {
                            children: _.jsx(tK, {})
                        })
                    }), _.jsx(Je, {
                        path: "/wallet",
                        element: _.jsx(dt, {
                            children: _.jsx(iK, {})
                        })
                    }), _.jsx(Je, {
                        path: "/convert",
                        element: _.jsx(dt, {
                            children: _.jsx(sK, {})
                        })
                    }), _.jsx(Je, {
                        path: "/order",
                        element: _.jsx(dt, {
                            children: _.jsx(cK, {})
                        })
                    }), _.jsx(Je, {
                        path: "/order-confirmation",
                        element: _.jsx(dt, {
                            children: _.jsx(dK, {})
                        })
                    }), _.jsx(Je, {
                        path: "/select-broker",
                        element: _.jsx(dt, {
                            children: _.jsx(uK, {})
                        })
                    }), _.jsx(Je, {
                        path: "/election",
                        element: _.jsx(dt, {
                            children: _.jsx(hK, {})
                        })
                    }), _.jsx(Je, {
                        path: "/points-select",
                        element: _.jsx(dt, {
                            children: _.jsx(mK, {})
                        })
                    }), _.jsx(Je, {
                        path: "/stock-picker",
                        element: _.jsx(dt, {
                            children: _.jsx(bK, {})
                        })
                    }), _.jsx(Je, {
                        path: "/stock-categories",
                        element: _.jsx(dt, {
                            children: _.jsx(gK, {})
                        })
                    }), _.jsx(Je, {
                        path: "/stock-list",
                        element: _.jsx(dt, {
                            children: _.jsx(wK, {})
                        })
                    }), _.jsx(Je, {
                        path: "/basket",
                        element: _.jsx(dt, {
                            children: _.jsx(AK, {})
                        })
                    }), _.jsx(Je, {
                        path: "/portfolio",
                        element: _.jsx(dt, {
                            children: _.jsx(vK, {})
                        })
                    }), _.jsx(Je, {
                        path: "/transactions",
                        element: _.jsx(dt, {
                            children: _.jsx(_K, {})
                        })
                    }), _.jsx(Je, {
                        path: "/admin",
                        element: _.jsx(dt, {
                            children: _.jsx(KK, {})
                        })
                    }), _.jsx(Je, {
                        path: "/wallet-admin",
                        element: _.jsx(dt, {
                            children: _.jsx(YK, {})
                        })
                    }), _.jsx(Je, {
                        path: "/ledger-admin",
                        element: _.jsx(dt, {
                            children: _.jsx(QK, {})
                        })
                    }), _.jsx(Je, {
                        path: "/demo-launch",
                        element: _.jsx(dt, {
                            children: _.jsx(ZK, {})
                        })
                    })]
                })]
            }, o.pathname)
        })
    })
}
function XK() {
    return null
}
c8.createRoot(document.getElementById("root")).render(_.jsx(GG, {
    children: _.jsx(aK, {
        children: _.jsxs(yU, {
            children: [_.jsx(XK, {}), _.jsx(JK, {})]
        })
    })
}));
